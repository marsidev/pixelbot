var ky = Object.defineProperty;
var _g = x => {
    throw TypeError(x)
}
;
var Ey = (x, l, _) => l in x ? ky(x, l, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: _
}) : x[l] = _;
var hr = (x, l, _) => Ey(x, typeof l != "symbol" ? l + "" : l, _)
  , uf = (x, l, _) => l.has(x) || _g("Cannot " + _);
var nt = (x, l, _) => (uf(x, l, "read from private field"),
_ ? _.call(x) : l.get(x))
  , Sr = (x, l, _) => l.has(x) ? _g("Cannot add the same private member more than once") : l instanceof WeakSet ? l.add(x) : l.set(x, _)
  , Hn = (x, l, _, T) => (uf(x, l, "write to private field"),
T ? T.call(x, _) : l.set(x, _),
_)
  , Nr = (x, l, _) => (uf(x, l, "access private method"),
_);
import "../chunks/Bzak7iHL.js";
import {o as wi, s as Wi} from "../chunks/B3fCajxr.js";
import {S as zy, a_ as Ly, bj as Dy, b0 as Ry, bg as By, bk as Fy, bb as Oy, g as Ny, h as gg, e as jy, i as qy, j as Vy, k as Zy, l as $y, m as Uy, aD as Gy, n as Hy, a1 as Wy, bl as Xy, bm as Xf, aQ as Ky, W as Yy, ao as Sn, E as Jy, bn as Qy, bo as ex, a2 as tx, v as so, bp as rx, bq as ix, br as nx, aS as mt, y as w, aI as fe, aH as Mn, p as Lr, aU as _t, q as Gr, f as Be, d as z, s as U, bs as ax, r as k, t as st, b as H, c as Dr, ak as Xi, aB as di, bc as _n, aC as Pr, be as Pu, u as Kf, aT as cr, a as Rt, aV as wa, ax as sx, aw as vg, ay as ox, aA as qg, bt as $a, bu as Vg, al as lx, am as cx} from "../chunks/BGIPkjyo.js";
import {a as ux, s as Ce} from "../chunks/Cq3jMZ3u.js";
import {p as At, i as tt, r as Jt, s as lo, u as Zg} from "../chunks/OCPOAKYS.js";
import {s as Vr, b as jr, r as Ea, e as Fn, f as Yf, a as Yt, d as lc, g as Su, c as Kl} from "../chunks/CZZKMiak.js";
import {c as hx, e as mn, i as Jf} from "../chunks/Df2eAhCX.js";
import {p as Za} from "../chunks/CbFwpzjI.js";
import {S as Bn, a as ri, t as Zr, u as Vt, h as as, g as aa, P as dx, C as yg, i as xg, j as px, k as fx, l as mx} from "../chunks/B_ghyyfR.js";
import {c as $g, A as ua, a as bf, g as hf, p as _x, b as gx} from "../chunks/CVKAT862.js";
import {g as Ug, b as vx} from "../chunks/Ds5vc7_K.js";
import {h as yx} from "../chunks/2P6RCwsQ.js";
import {b as Ss} from "../chunks/JWWr3N4f.js";
import {j as jd, g as Qf, k as em, a as ss, l as Xn, A as xx, m as Gg, i as Ql, t as Hg, n as tm, D as Wg, c as qd, o as bx, p as wx, q as Tx, I as bg, e as Cx, r as Sx, f as Px, s as Ix, P as Xg, d as Mx} from "../chunks/C1GZ182U.js";
import {g as Ge, l as Ax} from "../chunks/C5GsJ62f.js";
import "../chunks/Ckm0NTkT.js";
import {i as Kg} from "../chunks/C5u61be8.js";
import {L as Yg} from "../chunks/B1ds5mKJ.js";
import {c as an} from "../chunks/CptDP_jz.js";
import {L as kx, T as Jg, a as Ex} from "../chunks/D1SUD2mP.js";
import {_ as zx} from "../chunks/Dp1pzeXC.js";
import {R as Lx, r as Dx, W as Rx} from "../chunks/CykWqCDQ.js";
const Bx = [];
function Fx(x, l=!1) {
    return Cd(x, new Map, "", Bx)
}
function Cd(x, l, _, T, E=null) {
    if (typeof x == "object" && x !== null) {
        var F = l.get(x);
        if (F !== void 0)
            return F;
        if (x instanceof Map)
            return new Map(x);
        if (x instanceof Set)
            return new Set(x);
        if (zy(x)) {
            var C = Array(x.length);
            l.set(x, C),
            E !== null && l.set(E, C);
            for (var o = 0; o < x.length; o += 1) {
                var W = x[o];
                o in x && (C[o] = Cd(W, l, _, T))
            }
            return C
        }
        if (Ly(x) === Dy) {
            C = {},
            l.set(x, C),
            E !== null && l.set(E, C);
            for (var G in x)
                C[G] = Cd(x[G], l, _, T);
            return C
        }
        if (x instanceof Date)
            return structuredClone(x);
        if (typeof x.toJSON == "function")
            return Cd(x.toJSON(), l, _, T, x)
    }
    if (x instanceof EventTarget)
        return x;
    try {
        return structuredClone(x)
    } catch {
        return x
    }
}
function Ox() {
    return Symbol(Ry)
}
function Iu(x, l, _) {
    gg && jy();
    var T = x, E = Gy, F, C, o = null, W = By() ? Fy : Oy;
    function G() {
        F && Hy(F),
        o !== null && (o.lastChild.remove(),
        T.before(o),
        o = null),
        F = C
    }
    Ny( () => {
        if (W(E, E = l())) {
            var re = T
              , de = $y();
            de && (o = document.createDocumentFragment(),
            o.append(re = qy())),
            C = Vy( () => _(re)),
            de ? Zy.add_callback(G) : G()
        }
    }
    ),
    gg && (T = Uy)
}
const Nx = () => performance.now()
  , Cs = {
    tick: x => requestAnimationFrame(x),
    now: () => Nx(),
    tasks: new Set
};
function Qg() {
    const x = Cs.now();
    Cs.tasks.forEach(l => {
        l.c(x) || (Cs.tasks.delete(l),
        l.f())
    }
    ),
    Cs.tasks.size !== 0 && Cs.tick(Qg)
}
function jx(x) {
    let l;
    return Cs.tasks.size === 0 && Cs.tick(Qg),
    {
        promise: new Promise(_ => {
            Cs.tasks.add(l = {
                c: x,
                f: _
            })
        }
        ),
        abort() {
            Cs.tasks.delete(l)
        }
    }
}
function xd(x, l) {
    Xf( () => {
        x.dispatchEvent(new CustomEvent(l))
    }
    )
}
function qx(x) {
    if (x === "float")
        return "cssFloat";
    if (x === "offset")
        return "cssOffset";
    if (x.startsWith("--"))
        return x;
    const l = x.split("-");
    return l.length === 1 ? l[0] : l[0] + l.slice(1).map(_ => _[0].toUpperCase() + _.slice(1)).join("")
}
function wg(x) {
    const l = {}
      , _ = x.split(";");
    for (const T of _) {
        const [E,F] = T.split(":");
        if (!E || F === void 0)
            break;
        const C = qx(E.trim());
        l[C] = F.trim()
    }
    return l
}
const Vx = x => x;
function Ko(x, l, _) {
    var T = hx, E, F, C, o = null;
    T.a ?? (T.a = {
        element: x,
        measure() {
            E = this.element.getBoundingClientRect()
        },
        apply() {
            if (C == null || C.abort(),
            F = this.element.getBoundingClientRect(),
            E.left !== F.left || E.right !== F.right || E.top !== F.top || E.bottom !== F.bottom) {
                const W = l()(this.element, {
                    from: E,
                    to: F
                }, _ == null ? void 0 : _());
                C = Ed(this.element, W, void 0, 1, () => {
                    C == null || C.abort(),
                    C = void 0
                }
                )
            }
        },
        fix() {
            if (!x.getAnimations().length) {
                var {position: W, width: G, height: re} = getComputedStyle(x);
                if (W !== "absolute" && W !== "fixed") {
                    var de = x.style;
                    o = {
                        position: de.position,
                        width: de.width,
                        height: de.height,
                        transform: de.transform
                    },
                    de.position = "absolute",
                    de.width = G,
                    de.height = re;
                    var he = x.getBoundingClientRect();
                    if (E.left !== he.left || E.top !== he.top) {
                        var X = `translate(${E.left - he.left}px, ${E.top - he.top}px)`;
                        de.transform = de.transform ? `${de.transform} ${X}` : X
                    }
                }
            }
        },
        unfix() {
            if (o) {
                var W = x.style;
                W.position = o.position,
                W.width = o.width,
                W.height = o.height,
                W.transform = o.transform
            }
        }
    }),
    T.a.element = x
}
function Cn(x, l, _, T) {
    var E = (x & rx) !== 0, F = (x & ix) !== 0, C = E && F, o = (x & Xy) !== 0, W = C ? "both" : E ? "in" : "out", G, re = l.inert, de = l.style.overflow, he, X;
    function le() {
        return Xf( () => G ?? (G = _()(l, (T == null ? void 0 : T()) ?? {}, {
            direction: W
        })))
    }
    var Se = {
        is_global: o,
        in() {
            var Ne;
            if (l.inert = re,
            !E) {
                X == null || X.abort(),
                (Ne = X == null ? void 0 : X.reset) == null || Ne.call(X);
                return
            }
            F || he == null || he.abort(),
            xd(l, "introstart"),
            he = Ed(l, le(), X, 1, () => {
                xd(l, "introend"),
                he == null || he.abort(),
                he = G = void 0,
                l.style.overflow = de
            }
            )
        },
        out(Ne) {
            if (!F) {
                Ne == null || Ne(),
                G = void 0;
                return
            }
            l.inert = !0,
            xd(l, "outrostart"),
            X = Ed(l, le(), he, 0, () => {
                xd(l, "outroend"),
                Ne == null || Ne()
            }
            )
        },
        stop: () => {
            he == null || he.abort(),
            X == null || X.abort()
        }
    }
      , Ie = Wy;
    if ((Ie.transitions ?? (Ie.transitions = [])).push(Se),
    E && ux) {
        var De = o;
        if (!De) {
            for (var qe = Ie.parent; qe && (qe.f & Jy) !== 0; )
                for (; (qe = qe.parent) && (qe.f & Qy) === 0; )
                    ;
            De = !qe || (qe.f & ex) !== 0
        }
        De && tx( () => {
            so( () => Se.in())
        }
        )
    }
}
function Ed(x, l, _, T, E) {
    var F = T === 1;
    if (Ky(l)) {
        var C, o = !1;
        return Yy( () => {
            if (!o) {
                var Ie = l({
                    direction: F ? "in" : "out"
                });
                C = Ed(x, Ie, _, T, E)
            }
        }
        ),
        {
            abort: () => {
                o = !0,
                C == null || C.abort()
            }
            ,
            deactivate: () => C.deactivate(),
            reset: () => C.reset(),
            t: () => C.t()
        }
    }
    if (_ == null || _.deactivate(),
    !(l != null && l.duration))
        return E(),
        {
            abort: Sn,
            deactivate: Sn,
            reset: Sn,
            t: () => T
        };
    const {delay: W=0, css: G, tick: re, easing: de=Vx} = l;
    var he = [];
    if (F && _ === void 0 && (re && re(0, 1),
    G)) {
        var X = wg(G(0, 1));
        he.push(X, X)
    }
    var le = () => 1 - T
      , Se = x.animate(he, {
        duration: W,
        fill: "forwards"
    });
    return Se.onfinish = () => {
        Se.cancel();
        var Ie = (_ == null ? void 0 : _.t()) ?? 1 - T;
        _ == null || _.abort();
        var De = T - Ie
          , qe = l.duration * Math.abs(De)
          , Ne = [];
        if (qe > 0) {
            var Ze = !1;
            if (G)
                for (var ut = Math.ceil(qe / 16.666666666666668), rt = 0; rt <= ut; rt += 1) {
                    var Ue = Ie + De * de(rt / ut)
                      , lt = wg(G(Ue, 1 - Ue));
                    Ne.push(lt),
                    Ze || (Ze = lt.overflow === "hidden")
                }
            Ze && (x.style.overflow = "hidden"),
            le = () => {
                var et = Se.currentTime;
                return Ie + De * de(et / qe)
            }
            ,
            re && jx( () => {
                if (Se.playState !== "running")
                    return !1;
                var et = le();
                return re(et, 1 - et),
                !0
            }
            )
        }
        Se = x.animate(Ne, {
            duration: qe,
            fill: "forwards"
        }),
        Se.onfinish = () => {
            le = () => T,
            re == null || re(T, 1 - T),
            E()
        }
    }
    ,
    {
        abort: () => {
            Se && (Se.cancel(),
            Se.effect = null,
            Se.onfinish = Sn)
        }
        ,
        deactivate: () => {
            E = Sn
        }
        ,
        reset: () => {
            T === 0 && (re == null || re(1, 0))
        }
        ,
        t: () => le()
    }
}
function Vd(x, l) {
    nx(window, ["resize"], () => Xf( () => l(window[x])))
}
const Zx = () => "Log in"
  , $x = () => "Entrar"
  , Ux = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Zx() : $x()
  , Gx = () => "Store"
  , Hx = () => "Loja"
  , ev = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Gx() : Hx()
  , Wx = () => "Alliance"
  , Xx = () => "AlianÃ§a"
  , Zd = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Wx() : Xx()
  , Kx = () => "Leaderboard"
  , Yx = () => "Ranking"
  , rm = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Kx() : Yx()
  , Jx = () => "Unlock"
  , Qx = () => "Destravar"
  , e1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Jx() : Qx()
  , t1 = () => "Lock"
  , r1 = () => "Travar"
  , i1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? t1() : r1()
  , n1 = () => "Info"
  , a1 = () => "InformaÃ§Ãµes"
  , s1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? n1() : a1()
  , o1 = () => "Zoom in"
  , l1 = () => "Aumentar zoom"
  , c1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? o1() : l1()
  , u1 = () => "Zoom out"
  , h1 = () => "Diminuir zoom"
  , d1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? u1() : h1()
  , p1 = () => "Previous location"
  , f1 = () => "LocalizaÃ§Ã£o anterior"
  , m1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? p1() : f1()
  , _1 = () => "Offline"
  , g1 = () => "Offline"
  , v1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? _1() : g1()
  , y1 = () => "Zoom in to see the pixels"
  , x1 = () => "Amplie para ver os pixels"
  , b1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? y1() : x1()
  , w1 = () => "Phone verification required"
  , T1 = () => "VerificaÃ§Ã£o de telefone necessÃ¡ria"
  , Tg = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? w1() : T1()
  , C1 = () => "My location"
  , S1 = () => "Minha localizaÃ§Ã£o"
  , P1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? C1() : S1()
  , I1 = () => "You don't have charges to paint. Wait to recharge."
  , M1 = () => "VocÃª nÃ£o possui tinta para pintar. Aguarde para carrega-las."
  , A1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? I1() : M1()
  , k1 = () => "Map powered by:"
  , E1 = () => "Mapa fornecido por:"
  , z1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? k1() : E1()
  , L1 = () => "OpenMapTiles Data from"
  , D1 = () => "OpenMapTiles com dados do"
  , R1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? L1() : D1()
  , B1 = () => "Feedback and bugs"
  , F1 = () => "Feedback e bugs"
  , O1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? B1() : F1()
  , N1 = () => "Overview"
  , j1 = () => "VisÃ£o Geral"
  , q1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? N1() : j1()
  , V1 = () => "How to paint faster"
  , Z1 = () => "Como pintar mais rÃ¡pido"
  , $1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? V1() : Z1()
  , U1 = () => "When painting, click on the button"
  , G1 = () => "Quando pintar clique no botÃ£o"
  , H1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? U1() : G1()
  , W1 = () => "on the top right corner of the screen. This will lock the screen but it'll also enable painting by moving your finger over the map."
  , X1 = () => "no canto superior direito da tela. Isso bloquearÃ¡ a tela, mas tambÃ©m permitirÃ¡ pintar movendo o dedo sobre o mapa."
  , K1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? W1() : X1()
  , Y1 = () => "Hold"
  , J1 = () => "Segure"
  , Q1 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Y1() : J1()
  , eb = () => "SPACE"
  , tb = () => "EspaÃ§o"
  , rb = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? eb() : tb()
  , ib = () => "and move your cursor over the map."
  , nb = () => "e mova seu cursor sobre o mapa."
  , ab = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? ib() : nb()
  , sb = () => "Explore"
  , ob = () => "Explorar"
  , lb = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? sb() : ob()
  , cb = () => "Recharge paint charges"
  , ub = () => "Recarga de tinta"
  , hb = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? cb() : ub()
  , db = () => "Items"
  , pb = () => "Itens"
  , fb = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? db() : pb()
  , mb = () => "Get more charges"
  , _b = () => "Recarregue tinta para pintar"
  , gb = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? mb() : _b()
  , vb = x => `+${x.amount} Max. Charges`
  , yb = x => `+${x.amount} Tinta mÃ¡xima`
  , xb = (x, l={}) => (l.locale ?? Ge()) === "en" ? vb(x) : yb(x)
  , bb = () => "Increase your maximum paint charges capacity"
  , wb = () => "Aumente sua capacidade mÃ¡xima de tinta"
  , Tb = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? bb() : wb()
  , Cb = () => "Profile picture"
  , Sb = () => "Imagem de perfil"
  , Pb = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Cb() : Sb()
  , Ib = () => "Add a new 16x16 profile picture"
  , Mb = () => "Adicionar uma nova imagem de perfil 16x16"
  , Ab = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Ib() : Mb()
  , kb = () => "Not enough droplets"
  , Eb = () => "Droplets insuficientes"
  , $d = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? kb() : Eb()
  , zb = () => "Show profile"
  , Lb = () => "Exibir perfil"
  , Db = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? zb() : Lb()
  , Rb = () => "Pixels painted"
  , Bb = () => "Pixels pintados"
  , im = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Rb() : Bb()
  , Fb = () => "Menu"
  , Ob = () => "Menu"
  , Nb = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Fb() : Ob()
  , jb = x => `Could not install the app: ${x.error}`
  , qb = x => `NÃ£o pode instalar o app: ${x.error}`
  , Vb = (x, l={}) => (l.locale ?? Ge()) === "en" ? jb(x) : qb(x)
  , Zb = () => "Install App"
  , $b = () => "Instalar App"
  , Ub = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Zb() : $b()
  , Gb = () => "Livestreams"
  , Hb = () => "Livestreams"
  , Wb = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Gb() : Hb()
  , Xb = () => "Log Out"
  , Kb = () => "Log Out"
  , Yb = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Xb() : Kb()
  , Jb = () => "Hide UI"
  , Qb = () => "Esconder UI"
  , e2 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Jb() : Qb()
  , t2 = () => "Change picture:"
  , r2 = () => "Change picture:"
  , i2 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? t2() : r2()
  , n2 = () => "Email"
  , a2 = () => "Email"
  , s2 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? n2() : a2()
  , o2 = () => "Show last painted pixel on alliance"
  , l2 = () => "Mostrar Ãºltimo pixel pintado na alianÃ§a"
  , c2 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? o2() : l2()
  , u2 = () => "Delete Account"
  , h2 = () => "Deletar Conta"
  , Cg = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? u2() : h2()
  , d2 = () => "Save"
  , p2 = () => "Salvar"
  , f2 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? d2() : p2()
  , m2 = () => "Are you absolutely sure?"
  , _2 = () => "VocÃª tem certeza absoluta?"
  , g2 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? m2() : _2()
  , v2 = () => "This will permanently delete your account and all associated data. This action cannot be undone."
  , y2 = () => "Isso excluirÃ¡ permanentemente sua conta e todos os dados associados. Esta aÃ§Ã£o nÃ£o pode ser desfeita."
  , x2 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? v2() : y2()
  , b2 = () => "Profile"
  , w2 = () => "Perfil"
  , T2 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? b2() : w2()
  , C2 = () => "Display your countryâ€™s flag next to your username. Plus, when painting in regions where you own the corresponding flag, you recover 10% of the charges spent."
  , S2 = () => "Exiba a bandeira do seu paÃ­s ao lado do seu nome de usuÃ¡rio. AlÃ©m disso, ao pintar em regiÃµes onde vocÃª possui a bandeira correspondente, vocÃª recupera 10% das tintas gastas."
  , P2 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? C2() : S2()
  , I2 = () => "Does not need to be equiped to provide the bonus"
  , M2 = () => "NÃ£o precisa estar equipada para obter o bÃ²nus"
  , A2 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? I2() : M2()
  , k2 = () => "Equipped"
  , E2 = () => "Equipado"
  , z2 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? k2() : E2()
  , L2 = () => "Equip"
  , D2 = () => "Equipar"
  , R2 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? L2() : D2()
  , B2 = () => "Country"
  , F2 = () => "PaÃ­s"
  , tv = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? B2() : F2()
  , O2 = () => "No country found."
  , N2 = () => "PaÃ­s nÃ£o encontrado."
  , j2 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? O2() : N2()
  , q2 = () => "Welcome to"
  , V2 = () => "Bem vindo ao"
  , Z2 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? q2() : V2()
  , $2 = () => "Rules"
  , U2 = () => "Regras"
  , G2 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? $2() : U2()
  , H2 = () => "Important"
  , W2 = () => "Importante"
  , X2 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? H2() : W2()
  , K2 = () => "ðŸ˜ˆ Do not paint over other artworks using random colors or patterns just to mess things up"
  , Y2 = () => "ðŸ˜ˆ NÃ£o desenhe por cima de outras artes usando cores ou padrÃµes aleatÃ³rios sÃ³ para bagunÃ§ar"
  , J2 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? K2() : Y2()
  , Q2 = () => "ðŸ”ž No +18 or hate group related paintings"
  , ew = () => "ðŸ”ž Desenhos +18 ou com discurso de Ã³dio nÃ£o sÃ£o permitidos"
  , tw = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Q2() : ew()
  , rw = () => "ðŸ”— Do not reference inappropriate websites"
  , iw = () => "ðŸ”— NÃ£o faÃ§a referÃªncia a sites inapropriados"
  , nw = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? rw() : iw()
  , aw = () => "ðŸ§‘â€ðŸ¤â€ðŸ§‘ Do not paint with more than one account"
  , sw = () => "ðŸ§‘â€ðŸ¤â€ðŸ§‘ NÃ£o desenhe com mais de uma conta"
  , ow = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? aw() : sw()
  , lw = () => "ðŸ¤– Use of bots is not allowed"
  , cw = () => "ðŸ¤– Usar bots nÃ£o Ã© permitido"
  , uw = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? lw() : cw()
  , hw = () => "âœ… Painting over other artworks to complement them or create a new drawing is allowed"
  , dw = () => "âœ… Desenhar sobre outras artes para complementar ou criar novas artes Ã© permitido"
  , pw = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? hw() : dw()
  , fw = () => "âœ… Griefing political party flags or portraits of politicians is allowed"
  , mw = () => "âœ… Desenhar sobre bandeiras de partidos e retratos de polÃ­ticos Ã© permitido"
  , _w = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? fw() : mw()
  , gw = () => "ðŸ™… Disclosing other user's personal information is not allowed"
  , vw = () => "ðŸ™… Divulgar informaÃ§Ãµes pessoais de outros usuÃ¡rios nÃ£o Ã© permitido"
  , yw = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? gw() : vw()
  , xw = () => "Violations of these rules may result in suspension of your account."
  , bw = () => "ViolaÃ§Ãµes destas regras podem resultar na suspensÃ£o da sua conta."
  , ww = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? xw() : bw()
  , Tw = () => "Understood"
  , Cw = () => "Entendido"
  , Sw = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Tw() : Cw()
  , Pw = () => "Toggle art opacity"
  , Iw = () => "Alterar opacidade"
  , rv = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Pw() : Iw()
  , Mw = () => "Paint"
  , Aw = () => "Pintar"
  , iv = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Mw() : Aw()
  , kw = () => "Select a color"
  , Ew = () => "Selecione uma color"
  , zw = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? kw() : Ew()
  , Lw = () => "Select a pixel to erase"
  , Dw = () => "Selecione um pixel para apagar"
  , Rw = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Lw() : Dw()
  , Bw = () => "Pick a color from the map"
  , Fw = () => "Escolha uma cor do mapa"
  , Ow = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Bw() : Fw()
  , Nw = () => "Click"
  , jw = () => "Clique"
  , qw = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Nw() : jw()
  , Vw = () => "SPACE"
  , Zw = () => "ESPAÃ‡O"
  , $w = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Vw() : Zw()
  , Uw = () => "or hold"
  , Gw = () => "ou segure"
  , Hw = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Uw() : Gw()
  , Ww = () => "to paint,"
  , Xw = () => "para pintar"
  , Kw = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Ww() : Xw()
  , Yw = () => "You can paint more than 1 pixel"
  , Jw = () => "VocÃª pode pintar mais de 1 pixel"
  , Qw = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Yw() : Jw()
  , e5 = () => "Paint pixel"
  , t5 = () => "Pintar pixel"
  , r5 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? e5() : t5()
  , i5 = () => "Color Picker"
  , n5 = () => "Conta Gotas"
  , a5 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? i5() : n5()
  , s5 = () => "+2 max. charge/level"
  , o5 = () => "+2 tinta mÃ¡xima/level"
  , l5 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? s5() : o5()
  , c5 = () => "Name"
  , u5 = () => "Nome"
  , wf = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? c5() : u5()
  , h5 = () => "Discord Username"
  , d5 = () => "UsuÃ¡rio do Discord"
  , p5 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? h5() : d5()
  , f5 = () => "Max. Charges"
  , m5 = () => "Tinta mÃ¡xima"
  , Sg = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? f5() : m5()
  , _5 = () => "Paint Charges"
  , g5 = () => "Tintas"
  , v5 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? _5() : g5()
  , y5 = x => `+${x.amount} Paint Charges`
  , x5 = x => `+${x.amount} Tintas`
  , b5 = (x, l={}) => (l.locale ?? Ge()) === "en" ? y5(x) : x5(x)
  , w5 = () => "Leave alliance"
  , T5 = () => "Sair da alianÃ§a"
  , C5 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? w5() : T5()
  , S5 = () => "Members"
  , P5 = () => "Membros"
  , nv = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? S5() : P5()
  , I5 = () => "Headquarters"
  , M5 = () => "Quartel General"
  , A5 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? I5() : M5()
  , k5 = () => "Not set"
  , E5 = () => "NÃ£o configurado"
  , z5 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? k5() : E5()
  , L5 = () => "You are not in an alliance"
  , D5 = () => "VocÃª nÃ£o estÃ¡ em uma alianÃ§a"
  , R5 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? L5() : D5()
  , B5 = () => "Get invited to an alliance"
  , F5 = () => "Seja convidado para uma alianÃ§a"
  , O5 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? B5() : F5()
  , N5 = () => "OR"
  , j5 = () => "OU"
  , q5 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? N5() : j5()
  , V5 = () => "Create an alliance"
  , Z5 = () => "Crie uma alianÃ§a"
  , $5 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? V5() : Z5()
  , U5 = () => "Invite link"
  , G5 = () => "Link de convite"
  , H5 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? U5() : G5()
  , W5 = () => "Send the link bellow to everybody you want to invite to the alliance"
  , X5 = () => "Envie o link abaixo para quem vocÃª deseja convidar para a alianÃ§a"
  , K5 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? W5() : X5()
  , Y5 = () => "Copied"
  , J5 = () => "Copiado"
  , av = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Y5() : J5()
  , Q5 = () => "Copy"
  , eT = () => "Copiar"
  , Tf = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Q5() : eT()
  , tT = () => "No description"
  , rT = () => "Sem descriÃ§Ã£o"
  , sv = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? tT() : rT()
  , iT = () => "Invite"
  , nT = () => "Convite"
  , aT = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? iT() : nT()
  , sT = () => "No pixels painted"
  , oT = () => "Nenhum pixel pintado"
  , nm = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? sT() : oT()
  , lT = () => "Today"
  , cT = () => "Hoje"
  , Ud = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? lT() : cT()
  , uT = () => "Week"
  , hT = () => "Semana"
  , dT = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? uT() : hT()
  , pT = () => "Month"
  , fT = () => "MÃªs"
  , mT = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? pT() : fT()
  , _T = () => "All time"
  , gT = () => "Geral"
  , vT = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? _T() : gT()
  , yT = () => "this week"
  , xT = () => "nesta semana"
  , am = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? yT() : xT()
  , bT = () => "this month"
  , wT = () => "neste mÃªs"
  , sm = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? bT() : wT()
  , TT = () => "Player"
  , CT = () => "Jogador"
  , om = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? TT() : CT()
  , ST = () => "Last pixel"
  , PT = () => "Ãšltimo pixel"
  , IT = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? ST() : PT()
  , MT = () => "Create alliance"
  , AT = () => "Criar alianÃ§a"
  , kT = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? MT() : AT()
  , ET = () => "Alliance Name"
  , zT = () => "Nome da alianÃ§a"
  , LT = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? ET() : zT()
  , DT = () => "Create"
  , RT = () => "Criar"
  , BT = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? DT() : RT()
  , FT = () => "Give admin"
  , OT = () => "Tornar admin"
  , NT = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? FT() : OT()
  , jT = () => "Ban from alliance"
  , qT = () => "Banir da alianÃ§a"
  , ov = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? jT() : qT()
  , VT = () => "No action"
  , ZT = () => "Sem opÃ§Ã£o"
  , $T = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? VT() : ZT()
  , UT = () => "Unban"
  , GT = () => "Desbanir"
  , HT = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? UT() : GT()
  , WT = () => "No banned users"
  , XT = () => "Sem usuÃ¡rios banidos"
  , KT = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? WT() : XT()
  , YT = () => "Description"
  , JT = () => "DescriÃ§Ã£o"
  , QT = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? YT() : JT()
  , e3 = () => "Update"
  , t3 = () => "Atualizar"
  , r3 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? e3() : t3()
  , i3 = () => "Error giving admin to user"
  , n3 = () => "Erro ao tornar usuÃ¡rio admin"
  , a3 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? i3() : n3()
  , s3 = () => "Users"
  , o3 = () => "UsuÃ¡rios"
  , l3 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? s3() : o3()
  , c3 = () => "Banned"
  , u3 = () => "Banido"
  , h3 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? c3() : u3()
  , d3 = () => "Regions"
  , p3 = () => "RegiÃµes"
  , f3 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? d3() : p3()
  , m3 = () => "Countries"
  , _3 = () => "PaÃ­ses"
  , g3 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? m3() : _3()
  , v3 = () => "Players"
  , y3 = () => "Jogadores"
  , lv = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? v3() : y3()
  , x3 = () => "Alliances"
  , b3 = () => "AlianÃ§as"
  , cv = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? x3() : b3()
  , w3 = () => "Region"
  , T3 = () => "RegiÃ£o"
  , C3 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? w3() : T3()
  , S3 = () => "Pixels"
  , P3 = () => "Pixels"
  , Yl = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? S3() : P3()
  , I3 = () => "Painted"
  , M3 = () => "Pintados"
  , Jl = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? I3() : M3()
  , A3 = () => "Pixels painted inside the region"
  , k3 = () => "Pixels pintados dentro da regiÃ£o"
  , E3 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? A3() : k3()
  , z3 = () => "Visit"
  , L3 = () => "Visitar"
  , D3 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? z3() : L3()
  , R3 = () => "Not painted"
  , B3 = () => "NÃ£o pintado"
  , F3 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? R3() : B3()
  , O3 = () => "Painted by"
  , N3 = () => "Pintado por"
  , j3 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? O3() : N3()
  , q3 = () => "Limit reached"
  , V3 = () => "Limite atingido"
  , Z3 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? q3() : V3()
  , $3 = () => "Favorite"
  , U3 = () => "Favoritar"
  , G3 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? $3() : U3()
  , H3 = () => "Share"
  , W3 = () => "Compartilhar"
  , X3 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? H3() : W3()
  , K3 = () => "Share place"
  , Y3 = () => "Compartilhar local"
  , J3 = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? K3() : Y3()
  , Q3 = () => "Mute"
  , eC = () => "Mutar"
  , tC = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? Q3() : eC()
  , rC = () => "Unmute"
  , iC = () => "Desmutar"
  , nC = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? rC() : iC()
  , aC = () => "Select the headquarters location"
  , sC = () => "Selecione a localizaÃ§Ã£o do quartel general"
  , oC = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? aC() : sC()
  , lC = () => "Pixels painted inside the country"
  , cC = () => "Pixels pintados dentro do paÃ­s"
  , uC = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? lC() : cC()
  , hC = () => "Username copied to clipboard"
  , dC = () => "UsuÃ¡rio copiado"
  , pC = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? hC() : dC()
  , fC = () => "No more charges"
  , mC = () => "Acabou a tinta"
  , _C = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? fC() : mC()
  , gC = () => "You are not allowed to use multiple accounts"
  , vC = () => "NÃ£o Ã© permitido usar vÃ¡rias contas"
  , yC = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? gC() : vC()
  , xC = () => "SMS sent to"
  , bC = () => "SMS enviado para"
  , wC = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? xC() : bC()
  , TC = () => "Phone successfully verified"
  , CC = () => "Telefone verificado com sucesso"
  , SC = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? TC() : CC()
  , PC = () => "Not a valid phone number"
  , IC = () => "NÃ£o Ã© um nÃºmero vÃ¡lido"
  , MC = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? PC() : IC()
  , AC = () => "Location unfavorited"
  , kC = () => "LocalizaÃ§Ã£o desfavoritada"
  , EC = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? AC() : kC()
  , zC = () => "Location favorited"
  , LC = () => "LocalizaÃ§Ã£o favoritada"
  , DC = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? zC() : LC()
  , RC = () => "Giving admin to user"
  , BC = () => "Tornar usuÃ¡rio um admin"
  , FC = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? RC() : BC()
  , OC = () => "Profile updated"
  , NC = () => "Perfil atualizado"
  , jC = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? OC() : NC()
  , qC = () => "Account successfully deleted"
  , VC = () => "Conta deletada com sucesso"
  , ZC = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? qC() : VC()
  , $C = () => "Logged out"
  , UC = () => "Logout feito"
  , GC = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? $C() : UC()
  , HC = () => "Could not logout. Try refreshing the page."
  , WC = () => "NÃ£o foi possÃ­vel sair da conta. Tente recarregar a pÃ¡gina."
  , XC = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? HC() : WC()
  , KC = () => "You need zoom in to select a pixel"
  , YC = () => "DÃª zoom para selecionar um pixel"
  , JC = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? KC() : YC()
  , QC = () => "Phone verification"
  , eS = () => "VerificaÃ§Ã£o de telefone"
  , tS = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? QC() : eS()
  , rS = () => "Please verify your phone number to continue playing. This helps us keep bots out and ensure a safe, creative experience for everyone."
  , iS = () => "Por favor, verifique com seu telefone para continuar jogando. Isso nos ajuda a filtrar bots e manter um experiÃªncia segura e criativa para todos."
  , nS = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? rS() : iS()
  , aS = () => "Send Code"
  , sS = () => "Enviar o cÃ³digo"
  , oS = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? aS() : sS()
  , lS = () => "Input the code"
  , cS = () => "Insira o cÃ³digo"
  , uS = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? lS() : cS()
  , hS = () => "Sent to"
  , dS = () => "Enviar para"
  , pS = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? hS() : dS()
  , fS = () => "Resend Code"
  , mS = () => "Reenviar CÃ³digo"
  , _S = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? fS() : mS()
  , gS = () => "Try another number"
  , vS = () => "Tentar outro nÃºmero"
  , yS = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? gS() : vS()
  , xS = () => "Edit profile"
  , bS = () => "Editar perfil"
  , wS = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? xS() : bS()
  , TS = () => "Image"
  , CS = () => "Imagem"
  , SS = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? TS() : CS()
  , PS = () => "Download"
  , IS = () => "Download"
  , MS = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? PS() : IS()
  , AS = () => "Image copied to clipboard"
  , kS = () => "Imagem copiada para a Ã¡rea de transferÃªncia"
  , ES = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? AS() : kS()
  , zS = () => "My map is lagging"
  , LS = () => "Meu mapa estÃ¡ travando"
  , DS = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? zS() : LS()
  , RS = () => "Verify if"
  , BS = () => "Verifique se"
  , FS = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? RS() : BS()
  , OS = () => "Use graphics acceleration when available"
  , NS = () => "Usar aceleraÃ§Ã£o grÃ¡fica quando disponÃ­vel"
  , jS = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? OS() : NS()
  , qS = () => "is enabled on"
  , VS = () => "estÃ¡ habilitado em"
  , ZS = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? qS() : VS()
  , $S = () => "Follow the instructions to enable hardware acceleration"
  , US = () => "Siga a instruÃ§Ã£o para habilitar a aceleraÃ§Ã£o de hardware"
  , GS = (x={}, l={}) => (l.locale ?? Ge()) === "en" ? $S() : US()
  , xs = 2 * Math.PI * 6378137 / 2;
class cc {
    constructor(l=256) {
        hr(this, "initialResolution");
        this.tileSize = l,
        this.initialResolution = 2 * xs / this.tileSize
    }
    latLonToMeters(l, _) {
        const T = _ / 180 * xs
          , E = Math.log(Math.tan((90 + l) * Math.PI / 360)) / (Math.PI / 180) * xs / 180;
        return [T, E]
    }
    metersToLatLon(l, _) {
        const T = l / xs * 180;
        let E = _ / xs * 180;
        return E = 180 / Math.PI * (2 * Math.atan(Math.exp(E * Math.PI / 180)) - Math.PI / 2),
        [E, T]
    }
    pixelsToMeters(l, _, T) {
        const E = this.resolution(T)
          , F = l * E - xs
          , C = xs - _ * E;
        return [F, C]
    }
    pixelsToLatLon(l, _, T) {
        const [E,F] = this.pixelsToMeters(l, _, T);
        return this.metersToLatLon(E, F)
    }
    latLonToPixels(l, _, T) {
        const [E,F] = this.latLonToMeters(l, _);
        return this.metersToPixels(E, F, T)
    }
    latLonToPixelsFloor(l, _, T) {
        const [E,F] = this.latLonToPixels(l, _, T);
        return [Math.floor(E), Math.floor(F)]
    }
    metersToPixels(l, _, T) {
        const E = this.resolution(T)
          , F = (l + xs) / E
          , C = (xs - _) / E;
        return [F, C]
    }
    latLonToTile(l, _, T) {
        const [E,F] = this.latLonToMeters(l, _);
        return this.metersToTile(E, F, T)
    }
    metersToTile(l, _, T) {
        const [E,F] = this.metersToPixels(l, _, T);
        return this.pixelsToTile(E, F)
    }
    pixelsToTile(l, _) {
        const T = Math.ceil(l / this.tileSize) - 1
          , E = Math.ceil(_ / this.tileSize) - 1;
        return [T, E]
    }
    pixelsToTileLocal(l, _) {
        return {
            tile: this.pixelsToTile(l, _),
            pixel: [Math.floor(l) % this.tileSize, Math.floor(_) % this.tileSize]
        }
    }
    tileBounds(l, _, T) {
        const [E,F] = this.pixelsToMeters(l * this.tileSize, _ * this.tileSize, T)
          , [C,o] = this.pixelsToMeters((l + 1) * this.tileSize, (_ + 1) * this.tileSize, T);
        return {
            min: [E, F],
            max: [C, o]
        }
    }
    tileBoundsLatLon(l, _, T) {
        const E = this.tileBounds(l, _, T);
        return {
            min: this.metersToLatLon(E.min[0], E.min[1]),
            max: this.metersToLatLon(E.max[0], E.max[1])
        }
    }
    resolution(l) {
        return this.initialResolution / 2 ** l
    }
    latLonToTileAndPixel(l, _, T) {
        const [E,F] = this.latLonToMeters(l, _)
          , [C,o] = this.metersToTile(E, F, T)
          , [W,G] = this.metersToPixels(E, F, T);
        return {
            tile: [C, o],
            pixel: [Math.floor(W) % this.tileSize, Math.floor(G) % this.tileSize]
        }
    }
    pixelBounds(l, _, T) {
        return {
            min: this.pixelsToMeters(l, _, T),
            max: this.pixelsToMeters(l + 1, _ + 1, T)
        }
    }
    pixelToBoundsLatLon(l, _, T) {
        const E = this.pixelBounds(l, _, T)
          , F = .001885
          , C = (E.max[0] - E.min[0]) * F
          , o = (E.max[1] - E.min[1]) * F;
        return E.min[0] -= C,
        E.max[0] -= C,
        E.min[1] -= o,
        E.max[1] -= o,
        {
            min: this.metersToLatLon(E.min[0], E.min[1]),
            max: this.metersToLatLon(E.max[0], E.max[1])
        }
    }
    latLonToTileBoundsLatLon(l, _, T) {
        const [E,F] = this.latLonToMeters(l, _)
          , [C,o] = this.metersToTile(E, F, T);
        return this.tileBoundsLatLon(C, o, T)
    }
    latLonToPixelBoundsLatLon(l, _, T) {
        const [E,F] = this.latLonToMeters(l, _)
          , [C,o] = this.metersToPixels(E, F, T);
        return this.pixelToBoundsLatLon(Math.floor(C), Math.floor(o), T)
    }
    latLonToRegionAndPixel(l, _, T, E=Bn.regionSize) {
        const [F,C] = this.latLonToPixelsFloor(l, _, T)
          , o = this.tileSize * E;
        return {
            region: [Math.floor(F / o), Math.floor(C / o)],
            pixel: [F % o, C % o]
        }
    }
}
function lm(x, l=!0) {
    const {min: _, max: T} = x;
    return l ? [[_[1], T[0]], [T[1], T[0]], [T[1], _[0]], [_[1], _[0]]] : [[_[0], T[1]], [T[0], T[1]], [T[0], _[1]], [_[0], _[1]]]
}
function cm(x) {
    return [(x.min[0] + x.max[0]) / 2, (x.min[1] + x.max[1]) / 2]
}
const HS = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAAAAACoWZBhAAAAAXNSR0IArs4c6QAAACpJREFUeNpj+AsEZ86ASIa/DAwMZ84ACRDzDBigMs/AARITq1oUwxBWAADaREUdDMswKwAAAABJRU5ErkJggg=="
  , Pg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAACVJREFUeNpj+A8FDEAAZwMRBAIBmIYLIgHcgkQDIs3E6SRsjgcABYFLtfTgakEAAAAASUVORK5CYII=";
function WS(x) {
    return Math.floor(Math.random() * x)
}
const Cf = 14.5;
async function XS() {
    const x = JS();
    if (x)
        return x;
    try {
        if ((await navigator.permissions.query({
            name: "geolocation"
        })).state === "granted") {
            const _ = await new Promise( (T, E) => navigator.geolocation.getCurrentPosition(F => T(F), F => E(F)));
            return {
                lat: _.coords.latitude,
                lng: _.coords.longitude,
                zoom: Cf
            }
        }
    } catch (l) {
        console.error(l)
    }
    return {
        ...KS().pos,
        zoom: Cf
    }
}
function KS() {
    const x = Object.entries(YS)
      , l = WS(x.length)
      , [_,T] = x[l];
    return {
        city: _,
        pos: T
    }
}
const YS = {
    tokyo: {
        lat: 35.677545560719665,
        lng: 139.76394445809638
    },
    paris: {
        lat: 48.8537151734952,
        lng: 2.3484026030630787
    },
    newYork: {
        lat: 40.71283173786517,
        lng: -74.00599771376795
    },
    saoPaulo: {
        lat: -23.550584064565356,
        lng: -46.63339720713918
    },
    sydney: {
        lat: -33.86943325619071,
        lng: 151.2083447239608
    }
}
  , uv = "location";
function Va(x, l) {
    localStorage.setItem(uv, JSON.stringify({
        ...x,
        zoom: l
    }))
}
function JS() {
    const x = localStorage.getItem(uv);
    if (!x)
        return;
    const l = JSON.parse(x);
    return l.zoom ?? (l.zoom = Cf),
    l
}
var Eu, zu;
class QS {
    constructor() {
        Sr(this, Eu, mt(-1));
        Sr(this, zu, mt([]))
    }
    get idx() {
        return w(nt(this, Eu))
    }
    set idx(l) {
        fe(nt(this, Eu), l, !0)
    }
    get entries() {
        return w(nt(this, zu))
    }
    set entries(l) {
        fe(nt(this, zu), l)
    }
    hasNext() {
        return this.idx < this.entries.length - 1
    }
    goToNext(l) {
        const _ = this.idx + 1
          , T = this.entries[_];
        T && (this.idx = _,
        l.flyTo({
            center: T.pos,
            zoom: T.zoom
        }))
    }
    hasPrev() {
        return this.idx > 0
    }
    goToPrev(l) {
        const _ = this.idx - 1
          , T = this.entries[_];
        T && (this.idx = _,
        l.flyTo({
            center: T.pos,
            zoom: T.zoom
        }))
    }
    isEmpty() {
        return this.entries.length === 0
    }
    push(l) {
        this.idx = this.idx + 1,
        this.entries = [...this.entries.slice(0, this.idx), l]
    }
}
Eu = new WeakMap,
zu = new WeakMap;
const Jo = new QS;
function um(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x
}
var Sd = {
    exports: {}
};
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.6.1/LICENSE.txt
 */
var eP = Sd.exports, Ig;
function tP() {
    return Ig || (Ig = 1,
    function(x, l) {
        (function(_, T) {
            x.exports = T()
        }
        )(eP, function() {
            var _ = {}
              , T = {};
            function E(C, o, W) {
                if (T[C] = W,
                C === "index") {
                    var G = "var sharedModule = {}; (" + T.shared + ")(sharedModule); (" + T.worker + ")(sharedModule);"
                      , re = {};
                    return T.shared(re),
                    T.index(_, re),
                    typeof window < "u" && _.setWorkerUrl(window.URL.createObjectURL(new Blob([G],{
                        type: "text/javascript"
                    }))),
                    _
                }
            }
            E("shared", ["exports"], function(C) {
                function o(n, t, i, a) {
                    return new (i || (i = Promise))(function(u, p) {
                        function f(S) {
                            try {
                                y(a.next(S))
                            } catch (I) {
                                p(I)
                            }
                        }
                        function g(S) {
                            try {
                                y(a.throw(S))
                            } catch (I) {
                                p(I)
                            }
                        }
                        function y(S) {
                            var I;
                            S.done ? u(S.value) : (I = S.value,
                            I instanceof i ? I : new i(function(A) {
                                A(I)
                            }
                            )).then(f, g)
                        }
                        y((a = a.apply(n, t || [])).next())
                    }
                    )
                }
                function W(n) {
                    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
                }
                var G, re;
                function de() {
                    if (re)
                        return G;
                    function n(t, i) {
                        this.x = t,
                        this.y = i
                    }
                    return re = 1,
                    G = n,
                    n.prototype = {
                        clone: function() {
                            return new n(this.x,this.y)
                        },
                        add: function(t) {
                            return this.clone()._add(t)
                        },
                        sub: function(t) {
                            return this.clone()._sub(t)
                        },
                        multByPoint: function(t) {
                            return this.clone()._multByPoint(t)
                        },
                        divByPoint: function(t) {
                            return this.clone()._divByPoint(t)
                        },
                        mult: function(t) {
                            return this.clone()._mult(t)
                        },
                        div: function(t) {
                            return this.clone()._div(t)
                        },
                        rotate: function(t) {
                            return this.clone()._rotate(t)
                        },
                        rotateAround: function(t, i) {
                            return this.clone()._rotateAround(t, i)
                        },
                        matMult: function(t) {
                            return this.clone()._matMult(t)
                        },
                        unit: function() {
                            return this.clone()._unit()
                        },
                        perp: function() {
                            return this.clone()._perp()
                        },
                        round: function() {
                            return this.clone()._round()
                        },
                        mag: function() {
                            return Math.sqrt(this.x * this.x + this.y * this.y)
                        },
                        equals: function(t) {
                            return this.x === t.x && this.y === t.y
                        },
                        dist: function(t) {
                            return Math.sqrt(this.distSqr(t))
                        },
                        distSqr: function(t) {
                            var i = t.x - this.x
                              , a = t.y - this.y;
                            return i * i + a * a
                        },
                        angle: function() {
                            return Math.atan2(this.y, this.x)
                        },
                        angleTo: function(t) {
                            return Math.atan2(this.y - t.y, this.x - t.x)
                        },
                        angleWith: function(t) {
                            return this.angleWithSep(t.x, t.y)
                        },
                        angleWithSep: function(t, i) {
                            return Math.atan2(this.x * i - this.y * t, this.x * t + this.y * i)
                        },
                        _matMult: function(t) {
                            var i = t[2] * this.x + t[3] * this.y;
                            return this.x = t[0] * this.x + t[1] * this.y,
                            this.y = i,
                            this
                        },
                        _add: function(t) {
                            return this.x += t.x,
                            this.y += t.y,
                            this
                        },
                        _sub: function(t) {
                            return this.x -= t.x,
                            this.y -= t.y,
                            this
                        },
                        _mult: function(t) {
                            return this.x *= t,
                            this.y *= t,
                            this
                        },
                        _div: function(t) {
                            return this.x /= t,
                            this.y /= t,
                            this
                        },
                        _multByPoint: function(t) {
                            return this.x *= t.x,
                            this.y *= t.y,
                            this
                        },
                        _divByPoint: function(t) {
                            return this.x /= t.x,
                            this.y /= t.y,
                            this
                        },
                        _unit: function() {
                            return this._div(this.mag()),
                            this
                        },
                        _perp: function() {
                            var t = this.y;
                            return this.y = this.x,
                            this.x = -t,
                            this
                        },
                        _rotate: function(t) {
                            var i = Math.cos(t)
                              , a = Math.sin(t)
                              , u = a * this.x + i * this.y;
                            return this.x = i * this.x - a * this.y,
                            this.y = u,
                            this
                        },
                        _rotateAround: function(t, i) {
                            var a = Math.cos(t)
                              , u = Math.sin(t)
                              , p = i.y + u * (this.x - i.x) + a * (this.y - i.y);
                            return this.x = i.x + a * (this.x - i.x) - u * (this.y - i.y),
                            this.y = p,
                            this
                        },
                        _round: function() {
                            return this.x = Math.round(this.x),
                            this.y = Math.round(this.y),
                            this
                        }
                    },
                    n.convert = function(t) {
                        return t instanceof n ? t : Array.isArray(t) ? new n(t[0],t[1]) : t
                    }
                    ,
                    G
                }
                typeof SuppressedError == "function" && SuppressedError;
                var he, X, le = W(de()), Se = function() {
                    if (X)
                        return he;
                    function n(t, i, a, u) {
                        this.cx = 3 * t,
                        this.bx = 3 * (a - t) - this.cx,
                        this.ax = 1 - this.cx - this.bx,
                        this.cy = 3 * i,
                        this.by = 3 * (u - i) - this.cy,
                        this.ay = 1 - this.cy - this.by,
                        this.p1x = t,
                        this.p1y = i,
                        this.p2x = a,
                        this.p2y = u
                    }
                    return X = 1,
                    he = n,
                    n.prototype = {
                        sampleCurveX: function(t) {
                            return ((this.ax * t + this.bx) * t + this.cx) * t
                        },
                        sampleCurveY: function(t) {
                            return ((this.ay * t + this.by) * t + this.cy) * t
                        },
                        sampleCurveDerivativeX: function(t) {
                            return (3 * this.ax * t + 2 * this.bx) * t + this.cx
                        },
                        solveCurveX: function(t, i) {
                            if (i === void 0 && (i = 1e-6),
                            t < 0)
                                return 0;
                            if (t > 1)
                                return 1;
                            for (var a = t, u = 0; u < 8; u++) {
                                var p = this.sampleCurveX(a) - t;
                                if (Math.abs(p) < i)
                                    return a;
                                var f = this.sampleCurveDerivativeX(a);
                                if (Math.abs(f) < 1e-6)
                                    break;
                                a -= p / f
                            }
                            var g = 0
                              , y = 1;
                            for (a = t,
                            u = 0; u < 20 && (p = this.sampleCurveX(a),
                            !(Math.abs(p - t) < i)); u++)
                                t > p ? g = a : y = a,
                                a = .5 * (y - g) + g;
                            return a
                        },
                        solve: function(t, i) {
                            return this.sampleCurveY(this.solveCurveX(t, i))
                        }
                    },
                    he
                }(), Ie = W(Se);
                let De, qe;
                function Ne() {
                    return De == null && (De = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") && typeof createImageBitmap == "function"),
                    De
                }
                function Ze() {
                    if (qe == null && (qe = !1,
                    Ne())) {
                        const t = new OffscreenCanvas(5,5).getContext("2d", {
                            willReadFrequently: !0
                        });
                        if (t) {
                            for (let a = 0; a < 25; a++) {
                                const u = 4 * a;
                                t.fillStyle = `rgb(${u},${u + 1},${u + 2})`,
                                t.fillRect(a % 5, Math.floor(a / 5), 1, 1)
                            }
                            const i = t.getImageData(0, 0, 5, 5).data;
                            for (let a = 0; a < 100; a++)
                                if (a % 4 != 3 && i[a] !== a) {
                                    qe = !0;
                                    break
                                }
                        }
                    }
                    return qe || !1
                }
                var ut = 1e-6
                  , rt = typeof Float32Array < "u" ? Float32Array : Array;
                function Ue() {
                    var n = new rt(9);
                    return rt != Float32Array && (n[1] = 0,
                    n[2] = 0,
                    n[3] = 0,
                    n[5] = 0,
                    n[6] = 0,
                    n[7] = 0),
                    n[0] = 1,
                    n[4] = 1,
                    n[8] = 1,
                    n
                }
                function lt(n) {
                    return n[0] = 1,
                    n[1] = 0,
                    n[2] = 0,
                    n[3] = 0,
                    n[4] = 0,
                    n[5] = 1,
                    n[6] = 0,
                    n[7] = 0,
                    n[8] = 0,
                    n[9] = 0,
                    n[10] = 1,
                    n[11] = 0,
                    n[12] = 0,
                    n[13] = 0,
                    n[14] = 0,
                    n[15] = 1,
                    n
                }
                function et() {
                    var n = new rt(3);
                    return rt != Float32Array && (n[0] = 0,
                    n[1] = 0,
                    n[2] = 0),
                    n
                }
                function Ve(n) {
                    return Math.hypot(n[0], n[1], n[2])
                }
                function gt(n, t, i) {
                    var a = new rt(3);
                    return a[0] = n,
                    a[1] = t,
                    a[2] = i,
                    a
                }
                function dt(n, t, i) {
                    return n[0] = t[0] + i[0],
                    n[1] = t[1] + i[1],
                    n[2] = t[2] + i[2],
                    n
                }
                function ct(n, t, i) {
                    return n[0] = t[0] * i,
                    n[1] = t[1] * i,
                    n[2] = t[2] * i,
                    n
                }
                function ze(n, t, i) {
                    var a = t[0]
                      , u = t[1]
                      , p = t[2]
                      , f = i[0]
                      , g = i[1]
                      , y = i[2];
                    return n[0] = u * y - p * g,
                    n[1] = p * f - a * y,
                    n[2] = a * g - u * f,
                    n
                }
                Math.hypot || (Math.hypot = function() {
                    for (var n = 0, t = arguments.length; t--; )
                        n += arguments[t] * arguments[t];
                    return Math.sqrt(n)
                }
                );
                var vt, Q = Ve;
                function ie(n, t, i) {
                    var a = t[0]
                      , u = t[1]
                      , p = t[2]
                      , f = t[3];
                    return n[0] = i[0] * a + i[4] * u + i[8] * p + i[12] * f,
                    n[1] = i[1] * a + i[5] * u + i[9] * p + i[13] * f,
                    n[2] = i[2] * a + i[6] * u + i[10] * p + i[14] * f,
                    n[3] = i[3] * a + i[7] * u + i[11] * p + i[15] * f,
                    n
                }
                function xe() {
                    var n = new rt(4);
                    return rt != Float32Array && (n[0] = 0,
                    n[1] = 0,
                    n[2] = 0),
                    n[3] = 1,
                    n
                }
                function ue(n, t, i, a) {
                    var u = .5 * Math.PI / 180;
                    t *= u,
                    i *= u,
                    a *= u;
                    var p = Math.sin(t)
                      , f = Math.cos(t)
                      , g = Math.sin(i)
                      , y = Math.cos(i)
                      , S = Math.sin(a)
                      , I = Math.cos(a);
                    return n[0] = p * y * I - f * g * S,
                    n[1] = f * g * I + p * y * S,
                    n[2] = f * y * S - p * g * I,
                    n[3] = f * y * I + p * g * S,
                    n
                }
                function Le() {
                    var n = new rt(2);
                    return rt != Float32Array && (n[0] = 0,
                    n[1] = 0),
                    n
                }
                function Re(n, t) {
                    var i = new rt(2);
                    return i[0] = n,
                    i[1] = t,
                    i
                }
                et(),
                vt = new rt(4),
                rt != Float32Array && (vt[0] = 0,
                vt[1] = 0,
                vt[2] = 0,
                vt[3] = 0),
                et(),
                gt(1, 0, 0),
                gt(0, 1, 0),
                xe(),
                xe(),
                Ue(),
                Le();
                const We = 8192;
                function it(n, t, i) {
                    return t * (We / (n.tileSize * Math.pow(2, i - n.tileID.overscaledZ)))
                }
                function at(n, t) {
                    return (n % t + t) % t
                }
                function ht(n, t, i) {
                    return n * (1 - i) + t * i
                }
                function Ft(n) {
                    if (n <= 0)
                        return 0;
                    if (n >= 1)
                        return 1;
                    const t = n * n
                      , i = t * n;
                    return 4 * (n < .5 ? i : 3 * (n - t) + i - .75)
                }
                function zt(n, t, i, a) {
                    const u = new Ie(n,t,i,a);
                    return p => u.solve(p)
                }
                const lr = zt(.25, .1, .25, 1);
                function kt(n, t, i) {
                    return Math.min(i, Math.max(t, n))
                }
                function xt(n, t, i) {
                    const a = i - t
                      , u = ((n - t) % a + a) % a + t;
                    return u === t ? i : u
                }
                function Pt(n, ...t) {
                    for (const i of t)
                        for (const a in i)
                            n[a] = i[a];
                    return n
                }
                let jt = 1;
                function Lt(n, t, i) {
                    const a = {};
                    for (const u in n)
                        a[u] = t.call(this, n[u], u, n);
                    return a
                }
                function nr(n, t, i) {
                    const a = {};
                    for (const u in n)
                        t.call(this, n[u], u, n) && (a[u] = n[u]);
                    return a
                }
                function xr(n) {
                    return Array.isArray(n) ? n.map(xr) : typeof n == "object" && n ? Lt(n, xr) : n
                }
                const er = {};
                function Qt(n) {
                    er[n] || (typeof console < "u" && console.warn(n),
                    er[n] = !0)
                }
                function $t(n, t, i) {
                    return (i.y - n.y) * (t.x - n.x) > (t.y - n.y) * (i.x - n.x)
                }
                function tr(n) {
                    return typeof WorkerGlobalScope < "u" && n !== void 0 && n instanceof WorkerGlobalScope
                }
                let $r = null;
                function zr(n) {
                    return typeof ImageBitmap < "u" && n instanceof ImageBitmap
                }
                const Mr = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
                function sr(n, t, i, a, u) {
                    return o(this, void 0, void 0, function*() {
                        if (typeof VideoFrame > "u")
                            throw new Error("VideoFrame not supported");
                        const p = new VideoFrame(n,{
                            timestamp: 0
                        });
                        try {
                            const f = p == null ? void 0 : p.format;
                            if (!f || !f.startsWith("BGR") && !f.startsWith("RGB"))
                                throw new Error(`Unrecognized format ${f}`);
                            const g = f.startsWith("BGR")
                              , y = new Uint8ClampedArray(a * u * 4);
                            if (yield p.copyTo(y, function(S, I, A, R, N) {
                                const j = 4 * Math.max(-I, 0)
                                  , $ = (Math.max(0, A) - A) * R * 4 + j
                                  , J = 4 * R
                                  , se = Math.max(0, I)
                                  , Ae = Math.max(0, A);
                                return {
                                    rect: {
                                        x: se,
                                        y: Ae,
                                        width: Math.min(S.width, I + R) - se,
                                        height: Math.min(S.height, A + N) - Ae
                                    },
                                    layout: [{
                                        offset: $,
                                        stride: J
                                    }]
                                }
                            }(n, t, i, a, u)),
                            g)
                                for (let S = 0; S < y.length; S += 4) {
                                    const I = y[S];
                                    y[S] = y[S + 2],
                                    y[S + 2] = I
                                }
                            return y
                        } finally {
                            p.close()
                        }
                    })
                }
                let Xt, Ir;
                function mr(n, t, i, a) {
                    return n.addEventListener(t, i, a),
                    {
                        unsubscribe: () => {
                            n.removeEventListener(t, i, a)
                        }
                    }
                }
                function vr(n) {
                    return n * Math.PI / 180
                }
                function br(n) {
                    return n / Math.PI * 180
                }
                const _r = {
                    touchstart: !0,
                    touchmove: !0,
                    touchmoveWindow: !0,
                    touchend: !0,
                    touchcancel: !0
                }
                  , Ar = {
                    dblclick: !0,
                    click: !0,
                    mouseover: !0,
                    mouseout: !0,
                    mousedown: !0,
                    mousemove: !0,
                    mousemoveWindow: !0,
                    mouseup: !0,
                    mouseupWindow: !0,
                    contextmenu: !0,
                    wheel: !0
                }
                  , Tr = "AbortError";
                function be() {
                    return new Error(Tr)
                }
                const q = {
                    MAX_PARALLEL_IMAGE_REQUESTS: 16,
                    MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
                    MAX_TILE_CACHE_ZOOM_LEVELS: 5,
                    REGISTERED_PROTOCOLS: {},
                    WORKER_URL: ""
                };
                function V(n) {
                    return q.REGISTERED_PROTOCOLS[n.substring(0, n.indexOf("://"))]
                }
                const K = "global-dispatcher";
                class ae extends Error {
                    constructor(t, i, a, u) {
                        super(`AJAXError: ${i} (${t}): ${a}`),
                        this.status = t,
                        this.statusText = i,
                        this.url = a,
                        this.body = u
                    }
                }
                const we = () => tr(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href
                  , Me = function(n, t) {
                    if (/:\/\//.test(n.url) && !/^https?:|^file:/.test(n.url)) {
                        const a = V(n.url);
                        if (a)
                            return a(n, t);
                        if (tr(self) && self.worker && self.worker.actor)
                            return self.worker.actor.sendAsync({
                                type: "GR",
                                data: n,
                                targetMapId: K
                            }, t)
                    }
                    if (!(/^file:/.test(i = n.url) || /^file:/.test(we()) && !/^\w+:/.test(i))) {
                        if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
                            return function(a, u) {
                                return o(this, void 0, void 0, function*() {
                                    const p = new Request(a.url,{
                                        method: a.method || "GET",
                                        body: a.body,
                                        credentials: a.credentials,
                                        headers: a.headers,
                                        cache: a.cache,
                                        referrer: we(),
                                        signal: u.signal
                                    });
                                    let f, g;
                                    a.type !== "json" || p.headers.has("Accept") || p.headers.set("Accept", "application/json");
                                    try {
                                        f = yield fetch(p)
                                    } catch (S) {
                                        throw new ae(0,S.message,a.url,new Blob)
                                    }
                                    if (!f.ok) {
                                        const S = yield f.blob();
                                        throw new ae(f.status,f.statusText,a.url,S)
                                    }
                                    g = a.type === "arrayBuffer" || a.type === "image" ? f.arrayBuffer() : a.type === "json" ? f.json() : f.text();
                                    const y = yield g;
                                    if (u.signal.aborted)
                                        throw be();
                                    return {
                                        data: y,
                                        cacheControl: f.headers.get("Cache-Control"),
                                        expires: f.headers.get("Expires")
                                    }
                                })
                            }(n, t);
                        if (tr(self) && self.worker && self.worker.actor)
                            return self.worker.actor.sendAsync({
                                type: "GR",
                                data: n,
                                mustQueue: !0,
                                targetMapId: K
                            }, t)
                    }
                    var i;
                    return function(a, u) {
                        return new Promise( (p, f) => {
                            var g;
                            const y = new XMLHttpRequest;
                            y.open(a.method || "GET", a.url, !0),
                            a.type !== "arrayBuffer" && a.type !== "image" || (y.responseType = "arraybuffer");
                            for (const S in a.headers)
                                y.setRequestHeader(S, a.headers[S]);
                            a.type === "json" && (y.responseType = "text",
                            !((g = a.headers) === null || g === void 0) && g.Accept || y.setRequestHeader("Accept", "application/json")),
                            y.withCredentials = a.credentials === "include",
                            y.onerror = () => {
                                f(new Error(y.statusText))
                            }
                            ,
                            y.onload = () => {
                                if (!u.signal.aborted)
                                    if ((y.status >= 200 && y.status < 300 || y.status === 0) && y.response !== null) {
                                        let S = y.response;
                                        if (a.type === "json")
                                            try {
                                                S = JSON.parse(y.response)
                                            } catch (I) {
                                                return void f(I)
                                            }
                                        p({
                                            data: S,
                                            cacheControl: y.getResponseHeader("Cache-Control"),
                                            expires: y.getResponseHeader("Expires")
                                        })
                                    } else {
                                        const S = new Blob([y.response],{
                                            type: y.getResponseHeader("Content-Type")
                                        });
                                        f(new ae(y.status,y.statusText,a.url,S))
                                    }
                            }
                            ,
                            u.signal.addEventListener("abort", () => {
                                y.abort(),
                                f(be())
                            }
                            ),
                            y.send(a.body)
                        }
                        )
                    }(n, t)
                };
                function ke(n) {
                    if (!n || n.indexOf("://") <= 0 || n.indexOf("data:image/") === 0 || n.indexOf("blob:") === 0)
                        return !0;
                    const t = new URL(n)
                      , i = window.location;
                    return t.protocol === i.protocol && t.host === i.host
                }
                function ge(n, t, i) {
                    i[n] && i[n].indexOf(t) !== -1 || (i[n] = i[n] || [],
                    i[n].push(t))
                }
                function je(n, t, i) {
                    if (i && i[n]) {
                        const a = i[n].indexOf(t);
                        a !== -1 && i[n].splice(a, 1)
                    }
                }
                class Oe {
                    constructor(t, i={}) {
                        Pt(this, i),
                        this.type = t
                    }
                }
                class Ee extends Oe {
                    constructor(t, i={}) {
                        super("error", Pt({
                            error: t
                        }, i))
                    }
                }
                class Ke {
                    on(t, i) {
                        return this._listeners = this._listeners || {},
                        ge(t, i, this._listeners),
                        {
                            unsubscribe: () => {
                                this.off(t, i)
                            }
                        }
                    }
                    off(t, i) {
                        return je(t, i, this._listeners),
                        je(t, i, this._oneTimeListeners),
                        this
                    }
                    once(t, i) {
                        return i ? (this._oneTimeListeners = this._oneTimeListeners || {},
                        ge(t, i, this._oneTimeListeners),
                        this) : new Promise(a => this.once(t, a))
                    }
                    fire(t, i) {
                        typeof t == "string" && (t = new Oe(t,i || {}));
                        const a = t.type;
                        if (this.listens(a)) {
                            t.target = this;
                            const u = this._listeners && this._listeners[a] ? this._listeners[a].slice() : [];
                            for (const g of u)
                                g.call(this, t);
                            const p = this._oneTimeListeners && this._oneTimeListeners[a] ? this._oneTimeListeners[a].slice() : [];
                            for (const g of p)
                                je(a, g, this._oneTimeListeners),
                                g.call(this, t);
                            const f = this._eventedParent;
                            f && (Pt(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData),
                            f.fire(t))
                        } else
                            t instanceof Ee && console.error(t.error);
                        return this
                    }
                    listens(t) {
                        return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t)
                    }
                    setEventedParent(t, i) {
                        return this._eventedParent = t,
                        this._eventedParentData = i,
                        this
                    }
                }
                var ye = {
                    $version: 8,
                    $root: {
                        version: {
                            required: !0,
                            type: "enum",
                            values: [8]
                        },
                        name: {
                            type: "string"
                        },
                        metadata: {
                            type: "*"
                        },
                        center: {
                            type: "array",
                            value: "number"
                        },
                        centerAltitude: {
                            type: "number"
                        },
                        zoom: {
                            type: "number"
                        },
                        bearing: {
                            type: "number",
                            default: 0,
                            period: 360,
                            units: "degrees"
                        },
                        pitch: {
                            type: "number",
                            default: 0,
                            units: "degrees"
                        },
                        roll: {
                            type: "number",
                            default: 0,
                            units: "degrees"
                        },
                        state: {
                            type: "state",
                            default: {}
                        },
                        light: {
                            type: "light"
                        },
                        sky: {
                            type: "sky"
                        },
                        projection: {
                            type: "projection"
                        },
                        terrain: {
                            type: "terrain"
                        },
                        sources: {
                            required: !0,
                            type: "sources"
                        },
                        sprite: {
                            type: "sprite"
                        },
                        glyphs: {
                            type: "string"
                        },
                        transition: {
                            type: "transition"
                        },
                        layers: {
                            required: !0,
                            type: "array",
                            value: "layer"
                        }
                    },
                    sources: {
                        "*": {
                            type: "source"
                        }
                    },
                    source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
                    source_vector: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                vector: {}
                            }
                        },
                        url: {
                            type: "string"
                        },
                        tiles: {
                            type: "array",
                            value: "string"
                        },
                        bounds: {
                            type: "array",
                            value: "number",
                            length: 4,
                            default: [-180, -85.051129, 180, 85.051129]
                        },
                        scheme: {
                            type: "enum",
                            values: {
                                xyz: {},
                                tms: {}
                            },
                            default: "xyz"
                        },
                        minzoom: {
                            type: "number",
                            default: 0
                        },
                        maxzoom: {
                            type: "number",
                            default: 22
                        },
                        attribution: {
                            type: "string"
                        },
                        promoteId: {
                            type: "promoteId"
                        },
                        volatile: {
                            type: "boolean",
                            default: !1
                        },
                        "*": {
                            type: "*"
                        }
                    },
                    source_raster: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                raster: {}
                            }
                        },
                        url: {
                            type: "string"
                        },
                        tiles: {
                            type: "array",
                            value: "string"
                        },
                        bounds: {
                            type: "array",
                            value: "number",
                            length: 4,
                            default: [-180, -85.051129, 180, 85.051129]
                        },
                        minzoom: {
                            type: "number",
                            default: 0
                        },
                        maxzoom: {
                            type: "number",
                            default: 22
                        },
                        tileSize: {
                            type: "number",
                            default: 512,
                            units: "pixels"
                        },
                        scheme: {
                            type: "enum",
                            values: {
                                xyz: {},
                                tms: {}
                            },
                            default: "xyz"
                        },
                        attribution: {
                            type: "string"
                        },
                        volatile: {
                            type: "boolean",
                            default: !1
                        },
                        "*": {
                            type: "*"
                        }
                    },
                    source_raster_dem: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                "raster-dem": {}
                            }
                        },
                        url: {
                            type: "string"
                        },
                        tiles: {
                            type: "array",
                            value: "string"
                        },
                        bounds: {
                            type: "array",
                            value: "number",
                            length: 4,
                            default: [-180, -85.051129, 180, 85.051129]
                        },
                        minzoom: {
                            type: "number",
                            default: 0
                        },
                        maxzoom: {
                            type: "number",
                            default: 22
                        },
                        tileSize: {
                            type: "number",
                            default: 512,
                            units: "pixels"
                        },
                        attribution: {
                            type: "string"
                        },
                        encoding: {
                            type: "enum",
                            values: {
                                terrarium: {},
                                mapbox: {},
                                custom: {}
                            },
                            default: "mapbox"
                        },
                        redFactor: {
                            type: "number",
                            default: 1
                        },
                        blueFactor: {
                            type: "number",
                            default: 1
                        },
                        greenFactor: {
                            type: "number",
                            default: 1
                        },
                        baseShift: {
                            type: "number",
                            default: 0
                        },
                        volatile: {
                            type: "boolean",
                            default: !1
                        },
                        "*": {
                            type: "*"
                        }
                    },
                    source_geojson: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                geojson: {}
                            }
                        },
                        data: {
                            required: !0,
                            type: "*"
                        },
                        maxzoom: {
                            type: "number",
                            default: 18
                        },
                        attribution: {
                            type: "string"
                        },
                        buffer: {
                            type: "number",
                            default: 128,
                            maximum: 512,
                            minimum: 0
                        },
                        filter: {
                            type: "*"
                        },
                        tolerance: {
                            type: "number",
                            default: .375
                        },
                        cluster: {
                            type: "boolean",
                            default: !1
                        },
                        clusterRadius: {
                            type: "number",
                            default: 50,
                            minimum: 0
                        },
                        clusterMaxZoom: {
                            type: "number"
                        },
                        clusterMinPoints: {
                            type: "number"
                        },
                        clusterProperties: {
                            type: "*"
                        },
                        lineMetrics: {
                            type: "boolean",
                            default: !1
                        },
                        generateId: {
                            type: "boolean",
                            default: !1
                        },
                        promoteId: {
                            type: "promoteId"
                        }
                    },
                    source_video: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                video: {}
                            }
                        },
                        urls: {
                            required: !0,
                            type: "array",
                            value: "string"
                        },
                        coordinates: {
                            required: !0,
                            type: "array",
                            length: 4,
                            value: {
                                type: "array",
                                length: 2,
                                value: "number"
                            }
                        }
                    },
                    source_image: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                image: {}
                            }
                        },
                        url: {
                            required: !0,
                            type: "string"
                        },
                        coordinates: {
                            required: !0,
                            type: "array",
                            length: 4,
                            value: {
                                type: "array",
                                length: 2,
                                value: "number"
                            }
                        }
                    },
                    layer: {
                        id: {
                            type: "string",
                            required: !0
                        },
                        type: {
                            type: "enum",
                            values: {
                                fill: {},
                                line: {},
                                symbol: {},
                                circle: {},
                                heatmap: {},
                                "fill-extrusion": {},
                                raster: {},
                                hillshade: {},
                                "color-relief": {},
                                background: {}
                            },
                            required: !0
                        },
                        metadata: {
                            type: "*"
                        },
                        source: {
                            type: "string"
                        },
                        "source-layer": {
                            type: "string"
                        },
                        minzoom: {
                            type: "number",
                            minimum: 0,
                            maximum: 24
                        },
                        maxzoom: {
                            type: "number",
                            minimum: 0,
                            maximum: 24
                        },
                        filter: {
                            type: "filter"
                        },
                        layout: {
                            type: "layout"
                        },
                        paint: {
                            type: "paint"
                        }
                    },
                    layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"],
                    layout_background: {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_fill: {
                        "fill-sort-key": {
                            type: "number",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_circle: {
                        "circle-sort-key": {
                            type: "number",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_heatmap: {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    "layout_fill-extrusion": {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_line: {
                        "line-cap": {
                            type: "enum",
                            values: {
                                butt: {},
                                round: {},
                                square: {}
                            },
                            default: "butt",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-join": {
                            type: "enum",
                            values: {
                                bevel: {},
                                round: {},
                                miter: {}
                            },
                            default: "miter",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-miter-limit": {
                            type: "number",
                            default: 2,
                            requires: [{
                                "line-join": "miter"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-round-limit": {
                            type: "number",
                            default: 1.05,
                            requires: [{
                                "line-join": "round"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-sort-key": {
                            type: "number",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_symbol: {
                        "symbol-placement": {
                            type: "enum",
                            values: {
                                point: {},
                                line: {},
                                "line-center": {}
                            },
                            default: "point",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "symbol-spacing": {
                            type: "number",
                            default: 250,
                            minimum: 1,
                            units: "pixels",
                            requires: [{
                                "symbol-placement": "line"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "symbol-avoid-edges": {
                            type: "boolean",
                            default: !1,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "symbol-sort-key": {
                            type: "number",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "symbol-z-order": {
                            type: "enum",
                            values: {
                                auto: {},
                                "viewport-y": {},
                                source: {}
                            },
                            default: "auto",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-allow-overlap": {
                            type: "boolean",
                            default: !1,
                            requires: ["icon-image", {
                                "!": "icon-overlap"
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-overlap": {
                            type: "enum",
                            values: {
                                never: {},
                                always: {},
                                cooperative: {}
                            },
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-ignore-placement": {
                            type: "boolean",
                            default: !1,
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-optional": {
                            type: "boolean",
                            default: !1,
                            requires: ["icon-image", "text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-rotation-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {},
                                auto: {}
                            },
                            default: "auto",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-size": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            units: "factor of the original icon size",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-text-fit": {
                            type: "enum",
                            values: {
                                none: {},
                                width: {},
                                height: {},
                                both: {}
                            },
                            default: "none",
                            requires: ["icon-image", "text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-text-fit-padding": {
                            type: "array",
                            value: "number",
                            length: 4,
                            default: [0, 0, 0, 0],
                            units: "pixels",
                            requires: ["icon-image", "text-field", {
                                "icon-text-fit": ["both", "width", "height"]
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-image": {
                            type: "resolvedImage",
                            tokens: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-rotate": {
                            type: "number",
                            default: 0,
                            period: 360,
                            units: "degrees",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-padding": {
                            type: "padding",
                            default: [2],
                            units: "pixels",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-keep-upright": {
                            type: "boolean",
                            default: !1,
                            requires: ["icon-image", {
                                "icon-rotation-alignment": "map"
                            }, {
                                "symbol-placement": ["line", "line-center"]
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-offset": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-anchor": {
                            type: "enum",
                            values: {
                                center: {},
                                left: {},
                                right: {},
                                top: {},
                                bottom: {},
                                "top-left": {},
                                "top-right": {},
                                "bottom-left": {},
                                "bottom-right": {}
                            },
                            default: "center",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-pitch-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {},
                                auto: {}
                            },
                            default: "auto",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-pitch-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {},
                                auto: {}
                            },
                            default: "auto",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-rotation-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {},
                                "viewport-glyph": {},
                                auto: {}
                            },
                            default: "auto",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-field": {
                            type: "formatted",
                            default: "",
                            tokens: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-font": {
                            type: "array",
                            value: "string",
                            default: ["Open Sans Regular", "Arial Unicode MS Regular"],
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-size": {
                            type: "number",
                            default: 16,
                            minimum: 0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-max-width": {
                            type: "number",
                            default: 10,
                            minimum: 0,
                            units: "ems",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-line-height": {
                            type: "number",
                            default: 1.2,
                            units: "ems",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-letter-spacing": {
                            type: "number",
                            default: 0,
                            units: "ems",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-justify": {
                            type: "enum",
                            values: {
                                auto: {},
                                left: {},
                                center: {},
                                right: {}
                            },
                            default: "center",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-radial-offset": {
                            type: "number",
                            units: "ems",
                            default: 0,
                            requires: ["text-field"],
                            "property-type": "data-driven",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            }
                        },
                        "text-variable-anchor": {
                            type: "array",
                            value: "enum",
                            values: {
                                center: {},
                                left: {},
                                right: {},
                                top: {},
                                bottom: {},
                                "top-left": {},
                                "top-right": {},
                                "bottom-left": {},
                                "bottom-right": {}
                            },
                            requires: ["text-field", {
                                "symbol-placement": ["point"]
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-variable-anchor-offset": {
                            type: "variableAnchorOffsetCollection",
                            requires: ["text-field", {
                                "symbol-placement": ["point"]
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-anchor": {
                            type: "enum",
                            values: {
                                center: {},
                                left: {},
                                right: {},
                                top: {},
                                bottom: {},
                                "top-left": {},
                                "top-right": {},
                                "bottom-left": {},
                                "bottom-right": {}
                            },
                            default: "center",
                            requires: ["text-field", {
                                "!": "text-variable-anchor"
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-max-angle": {
                            type: "number",
                            default: 45,
                            units: "degrees",
                            requires: ["text-field", {
                                "symbol-placement": ["line", "line-center"]
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-writing-mode": {
                            type: "array",
                            value: "enum",
                            values: {
                                horizontal: {},
                                vertical: {}
                            },
                            requires: ["text-field", {
                                "symbol-placement": ["point"]
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-rotate": {
                            type: "number",
                            default: 0,
                            period: 360,
                            units: "degrees",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-padding": {
                            type: "number",
                            default: 2,
                            minimum: 0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-keep-upright": {
                            type: "boolean",
                            default: !0,
                            requires: ["text-field", {
                                "text-rotation-alignment": "map"
                            }, {
                                "symbol-placement": ["line", "line-center"]
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-transform": {
                            type: "enum",
                            values: {
                                none: {},
                                uppercase: {},
                                lowercase: {}
                            },
                            default: "none",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-offset": {
                            type: "array",
                            value: "number",
                            units: "ems",
                            length: 2,
                            default: [0, 0],
                            requires: ["text-field", {
                                "!": "text-radial-offset"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-allow-overlap": {
                            type: "boolean",
                            default: !1,
                            requires: ["text-field", {
                                "!": "text-overlap"
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-overlap": {
                            type: "enum",
                            values: {
                                never: {},
                                always: {},
                                cooperative: {}
                            },
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-ignore-placement": {
                            type: "boolean",
                            default: !1,
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-optional": {
                            type: "boolean",
                            default: !1,
                            requires: ["text-field", "icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_raster: {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_hillshade: {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    "layout_color-relief": {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    filter: {
                        type: "array",
                        value: "*"
                    },
                    filter_operator: {
                        type: "enum",
                        values: {
                            "==": {},
                            "!=": {},
                            ">": {},
                            ">=": {},
                            "<": {},
                            "<=": {},
                            in: {},
                            "!in": {},
                            all: {},
                            any: {},
                            none: {},
                            has: {},
                            "!has": {}
                        }
                    },
                    geometry_type: {
                        type: "enum",
                        values: {
                            Point: {},
                            LineString: {},
                            Polygon: {}
                        }
                    },
                    function: {
                        expression: {
                            type: "expression"
                        },
                        stops: {
                            type: "array",
                            value: "function_stop"
                        },
                        base: {
                            type: "number",
                            default: 1,
                            minimum: 0
                        },
                        property: {
                            type: "string",
                            default: "$zoom"
                        },
                        type: {
                            type: "enum",
                            values: {
                                identity: {},
                                exponential: {},
                                interval: {},
                                categorical: {}
                            },
                            default: "exponential"
                        },
                        colorSpace: {
                            type: "enum",
                            values: {
                                rgb: {},
                                lab: {},
                                hcl: {}
                            },
                            default: "rgb"
                        },
                        default: {
                            type: "*",
                            required: !1
                        }
                    },
                    function_stop: {
                        type: "array",
                        minimum: 0,
                        maximum: 24,
                        value: ["number", "color"],
                        length: 2
                    },
                    expression: {
                        type: "array",
                        value: "*",
                        minimum: 1
                    },
                    light: {
                        anchor: {
                            type: "enum",
                            default: "viewport",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            "property-type": "data-constant",
                            transition: !1,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            }
                        },
                        position: {
                            type: "array",
                            default: [1.15, 210, 30],
                            length: 3,
                            value: "number",
                            "property-type": "data-constant",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            }
                        },
                        color: {
                            type: "color",
                            "property-type": "data-constant",
                            default: "#ffffff",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        intensity: {
                            type: "number",
                            "property-type": "data-constant",
                            default: .5,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        }
                    },
                    sky: {
                        "sky-color": {
                            type: "color",
                            "property-type": "data-constant",
                            default: "#88C6FC",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "horizon-color": {
                            type: "color",
                            "property-type": "data-constant",
                            default: "#ffffff",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "fog-color": {
                            type: "color",
                            "property-type": "data-constant",
                            default: "#ffffff",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "fog-ground-blend": {
                            type: "number",
                            "property-type": "data-constant",
                            default: .5,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "horizon-fog-blend": {
                            type: "number",
                            "property-type": "data-constant",
                            default: .8,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "sky-horizon-blend": {
                            type: "number",
                            "property-type": "data-constant",
                            default: .8,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "atmosphere-blend": {
                            type: "number",
                            "property-type": "data-constant",
                            default: .8,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        }
                    },
                    terrain: {
                        source: {
                            type: "string",
                            required: !0
                        },
                        exaggeration: {
                            type: "number",
                            minimum: 0,
                            default: 1
                        }
                    },
                    projection: {
                        type: {
                            type: "projectionDefinition",
                            default: "mercator",
                            "property-type": "data-constant",
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            }
                        }
                    },
                    paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"],
                    paint_fill: {
                        "fill-antialias": {
                            type: "boolean",
                            default: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: [{
                                "!": "fill-pattern"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-outline-color": {
                            type: "color",
                            transition: !0,
                            requires: [{
                                "!": "fill-pattern"
                            }, {
                                "fill-antialias": !0
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["fill-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-pattern": {
                            type: "resolvedImage",
                            transition: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "cross-faded-data-driven"
                        }
                    },
                    "paint_fill-extrusion": {
                        "fill-extrusion-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-extrusion-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: [{
                                "!": "fill-extrusion-pattern"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-extrusion-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-extrusion-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["fill-extrusion-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-extrusion-pattern": {
                            type: "resolvedImage",
                            transition: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "cross-faded-data-driven"
                        },
                        "fill-extrusion-height": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            units: "meters",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-extrusion-base": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            units: "meters",
                            transition: !0,
                            requires: ["fill-extrusion-height"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-extrusion-vertical-gradient": {
                            type: "boolean",
                            default: !0,
                            transition: !1,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    paint_line: {
                        "line-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: [{
                                "!": "line-pattern"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["line-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-width": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-gap-width": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-offset": {
                            type: "number",
                            default: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-blur": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-dasharray": {
                            type: "array",
                            value: "number",
                            minimum: 0,
                            transition: !0,
                            units: "line widths",
                            requires: [{
                                "!": "line-pattern"
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "cross-faded"
                        },
                        "line-pattern": {
                            type: "resolvedImage",
                            transition: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "cross-faded-data-driven"
                        },
                        "line-gradient": {
                            type: "color",
                            transition: !1,
                            requires: [{
                                "!": "line-dasharray"
                            }, {
                                "!": "line-pattern"
                            }, {
                                source: "geojson",
                                has: {
                                    lineMetrics: !0
                                }
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["line-progress"]
                            },
                            "property-type": "color-ramp"
                        }
                    },
                    paint_circle: {
                        "circle-radius": {
                            type: "number",
                            default: 5,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-blur": {
                            type: "number",
                            default: 0,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "circle-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["circle-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "circle-pitch-scale": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "circle-pitch-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "viewport",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "circle-stroke-width": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-stroke-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-stroke-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        }
                    },
                    paint_heatmap: {
                        "heatmap-radius": {
                            type: "number",
                            default: 30,
                            minimum: 1,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "heatmap-weight": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "heatmap-intensity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "heatmap-color": {
                            type: "color",
                            default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"],
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["heatmap-density"]
                            },
                            "property-type": "color-ramp"
                        },
                        "heatmap-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    paint_symbol: {
                        "icon-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-halo-color": {
                            type: "color",
                            default: "rgba(0, 0, 0, 0)",
                            transition: !0,
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-halo-width": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-halo-blur": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["icon-image", "icon-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            overridable: !0,
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-halo-color": {
                            type: "color",
                            default: "rgba(0, 0, 0, 0)",
                            transition: !0,
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-halo-width": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-halo-blur": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["text-field", "text-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    paint_raster: {
                        "raster-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-hue-rotate": {
                            type: "number",
                            default: 0,
                            period: 360,
                            transition: !0,
                            units: "degrees",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-brightness-min": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-brightness-max": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-saturation": {
                            type: "number",
                            default: 0,
                            minimum: -1,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-contrast": {
                            type: "number",
                            default: 0,
                            minimum: -1,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-resampling": {
                            type: "enum",
                            values: {
                                linear: {},
                                nearest: {}
                            },
                            default: "linear",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-fade-duration": {
                            type: "number",
                            default: 300,
                            minimum: 0,
                            transition: !1,
                            units: "milliseconds",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    paint_hillshade: {
                        "hillshade-illumination-direction": {
                            type: "numberArray",
                            default: 335,
                            minimum: 0,
                            maximum: 359,
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-illumination-altitude": {
                            type: "numberArray",
                            default: 45,
                            minimum: 0,
                            maximum: 90,
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-illumination-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "viewport",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-exaggeration": {
                            type: "number",
                            default: .5,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-shadow-color": {
                            type: "colorArray",
                            default: "#000000",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-highlight-color": {
                            type: "colorArray",
                            default: "#FFFFFF",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-accent-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-method": {
                            type: "enum",
                            values: {
                                standard: {},
                                basic: {},
                                combined: {},
                                igor: {},
                                multidirectional: {}
                            },
                            default: "standard",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    "paint_color-relief": {
                        "color-relief-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "color-relief-color": {
                            type: "color",
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["elevation"]
                            },
                            "property-type": "color-ramp"
                        }
                    },
                    paint_background: {
                        "background-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: [{
                                "!": "background-pattern"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "background-pattern": {
                            type: "resolvedImage",
                            transition: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "cross-faded"
                        },
                        "background-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    transition: {
                        duration: {
                            type: "number",
                            default: 300,
                            minimum: 0,
                            units: "milliseconds"
                        },
                        delay: {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            units: "milliseconds"
                        }
                    },
                    "property-type": {
                        "data-driven": {
                            type: "property-type"
                        },
                        "cross-faded": {
                            type: "property-type"
                        },
                        "cross-faded-data-driven": {
                            type: "property-type"
                        },
                        "color-ramp": {
                            type: "property-type"
                        },
                        "data-constant": {
                            type: "property-type"
                        },
                        constant: {
                            type: "property-type"
                        }
                    },
                    promoteId: {
                        "*": {
                            type: "string"
                        }
                    }
                };
                const It = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
                function Kt(n, t) {
                    const i = {};
                    for (const a in n)
                        a !== "ref" && (i[a] = n[a]);
                    return It.forEach(a => {
                        a in t && (i[a] = t[a])
                    }
                    ),
                    i
                }
                function Bt(n, t) {
                    if (Array.isArray(n)) {
                        if (!Array.isArray(t) || n.length !== t.length)
                            return !1;
                        for (let i = 0; i < n.length; i++)
                            if (!Bt(n[i], t[i]))
                                return !1;
                        return !0
                    }
                    if (typeof n == "object" && n !== null && t !== null) {
                        if (typeof t != "object" || Object.keys(n).length !== Object.keys(t).length)
                            return !1;
                        for (const i in n)
                            if (!Bt(n[i], t[i]))
                                return !1;
                        return !0
                    }
                    return n === t
                }
                function Ut(n, t) {
                    n.push(t)
                }
                function wr(n, t, i) {
                    Ut(i, {
                        command: "addSource",
                        args: [n, t[n]]
                    })
                }
                function ci(n, t, i) {
                    Ut(t, {
                        command: "removeSource",
                        args: [n]
                    }),
                    i[n] = !0
                }
                function Yr(n, t, i, a) {
                    ci(n, i, a),
                    wr(n, t, i)
                }
                function yt(n, t, i) {
                    let a;
                    for (a in n[i])
                        if (Object.prototype.hasOwnProperty.call(n[i], a) && a !== "data" && !Bt(n[i][a], t[i][a]))
                            return !1;
                    for (a in t[i])
                        if (Object.prototype.hasOwnProperty.call(t[i], a) && a !== "data" && !Bt(n[i][a], t[i][a]))
                            return !1;
                    return !0
                }
                function Mt(n, t, i, a, u, p) {
                    n = n || {},
                    t = t || {};
                    for (const f in n)
                        Object.prototype.hasOwnProperty.call(n, f) && (Bt(n[f], t[f]) || i.push({
                            command: p,
                            args: [a, f, t[f], u]
                        }));
                    for (const f in t)
                        Object.prototype.hasOwnProperty.call(t, f) && !Object.prototype.hasOwnProperty.call(n, f) && (Bt(n[f], t[f]) || i.push({
                            command: p,
                            args: [a, f, t[f], u]
                        }))
                }
                function Gt(n) {
                    return n.id
                }
                function Fr(n, t) {
                    return n[t.id] = t,
                    n
                }
                class ft {
                    constructor(t, i, a, u) {
                        this.message = (t ? `${t}: ` : "") + a,
                        u && (this.identifier = u),
                        i != null && i.__line__ && (this.line = i.__line__)
                    }
                }
                function Br(n, ...t) {
                    for (const i of t)
                        for (const a in i)
                            n[a] = i[a];
                    return n
                }
                class Ur extends Error {
                    constructor(t, i) {
                        super(i),
                        this.message = i,
                        this.key = t
                    }
                }
                class Si {
                    constructor(t, i=[]) {
                        this.parent = t,
                        this.bindings = {};
                        for (const [a,u] of i)
                            this.bindings[a] = u
                    }
                    concat(t) {
                        return new Si(this,t)
                    }
                    get(t) {
                        if (this.bindings[t])
                            return this.bindings[t];
                        if (this.parent)
                            return this.parent.get(t);
                        throw new Error(`${t} not found in scope.`)
                    }
                    has(t) {
                        return !!this.bindings[t] || !!this.parent && this.parent.has(t)
                    }
                }
                const ui = {
                    kind: "null"
                }
                  , St = {
                    kind: "number"
                }
                  , yr = {
                    kind: "string"
                }
                  , pr = {
                    kind: "boolean"
                }
                  , hi = {
                    kind: "color"
                }
                  , Or = {
                    kind: "projectionDefinition"
                }
                  , si = {
                    kind: "object"
                }
                  , fr = {
                    kind: "value"
                }
                  , $i = {
                    kind: "collator"
                }
                  , On = {
                    kind: "formatted"
                }
                  , _i = {
                    kind: "padding"
                }
                  , An = {
                    kind: "colorArray"
                }
                  , Kn = {
                    kind: "numberArray"
                }
                  , Nn = {
                    kind: "resolvedImage"
                }
                  , Tt = {
                    kind: "variableAnchorOffsetCollection"
                };
                function Ot(n, t) {
                    return {
                        kind: "array",
                        itemType: n,
                        N: t
                    }
                }
                function Ht(n) {
                    if (n.kind === "array") {
                        const t = Ht(n.itemType);
                        return typeof n.N == "number" ? `array<${t}, ${n.N}>` : n.itemType.kind === "value" ? "array" : `array<${t}>`
                    }
                    return n.kind
                }
                const mi = [ui, St, yr, pr, hi, Or, On, si, Ot(fr), _i, Kn, An, Nn, Tt];
                function Ii(n, t) {
                    if (t.kind === "error")
                        return null;
                    if (n.kind === "array") {
                        if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !Ii(n.itemType, t.itemType)) && (typeof n.N != "number" || n.N === t.N))
                            return null
                    } else {
                        if (n.kind === t.kind)
                            return null;
                        if (n.kind === "value") {
                            for (const i of mi)
                                if (!Ii(i, t))
                                    return null
                        }
                    }
                    return `Expected ${Ht(n)} but found ${Ht(t)} instead.`
                }
                function Qi(n, t) {
                    return t.some(i => i.kind === n.kind)
                }
                function vi(n, t) {
                    return t.some(i => i === "null" ? n === null : i === "array" ? Array.isArray(n) : i === "object" ? n && !Array.isArray(n) && typeof n == "object" : i === typeof n)
                }
                function kr(n, t) {
                    return n.kind === "array" && t.kind === "array" ? n.itemType.kind === t.itemType.kind && typeof n.N == "number" : n.kind === t.kind
                }
                const Yn = .96422
                  , gr = .82521
                  , Zt = 4 / 29
                  , Qr = 6 / 29
                  , ni = 3 * Qr * Qr
                  , yi = Qr * Qr * Qr
                  , oi = Math.PI / 180
                  , ki = 180 / Math.PI;
                function Ki(n) {
                    return (n %= 360) < 0 && (n += 360),
                    n
                }
                function Pi([n,t,i,a]) {
                    let u, p;
                    const f = zi((.2225045 * (n = Ni(n)) + .7168786 * (t = Ni(t)) + .0606169 * (i = Ni(i))) / 1);
                    n === t && t === i ? u = p = f : (u = zi((.4360747 * n + .3850649 * t + .1430804 * i) / Yn),
                    p = zi((.0139322 * n + .0971045 * t + .7141733 * i) / gr));
                    const g = 116 * f - 16;
                    return [g < 0 ? 0 : g, 500 * (u - f), 200 * (f - p), a]
                }
                function Ni(n) {
                    return n <= .04045 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4)
                }
                function zi(n) {
                    return n > yi ? Math.pow(n, 1 / 3) : n / ni + Zt
                }
                function gi([n,t,i,a]) {
                    let u = (n + 16) / 116
                      , p = isNaN(t) ? u : u + t / 500
                      , f = isNaN(i) ? u : u - i / 200;
                    return u = 1 * Jn(u),
                    p = Yn * Jn(p),
                    f = gr * Jn(f),
                    [en(3.1338561 * p - 1.6168667 * u - .4906146 * f), en(-.9787684 * p + 1.9161415 * u + .033454 * f), en(.0719453 * p - .2289914 * u + 1.4052427 * f), a]
                }
                function en(n) {
                    return (n = n <= .00304 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - .055) < 0 ? 0 : n > 1 ? 1 : n
                }
                function Jn(n) {
                    return n > Qr ? n * n * n : ni * (n - Zt)
                }
                const Ui = Object.hasOwn || function(n, t) {
                    return Object.prototype.hasOwnProperty.call(n, t)
                }
                ;
                function Wr(n, t) {
                    return Ui(n, t) ? n[t] : void 0
                }
                function Qn(n) {
                    return parseInt(n.padEnd(2, n), 16) / 255
                }
                function sa(n, t) {
                    return da(t ? n / 100 : n, 0, 1)
                }
                function da(n, t, i) {
                    return Math.min(Math.max(t, n), i)
                }
                function os(n) {
                    return !n.some(Number.isNaN)
                }
                const Ps = {
                    aliceblue: [240, 248, 255],
                    antiquewhite: [250, 235, 215],
                    aqua: [0, 255, 255],
                    aquamarine: [127, 255, 212],
                    azure: [240, 255, 255],
                    beige: [245, 245, 220],
                    bisque: [255, 228, 196],
                    black: [0, 0, 0],
                    blanchedalmond: [255, 235, 205],
                    blue: [0, 0, 255],
                    blueviolet: [138, 43, 226],
                    brown: [165, 42, 42],
                    burlywood: [222, 184, 135],
                    cadetblue: [95, 158, 160],
                    chartreuse: [127, 255, 0],
                    chocolate: [210, 105, 30],
                    coral: [255, 127, 80],
                    cornflowerblue: [100, 149, 237],
                    cornsilk: [255, 248, 220],
                    crimson: [220, 20, 60],
                    cyan: [0, 255, 255],
                    darkblue: [0, 0, 139],
                    darkcyan: [0, 139, 139],
                    darkgoldenrod: [184, 134, 11],
                    darkgray: [169, 169, 169],
                    darkgreen: [0, 100, 0],
                    darkgrey: [169, 169, 169],
                    darkkhaki: [189, 183, 107],
                    darkmagenta: [139, 0, 139],
                    darkolivegreen: [85, 107, 47],
                    darkorange: [255, 140, 0],
                    darkorchid: [153, 50, 204],
                    darkred: [139, 0, 0],
                    darksalmon: [233, 150, 122],
                    darkseagreen: [143, 188, 143],
                    darkslateblue: [72, 61, 139],
                    darkslategray: [47, 79, 79],
                    darkslategrey: [47, 79, 79],
                    darkturquoise: [0, 206, 209],
                    darkviolet: [148, 0, 211],
                    deeppink: [255, 20, 147],
                    deepskyblue: [0, 191, 255],
                    dimgray: [105, 105, 105],
                    dimgrey: [105, 105, 105],
                    dodgerblue: [30, 144, 255],
                    firebrick: [178, 34, 34],
                    floralwhite: [255, 250, 240],
                    forestgreen: [34, 139, 34],
                    fuchsia: [255, 0, 255],
                    gainsboro: [220, 220, 220],
                    ghostwhite: [248, 248, 255],
                    gold: [255, 215, 0],
                    goldenrod: [218, 165, 32],
                    gray: [128, 128, 128],
                    green: [0, 128, 0],
                    greenyellow: [173, 255, 47],
                    grey: [128, 128, 128],
                    honeydew: [240, 255, 240],
                    hotpink: [255, 105, 180],
                    indianred: [205, 92, 92],
                    indigo: [75, 0, 130],
                    ivory: [255, 255, 240],
                    khaki: [240, 230, 140],
                    lavender: [230, 230, 250],
                    lavenderblush: [255, 240, 245],
                    lawngreen: [124, 252, 0],
                    lemonchiffon: [255, 250, 205],
                    lightblue: [173, 216, 230],
                    lightcoral: [240, 128, 128],
                    lightcyan: [224, 255, 255],
                    lightgoldenrodyellow: [250, 250, 210],
                    lightgray: [211, 211, 211],
                    lightgreen: [144, 238, 144],
                    lightgrey: [211, 211, 211],
                    lightpink: [255, 182, 193],
                    lightsalmon: [255, 160, 122],
                    lightseagreen: [32, 178, 170],
                    lightskyblue: [135, 206, 250],
                    lightslategray: [119, 136, 153],
                    lightslategrey: [119, 136, 153],
                    lightsteelblue: [176, 196, 222],
                    lightyellow: [255, 255, 224],
                    lime: [0, 255, 0],
                    limegreen: [50, 205, 50],
                    linen: [250, 240, 230],
                    magenta: [255, 0, 255],
                    maroon: [128, 0, 0],
                    mediumaquamarine: [102, 205, 170],
                    mediumblue: [0, 0, 205],
                    mediumorchid: [186, 85, 211],
                    mediumpurple: [147, 112, 219],
                    mediumseagreen: [60, 179, 113],
                    mediumslateblue: [123, 104, 238],
                    mediumspringgreen: [0, 250, 154],
                    mediumturquoise: [72, 209, 204],
                    mediumvioletred: [199, 21, 133],
                    midnightblue: [25, 25, 112],
                    mintcream: [245, 255, 250],
                    mistyrose: [255, 228, 225],
                    moccasin: [255, 228, 181],
                    navajowhite: [255, 222, 173],
                    navy: [0, 0, 128],
                    oldlace: [253, 245, 230],
                    olive: [128, 128, 0],
                    olivedrab: [107, 142, 35],
                    orange: [255, 165, 0],
                    orangered: [255, 69, 0],
                    orchid: [218, 112, 214],
                    palegoldenrod: [238, 232, 170],
                    palegreen: [152, 251, 152],
                    paleturquoise: [175, 238, 238],
                    palevioletred: [219, 112, 147],
                    papayawhip: [255, 239, 213],
                    peachpuff: [255, 218, 185],
                    peru: [205, 133, 63],
                    pink: [255, 192, 203],
                    plum: [221, 160, 221],
                    powderblue: [176, 224, 230],
                    purple: [128, 0, 128],
                    rebeccapurple: [102, 51, 153],
                    red: [255, 0, 0],
                    rosybrown: [188, 143, 143],
                    royalblue: [65, 105, 225],
                    saddlebrown: [139, 69, 19],
                    salmon: [250, 128, 114],
                    sandybrown: [244, 164, 96],
                    seagreen: [46, 139, 87],
                    seashell: [255, 245, 238],
                    sienna: [160, 82, 45],
                    silver: [192, 192, 192],
                    skyblue: [135, 206, 235],
                    slateblue: [106, 90, 205],
                    slategray: [112, 128, 144],
                    slategrey: [112, 128, 144],
                    snow: [255, 250, 250],
                    springgreen: [0, 255, 127],
                    steelblue: [70, 130, 180],
                    tan: [210, 180, 140],
                    teal: [0, 128, 128],
                    thistle: [216, 191, 216],
                    tomato: [255, 99, 71],
                    turquoise: [64, 224, 208],
                    violet: [238, 130, 238],
                    wheat: [245, 222, 179],
                    white: [255, 255, 255],
                    whitesmoke: [245, 245, 245],
                    yellow: [255, 255, 0],
                    yellowgreen: [154, 205, 50]
                };
                function jn(n, t, i) {
                    return n + i * (t - n)
                }
                function ea(n, t, i) {
                    return n.map( (a, u) => jn(a, t[u], i))
                }
                class Jr {
                    constructor(t, i, a, u=1, p=!0) {
                        this.r = t,
                        this.g = i,
                        this.b = a,
                        this.a = u,
                        p || (this.r *= u,
                        this.g *= u,
                        this.b *= u,
                        u || this.overwriteGetter("rgb", [t, i, a, u]))
                    }
                    static parse(t) {
                        if (t instanceof Jr)
                            return t;
                        if (typeof t != "string")
                            return;
                        const i = function(a) {
                            if ((a = a.toLowerCase().trim()) === "transparent")
                                return [0, 0, 0, 0];
                            const u = Wr(Ps, a);
                            if (u) {
                                const [f,g,y] = u;
                                return [f / 255, g / 255, y / 255, 1]
                            }
                            if (a.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(a)) {
                                const f = a.length < 6 ? 1 : 2;
                                let g = 1;
                                return [Qn(a.slice(g, g += f)), Qn(a.slice(g, g += f)), Qn(a.slice(g, g += f)), Qn(a.slice(g, g + f) || "ff")]
                            }
                            if (a.startsWith("rgb")) {
                                const f = a.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                                if (f) {
                                    const [g,y,S,I,A,R,N,j,$,J,se,Ae] = f
                                      , _e = [I || " ", N || " ", J].join("");
                                    if (_e === "  " || _e === "  /" || _e === ",," || _e === ",,,") {
                                        const O = [S, R, $].join("")
                                          , Y = O === "%%%" ? 100 : O === "" ? 255 : 0;
                                        if (Y) {
                                            const ve = [da(+y / Y, 0, 1), da(+A / Y, 0, 1), da(+j / Y, 0, 1), se ? sa(+se, Ae) : 1];
                                            if (os(ve))
                                                return ve
                                        }
                                    }
                                    return
                                }
                            }
                            const p = a.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                            if (p) {
                                const [f,g,y,S,I,A,R,N,j] = p
                                  , $ = [y || " ", I || " ", R].join("");
                                if ($ === "  " || $ === "  /" || $ === ",," || $ === ",,,") {
                                    const J = [+g, da(+S, 0, 100), da(+A, 0, 100), N ? sa(+N, j) : 1];
                                    if (os(J))
                                        return function([se,Ae,_e,O]) {
                                            function Y(ve) {
                                                const Xe = (ve + se / 30) % 12
                                                  , bt = Ae * Math.min(_e, 1 - _e);
                                                return _e - bt * Math.max(-1, Math.min(Xe - 3, 9 - Xe, 1))
                                            }
                                            return se = Ki(se),
                                            Ae /= 100,
                                            _e /= 100,
                                            [Y(0), Y(8), Y(4), O]
                                        }(J)
                                }
                            }
                        }(t);
                        return i ? new Jr(...i,!1) : void 0
                    }
                    get rgb() {
                        const {r: t, g: i, b: a, a: u} = this
                          , p = u || 1 / 0;
                        return this.overwriteGetter("rgb", [t / p, i / p, a / p, u])
                    }
                    get hcl() {
                        return this.overwriteGetter("hcl", function(t) {
                            const [i,a,u,p] = Pi(t)
                              , f = Math.sqrt(a * a + u * u);
                            return [Math.round(1e4 * f) ? Ki(Math.atan2(u, a) * ki) : NaN, f, i, p]
                        }(this.rgb))
                    }
                    get lab() {
                        return this.overwriteGetter("lab", Pi(this.rgb))
                    }
                    overwriteGetter(t, i) {
                        return Object.defineProperty(this, t, {
                            value: i
                        }),
                        i
                    }
                    toString() {
                        const [t,i,a,u] = this.rgb;
                        return `rgba(${[t, i, a].map(p => Math.round(255 * p)).join(",")},${u})`
                    }
                    static interpolate(t, i, a, u="rgb") {
                        switch (u) {
                        case "rgb":
                            {
                                const [p,f,g,y] = ea(t.rgb, i.rgb, a);
                                return new Jr(p,f,g,y,!1)
                            }
                        case "hcl":
                            {
                                const [p,f,g,y] = t.hcl
                                  , [S,I,A,R] = i.hcl;
                                let N, j;
                                if (isNaN(p) || isNaN(S))
                                    isNaN(p) ? isNaN(S) ? N = NaN : (N = S,
                                    g !== 1 && g !== 0 || (j = I)) : (N = p,
                                    A !== 1 && A !== 0 || (j = f));
                                else {
                                    let _e = S - p;
                                    S > p && _e > 180 ? _e -= 360 : S < p && p - S > 180 && (_e += 360),
                                    N = p + a * _e
                                }
                                const [$,J,se,Ae] = function([_e,O,Y,ve]) {
                                    return _e = isNaN(_e) ? 0 : _e * oi,
                                    gi([Y, Math.cos(_e) * O, Math.sin(_e) * O, ve])
                                }([N, j ?? jn(f, I, a), jn(g, A, a), jn(y, R, a)]);
                                return new Jr($,J,se,Ae,!1)
                            }
                        case "lab":
                            {
                                const [p,f,g,y] = gi(ea(t.lab, i.lab, a));
                                return new Jr(p,f,g,y,!1)
                            }
                        }
                    }
                }
                Jr.black = new Jr(0,0,0,1),
                Jr.white = new Jr(1,1,1,1),
                Jr.transparent = new Jr(0,0,0,0),
                Jr.red = new Jr(1,0,0,1);
                class Ua {
                    constructor(t, i, a) {
                        this.sensitivity = t ? i ? "variant" : "case" : i ? "accent" : "base",
                        this.locale = a,
                        this.collator = new Intl.Collator(this.locale ? this.locale : [],{
                            sensitivity: this.sensitivity,
                            usage: "search"
                        })
                    }
                    compare(t, i) {
                        return this.collator.compare(t, i)
                    }
                    resolvedLocale() {
                        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
                    }
                }
                const Da = ["bottom", "center", "top"];
                class co {
                    constructor(t, i, a, u, p, f) {
                        this.text = t,
                        this.image = i,
                        this.scale = a,
                        this.fontStack = u,
                        this.textColor = p,
                        this.verticalAlign = f
                    }
                }
                class Gi {
                    constructor(t) {
                        this.sections = t
                    }
                    static fromString(t) {
                        return new Gi([new co(t,null,null,null,null,null)])
                    }
                    isEmpty() {
                        return this.sections.length === 0 || !this.sections.some(t => t.text.length !== 0 || t.image && t.image.name.length !== 0)
                    }
                    static factory(t) {
                        return t instanceof Gi ? t : Gi.fromString(t)
                    }
                    toString() {
                        return this.sections.length === 0 ? "" : this.sections.map(t => t.text).join("")
                    }
                }
                class Li {
                    constructor(t) {
                        this.values = t.slice()
                    }
                    static parse(t) {
                        if (t instanceof Li)
                            return t;
                        if (typeof t == "number")
                            return new Li([t, t, t, t]);
                        if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
                            for (const i of t)
                                if (typeof i != "number")
                                    return;
                            switch (t.length) {
                            case 1:
                                t = [t[0], t[0], t[0], t[0]];
                                break;
                            case 2:
                                t = [t[0], t[1], t[0], t[1]];
                                break;
                            case 3:
                                t = [t[0], t[1], t[2], t[1]]
                            }
                            return new Li(t)
                        }
                    }
                    toString() {
                        return JSON.stringify(this.values)
                    }
                    static interpolate(t, i, a) {
                        return new Li(ea(t.values, i.values, a))
                    }
                }
                class sn {
                    constructor(t) {
                        this.values = t.slice()
                    }
                    static parse(t) {
                        if (t instanceof sn)
                            return t;
                        if (typeof t == "number")
                            return new sn([t]);
                        if (Array.isArray(t)) {
                            for (const i of t)
                                if (typeof i != "number")
                                    return;
                            return new sn(t)
                        }
                    }
                    toString() {
                        return JSON.stringify(this.values)
                    }
                    static interpolate(t, i, a) {
                        return new sn(ea(t.values, i.values, a))
                    }
                }
                class on {
                    constructor(t) {
                        this.values = t.slice()
                    }
                    static parse(t) {
                        if (t instanceof on)
                            return t;
                        if (typeof t == "string") {
                            const a = Jr.parse(t);
                            return a ? new on([a]) : void 0
                        }
                        if (!Array.isArray(t))
                            return;
                        const i = [];
                        for (const a of t) {
                            if (typeof a != "string")
                                return;
                            const u = Jr.parse(a);
                            if (!u)
                                return;
                            i.push(u)
                        }
                        return new on(i)
                    }
                    toString() {
                        return JSON.stringify(this.values)
                    }
                    static interpolate(t, i, a, u="rgb") {
                        const p = [];
                        if (t.values.length != i.values.length)
                            throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${i.values.length}), cannot interpolate.`);
                        for (let f = 0; f < t.values.length; f++)
                            p.push(Jr.interpolate(t.values[f], i.values[f], a, u));
                        return new on(p)
                    }
                }
                class Di extends Error {
                    constructor(t) {
                        super(t),
                        this.name = "RuntimeError"
                    }
                    toJSON() {
                        return this.message
                    }
                }
                const tl = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
                class ai {
                    constructor(t) {
                        this.values = t.slice()
                    }
                    static parse(t) {
                        if (t instanceof ai)
                            return t;
                        if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
                            for (let i = 0; i < t.length; i += 2) {
                                const a = t[i]
                                  , u = t[i + 1];
                                if (typeof a != "string" || !tl.has(a) || !Array.isArray(u) || u.length !== 2 || typeof u[0] != "number" || typeof u[1] != "number")
                                    return
                            }
                            return new ai(t)
                        }
                    }
                    toString() {
                        return JSON.stringify(this.values)
                    }
                    static interpolate(t, i, a) {
                        const u = t.values
                          , p = i.values;
                        if (u.length !== p.length)
                            throw new Di(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${i.toString()}`);
                        const f = [];
                        for (let g = 0; g < u.length; g += 2) {
                            if (u[g] !== p[g])
                                throw new Di(`Cannot interpolate values containing mismatched anchors. from[${g}]: ${u[g]}, to[${g}]: ${p[g]}`);
                            f.push(u[g]);
                            const [y,S] = u[g + 1]
                              , [I,A] = p[g + 1];
                            f.push([jn(y, I, a), jn(S, A, a)])
                        }
                        return new ai(f)
                    }
                }
                class qn {
                    constructor(t) {
                        this.name = t.name,
                        this.available = t.available
                    }
                    toString() {
                        return this.name
                    }
                    static fromString(t) {
                        return t ? new qn({
                            name: t,
                            available: !1
                        }) : null
                    }
                }
                class Hr {
                    constructor(t, i, a) {
                        this.from = t,
                        this.to = i,
                        this.transition = a
                    }
                    static interpolate(t, i, a) {
                        return new Hr(t,i,a)
                    }
                    static parse(t) {
                        return t instanceof Hr ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new Hr(t[0],t[1],t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new Hr(t.from,t.to,t.transition) : typeof t == "string" ? new Hr(t,t,1) : void 0
                    }
                }
                function Xr(n, t, i, a) {
                    return typeof n == "number" && n >= 0 && n <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof i == "number" && i >= 0 && i <= 255 ? a === void 0 || typeof a == "number" && a >= 0 && a <= 1 ? null : `Invalid rgba value [${[n, t, i, a].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof a == "number" ? [n, t, i, a] : [n, t, i]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
                }
                function ls(n) {
                    if (n === null || typeof n == "string" || typeof n == "boolean" || typeof n == "number" || n instanceof Hr || n instanceof Jr || n instanceof Ua || n instanceof Gi || n instanceof Li || n instanceof sn || n instanceof on || n instanceof ai || n instanceof qn)
                        return !0;
                    if (Array.isArray(n)) {
                        for (const t of n)
                            if (!ls(t))
                                return !1;
                        return !0
                    }
                    if (typeof n == "object") {
                        for (const t in n)
                            if (!ls(n[t]))
                                return !1;
                        return !0
                    }
                    return !1
                }
                function qr(n) {
                    if (n === null)
                        return ui;
                    if (typeof n == "string")
                        return yr;
                    if (typeof n == "boolean")
                        return pr;
                    if (typeof n == "number")
                        return St;
                    if (n instanceof Jr)
                        return hi;
                    if (n instanceof Hr)
                        return Or;
                    if (n instanceof Ua)
                        return $i;
                    if (n instanceof Gi)
                        return On;
                    if (n instanceof Li)
                        return _i;
                    if (n instanceof sn)
                        return Kn;
                    if (n instanceof on)
                        return An;
                    if (n instanceof ai)
                        return Tt;
                    if (n instanceof qn)
                        return Nn;
                    if (Array.isArray(n)) {
                        const t = n.length;
                        let i;
                        for (const a of n) {
                            const u = qr(a);
                            if (i) {
                                if (i === u)
                                    continue;
                                i = fr;
                                break
                            }
                            i = u
                        }
                        return Ot(i || fr, t)
                    }
                    return si
                }
                function cs(n) {
                    const t = typeof n;
                    return n === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(n) : n instanceof Jr || n instanceof Hr || n instanceof Gi || n instanceof Li || n instanceof sn || n instanceof on || n instanceof ai || n instanceof qn ? n.toString() : JSON.stringify(n)
                }
                class kn {
                    constructor(t, i) {
                        this.type = t,
                        this.value = i
                    }
                    static parse(t, i) {
                        if (t.length !== 2)
                            return i.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                        if (!ls(t[1]))
                            return i.error("invalid value");
                        const a = t[1];
                        let u = qr(a);
                        const p = i.expectedType;
                        return u.kind !== "array" || u.N !== 0 || !p || p.kind !== "array" || typeof p.N == "number" && p.N !== 0 || (u = p),
                        new kn(u,a)
                    }
                    evaluate() {
                        return this.value
                    }
                    eachChild() {}
                    outputDefined() {
                        return !0
                    }
                }
                const Is = {
                    string: yr,
                    number: St,
                    boolean: pr,
                    object: si
                };
                class Vn {
                    constructor(t, i) {
                        this.type = t,
                        this.args = i
                    }
                    static parse(t, i) {
                        if (t.length < 2)
                            return i.error("Expected at least one argument.");
                        let a, u = 1;
                        const p = t[0];
                        if (p === "array") {
                            let g, y;
                            if (t.length > 2) {
                                const S = t[1];
                                if (typeof S != "string" || !(S in Is) || S === "object")
                                    return i.error('The item type argument of "array" must be one of string, number, boolean', 1);
                                g = Is[S],
                                u++
                            } else
                                g = fr;
                            if (t.length > 3) {
                                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2])))
                                    return i.error('The length argument to "array" must be a positive integer literal', 2);
                                y = t[2],
                                u++
                            }
                            a = Ot(g, y)
                        } else {
                            if (!Is[p])
                                throw new Error(`Types doesn't contain name = ${p}`);
                            a = Is[p]
                        }
                        const f = [];
                        for (; u < t.length; u++) {
                            const g = i.parse(t[u], u, fr);
                            if (!g)
                                return null;
                            f.push(g)
                        }
                        return new Vn(a,f)
                    }
                    evaluate(t) {
                        for (let i = 0; i < this.args.length; i++) {
                            const a = this.args[i].evaluate(t);
                            if (!Ii(this.type, qr(a)))
                                return a;
                            if (i === this.args.length - 1)
                                throw new Di(`Expected value to be of type ${Ht(this.type)}, but found ${Ht(qr(a))} instead.`)
                        }
                        throw new Error
                    }
                    eachChild(t) {
                        this.args.forEach(t)
                    }
                    outputDefined() {
                        return this.args.every(t => t.outputDefined())
                    }
                }
                const pc = {
                    "to-boolean": pr,
                    "to-color": hi,
                    "to-number": St,
                    "to-string": yr
                };
                class Ca {
                    constructor(t, i) {
                        this.type = t,
                        this.args = i
                    }
                    static parse(t, i) {
                        if (t.length < 2)
                            return i.error("Expected at least one argument.");
                        const a = t[0];
                        if (!pc[a])
                            throw new Error(`Can't parse ${a} as it is not part of the known types`);
                        if ((a === "to-boolean" || a === "to-string") && t.length !== 2)
                            return i.error("Expected one argument.");
                        const u = pc[a]
                          , p = [];
                        for (let f = 1; f < t.length; f++) {
                            const g = i.parse(t[f], f, fr);
                            if (!g)
                                return null;
                            p.push(g)
                        }
                        return new Ca(u,p)
                    }
                    evaluate(t) {
                        switch (this.type.kind) {
                        case "boolean":
                            return !!this.args[0].evaluate(t);
                        case "color":
                            {
                                let i, a;
                                for (const u of this.args) {
                                    if (i = u.evaluate(t),
                                    a = null,
                                    i instanceof Jr)
                                        return i;
                                    if (typeof i == "string") {
                                        const p = t.parseColor(i);
                                        if (p)
                                            return p
                                    } else if (Array.isArray(i) && (a = i.length < 3 || i.length > 4 ? `Invalid rgba value ${JSON.stringify(i)}: expected an array containing either three or four numeric values.` : Xr(i[0], i[1], i[2], i[3]),
                                    !a))
                                        return new Jr(i[0] / 255,i[1] / 255,i[2] / 255,i[3])
                                }
                                throw new Di(a || `Could not parse color from value '${typeof i == "string" ? i : JSON.stringify(i)}'`)
                            }
                        case "padding":
                            {
                                let i;
                                for (const a of this.args) {
                                    i = a.evaluate(t);
                                    const u = Li.parse(i);
                                    if (u)
                                        return u
                                }
                                throw new Di(`Could not parse padding from value '${typeof i == "string" ? i : JSON.stringify(i)}'`)
                            }
                        case "numberArray":
                            {
                                let i;
                                for (const a of this.args) {
                                    i = a.evaluate(t);
                                    const u = sn.parse(i);
                                    if (u)
                                        return u
                                }
                                throw new Di(`Could not parse numberArray from value '${typeof i == "string" ? i : JSON.stringify(i)}'`)
                            }
                        case "colorArray":
                            {
                                let i;
                                for (const a of this.args) {
                                    i = a.evaluate(t);
                                    const u = on.parse(i);
                                    if (u)
                                        return u
                                }
                                throw new Di(`Could not parse colorArray from value '${typeof i == "string" ? i : JSON.stringify(i)}'`)
                            }
                        case "variableAnchorOffsetCollection":
                            {
                                let i;
                                for (const a of this.args) {
                                    i = a.evaluate(t);
                                    const u = ai.parse(i);
                                    if (u)
                                        return u
                                }
                                throw new Di(`Could not parse variableAnchorOffsetCollection from value '${typeof i == "string" ? i : JSON.stringify(i)}'`)
                            }
                        case "number":
                            {
                                let i = null;
                                for (const a of this.args) {
                                    if (i = a.evaluate(t),
                                    i === null)
                                        return 0;
                                    const u = Number(i);
                                    if (!isNaN(u))
                                        return u
                                }
                                throw new Di(`Could not convert ${JSON.stringify(i)} to number.`)
                            }
                        case "formatted":
                            return Gi.fromString(cs(this.args[0].evaluate(t)));
                        case "resolvedImage":
                            return qn.fromString(cs(this.args[0].evaluate(t)));
                        case "projectionDefinition":
                            return this.args[0].evaluate(t);
                        default:
                            return cs(this.args[0].evaluate(t))
                        }
                    }
                    eachChild(t) {
                        this.args.forEach(t)
                    }
                    outputDefined() {
                        return this.args.every(t => t.outputDefined())
                    }
                }
                const gh = ["Unknown", "Point", "LineString", "Polygon"];
                class vh {
                    constructor() {
                        this.globals = null,
                        this.feature = null,
                        this.featureState = null,
                        this.formattedSection = null,
                        this._parseColorCache = new Map,
                        this.availableImages = null,
                        this.canonical = null
                    }
                    id() {
                        return this.feature && "id"in this.feature ? this.feature.id : null
                    }
                    geometryType() {
                        return this.feature ? typeof this.feature.type == "number" ? gh[this.feature.type] : this.feature.type : null
                    }
                    geometry() {
                        return this.feature && "geometry"in this.feature ? this.feature.geometry : null
                    }
                    canonicalID() {
                        return this.canonical
                    }
                    properties() {
                        return this.feature && this.feature.properties || {}
                    }
                    parseColor(t) {
                        let i = this._parseColorCache.get(t);
                        return i || (i = Jr.parse(t),
                        this._parseColorCache.set(t, i)),
                        i
                    }
                }
                class uo {
                    constructor(t, i, a=[], u, p=new Si, f=[]) {
                        this.registry = t,
                        this.path = a,
                        this.key = a.map(g => `[${g}]`).join(""),
                        this.scope = p,
                        this.errors = f,
                        this.expectedType = u,
                        this._isConstant = i
                    }
                    parse(t, i, a, u, p={}) {
                        return i ? this.concat(i, a, u)._parse(t, p) : this._parse(t, p)
                    }
                    _parse(t, i) {
                        function a(u, p, f) {
                            return f === "assert" ? new Vn(p,[u]) : f === "coerce" ? new Ca(p,[u]) : u
                        }
                        if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]),
                        Array.isArray(t)) {
                            if (t.length === 0)
                                return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                            const u = t[0];
                            if (typeof u != "string")
                                return this.error(`Expression name must be a string, but found ${typeof u} instead. If you wanted a literal array, use ["literal", [...]].`, 0),
                                null;
                            const p = this.registry[u];
                            if (p) {
                                let f = p.parse(t, this);
                                if (!f)
                                    return null;
                                if (this.expectedType) {
                                    const g = this.expectedType
                                      , y = f.type;
                                    if (g.kind !== "string" && g.kind !== "number" && g.kind !== "boolean" && g.kind !== "object" && g.kind !== "array" || y.kind !== "value") {
                                        if (g.kind === "projectionDefinition" && ["string", "array"].includes(y.kind) || ["color", "formatted", "resolvedImage"].includes(g.kind) && ["value", "string"].includes(y.kind) || ["padding", "numberArray"].includes(g.kind) && ["value", "number", "array"].includes(y.kind) || g.kind === "colorArray" && ["value", "string", "array"].includes(y.kind) || g.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(y.kind))
                                            f = a(f, g, i.typeAnnotation || "coerce");
                                        else if (this.checkSubtype(g, y))
                                            return null
                                    } else
                                        f = a(f, g, i.typeAnnotation || "assert")
                                }
                                if (!(f instanceof kn) && f.type.kind !== "resolvedImage" && this._isConstant(f)) {
                                    const g = new vh;
                                    try {
                                        f = new kn(f.type,f.evaluate(g))
                                    } catch (y) {
                                        return this.error(y.message),
                                        null
                                    }
                                }
                                return f
                            }
                            return this.error(`Unknown expression "${u}". If you wanted a literal array, use ["literal", [...]].`, 0)
                        }
                        return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`)
                    }
                    concat(t, i, a) {
                        const u = typeof t == "number" ? this.path.concat(t) : this.path
                          , p = a ? this.scope.concat(a) : this.scope;
                        return new uo(this.registry,this._isConstant,u,i || null,p,this.errors)
                    }
                    error(t, ...i) {
                        const a = `${this.key}${i.map(u => `[${u}]`).join("")}`;
                        this.errors.push(new Ur(a,t))
                    }
                    checkSubtype(t, i) {
                        const a = Ii(t, i);
                        return a && this.error(a),
                        a
                    }
                }
                class ho {
                    constructor(t, i) {
                        this.type = i.type,
                        this.bindings = [].concat(t),
                        this.result = i
                    }
                    evaluate(t) {
                        return this.result.evaluate(t)
                    }
                    eachChild(t) {
                        for (const i of this.bindings)
                            t(i[1]);
                        t(this.result)
                    }
                    static parse(t, i) {
                        if (t.length < 4)
                            return i.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
                        const a = [];
                        for (let p = 1; p < t.length - 1; p += 2) {
                            const f = t[p];
                            if (typeof f != "string")
                                return i.error(`Expected string, but found ${typeof f} instead.`, p);
                            if (/[^a-zA-Z0-9_]/.test(f))
                                return i.error("Variable names must contain only alphanumeric characters or '_'.", p);
                            const g = i.parse(t[p + 1], p + 1);
                            if (!g)
                                return null;
                            a.push([f, g])
                        }
                        const u = i.parse(t[t.length - 1], t.length - 1, i.expectedType, a);
                        return u ? new ho(a,u) : null
                    }
                    outputDefined() {
                        return this.result.outputDefined()
                    }
                }
                class pa {
                    constructor(t, i) {
                        this.type = i.type,
                        this.name = t,
                        this.boundExpression = i
                    }
                    static parse(t, i) {
                        if (t.length !== 2 || typeof t[1] != "string")
                            return i.error("'var' expression requires exactly one string literal argument.");
                        const a = t[1];
                        return i.scope.has(a) ? new pa(a,i.scope.get(a)) : i.error(`Unknown variable "${a}". Make sure "${a}" has been bound in an enclosing "let" expression before using it.`, 1)
                    }
                    evaluate(t) {
                        return this.boundExpression.evaluate(t)
                    }
                    eachChild() {}
                    outputDefined() {
                        return !1
                    }
                }
                class ln {
                    constructor(t, i, a) {
                        this.type = t,
                        this.index = i,
                        this.input = a
                    }
                    static parse(t, i) {
                        if (t.length !== 3)
                            return i.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
                        const a = i.parse(t[1], 1, St)
                          , u = i.parse(t[2], 2, Ot(i.expectedType || fr));
                        return a && u ? new ln(u.type.itemType,a,u) : null
                    }
                    evaluate(t) {
                        const i = this.index.evaluate(t)
                          , a = this.input.evaluate(t);
                        if (i < 0)
                            throw new Di(`Array index out of bounds: ${i} < 0.`);
                        if (i >= a.length)
                            throw new Di(`Array index out of bounds: ${i} > ${a.length - 1}.`);
                        if (i !== Math.floor(i))
                            throw new Di(`Array index must be an integer, but found ${i} instead.`);
                        return a[i]
                    }
                    eachChild(t) {
                        t(this.index),
                        t(this.input)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class Ms {
                    constructor(t, i) {
                        this.type = pr,
                        this.needle = t,
                        this.haystack = i
                    }
                    static parse(t, i) {
                        if (t.length !== 3)
                            return i.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
                        const a = i.parse(t[1], 1, fr)
                          , u = i.parse(t[2], 2, fr);
                        return a && u ? Qi(a.type, [pr, yr, St, ui, fr]) ? new Ms(a,u) : i.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ht(a.type)} instead`) : null
                    }
                    evaluate(t) {
                        const i = this.needle.evaluate(t)
                          , a = this.haystack.evaluate(t);
                        if (!a)
                            return !1;
                        if (!vi(i, ["boolean", "string", "number", "null"]))
                            throw new Di(`Expected first argument to be of type boolean, string, number or null, but found ${Ht(qr(i))} instead.`);
                        if (!vi(a, ["string", "array"]))
                            throw new Di(`Expected second argument to be of type array or string, but found ${Ht(qr(a))} instead.`);
                        return a.indexOf(i) >= 0
                    }
                    eachChild(t) {
                        t(this.needle),
                        t(this.haystack)
                    }
                    outputDefined() {
                        return !0
                    }
                }
                class po {
                    constructor(t, i, a) {
                        this.type = St,
                        this.needle = t,
                        this.haystack = i,
                        this.fromIndex = a
                    }
                    static parse(t, i) {
                        if (t.length <= 2 || t.length >= 5)
                            return i.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
                        const a = i.parse(t[1], 1, fr)
                          , u = i.parse(t[2], 2, fr);
                        if (!a || !u)
                            return null;
                        if (!Qi(a.type, [pr, yr, St, ui, fr]))
                            return i.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ht(a.type)} instead`);
                        if (t.length === 4) {
                            const p = i.parse(t[3], 3, St);
                            return p ? new po(a,u,p) : null
                        }
                        return new po(a,u)
                    }
                    evaluate(t) {
                        const i = this.needle.evaluate(t)
                          , a = this.haystack.evaluate(t);
                        if (!vi(i, ["boolean", "string", "number", "null"]))
                            throw new Di(`Expected first argument to be of type boolean, string, number or null, but found ${Ht(qr(i))} instead.`);
                        let u;
                        if (this.fromIndex && (u = this.fromIndex.evaluate(t)),
                        vi(a, ["string"])) {
                            const p = a.indexOf(i, u);
                            return p === -1 ? -1 : [...a.slice(0, p)].length
                        }
                        if (vi(a, ["array"]))
                            return a.indexOf(i, u);
                        throw new Di(`Expected second argument to be of type array or string, but found ${Ht(qr(a))} instead.`)
                    }
                    eachChild(t) {
                        t(this.needle),
                        t(this.haystack),
                        this.fromIndex && t(this.fromIndex)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class As {
                    constructor(t, i, a, u, p, f) {
                        this.inputType = t,
                        this.type = i,
                        this.input = a,
                        this.cases = u,
                        this.outputs = p,
                        this.otherwise = f
                    }
                    static parse(t, i) {
                        if (t.length < 5)
                            return i.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                        if (t.length % 2 != 1)
                            return i.error("Expected an even number of arguments.");
                        let a, u;
                        i.expectedType && i.expectedType.kind !== "value" && (u = i.expectedType);
                        const p = {}
                          , f = [];
                        for (let S = 2; S < t.length - 1; S += 2) {
                            let I = t[S];
                            const A = t[S + 1];
                            Array.isArray(I) || (I = [I]);
                            const R = i.concat(S);
                            if (I.length === 0)
                                return R.error("Expected at least one branch label.");
                            for (const j of I) {
                                if (typeof j != "number" && typeof j != "string")
                                    return R.error("Branch labels must be numbers or strings.");
                                if (typeof j == "number" && Math.abs(j) > Number.MAX_SAFE_INTEGER)
                                    return R.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                                if (typeof j == "number" && Math.floor(j) !== j)
                                    return R.error("Numeric branch labels must be integer values.");
                                if (a) {
                                    if (R.checkSubtype(a, qr(j)))
                                        return null
                                } else
                                    a = qr(j);
                                if (p[String(j)] !== void 0)
                                    return R.error("Branch labels must be unique.");
                                p[String(j)] = f.length
                            }
                            const N = i.parse(A, S, u);
                            if (!N)
                                return null;
                            u = u || N.type,
                            f.push(N)
                        }
                        const g = i.parse(t[1], 1, fr);
                        if (!g)
                            return null;
                        const y = i.parse(t[t.length - 1], t.length - 1, u);
                        return y ? g.type.kind !== "value" && i.concat(1).checkSubtype(a, g.type) ? null : new As(a,u,g,p,f,y) : null
                    }
                    evaluate(t) {
                        const i = this.input.evaluate(t);
                        return (qr(i) === this.inputType && this.outputs[this.cases[i]] || this.otherwise).evaluate(t)
                    }
                    eachChild(t) {
                        t(this.input),
                        this.outputs.forEach(t),
                        t(this.otherwise)
                    }
                    outputDefined() {
                        return this.outputs.every(t => t.outputDefined()) && this.otherwise.outputDefined()
                    }
                }
                class Yi {
                    constructor(t, i, a) {
                        this.type = t,
                        this.branches = i,
                        this.otherwise = a
                    }
                    static parse(t, i) {
                        if (t.length < 4)
                            return i.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
                        if (t.length % 2 != 0)
                            return i.error("Expected an odd number of arguments.");
                        let a;
                        i.expectedType && i.expectedType.kind !== "value" && (a = i.expectedType);
                        const u = [];
                        for (let f = 1; f < t.length - 1; f += 2) {
                            const g = i.parse(t[f], f, pr);
                            if (!g)
                                return null;
                            const y = i.parse(t[f + 1], f + 1, a);
                            if (!y)
                                return null;
                            u.push([g, y]),
                            a = a || y.type
                        }
                        const p = i.parse(t[t.length - 1], t.length - 1, a);
                        if (!p)
                            return null;
                        if (!a)
                            throw new Error("Can't infer output type");
                        return new Yi(a,u,p)
                    }
                    evaluate(t) {
                        for (const [i,a] of this.branches)
                            if (i.evaluate(t))
                                return a.evaluate(t);
                        return this.otherwise.evaluate(t)
                    }
                    eachChild(t) {
                        for (const [i,a] of this.branches)
                            t(i),
                            t(a);
                        t(this.otherwise)
                    }
                    outputDefined() {
                        return this.branches.every( ([t,i]) => i.outputDefined()) && this.otherwise.outputDefined()
                    }
                }
                class fo {
                    constructor(t, i, a, u) {
                        this.type = t,
                        this.input = i,
                        this.beginIndex = a,
                        this.endIndex = u
                    }
                    static parse(t, i) {
                        if (t.length <= 2 || t.length >= 5)
                            return i.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
                        const a = i.parse(t[1], 1, fr)
                          , u = i.parse(t[2], 2, St);
                        if (!a || !u)
                            return null;
                        if (!Qi(a.type, [Ot(fr), yr, fr]))
                            return i.error(`Expected first argument to be of type array or string, but found ${Ht(a.type)} instead`);
                        if (t.length === 4) {
                            const p = i.parse(t[3], 3, St);
                            return p ? new fo(a.type,a,u,p) : null
                        }
                        return new fo(a.type,a,u)
                    }
                    evaluate(t) {
                        const i = this.input.evaluate(t)
                          , a = this.beginIndex.evaluate(t);
                        let u;
                        if (this.endIndex && (u = this.endIndex.evaluate(t)),
                        vi(i, ["string"]))
                            return [...i].slice(a, u).join("");
                        if (vi(i, ["array"]))
                            return i.slice(a, u);
                        throw new Di(`Expected first argument to be of type array or string, but found ${Ht(qr(i))} instead.`)
                    }
                    eachChild(t) {
                        t(this.input),
                        t(this.beginIndex),
                        this.endIndex && t(this.endIndex)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                function ks(n, t) {
                    const i = n.length - 1;
                    let a, u, p = 0, f = i, g = 0;
                    for (; p <= f; )
                        if (g = Math.floor((p + f) / 2),
                        a = n[g],
                        u = n[g + 1],
                        a <= t) {
                            if (g === i || t < u)
                                return g;
                            p = g + 1
                        } else {
                            if (!(a > t))
                                throw new Di("Input is not a number.");
                            f = g - 1
                        }
                    return 0
                }
                class Es {
                    constructor(t, i, a) {
                        this.type = t,
                        this.input = i,
                        this.labels = [],
                        this.outputs = [];
                        for (const [u,p] of a)
                            this.labels.push(u),
                            this.outputs.push(p)
                    }
                    static parse(t, i) {
                        if (t.length - 1 < 4)
                            return i.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                        if ((t.length - 1) % 2 != 0)
                            return i.error("Expected an even number of arguments.");
                        const a = i.parse(t[1], 1, St);
                        if (!a)
                            return null;
                        const u = [];
                        let p = null;
                        i.expectedType && i.expectedType.kind !== "value" && (p = i.expectedType);
                        for (let f = 1; f < t.length; f += 2) {
                            const g = f === 1 ? -1 / 0 : t[f]
                              , y = t[f + 1]
                              , S = f
                              , I = f + 1;
                            if (typeof g != "number")
                                return i.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', S);
                            if (u.length && u[u.length - 1][0] >= g)
                                return i.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', S);
                            const A = i.parse(y, I, p);
                            if (!A)
                                return null;
                            p = p || A.type,
                            u.push([g, A])
                        }
                        return new Es(p,a,u)
                    }
                    evaluate(t) {
                        const i = this.labels
                          , a = this.outputs;
                        if (i.length === 1)
                            return a[0].evaluate(t);
                        const u = this.input.evaluate(t);
                        if (u <= i[0])
                            return a[0].evaluate(t);
                        const p = i.length;
                        return u >= i[p - 1] ? a[p - 1].evaluate(t) : a[ks(i, u)].evaluate(t)
                    }
                    eachChild(t) {
                        t(this.input);
                        for (const i of this.outputs)
                            t(i)
                    }
                    outputDefined() {
                        return this.outputs.every(t => t.outputDefined())
                    }
                }
                function Wd(n) {
                    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
                }
                var Ga, mo, fc = function() {
                    if (mo)
                        return Ga;
                    function n(t, i, a, u) {
                        this.cx = 3 * t,
                        this.bx = 3 * (a - t) - this.cx,
                        this.ax = 1 - this.cx - this.bx,
                        this.cy = 3 * i,
                        this.by = 3 * (u - i) - this.cy,
                        this.ay = 1 - this.cy - this.by,
                        this.p1x = t,
                        this.p1y = i,
                        this.p2x = a,
                        this.p2y = u
                    }
                    return mo = 1,
                    Ga = n,
                    n.prototype = {
                        sampleCurveX: function(t) {
                            return ((this.ax * t + this.bx) * t + this.cx) * t
                        },
                        sampleCurveY: function(t) {
                            return ((this.ay * t + this.by) * t + this.cy) * t
                        },
                        sampleCurveDerivativeX: function(t) {
                            return (3 * this.ax * t + 2 * this.bx) * t + this.cx
                        },
                        solveCurveX: function(t, i) {
                            if (i === void 0 && (i = 1e-6),
                            t < 0)
                                return 0;
                            if (t > 1)
                                return 1;
                            for (var a = t, u = 0; u < 8; u++) {
                                var p = this.sampleCurveX(a) - t;
                                if (Math.abs(p) < i)
                                    return a;
                                var f = this.sampleCurveDerivativeX(a);
                                if (Math.abs(f) < 1e-6)
                                    break;
                                a -= p / f
                            }
                            var g = 0
                              , y = 1;
                            for (a = t,
                            u = 0; u < 20 && (p = this.sampleCurveX(a),
                            !(Math.abs(p - t) < i)); u++)
                                t > p ? g = a : y = a,
                                a = .5 * (y - g) + g;
                            return a
                        },
                        solve: function(t, i) {
                            return this.sampleCurveY(this.solveCurveX(t, i))
                        }
                    },
                    Ga
                }(), Xd = Wd(fc);
                class En {
                    constructor(t, i, a, u, p) {
                        this.type = t,
                        this.operator = i,
                        this.interpolation = a,
                        this.input = u,
                        this.labels = [],
                        this.outputs = [];
                        for (const [f,g] of p)
                            this.labels.push(f),
                            this.outputs.push(g)
                    }
                    static interpolationFactor(t, i, a, u) {
                        let p = 0;
                        if (t.name === "exponential")
                            p = zs(i, t.base, a, u);
                        else if (t.name === "linear")
                            p = zs(i, 1, a, u);
                        else if (t.name === "cubic-bezier") {
                            const f = t.controlPoints;
                            p = new Xd(f[0],f[1],f[2],f[3]).solve(zs(i, 1, a, u))
                        }
                        return p
                    }
                    static parse(t, i) {
                        let[a,u,p,...f] = t;
                        if (!Array.isArray(u) || u.length === 0)
                            return i.error("Expected an interpolation type expression.", 1);
                        if (u[0] === "linear")
                            u = {
                                name: "linear"
                            };
                        else if (u[0] === "exponential") {
                            const S = u[1];
                            if (typeof S != "number")
                                return i.error("Exponential interpolation requires a numeric base.", 1, 1);
                            u = {
                                name: "exponential",
                                base: S
                            }
                        } else {
                            if (u[0] !== "cubic-bezier")
                                return i.error(`Unknown interpolation type ${String(u[0])}`, 1, 0);
                            {
                                const S = u.slice(1);
                                if (S.length !== 4 || S.some(I => typeof I != "number" || I < 0 || I > 1))
                                    return i.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                                u = {
                                    name: "cubic-bezier",
                                    controlPoints: S
                                }
                            }
                        }
                        if (t.length - 1 < 4)
                            return i.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                        if ((t.length - 1) % 2 != 0)
                            return i.error("Expected an even number of arguments.");
                        if (p = i.parse(p, 2, St),
                        !p)
                            return null;
                        const g = [];
                        let y = null;
                        a !== "interpolate-hcl" && a !== "interpolate-lab" || i.expectedType == An ? i.expectedType && i.expectedType.kind !== "value" && (y = i.expectedType) : y = hi;
                        for (let S = 0; S < f.length; S += 2) {
                            const I = f[S]
                              , A = f[S + 1]
                              , R = S + 3
                              , N = S + 4;
                            if (typeof I != "number")
                                return i.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', R);
                            if (g.length && g[g.length - 1][0] >= I)
                                return i.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', R);
                            const j = i.parse(A, N, y);
                            if (!j)
                                return null;
                            y = y || j.type,
                            g.push([I, j])
                        }
                        return kr(y, St) || kr(y, Or) || kr(y, hi) || kr(y, _i) || kr(y, Kn) || kr(y, An) || kr(y, Tt) || kr(y, Ot(St)) ? new En(y,a,u,p,g) : i.error(`Type ${Ht(y)} is not interpolatable.`)
                    }
                    evaluate(t) {
                        const i = this.labels
                          , a = this.outputs;
                        if (i.length === 1)
                            return a[0].evaluate(t);
                        const u = this.input.evaluate(t);
                        if (u <= i[0])
                            return a[0].evaluate(t);
                        const p = i.length;
                        if (u >= i[p - 1])
                            return a[p - 1].evaluate(t);
                        const f = ks(i, u)
                          , g = En.interpolationFactor(this.interpolation, u, i[f], i[f + 1])
                          , y = a[f].evaluate(t)
                          , S = a[f + 1].evaluate(t);
                        switch (this.operator) {
                        case "interpolate":
                            switch (this.type.kind) {
                            case "number":
                                return jn(y, S, g);
                            case "color":
                                return Jr.interpolate(y, S, g);
                            case "padding":
                                return Li.interpolate(y, S, g);
                            case "colorArray":
                                return on.interpolate(y, S, g);
                            case "numberArray":
                                return sn.interpolate(y, S, g);
                            case "variableAnchorOffsetCollection":
                                return ai.interpolate(y, S, g);
                            case "array":
                                return ea(y, S, g);
                            case "projectionDefinition":
                                return Hr.interpolate(y, S, g)
                            }
                        case "interpolate-hcl":
                            switch (this.type.kind) {
                            case "color":
                                return Jr.interpolate(y, S, g, "hcl");
                            case "colorArray":
                                return on.interpolate(y, S, g, "hcl")
                            }
                        case "interpolate-lab":
                            switch (this.type.kind) {
                            case "color":
                                return Jr.interpolate(y, S, g, "lab");
                            case "colorArray":
                                return on.interpolate(y, S, g, "lab")
                            }
                        }
                    }
                    eachChild(t) {
                        t(this.input);
                        for (const i of this.outputs)
                            t(i)
                    }
                    outputDefined() {
                        return this.outputs.every(t => t.outputDefined())
                    }
                }
                function zs(n, t, i, a) {
                    const u = a - i
                      , p = n - i;
                    return u === 0 ? 0 : t === 1 ? p / u : (Math.pow(t, p) - 1) / (Math.pow(t, u) - 1)
                }
                const ta = {
                    color: Jr.interpolate,
                    number: jn,
                    padding: Li.interpolate,
                    numberArray: sn.interpolate,
                    colorArray: on.interpolate,
                    variableAnchorOffsetCollection: ai.interpolate,
                    array: ea
                };
                class Zn {
                    constructor(t, i) {
                        this.type = t,
                        this.args = i
                    }
                    static parse(t, i) {
                        if (t.length < 2)
                            return i.error("Expected at least one argument.");
                        let a = null;
                        const u = i.expectedType;
                        u && u.kind !== "value" && (a = u);
                        const p = [];
                        for (const g of t.slice(1)) {
                            const y = i.parse(g, 1 + p.length, a, void 0, {
                                typeAnnotation: "omit"
                            });
                            if (!y)
                                return null;
                            a = a || y.type,
                            p.push(y)
                        }
                        if (!a)
                            throw new Error("No output type");
                        const f = u && p.some(g => Ii(u, g.type));
                        return new Zn(f ? fr : a,p)
                    }
                    evaluate(t) {
                        let i, a = null, u = 0;
                        for (const p of this.args)
                            if (u++,
                            a = p.evaluate(t),
                            a && a instanceof qn && !a.available && (i || (i = a.name),
                            a = null,
                            u === this.args.length && (a = i)),
                            a !== null)
                                break;
                        return a
                    }
                    eachChild(t) {
                        this.args.forEach(t)
                    }
                    outputDefined() {
                        return this.args.every(t => t.outputDefined())
                    }
                }
                function mc(n, t) {
                    return n === "==" || n === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value"
                }
                function _o(n, t, i, a) {
                    return a.compare(t, i) === 0
                }
                function Ls(n, t, i) {
                    const a = n !== "==" && n !== "!=";
                    return class hv {
                        constructor(p, f, g) {
                            this.type = pr,
                            this.lhs = p,
                            this.rhs = f,
                            this.collator = g,
                            this.hasUntypedArgument = p.type.kind === "value" || f.type.kind === "value"
                        }
                        static parse(p, f) {
                            if (p.length !== 3 && p.length !== 4)
                                return f.error("Expected two or three arguments.");
                            const g = p[0];
                            let y = f.parse(p[1], 1, fr);
                            if (!y)
                                return null;
                            if (!mc(g, y.type))
                                return f.concat(1).error(`"${g}" comparisons are not supported for type '${Ht(y.type)}'.`);
                            let S = f.parse(p[2], 2, fr);
                            if (!S)
                                return null;
                            if (!mc(g, S.type))
                                return f.concat(2).error(`"${g}" comparisons are not supported for type '${Ht(S.type)}'.`);
                            if (y.type.kind !== S.type.kind && y.type.kind !== "value" && S.type.kind !== "value")
                                return f.error(`Cannot compare types '${Ht(y.type)}' and '${Ht(S.type)}'.`);
                            a && (y.type.kind === "value" && S.type.kind !== "value" ? y = new Vn(S.type,[y]) : y.type.kind !== "value" && S.type.kind === "value" && (S = new Vn(y.type,[S])));
                            let I = null;
                            if (p.length === 4) {
                                if (y.type.kind !== "string" && S.type.kind !== "string" && y.type.kind !== "value" && S.type.kind !== "value")
                                    return f.error("Cannot use collator to compare non-string types.");
                                if (I = f.parse(p[3], 3, $i),
                                !I)
                                    return null
                            }
                            return new hv(y,S,I)
                        }
                        evaluate(p) {
                            const f = this.lhs.evaluate(p)
                              , g = this.rhs.evaluate(p);
                            if (a && this.hasUntypedArgument) {
                                const y = qr(f)
                                  , S = qr(g);
                                if (y.kind !== S.kind || y.kind !== "string" && y.kind !== "number")
                                    throw new Di(`Expected arguments for "${n}" to be (string, string) or (number, number), but found (${y.kind}, ${S.kind}) instead.`)
                            }
                            if (this.collator && !a && this.hasUntypedArgument) {
                                const y = qr(f)
                                  , S = qr(g);
                                if (y.kind !== "string" || S.kind !== "string")
                                    return t(p, f, g)
                            }
                            return this.collator ? i(p, f, g, this.collator.evaluate(p)) : t(p, f, g)
                        }
                        eachChild(p) {
                            p(this.lhs),
                            p(this.rhs),
                            this.collator && p(this.collator)
                        }
                        outputDefined() {
                            return !0
                        }
                    }
                }
                const _c = Ls("==", function(n, t, i) {
                    return t === i
                }, _o)
                  , Kd = Ls("!=", function(n, t, i) {
                    return t !== i
                }, function(n, t, i, a) {
                    return !_o(0, t, i, a)
                })
                  , Yd = Ls("<", function(n, t, i) {
                    return t < i
                }, function(n, t, i, a) {
                    return a.compare(t, i) < 0
                })
                  , Jd = Ls(">", function(n, t, i) {
                    return t > i
                }, function(n, t, i, a) {
                    return a.compare(t, i) > 0
                })
                  , Qd = Ls("<=", function(n, t, i) {
                    return t <= i
                }, function(n, t, i, a) {
                    return a.compare(t, i) <= 0
                })
                  , rl = Ls(">=", function(n, t, i) {
                    return t >= i
                }, function(n, t, i, a) {
                    return a.compare(t, i) >= 0
                });
                class il {
                    constructor(t, i, a) {
                        this.type = $i,
                        this.locale = a,
                        this.caseSensitive = t,
                        this.diacriticSensitive = i
                    }
                    static parse(t, i) {
                        if (t.length !== 2)
                            return i.error("Expected one argument.");
                        const a = t[1];
                        if (typeof a != "object" || Array.isArray(a))
                            return i.error("Collator options argument must be an object.");
                        const u = i.parse(a["case-sensitive"] !== void 0 && a["case-sensitive"], 1, pr);
                        if (!u)
                            return null;
                        const p = i.parse(a["diacritic-sensitive"] !== void 0 && a["diacritic-sensitive"], 1, pr);
                        if (!p)
                            return null;
                        let f = null;
                        return a.locale && (f = i.parse(a.locale, 1, yr),
                        !f) ? null : new il(u,p,f)
                    }
                    evaluate(t) {
                        return new Ua(this.caseSensitive.evaluate(t),this.diacriticSensitive.evaluate(t),this.locale ? this.locale.evaluate(t) : null)
                    }
                    eachChild(t) {
                        t(this.caseSensitive),
                        t(this.diacriticSensitive),
                        this.locale && t(this.locale)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class nl {
                    constructor(t, i, a, u, p) {
                        this.type = yr,
                        this.number = t,
                        this.locale = i,
                        this.currency = a,
                        this.minFractionDigits = u,
                        this.maxFractionDigits = p
                    }
                    static parse(t, i) {
                        if (t.length !== 3)
                            return i.error("Expected two arguments.");
                        const a = i.parse(t[1], 1, St);
                        if (!a)
                            return null;
                        const u = t[2];
                        if (typeof u != "object" || Array.isArray(u))
                            return i.error("NumberFormat options argument must be an object.");
                        let p = null;
                        if (u.locale && (p = i.parse(u.locale, 1, yr),
                        !p))
                            return null;
                        let f = null;
                        if (u.currency && (f = i.parse(u.currency, 1, yr),
                        !f))
                            return null;
                        let g = null;
                        if (u["min-fraction-digits"] && (g = i.parse(u["min-fraction-digits"], 1, St),
                        !g))
                            return null;
                        let y = null;
                        return u["max-fraction-digits"] && (y = i.parse(u["max-fraction-digits"], 1, St),
                        !y) ? null : new nl(a,p,f,g,y)
                    }
                    evaluate(t) {
                        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [],{
                            style: this.currency ? "currency" : "decimal",
                            currency: this.currency ? this.currency.evaluate(t) : void 0,
                            minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
                            maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
                        }).format(this.number.evaluate(t))
                    }
                    eachChild(t) {
                        t(this.number),
                        this.locale && t(this.locale),
                        this.currency && t(this.currency),
                        this.minFractionDigits && t(this.minFractionDigits),
                        this.maxFractionDigits && t(this.maxFractionDigits)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class go {
                    constructor(t) {
                        this.type = On,
                        this.sections = t
                    }
                    static parse(t, i) {
                        if (t.length < 2)
                            return i.error("Expected at least one argument.");
                        const a = t[1];
                        if (!Array.isArray(a) && typeof a == "object")
                            return i.error("First argument must be an image or text section.");
                        const u = [];
                        let p = !1;
                        for (let f = 1; f <= t.length - 1; ++f) {
                            const g = t[f];
                            if (p && typeof g == "object" && !Array.isArray(g)) {
                                p = !1;
                                let y = null;
                                if (g["font-scale"] && (y = i.parse(g["font-scale"], 1, St),
                                !y))
                                    return null;
                                let S = null;
                                if (g["text-font"] && (S = i.parse(g["text-font"], 1, Ot(yr)),
                                !S))
                                    return null;
                                let I = null;
                                if (g["text-color"] && (I = i.parse(g["text-color"], 1, hi),
                                !I))
                                    return null;
                                let A = null;
                                if (g["vertical-align"]) {
                                    if (typeof g["vertical-align"] == "string" && !Da.includes(g["vertical-align"]))
                                        return i.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${g["vertical-align"]}' instead.`);
                                    if (A = i.parse(g["vertical-align"], 1, yr),
                                    !A)
                                        return null
                                }
                                const R = u[u.length - 1];
                                R.scale = y,
                                R.font = S,
                                R.textColor = I,
                                R.verticalAlign = A
                            } else {
                                const y = i.parse(t[f], 1, fr);
                                if (!y)
                                    return null;
                                const S = y.type.kind;
                                if (S !== "string" && S !== "value" && S !== "null" && S !== "resolvedImage")
                                    return i.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                                p = !0,
                                u.push({
                                    content: y,
                                    scale: null,
                                    font: null,
                                    textColor: null,
                                    verticalAlign: null
                                })
                            }
                        }
                        return new go(u)
                    }
                    evaluate(t) {
                        return new Gi(this.sections.map(i => {
                            const a = i.content.evaluate(t);
                            return qr(a) === Nn ? new co("",a,null,null,null,i.verticalAlign ? i.verticalAlign.evaluate(t) : null) : new co(cs(a),null,i.scale ? i.scale.evaluate(t) : null,i.font ? i.font.evaluate(t).join(",") : null,i.textColor ? i.textColor.evaluate(t) : null,i.verticalAlign ? i.verticalAlign.evaluate(t) : null)
                        }
                        ))
                    }
                    eachChild(t) {
                        for (const i of this.sections)
                            t(i.content),
                            i.scale && t(i.scale),
                            i.font && t(i.font),
                            i.textColor && t(i.textColor),
                            i.verticalAlign && t(i.verticalAlign)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class gc {
                    constructor(t) {
                        this.type = Nn,
                        this.input = t
                    }
                    static parse(t, i) {
                        if (t.length !== 2)
                            return i.error("Expected two arguments.");
                        const a = i.parse(t[1], 1, yr);
                        return a ? new gc(a) : i.error("No image name provided.")
                    }
                    evaluate(t) {
                        const i = this.input.evaluate(t)
                          , a = qn.fromString(i);
                        return a && t.availableImages && (a.available = t.availableImages.indexOf(i) > -1),
                        a
                    }
                    eachChild(t) {
                        t(this.input)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class al {
                    constructor(t) {
                        this.type = St,
                        this.input = t
                    }
                    static parse(t, i) {
                        if (t.length !== 2)
                            return i.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
                        const a = i.parse(t[1], 1);
                        return a ? a.type.kind !== "array" && a.type.kind !== "string" && a.type.kind !== "value" ? i.error(`Expected argument of type string or array, but found ${Ht(a.type)} instead.`) : new al(a) : null
                    }
                    evaluate(t) {
                        const i = this.input.evaluate(t);
                        if (typeof i == "string")
                            return [...i].length;
                        if (Array.isArray(i))
                            return i.length;
                        throw new Di(`Expected value to be of type string or array, but found ${Ht(qr(i))} instead.`)
                    }
                    eachChild(t) {
                        t(this.input)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                const Sa = 8192;
                function ep(n, t) {
                    const i = (180 + n[0]) / 360
                      , a = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n[1] * Math.PI / 360))) / 360
                      , u = Math.pow(2, t.z);
                    return [Math.round(i * u * Sa), Math.round(a * u * Sa)]
                }
                function vc(n, t) {
                    const i = Math.pow(2, t.z);
                    return [(u = (n[0] / Sa + t.x) / i,
                    360 * u - 180), (a = (n[1] / Sa + t.y) / i,
                    360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90)];
                    var a, u
                }
                function vo(n, t) {
                    n[0] = Math.min(n[0], t[0]),
                    n[1] = Math.min(n[1], t[1]),
                    n[2] = Math.max(n[2], t[0]),
                    n[3] = Math.max(n[3], t[1])
                }
                function yo(n, t) {
                    return !(n[0] <= t[0] || n[2] >= t[2] || n[1] <= t[1] || n[3] >= t[3])
                }
                function yh(n, t, i) {
                    const a = n[0] - t[0]
                      , u = n[1] - t[1]
                      , p = n[0] - i[0]
                      , f = n[1] - i[1];
                    return a * f - p * u == 0 && a * p <= 0 && u * f <= 0
                }
                function xo(n, t, i, a) {
                    return (u = [a[0] - i[0], a[1] - i[1]])[0] * (p = [t[0] - n[0], t[1] - n[1]])[1] - u[1] * p[0] != 0 && !(!sl(n, t, i, a) || !sl(i, a, n, t));
                    var u, p
                }
                function xh(n, t, i) {
                    for (const a of i)
                        for (let u = 0; u < a.length - 1; ++u)
                            if (xo(n, t, a[u], a[u + 1]))
                                return !0;
                    return !1
                }
                function Ds(n, t, i=!1) {
                    let a = !1;
                    for (const g of t)
                        for (let y = 0; y < g.length - 1; y++) {
                            if (yh(n, g[y], g[y + 1]))
                                return i;
                            (p = g[y])[1] > (u = n)[1] != (f = g[y + 1])[1] > u[1] && u[0] < (f[0] - p[0]) * (u[1] - p[1]) / (f[1] - p[1]) + p[0] && (a = !a)
                        }
                    var u, p, f;
                    return a
                }
                function tp(n, t) {
                    for (const i of t)
                        if (Ds(n, i))
                            return !0;
                    return !1
                }
                function bh(n, t) {
                    for (const i of n)
                        if (!Ds(i, t))
                            return !1;
                    for (let i = 0; i < n.length - 1; ++i)
                        if (xh(n[i], n[i + 1], t))
                            return !1;
                    return !0
                }
                function rp(n, t) {
                    for (const i of t)
                        if (bh(n, i))
                            return !0;
                    return !1
                }
                function sl(n, t, i, a) {
                    const u = a[0] - i[0]
                      , p = a[1] - i[1]
                      , f = (n[0] - i[0]) * p - u * (n[1] - i[1])
                      , g = (t[0] - i[0]) * p - u * (t[1] - i[1]);
                    return f > 0 && g < 0 || f < 0 && g > 0
                }
                function yc(n, t, i) {
                    const a = [];
                    for (let u = 0; u < n.length; u++) {
                        const p = [];
                        for (let f = 0; f < n[u].length; f++) {
                            const g = ep(n[u][f], i);
                            vo(t, g),
                            p.push(g)
                        }
                        a.push(p)
                    }
                    return a
                }
                function wh(n, t, i) {
                    const a = [];
                    for (let u = 0; u < n.length; u++) {
                        const p = yc(n[u], t, i);
                        a.push(p)
                    }
                    return a
                }
                function Th(n, t, i, a) {
                    if (n[0] < i[0] || n[0] > i[2]) {
                        const u = .5 * a;
                        let p = n[0] - i[0] > u ? -a : i[0] - n[0] > u ? a : 0;
                        p === 0 && (p = n[0] - i[2] > u ? -a : i[2] - n[0] > u ? a : 0),
                        n[0] += p
                    }
                    vo(t, n)
                }
                function xc(n, t, i, a) {
                    const u = Math.pow(2, a.z) * Sa
                      , p = [a.x * Sa, a.y * Sa]
                      , f = [];
                    for (const g of n)
                        for (const y of g) {
                            const S = [y.x + p[0], y.y + p[1]];
                            Th(S, t, i, u),
                            f.push(S)
                        }
                    return f
                }
                function bc(n, t, i, a) {
                    const u = Math.pow(2, a.z) * Sa
                      , p = [a.x * Sa, a.y * Sa]
                      , f = [];
                    for (const y of n) {
                        const S = [];
                        for (const I of y) {
                            const A = [I.x + p[0], I.y + p[1]];
                            vo(t, A),
                            S.push(A)
                        }
                        f.push(S)
                    }
                    if (t[2] - t[0] <= u / 2) {
                        (g = t)[0] = g[1] = 1 / 0,
                        g[2] = g[3] = -1 / 0;
                        for (const y of f)
                            for (const S of y)
                                Th(S, t, i, u)
                    }
                    var g;
                    return f
                }
                class us {
                    constructor(t, i) {
                        this.type = pr,
                        this.geojson = t,
                        this.geometries = i
                    }
                    static parse(t, i) {
                        if (t.length !== 2)
                            return i.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                        if (ls(t[1])) {
                            const a = t[1];
                            if (a.type === "FeatureCollection") {
                                const u = [];
                                for (const p of a.features) {
                                    const {type: f, coordinates: g} = p.geometry;
                                    f === "Polygon" && u.push(g),
                                    f === "MultiPolygon" && u.push(...g)
                                }
                                if (u.length)
                                    return new us(a,{
                                        type: "MultiPolygon",
                                        coordinates: u
                                    })
                            } else if (a.type === "Feature") {
                                const u = a.geometry.type;
                                if (u === "Polygon" || u === "MultiPolygon")
                                    return new us(a,a.geometry)
                            } else if (a.type === "Polygon" || a.type === "MultiPolygon")
                                return new us(a,a)
                        }
                        return i.error("'within' expression requires valid geojson object that contains polygon geometry type.")
                    }
                    evaluate(t) {
                        if (t.geometry() != null && t.canonicalID() != null) {
                            if (t.geometryType() === "Point")
                                return function(i, a) {
                                    const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , p = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , f = i.canonicalID();
                                    if (a.type === "Polygon") {
                                        const g = yc(a.coordinates, p, f)
                                          , y = xc(i.geometry(), u, p, f);
                                        if (!yo(u, p))
                                            return !1;
                                        for (const S of y)
                                            if (!Ds(S, g))
                                                return !1
                                    }
                                    if (a.type === "MultiPolygon") {
                                        const g = wh(a.coordinates, p, f)
                                          , y = xc(i.geometry(), u, p, f);
                                        if (!yo(u, p))
                                            return !1;
                                        for (const S of y)
                                            if (!tp(S, g))
                                                return !1
                                    }
                                    return !0
                                }(t, this.geometries);
                            if (t.geometryType() === "LineString")
                                return function(i, a) {
                                    const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , p = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , f = i.canonicalID();
                                    if (a.type === "Polygon") {
                                        const g = yc(a.coordinates, p, f)
                                          , y = bc(i.geometry(), u, p, f);
                                        if (!yo(u, p))
                                            return !1;
                                        for (const S of y)
                                            if (!bh(S, g))
                                                return !1
                                    }
                                    if (a.type === "MultiPolygon") {
                                        const g = wh(a.coordinates, p, f)
                                          , y = bc(i.geometry(), u, p, f);
                                        if (!yo(u, p))
                                            return !1;
                                        for (const S of y)
                                            if (!rp(S, g))
                                                return !1
                                    }
                                    return !0
                                }(t, this.geometries)
                        }
                        return !1
                    }
                    eachChild() {}
                    outputDefined() {
                        return !0
                    }
                }
                let Ch = class {
                    constructor(n=[], t= (i, a) => i < a ? -1 : i > a ? 1 : 0) {
                        if (this.data = n,
                        this.length = this.data.length,
                        this.compare = t,
                        this.length > 0)
                            for (let i = (this.length >> 1) - 1; i >= 0; i--)
                                this._down(i)
                    }
                    push(n) {
                        this.data.push(n),
                        this._up(this.length++)
                    }
                    pop() {
                        if (this.length === 0)
                            return;
                        const n = this.data[0]
                          , t = this.data.pop();
                        return --this.length > 0 && (this.data[0] = t,
                        this._down(0)),
                        n
                    }
                    peek() {
                        return this.data[0]
                    }
                    _up(n) {
                        const {data: t, compare: i} = this
                          , a = t[n];
                        for (; n > 0; ) {
                            const u = n - 1 >> 1
                              , p = t[u];
                            if (i(a, p) >= 0)
                                break;
                            t[n] = p,
                            n = u
                        }
                        t[n] = a
                    }
                    _down(n) {
                        const {data: t, compare: i} = this
                          , a = this.length >> 1
                          , u = t[n];
                        for (; n < a; ) {
                            let p = 1 + (n << 1);
                            const f = p + 1;
                            if (f < this.length && i(t[f], t[p]) < 0 && (p = f),
                            i(t[p], u) >= 0)
                                break;
                            t[n] = t[p],
                            n = p
                        }
                        t[n] = u
                    }
                }
                ;
                function wc(n, t, i=0, a=n.length - 1, u=ip) {
                    for (; a > i; ) {
                        if (a - i > 600) {
                            const y = a - i + 1
                              , S = t - i + 1
                              , I = Math.log(y)
                              , A = .5 * Math.exp(2 * I / 3)
                              , R = .5 * Math.sqrt(I * A * (y - A) / y) * (S - y / 2 < 0 ? -1 : 1);
                            wc(n, t, Math.max(i, Math.floor(t - S * A / y + R)), Math.min(a, Math.floor(t + (y - S) * A / y + R)), u)
                        }
                        const p = n[t];
                        let f = i
                          , g = a;
                        for (Rs(n, i, t),
                        u(n[a], p) > 0 && Rs(n, i, a); f < g; ) {
                            for (Rs(n, f, g),
                            f++,
                            g--; u(n[f], p) < 0; )
                                f++;
                            for (; u(n[g], p) > 0; )
                                g--
                        }
                        u(n[i], p) === 0 ? Rs(n, i, g) : (g++,
                        Rs(n, g, a)),
                        g <= t && (i = g + 1),
                        t <= g && (a = g - 1)
                    }
                }
                function Rs(n, t, i) {
                    const a = n[t];
                    n[t] = n[i],
                    n[i] = a
                }
                function ip(n, t) {
                    return n < t ? -1 : n > t ? 1 : 0
                }
                function ol(n, t) {
                    if (n.length <= 1)
                        return [n];
                    const i = [];
                    let a, u;
                    for (const p of n) {
                        const f = Sh(p);
                        f !== 0 && (p.area = Math.abs(f),
                        u === void 0 && (u = f < 0),
                        u === f < 0 ? (a && i.push(a),
                        a = [p]) : a.push(p))
                    }
                    if (a && i.push(a),
                    t > 1)
                        for (let p = 0; p < i.length; p++)
                            i[p].length <= t || (wc(i[p], t, 1, i[p].length - 1, np),
                            i[p] = i[p].slice(0, t));
                    return i
                }
                function np(n, t) {
                    return t.area - n.area
                }
                function Sh(n) {
                    let t = 0;
                    for (let i, a, u = 0, p = n.length, f = p - 1; u < p; f = u++)
                        i = n[u],
                        a = n[f],
                        t += (a.x - i.x) * (i.y + a.y);
                    return t
                }
                const Ph = 1 / 298.257223563
                  , Ih = Ph * (2 - Ph)
                  , Mh = Math.PI / 180;
                class Tc {
                    constructor(t) {
                        const i = 6378.137 * Mh * 1e3
                          , a = Math.cos(t * Mh)
                          , u = 1 / (1 - Ih * (1 - a * a))
                          , p = Math.sqrt(u);
                        this.kx = i * p * a,
                        this.ky = i * p * u * (1 - Ih)
                    }
                    distance(t, i) {
                        const a = this.wrap(t[0] - i[0]) * this.kx
                          , u = (t[1] - i[1]) * this.ky;
                        return Math.sqrt(a * a + u * u)
                    }
                    pointOnLine(t, i) {
                        let a, u, p, f, g = 1 / 0;
                        for (let y = 0; y < t.length - 1; y++) {
                            let S = t[y][0]
                              , I = t[y][1]
                              , A = this.wrap(t[y + 1][0] - S) * this.kx
                              , R = (t[y + 1][1] - I) * this.ky
                              , N = 0;
                            A === 0 && R === 0 || (N = (this.wrap(i[0] - S) * this.kx * A + (i[1] - I) * this.ky * R) / (A * A + R * R),
                            N > 1 ? (S = t[y + 1][0],
                            I = t[y + 1][1]) : N > 0 && (S += A / this.kx * N,
                            I += R / this.ky * N)),
                            A = this.wrap(i[0] - S) * this.kx,
                            R = (i[1] - I) * this.ky;
                            const j = A * A + R * R;
                            j < g && (g = j,
                            a = S,
                            u = I,
                            p = y,
                            f = N)
                        }
                        return {
                            point: [a, u],
                            index: p,
                            t: Math.max(0, Math.min(1, f))
                        }
                    }
                    wrap(t) {
                        for (; t < -180; )
                            t += 360;
                        for (; t > 180; )
                            t -= 360;
                        return t
                    }
                }
                function pi(n, t) {
                    return t[0] - n[0]
                }
                function ll(n) {
                    return n[1] - n[0] + 1
                }
                function Ra(n, t) {
                    return n[1] >= n[0] && n[1] < t
                }
                function Cc(n, t) {
                    if (n[0] > n[1])
                        return [null, null];
                    const i = ll(n);
                    if (t) {
                        if (i === 2)
                            return [n, null];
                        const u = Math.floor(i / 2);
                        return [[n[0], n[0] + u], [n[0] + u, n[1]]]
                    }
                    if (i === 1)
                        return [n, null];
                    const a = Math.floor(i / 2) - 1;
                    return [[n[0], n[0] + a], [n[0] + a + 1, n[1]]]
                }
                function Sc(n, t) {
                    if (!Ra(t, n.length))
                        return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    for (let a = t[0]; a <= t[1]; ++a)
                        vo(i, n[a]);
                    return i
                }
                function Pc(n) {
                    const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    for (const i of n)
                        for (const a of i)
                            vo(t, a);
                    return t
                }
                function Ah(n) {
                    return n[0] !== -1 / 0 && n[1] !== -1 / 0 && n[2] !== 1 / 0 && n[3] !== 1 / 0
                }
                function Ic(n, t, i) {
                    if (!Ah(n) || !Ah(t))
                        return NaN;
                    let a = 0
                      , u = 0;
                    return n[2] < t[0] && (a = t[0] - n[2]),
                    n[0] > t[2] && (a = n[0] - t[2]),
                    n[1] > t[3] && (u = n[1] - t[3]),
                    n[3] < t[1] && (u = t[1] - n[3]),
                    i.distance([0, 0], [a, u])
                }
                function hs(n, t, i) {
                    const a = i.pointOnLine(t, n);
                    return i.distance(n, a.point)
                }
                function Mc(n, t, i, a, u) {
                    const p = Math.min(hs(n, [i, a], u), hs(t, [i, a], u))
                      , f = Math.min(hs(i, [n, t], u), hs(a, [n, t], u));
                    return Math.min(p, f)
                }
                function ap(n, t, i, a, u) {
                    if (!Ra(t, n.length) || !Ra(a, i.length))
                        return 1 / 0;
                    let p = 1 / 0;
                    for (let f = t[0]; f < t[1]; ++f) {
                        const g = n[f]
                          , y = n[f + 1];
                        for (let S = a[0]; S < a[1]; ++S) {
                            const I = i[S]
                              , A = i[S + 1];
                            if (xo(g, y, I, A))
                                return 0;
                            p = Math.min(p, Mc(g, y, I, A, u))
                        }
                    }
                    return p
                }
                function sp(n, t, i, a, u) {
                    if (!Ra(t, n.length) || !Ra(a, i.length))
                        return NaN;
                    let p = 1 / 0;
                    for (let f = t[0]; f <= t[1]; ++f)
                        for (let g = a[0]; g <= a[1]; ++g)
                            if (p = Math.min(p, u.distance(n[f], i[g])),
                            p === 0)
                                return p;
                    return p
                }
                function op(n, t, i) {
                    if (Ds(n, t, !0))
                        return 0;
                    let a = 1 / 0;
                    for (const u of t) {
                        const p = u[0]
                          , f = u[u.length - 1];
                        if (p !== f && (a = Math.min(a, hs(n, [f, p], i)),
                        a === 0))
                            return a;
                        const g = i.pointOnLine(u, n);
                        if (a = Math.min(a, i.distance(n, g.point)),
                        a === 0)
                            return a
                    }
                    return a
                }
                function lp(n, t, i, a) {
                    if (!Ra(t, n.length))
                        return NaN;
                    for (let p = t[0]; p <= t[1]; ++p)
                        if (Ds(n[p], i, !0))
                            return 0;
                    let u = 1 / 0;
                    for (let p = t[0]; p < t[1]; ++p) {
                        const f = n[p]
                          , g = n[p + 1];
                        for (const y of i)
                            for (let S = 0, I = y.length, A = I - 1; S < I; A = S++) {
                                const R = y[A]
                                  , N = y[S];
                                if (xo(f, g, R, N))
                                    return 0;
                                u = Math.min(u, Mc(f, g, R, N, a))
                            }
                    }
                    return u
                }
                function kh(n, t) {
                    for (const i of n)
                        for (const a of i)
                            if (Ds(a, t, !0))
                                return !0;
                    return !1
                }
                function cp(n, t, i, a=1 / 0) {
                    const u = Pc(n)
                      , p = Pc(t);
                    if (a !== 1 / 0 && Ic(u, p, i) >= a)
                        return a;
                    if (yo(u, p)) {
                        if (kh(n, t))
                            return 0
                    } else if (kh(t, n))
                        return 0;
                    let f = 1 / 0;
                    for (const g of n)
                        for (let y = 0, S = g.length, I = S - 1; y < S; I = y++) {
                            const A = g[I]
                              , R = g[y];
                            for (const N of t)
                                for (let j = 0, $ = N.length, J = $ - 1; j < $; J = j++) {
                                    const se = N[J]
                                      , Ae = N[j];
                                    if (xo(A, R, se, Ae))
                                        return 0;
                                    f = Math.min(f, Mc(A, R, se, Ae, i))
                                }
                        }
                    return f
                }
                function Eh(n, t, i, a, u, p) {
                    if (!p)
                        return;
                    const f = Ic(Sc(a, p), u, i);
                    f < t && n.push([f, p, [0, 0]])
                }
                function cl(n, t, i, a, u, p, f) {
                    if (!p || !f)
                        return;
                    const g = Ic(Sc(a, p), Sc(u, f), i);
                    g < t && n.push([g, p, f])
                }
                function ul(n, t, i, a, u=1 / 0) {
                    let p = Math.min(a.distance(n[0], i[0][0]), u);
                    if (p === 0)
                        return p;
                    const f = new Ch([[0, [0, n.length - 1], [0, 0]]],pi)
                      , g = Pc(i);
                    for (; f.length > 0; ) {
                        const y = f.pop();
                        if (y[0] >= p)
                            continue;
                        const S = y[1]
                          , I = t ? 50 : 100;
                        if (ll(S) <= I) {
                            if (!Ra(S, n.length))
                                return NaN;
                            if (t) {
                                const A = lp(n, S, i, a);
                                if (isNaN(A) || A === 0)
                                    return A;
                                p = Math.min(p, A)
                            } else
                                for (let A = S[0]; A <= S[1]; ++A) {
                                    const R = op(n[A], i, a);
                                    if (p = Math.min(p, R),
                                    p === 0)
                                        return 0
                                }
                        } else {
                            const A = Cc(S, t);
                            Eh(f, p, a, n, g, A[0]),
                            Eh(f, p, a, n, g, A[1])
                        }
                    }
                    return p
                }
                function hl(n, t, i, a, u, p=1 / 0) {
                    let f = Math.min(p, u.distance(n[0], i[0]));
                    if (f === 0)
                        return f;
                    const g = new Ch([[0, [0, n.length - 1], [0, i.length - 1]]],pi);
                    for (; g.length > 0; ) {
                        const y = g.pop();
                        if (y[0] >= f)
                            continue;
                        const S = y[1]
                          , I = y[2]
                          , A = t ? 50 : 100
                          , R = a ? 50 : 100;
                        if (ll(S) <= A && ll(I) <= R) {
                            if (!Ra(S, n.length) && Ra(I, i.length))
                                return NaN;
                            let N;
                            if (t && a)
                                N = ap(n, S, i, I, u),
                                f = Math.min(f, N);
                            else if (t && !a) {
                                const j = n.slice(S[0], S[1] + 1);
                                for (let $ = I[0]; $ <= I[1]; ++$)
                                    if (N = hs(i[$], j, u),
                                    f = Math.min(f, N),
                                    f === 0)
                                        return f
                            } else if (!t && a) {
                                const j = i.slice(I[0], I[1] + 1);
                                for (let $ = S[0]; $ <= S[1]; ++$)
                                    if (N = hs(n[$], j, u),
                                    f = Math.min(f, N),
                                    f === 0)
                                        return f
                            } else
                                N = sp(n, S, i, I, u),
                                f = Math.min(f, N)
                        } else {
                            const N = Cc(S, t)
                              , j = Cc(I, a);
                            cl(g, f, u, n, i, N[0], j[0]),
                            cl(g, f, u, n, i, N[0], j[1]),
                            cl(g, f, u, n, i, N[1], j[0]),
                            cl(g, f, u, n, i, N[1], j[1])
                        }
                    }
                    return f
                }
                function Ac(n) {
                    return n.type === "MultiPolygon" ? n.coordinates.map(t => ({
                        type: "Polygon",
                        coordinates: t
                    })) : n.type === "MultiLineString" ? n.coordinates.map(t => ({
                        type: "LineString",
                        coordinates: t
                    })) : n.type === "MultiPoint" ? n.coordinates.map(t => ({
                        type: "Point",
                        coordinates: t
                    })) : [n]
                }
                class ds {
                    constructor(t, i) {
                        this.type = St,
                        this.geojson = t,
                        this.geometries = i
                    }
                    static parse(t, i) {
                        if (t.length !== 2)
                            return i.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                        if (ls(t[1])) {
                            const a = t[1];
                            if (a.type === "FeatureCollection")
                                return new ds(a,a.features.map(u => Ac(u.geometry)).flat());
                            if (a.type === "Feature")
                                return new ds(a,Ac(a.geometry));
                            if ("type"in a && "coordinates"in a)
                                return new ds(a,Ac(a))
                        }
                        return i.error("'distance' expression requires valid geojson object that contains polygon geometry type.")
                    }
                    evaluate(t) {
                        if (t.geometry() != null && t.canonicalID() != null) {
                            if (t.geometryType() === "Point")
                                return function(i, a) {
                                    const u = i.geometry()
                                      , p = u.flat().map(y => vc([y.x, y.y], i.canonical));
                                    if (u.length === 0)
                                        return NaN;
                                    const f = new Tc(p[0][1]);
                                    let g = 1 / 0;
                                    for (const y of a) {
                                        switch (y.type) {
                                        case "Point":
                                            g = Math.min(g, hl(p, !1, [y.coordinates], !1, f, g));
                                            break;
                                        case "LineString":
                                            g = Math.min(g, hl(p, !1, y.coordinates, !0, f, g));
                                            break;
                                        case "Polygon":
                                            g = Math.min(g, ul(p, !1, y.coordinates, f, g))
                                        }
                                        if (g === 0)
                                            return g
                                    }
                                    return g
                                }(t, this.geometries);
                            if (t.geometryType() === "LineString")
                                return function(i, a) {
                                    const u = i.geometry()
                                      , p = u.flat().map(y => vc([y.x, y.y], i.canonical));
                                    if (u.length === 0)
                                        return NaN;
                                    const f = new Tc(p[0][1]);
                                    let g = 1 / 0;
                                    for (const y of a) {
                                        switch (y.type) {
                                        case "Point":
                                            g = Math.min(g, hl(p, !0, [y.coordinates], !1, f, g));
                                            break;
                                        case "LineString":
                                            g = Math.min(g, hl(p, !0, y.coordinates, !0, f, g));
                                            break;
                                        case "Polygon":
                                            g = Math.min(g, ul(p, !0, y.coordinates, f, g))
                                        }
                                        if (g === 0)
                                            return g
                                    }
                                    return g
                                }(t, this.geometries);
                            if (t.geometryType() === "Polygon")
                                return function(i, a) {
                                    const u = i.geometry();
                                    if (u.length === 0 || u[0].length === 0)
                                        return NaN;
                                    const p = ol(u, 0).map(y => y.map(S => S.map(I => vc([I.x, I.y], i.canonical))))
                                      , f = new Tc(p[0][0][0][1]);
                                    let g = 1 / 0;
                                    for (const y of a)
                                        for (const S of p) {
                                            switch (y.type) {
                                            case "Point":
                                                g = Math.min(g, ul([y.coordinates], !1, S, f, g));
                                                break;
                                            case "LineString":
                                                g = Math.min(g, ul(y.coordinates, !0, S, f, g));
                                                break;
                                            case "Polygon":
                                                g = Math.min(g, cp(S, y.coordinates, f, g))
                                            }
                                            if (g === 0)
                                                return g
                                        }
                                    return g
                                }(t, this.geometries)
                        }
                        return NaN
                    }
                    eachChild() {}
                    outputDefined() {
                        return !0
                    }
                }
                class bo {
                    constructor(t) {
                        this.type = fr,
                        this.key = t
                    }
                    static parse(t, i) {
                        if (t.length !== 2)
                            return i.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
                        const a = t[1];
                        return a == null ? i.error("Global state property must be defined.") : typeof a != "string" ? i.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new bo(a)
                    }
                    evaluate(t) {
                        var i;
                        const a = (i = t.globals) === null || i === void 0 ? void 0 : i.globalState;
                        return a && Object.keys(a).length !== 0 ? Wr(a, this.key) : null
                    }
                    eachChild() {}
                    outputDefined() {
                        return !1
                    }
                }
                const Bs = {
                    "==": _c,
                    "!=": Kd,
                    ">": Jd,
                    "<": Yd,
                    ">=": rl,
                    "<=": Qd,
                    array: Vn,
                    at: ln,
                    boolean: Vn,
                    case: Yi,
                    coalesce: Zn,
                    collator: il,
                    format: go,
                    image: gc,
                    in: Ms,
                    "index-of": po,
                    interpolate: En,
                    "interpolate-hcl": En,
                    "interpolate-lab": En,
                    length: al,
                    let: ho,
                    literal: kn,
                    match: As,
                    number: Vn,
                    "number-format": nl,
                    object: Vn,
                    slice: fo,
                    step: Es,
                    string: Vn,
                    "to-boolean": Ca,
                    "to-color": Ca,
                    "to-number": Ca,
                    "to-string": Ca,
                    var: pa,
                    within: us,
                    distance: ds,
                    "global-state": bo
                };
                class oa {
                    constructor(t, i, a, u) {
                        this.name = t,
                        this.type = i,
                        this._evaluate = a,
                        this.args = u
                    }
                    evaluate(t) {
                        return this._evaluate(t, this.args)
                    }
                    eachChild(t) {
                        this.args.forEach(t)
                    }
                    outputDefined() {
                        return !1
                    }
                    static parse(t, i) {
                        const a = t[0]
                          , u = oa.definitions[a];
                        if (!u)
                            return i.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0);
                        const p = Array.isArray(u) ? u[0] : u.type
                          , f = Array.isArray(u) ? [[u[1], u[2]]] : u.overloads
                          , g = f.filter( ([S]) => !Array.isArray(S) || S.length === t.length - 1);
                        let y = null;
                        for (const [S,I] of g) {
                            y = new uo(i.registry,dl,i.path,null,i.scope);
                            const A = [];
                            let R = !1;
                            for (let N = 1; N < t.length; N++) {
                                const j = t[N]
                                  , $ = Array.isArray(S) ? S[N - 1] : S.type
                                  , J = y.parse(j, 1 + A.length, $);
                                if (!J) {
                                    R = !0;
                                    break
                                }
                                A.push(J)
                            }
                            if (!R)
                                if (Array.isArray(S) && S.length !== A.length)
                                    y.error(`Expected ${S.length} arguments, but found ${A.length} instead.`);
                                else {
                                    for (let N = 0; N < A.length; N++) {
                                        const j = Array.isArray(S) ? S[N] : S.type
                                          , $ = A[N];
                                        y.concat(N + 1).checkSubtype(j, $.type)
                                    }
                                    if (y.errors.length === 0)
                                        return new oa(a,p,I,A)
                                }
                        }
                        if (g.length === 1)
                            i.errors.push(...y.errors);
                        else {
                            const S = (g.length ? g : f).map( ([A]) => {
                                return R = A,
                                Array.isArray(R) ? `(${R.map(Ht).join(", ")})` : `(${Ht(R.type)}...)`;
                                var R
                            }
                            ).join(" | ")
                              , I = [];
                            for (let A = 1; A < t.length; A++) {
                                const R = i.parse(t[A], 1 + I.length);
                                if (!R)
                                    return null;
                                I.push(Ht(R.type))
                            }
                            i.error(`Expected arguments of type ${S}, but found (${I.join(", ")}) instead.`)
                        }
                        return null
                    }
                    static register(t, i) {
                        oa.definitions = i;
                        for (const a in i)
                            t[a] = oa
                    }
                }
                function zh(n, [t,i,a,u]) {
                    t = t.evaluate(n),
                    i = i.evaluate(n),
                    a = a.evaluate(n);
                    const p = u ? u.evaluate(n) : 1
                      , f = Xr(t, i, a, p);
                    if (f)
                        throw new Di(f);
                    return new Jr(t / 255,i / 255,a / 255,p,!1)
                }
                function Lh(n, t) {
                    return n in t
                }
                function kc(n, t) {
                    const i = t[n];
                    return i === void 0 ? null : i
                }
                function ps(n) {
                    return {
                        type: n
                    }
                }
                function dl(n) {
                    if (n instanceof pa)
                        return dl(n.boundExpression);
                    if (n instanceof oa && n.name === "error" || n instanceof il || n instanceof us || n instanceof ds || n instanceof bo)
                        return !1;
                    const t = n instanceof Ca || n instanceof Vn;
                    let i = !0;
                    return n.eachChild(a => {
                        i = t ? i && dl(a) : i && a instanceof kn
                    }
                    ),
                    !!i && pl(n) && Fs(n, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"])
                }
                function pl(n) {
                    if (n instanceof oa && (n.name === "get" && n.args.length === 1 || n.name === "feature-state" || n.name === "has" && n.args.length === 1 || n.name === "properties" || n.name === "geometry-type" || n.name === "id" || /^filter-/.test(n.name)) || n instanceof us || n instanceof ds)
                        return !1;
                    let t = !0;
                    return n.eachChild(i => {
                        t && !pl(i) && (t = !1)
                    }
                    ),
                    t
                }
                function wo(n) {
                    if (n instanceof oa && n.name === "feature-state")
                        return !1;
                    let t = !0;
                    return n.eachChild(i => {
                        t && !wo(i) && (t = !1)
                    }
                    ),
                    t
                }
                function Fs(n, t) {
                    if (n instanceof oa && t.indexOf(n.name) >= 0)
                        return !1;
                    let i = !0;
                    return n.eachChild(a => {
                        i && !Fs(a, t) && (i = !1)
                    }
                    ),
                    i
                }
                function Dh(n) {
                    return {
                        result: "success",
                        value: n
                    }
                }
                function Os(n) {
                    return {
                        result: "error",
                        value: n
                    }
                }
                function Ns(n) {
                    return n["property-type"] === "data-driven" || n["property-type"] === "cross-faded-data-driven"
                }
                function Ec(n) {
                    return !!n.expression && n.expression.parameters.indexOf("zoom") > -1
                }
                function zc(n) {
                    return !!n.expression && n.expression.interpolated
                }
                function ei(n) {
                    return n instanceof Number ? "number" : n instanceof String ? "string" : n instanceof Boolean ? "boolean" : Array.isArray(n) ? "array" : n === null ? "null" : typeof n
                }
                function fs(n) {
                    return typeof n == "object" && n !== null && !Array.isArray(n) && qr(n) === si
                }
                function Rh(n) {
                    return n
                }
                function Bh(n, t) {
                    const i = n.stops && typeof n.stops[0][0] == "object"
                      , a = i || !(i || n.property !== void 0)
                      , u = n.type || (zc(t) ? "exponential" : "interval")
                      , p = function(I) {
                        switch (I.type) {
                        case "color":
                            return Jr.parse;
                        case "padding":
                            return Li.parse;
                        case "numberArray":
                            return sn.parse;
                        case "colorArray":
                            return on.parse;
                        default:
                            return null
                        }
                    }(t);
                    if (p && ((n = Br({}, n)).stops && (n.stops = n.stops.map(I => [I[0], p(I[1])])),
                    n.default = p(n.default ? n.default : t.default)),
                    n.colorSpace && (f = n.colorSpace) !== "rgb" && f !== "hcl" && f !== "lab")
                        throw new Error(`Unknown color space: "${n.colorSpace}"`);
                    var f;
                    const g = function(I) {
                        switch (I) {
                        case "exponential":
                            return Fh;
                        case "interval":
                            return hp;
                        case "categorical":
                            return up;
                        case "identity":
                            return Oh;
                        default:
                            throw new Error(`Unknown function type "${I}"`)
                        }
                    }(u);
                    let y, S;
                    if (u === "categorical") {
                        y = Object.create(null);
                        for (const I of n.stops)
                            y[I[0]] = I[1];
                        S = typeof n.stops[0][0]
                    }
                    if (i) {
                        const I = {}
                          , A = [];
                        for (let j = 0; j < n.stops.length; j++) {
                            const $ = n.stops[j]
                              , J = $[0].zoom;
                            I[J] === void 0 && (I[J] = {
                                zoom: J,
                                type: n.type,
                                property: n.property,
                                default: n.default,
                                stops: []
                            },
                            A.push(J)),
                            I[J].stops.push([$[0].value, $[1]])
                        }
                        const R = [];
                        for (const j of A)
                            R.push([I[j].zoom, Bh(I[j], t)]);
                        const N = {
                            name: "linear"
                        };
                        return {
                            kind: "composite",
                            interpolationType: N,
                            interpolationFactor: En.interpolationFactor.bind(void 0, N),
                            zoomStops: R.map(j => j[0]),
                            evaluate: ({zoom: j}, $) => Fh({
                                stops: R,
                                base: n.base
                            }, t, j).evaluate(j, $)
                        }
                    }
                    if (a) {
                        const I = u === "exponential" ? {
                            name: "exponential",
                            base: n.base !== void 0 ? n.base : 1
                        } : null;
                        return {
                            kind: "camera",
                            interpolationType: I,
                            interpolationFactor: En.interpolationFactor.bind(void 0, I),
                            zoomStops: n.stops.map(A => A[0]),
                            evaluate: ({zoom: A}) => g(n, t, A, y, S)
                        }
                    }
                    return {
                        kind: "source",
                        evaluate(I, A) {
                            const R = A && A.properties ? A.properties[n.property] : void 0;
                            return R === void 0 ? To(n.default, t.default) : g(n, t, R, y, S)
                        }
                    }
                }
                function To(n, t, i) {
                    return n !== void 0 ? n : t !== void 0 ? t : i !== void 0 ? i : void 0
                }
                function up(n, t, i, a, u) {
                    return To(typeof i === u ? a[i] : void 0, n.default, t.default)
                }
                function hp(n, t, i) {
                    if (ei(i) !== "number")
                        return To(n.default, t.default);
                    const a = n.stops.length;
                    if (a === 1 || i <= n.stops[0][0])
                        return n.stops[0][1];
                    if (i >= n.stops[a - 1][0])
                        return n.stops[a - 1][1];
                    const u = ks(n.stops.map(p => p[0]), i);
                    return n.stops[u][1]
                }
                function Fh(n, t, i) {
                    const a = n.base !== void 0 ? n.base : 1;
                    if (ei(i) !== "number")
                        return To(n.default, t.default);
                    const u = n.stops.length;
                    if (u === 1 || i <= n.stops[0][0])
                        return n.stops[0][1];
                    if (i >= n.stops[u - 1][0])
                        return n.stops[u - 1][1];
                    const p = ks(n.stops.map(I => I[0]), i)
                      , f = function(I, A, R, N) {
                        const j = N - R
                          , $ = I - R;
                        return j === 0 ? 0 : A === 1 ? $ / j : (Math.pow(A, $) - 1) / (Math.pow(A, j) - 1)
                    }(i, a, n.stops[p][0], n.stops[p + 1][0])
                      , g = n.stops[p][1]
                      , y = n.stops[p + 1][1]
                      , S = ta[t.type] || Rh;
                    return typeof g.evaluate == "function" ? {
                        evaluate(...I) {
                            const A = g.evaluate.apply(void 0, I)
                              , R = y.evaluate.apply(void 0, I);
                            if (A !== void 0 && R !== void 0)
                                return S(A, R, f, n.colorSpace)
                        }
                    } : S(g, y, f, n.colorSpace)
                }
                function Oh(n, t, i) {
                    switch (t.type) {
                    case "color":
                        i = Jr.parse(i);
                        break;
                    case "formatted":
                        i = Gi.fromString(i.toString());
                        break;
                    case "resolvedImage":
                        i = qn.fromString(i.toString());
                        break;
                    case "padding":
                        i = Li.parse(i);
                        break;
                    case "colorArray":
                        i = on.parse(i);
                        break;
                    case "numberArray":
                        i = sn.parse(i);
                        break;
                    default:
                        ei(i) === t.type || t.type === "enum" && t.values[i] || (i = void 0)
                    }
                    return To(i, n.default, t.default)
                }
                oa.register(Bs, {
                    error: [{
                        kind: "error"
                    }, [yr], (n, [t]) => {
                        throw new Di(t.evaluate(n))
                    }
                    ],
                    typeof: [yr, [fr], (n, [t]) => Ht(qr(t.evaluate(n)))],
                    "to-rgba": [Ot(St, 4), [hi], (n, [t]) => {
                        const [i,a,u,p] = t.evaluate(n).rgb;
                        return [255 * i, 255 * a, 255 * u, p]
                    }
                    ],
                    rgb: [hi, [St, St, St], zh],
                    rgba: [hi, [St, St, St, St], zh],
                    has: {
                        type: pr,
                        overloads: [[[yr], (n, [t]) => Lh(t.evaluate(n), n.properties())], [[yr, si], (n, [t,i]) => Lh(t.evaluate(n), i.evaluate(n))]]
                    },
                    get: {
                        type: fr,
                        overloads: [[[yr], (n, [t]) => kc(t.evaluate(n), n.properties())], [[yr, si], (n, [t,i]) => kc(t.evaluate(n), i.evaluate(n))]]
                    },
                    "feature-state": [fr, [yr], (n, [t]) => kc(t.evaluate(n), n.featureState || {})],
                    properties: [si, [], n => n.properties()],
                    "geometry-type": [yr, [], n => n.geometryType()],
                    id: [fr, [], n => n.id()],
                    zoom: [St, [], n => n.globals.zoom],
                    "heatmap-density": [St, [], n => n.globals.heatmapDensity || 0],
                    elevation: [St, [], n => n.globals.elevation || 0],
                    "line-progress": [St, [], n => n.globals.lineProgress || 0],
                    accumulated: [fr, [], n => n.globals.accumulated === void 0 ? null : n.globals.accumulated],
                    "+": [St, ps(St), (n, t) => {
                        let i = 0;
                        for (const a of t)
                            i += a.evaluate(n);
                        return i
                    }
                    ],
                    "*": [St, ps(St), (n, t) => {
                        let i = 1;
                        for (const a of t)
                            i *= a.evaluate(n);
                        return i
                    }
                    ],
                    "-": {
                        type: St,
                        overloads: [[[St, St], (n, [t,i]) => t.evaluate(n) - i.evaluate(n)], [[St], (n, [t]) => -t.evaluate(n)]]
                    },
                    "/": [St, [St, St], (n, [t,i]) => t.evaluate(n) / i.evaluate(n)],
                    "%": [St, [St, St], (n, [t,i]) => t.evaluate(n) % i.evaluate(n)],
                    ln2: [St, [], () => Math.LN2],
                    pi: [St, [], () => Math.PI],
                    e: [St, [], () => Math.E],
                    "^": [St, [St, St], (n, [t,i]) => Math.pow(t.evaluate(n), i.evaluate(n))],
                    sqrt: [St, [St], (n, [t]) => Math.sqrt(t.evaluate(n))],
                    log10: [St, [St], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN10],
                    ln: [St, [St], (n, [t]) => Math.log(t.evaluate(n))],
                    log2: [St, [St], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN2],
                    sin: [St, [St], (n, [t]) => Math.sin(t.evaluate(n))],
                    cos: [St, [St], (n, [t]) => Math.cos(t.evaluate(n))],
                    tan: [St, [St], (n, [t]) => Math.tan(t.evaluate(n))],
                    asin: [St, [St], (n, [t]) => Math.asin(t.evaluate(n))],
                    acos: [St, [St], (n, [t]) => Math.acos(t.evaluate(n))],
                    atan: [St, [St], (n, [t]) => Math.atan(t.evaluate(n))],
                    min: [St, ps(St), (n, t) => Math.min(...t.map(i => i.evaluate(n)))],
                    max: [St, ps(St), (n, t) => Math.max(...t.map(i => i.evaluate(n)))],
                    abs: [St, [St], (n, [t]) => Math.abs(t.evaluate(n))],
                    round: [St, [St], (n, [t]) => {
                        const i = t.evaluate(n);
                        return i < 0 ? -Math.round(-i) : Math.round(i)
                    }
                    ],
                    floor: [St, [St], (n, [t]) => Math.floor(t.evaluate(n))],
                    ceil: [St, [St], (n, [t]) => Math.ceil(t.evaluate(n))],
                    "filter-==": [pr, [yr, fr], (n, [t,i]) => n.properties()[t.value] === i.value],
                    "filter-id-==": [pr, [fr], (n, [t]) => n.id() === t.value],
                    "filter-type-==": [pr, [yr], (n, [t]) => n.geometryType() === t.value],
                    "filter-<": [pr, [yr, fr], (n, [t,i]) => {
                        const a = n.properties()[t.value]
                          , u = i.value;
                        return typeof a == typeof u && a < u
                    }
                    ],
                    "filter-id-<": [pr, [fr], (n, [t]) => {
                        const i = n.id()
                          , a = t.value;
                        return typeof i == typeof a && i < a
                    }
                    ],
                    "filter->": [pr, [yr, fr], (n, [t,i]) => {
                        const a = n.properties()[t.value]
                          , u = i.value;
                        return typeof a == typeof u && a > u
                    }
                    ],
                    "filter-id->": [pr, [fr], (n, [t]) => {
                        const i = n.id()
                          , a = t.value;
                        return typeof i == typeof a && i > a
                    }
                    ],
                    "filter-<=": [pr, [yr, fr], (n, [t,i]) => {
                        const a = n.properties()[t.value]
                          , u = i.value;
                        return typeof a == typeof u && a <= u
                    }
                    ],
                    "filter-id-<=": [pr, [fr], (n, [t]) => {
                        const i = n.id()
                          , a = t.value;
                        return typeof i == typeof a && i <= a
                    }
                    ],
                    "filter->=": [pr, [yr, fr], (n, [t,i]) => {
                        const a = n.properties()[t.value]
                          , u = i.value;
                        return typeof a == typeof u && a >= u
                    }
                    ],
                    "filter-id->=": [pr, [fr], (n, [t]) => {
                        const i = n.id()
                          , a = t.value;
                        return typeof i == typeof a && i >= a
                    }
                    ],
                    "filter-has": [pr, [fr], (n, [t]) => t.value in n.properties()],
                    "filter-has-id": [pr, [], n => n.id() !== null && n.id() !== void 0],
                    "filter-type-in": [pr, [Ot(yr)], (n, [t]) => t.value.indexOf(n.geometryType()) >= 0],
                    "filter-id-in": [pr, [Ot(fr)], (n, [t]) => t.value.indexOf(n.id()) >= 0],
                    "filter-in-small": [pr, [yr, Ot(fr)], (n, [t,i]) => i.value.indexOf(n.properties()[t.value]) >= 0],
                    "filter-in-large": [pr, [yr, Ot(fr)], (n, [t,i]) => function(a, u, p, f) {
                        for (; p <= f; ) {
                            const g = p + f >> 1;
                            if (u[g] === a)
                                return !0;
                            u[g] > a ? f = g - 1 : p = g + 1
                        }
                        return !1
                    }(n.properties()[t.value], i.value, 0, i.value.length - 1)],
                    all: {
                        type: pr,
                        overloads: [[[pr, pr], (n, [t,i]) => t.evaluate(n) && i.evaluate(n)], [ps(pr), (n, t) => {
                            for (const i of t)
                                if (!i.evaluate(n))
                                    return !1;
                            return !0
                        }
                        ]]
                    },
                    any: {
                        type: pr,
                        overloads: [[[pr, pr], (n, [t,i]) => t.evaluate(n) || i.evaluate(n)], [ps(pr), (n, t) => {
                            for (const i of t)
                                if (i.evaluate(n))
                                    return !0;
                            return !1
                        }
                        ]]
                    },
                    "!": [pr, [pr], (n, [t]) => !t.evaluate(n)],
                    "is-supported-script": [pr, [yr], (n, [t]) => {
                        const i = n.globals && n.globals.isSupportedScript;
                        return !i || i(t.evaluate(n))
                    }
                    ],
                    upcase: [yr, [yr], (n, [t]) => t.evaluate(n).toUpperCase()],
                    downcase: [yr, [yr], (n, [t]) => t.evaluate(n).toLowerCase()],
                    concat: [yr, ps(fr), (n, t) => t.map(i => cs(i.evaluate(n))).join("")],
                    "resolved-locale": [yr, [$i], (n, [t]) => t.evaluate(n).resolvedLocale()]
                });
                class fl {
                    constructor(t, i) {
                        this.expression = t,
                        this._warningHistory = {},
                        this._evaluator = new vh,
                        this._defaultValue = i ? function(a) {
                            if (a.type === "color" && fs(a.default))
                                return new Jr(0,0,0,0);
                            switch (a.type) {
                            case "color":
                                return Jr.parse(a.default) || null;
                            case "padding":
                                return Li.parse(a.default) || null;
                            case "numberArray":
                                return sn.parse(a.default) || null;
                            case "colorArray":
                                return on.parse(a.default) || null;
                            case "variableAnchorOffsetCollection":
                                return ai.parse(a.default) || null;
                            case "projectionDefinition":
                                return Hr.parse(a.default) || null;
                            default:
                                return a.default === void 0 ? null : a.default
                            }
                        }(i) : null,
                        this._enumValues = i && i.type === "enum" ? i.values : null
                    }
                    evaluateWithoutErrorHandling(t, i, a, u, p, f) {
                        return this._evaluator.globals = t,
                        this._evaluator.feature = i,
                        this._evaluator.featureState = a,
                        this._evaluator.canonical = u,
                        this._evaluator.availableImages = p || null,
                        this._evaluator.formattedSection = f,
                        this.expression.evaluate(this._evaluator)
                    }
                    evaluate(t, i, a, u, p, f) {
                        this._evaluator.globals = t,
                        this._evaluator.feature = i || null,
                        this._evaluator.featureState = a || null,
                        this._evaluator.canonical = u,
                        this._evaluator.availableImages = p || null,
                        this._evaluator.formattedSection = f || null;
                        try {
                            const g = this.expression.evaluate(this._evaluator);
                            if (g == null || typeof g == "number" && g != g)
                                return this._defaultValue;
                            if (this._enumValues && !(g in this._enumValues))
                                throw new Di(`Expected value to be one of ${Object.keys(this._enumValues).map(y => JSON.stringify(y)).join(", ")}, but found ${JSON.stringify(g)} instead.`);
                            return g
                        } catch (g) {
                            return this._warningHistory[g.message] || (this._warningHistory[g.message] = !0,
                            typeof console < "u" && console.warn(g.message)),
                            this._defaultValue
                        }
                    }
                }
                function ml(n) {
                    return Array.isArray(n) && n.length > 0 && typeof n[0] == "string" && n[0]in Bs
                }
                function _l(n, t) {
                    const i = new uo(Bs,dl,[],t ? function(u) {
                        const p = {
                            color: hi,
                            string: yr,
                            number: St,
                            enum: yr,
                            boolean: pr,
                            formatted: On,
                            padding: _i,
                            numberArray: Kn,
                            colorArray: An,
                            projectionDefinition: Or,
                            resolvedImage: Nn,
                            variableAnchorOffsetCollection: Tt
                        };
                        return u.type === "array" ? Ot(p[u.value] || fr, u.length) : p[u.type]
                    }(t) : void 0)
                      , a = i.parse(n, void 0, void 0, void 0, t && t.type === "string" ? {
                        typeAnnotation: "coerce"
                    } : void 0);
                    return a ? Dh(new fl(a,t)) : Os(i.errors)
                }
                class Co {
                    constructor(t, i) {
                        this.kind = t,
                        this._styleExpression = i,
                        this.isStateDependent = t !== "constant" && !wo(i.expression),
                        this.globalStateRefs = qs(i.expression)
                    }
                    evaluateWithoutErrorHandling(t, i, a, u, p, f) {
                        return this._styleExpression.evaluateWithoutErrorHandling(t, i, a, u, p, f)
                    }
                    evaluate(t, i, a, u, p, f) {
                        return this._styleExpression.evaluate(t, i, a, u, p, f)
                    }
                }
                class gl {
                    constructor(t, i, a, u) {
                        this.kind = t,
                        this.zoomStops = a,
                        this._styleExpression = i,
                        this.isStateDependent = t !== "camera" && !wo(i.expression),
                        this.globalStateRefs = qs(i.expression),
                        this.interpolationType = u
                    }
                    evaluateWithoutErrorHandling(t, i, a, u, p, f) {
                        return this._styleExpression.evaluateWithoutErrorHandling(t, i, a, u, p, f)
                    }
                    evaluate(t, i, a, u, p, f) {
                        return this._styleExpression.evaluate(t, i, a, u, p, f)
                    }
                    interpolationFactor(t, i, a) {
                        return this.interpolationType ? En.interpolationFactor(this.interpolationType, t, i, a) : 0
                    }
                }
                function Lc(n, t) {
                    const i = _l(n, t);
                    if (i.result === "error")
                        return i;
                    const a = i.value.expression
                      , u = pl(a);
                    if (!u && !Ns(t))
                        return Os([new Ur("","data expressions not supported")]);
                    const p = Fs(a, ["zoom"]);
                    if (!p && !Ec(t))
                        return Os([new Ur("","zoom expressions not supported")]);
                    const f = js(a);
                    return f || p ? f instanceof Ur ? Os([f]) : f instanceof En && !zc(t) ? Os([new Ur("",'"interpolate" expressions cannot be used with this property')]) : Dh(f ? new gl(u ? "camera" : "composite",i.value,f.labels,f instanceof En ? f.interpolation : void 0) : new Co(u ? "constant" : "source",i.value)) : Os([new Ur("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
                }
                class So {
                    constructor(t, i) {
                        this._parameters = t,
                        this._specification = i,
                        Br(this, Bh(this._parameters, this._specification))
                    }
                    static deserialize(t) {
                        return new So(t._parameters,t._specification)
                    }
                    static serialize(t) {
                        return {
                            _parameters: t._parameters,
                            _specification: t._specification
                        }
                    }
                }
                function js(n) {
                    let t = null;
                    if (n instanceof ho)
                        t = js(n.result);
                    else if (n instanceof Zn) {
                        for (const i of n.args)
                            if (t = js(i),
                            t)
                                break
                    } else
                        (n instanceof Es || n instanceof En) && n.input instanceof oa && n.input.name === "zoom" && (t = n);
                    return t instanceof Ur || n.eachChild(i => {
                        const a = js(i);
                        a instanceof Ur ? t = a : !t && a ? t = new Ur("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && a && t !== a && (t = new Ur("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
                    }
                    ),
                    t
                }
                function qs(n, t=new Set) {
                    return n instanceof bo && t.add(n.key),
                    n.eachChild(i => {
                        qs(i, t)
                    }
                    ),
                    t
                }
                function Po(n) {
                    if (n === !0 || n === !1)
                        return !0;
                    if (!Array.isArray(n) || n.length === 0)
                        return !1;
                    switch (n[0]) {
                    case "has":
                        return n.length >= 2 && n[1] !== "$id" && n[1] !== "$type";
                    case "in":
                        return n.length >= 3 && (typeof n[1] != "string" || Array.isArray(n[2]));
                    case "!in":
                    case "!has":
                    case "none":
                        return !1;
                    case "==":
                    case "!=":
                    case ">":
                    case ">=":
                    case "<":
                    case "<=":
                        return n.length !== 3 || Array.isArray(n[1]) || Array.isArray(n[2]);
                    case "any":
                    case "all":
                        for (const t of n.slice(1))
                            if (!Po(t) && typeof t != "boolean")
                                return !1;
                        return !0;
                    default:
                        return !0
                    }
                }
                const Dc = {
                    type: "boolean",
                    default: !1,
                    transition: !1,
                    "property-type": "data-driven",
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    }
                };
                function Ha(n) {
                    if (n == null)
                        return {
                            filter: () => !0,
                            needGeometry: !1,
                            getGlobalStateRefs: () => new Set
                        };
                    Po(n) || (n = vl(n));
                    const t = _l(n, Dc);
                    if (t.result === "error")
                        throw new Error(t.value.map(i => `${i.key}: ${i.message}`).join(", "));
                    return {
                        filter: (i, a, u) => t.value.evaluate(i, a, {}, u),
                        needGeometry: Nh(n),
                        getGlobalStateRefs: () => qs(t.value.expression)
                    }
                }
                function dp(n, t) {
                    return n < t ? -1 : n > t ? 1 : 0
                }
                function Nh(n) {
                    if (!Array.isArray(n))
                        return !1;
                    if (n[0] === "within" || n[0] === "distance")
                        return !0;
                    for (let t = 1; t < n.length; t++)
                        if (Nh(n[t]))
                            return !0;
                    return !1
                }
                function vl(n) {
                    if (!n)
                        return !0;
                    const t = n[0];
                    return n.length <= 1 ? t !== "any" : t === "==" ? Rc(n[1], n[2], "==") : t === "!=" ? Io(Rc(n[1], n[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? Rc(n[1], n[2], t) : t === "any" ? (i = n.slice(1),
                    ["any"].concat(i.map(vl))) : t === "all" ? ["all"].concat(n.slice(1).map(vl)) : t === "none" ? ["all"].concat(n.slice(1).map(vl).map(Io)) : t === "in" ? jh(n[1], n.slice(2)) : t === "!in" ? Io(jh(n[1], n.slice(2))) : t === "has" ? qh(n[1]) : t !== "!has" || Io(qh(n[1]));
                    var i
                }
                function Rc(n, t, i) {
                    switch (n) {
                    case "$type":
                        return [`filter-type-${i}`, t];
                    case "$id":
                        return [`filter-id-${i}`, t];
                    default:
                        return [`filter-${i}`, n, t]
                    }
                }
                function jh(n, t) {
                    if (t.length === 0)
                        return !1;
                    switch (n) {
                    case "$type":
                        return ["filter-type-in", ["literal", t]];
                    case "$id":
                        return ["filter-id-in", ["literal", t]];
                    default:
                        return t.length > 200 && !t.some(i => typeof i != typeof t[0]) ? ["filter-in-large", n, ["literal", t.sort(dp)]] : ["filter-in-small", n, ["literal", t]]
                    }
                }
                function qh(n) {
                    switch (n) {
                    case "$type":
                        return !0;
                    case "$id":
                        return ["filter-has-id"];
                    default:
                        return ["filter-has", n]
                    }
                }
                function Io(n) {
                    return ["!", n]
                }
                function yl(n) {
                    const t = typeof n;
                    if (t === "number" || t === "boolean" || t === "string" || n == null)
                        return JSON.stringify(n);
                    if (Array.isArray(n)) {
                        let u = "[";
                        for (const p of n)
                            u += `${yl(p)},`;
                        return `${u}]`
                    }
                    const i = Object.keys(n).sort();
                    let a = "{";
                    for (let u = 0; u < i.length; u++)
                        a += `${JSON.stringify(i[u])}:${yl(n[i[u]])},`;
                    return `${a}}`
                }
                function xl(n) {
                    let t = "";
                    for (const i of It)
                        t += `/${yl(n[i])}`;
                    return t
                }
                function Vh(n) {
                    const t = n.value;
                    return t ? [new ft(n.key,t,"constants have been deprecated as of v8")] : []
                }
                function ji(n) {
                    return n instanceof Number || n instanceof String || n instanceof Boolean ? n.valueOf() : n
                }
                function Wa(n) {
                    if (Array.isArray(n))
                        return n.map(Wa);
                    if (n instanceof Object && !(n instanceof Number || n instanceof String || n instanceof Boolean)) {
                        const t = {};
                        for (const i in n)
                            t[i] = Wa(n[i]);
                        return t
                    }
                    return ji(n)
                }
                function la(n) {
                    const t = n.key
                      , i = n.value
                      , a = n.valueSpec || {}
                      , u = n.objectElementValidators || {}
                      , p = n.style
                      , f = n.styleSpec
                      , g = n.validateSpec;
                    let y = [];
                    const S = ei(i);
                    if (S !== "object")
                        return [new ft(t,i,`object expected, ${S} found`)];
                    for (const I in i) {
                        const A = I.split(".")[0]
                          , R = Wr(a, A) || a["*"];
                        let N;
                        if (Wr(u, A))
                            N = u[A];
                        else if (Wr(a, A))
                            N = g;
                        else if (u["*"])
                            N = u["*"];
                        else {
                            if (!a["*"]) {
                                y.push(new ft(t,i[I],`unknown property "${I}"`));
                                continue
                            }
                            N = g
                        }
                        y = y.concat(N({
                            key: (t && `${t}.`) + I,
                            value: i[I],
                            valueSpec: R,
                            style: p,
                            styleSpec: f,
                            object: i,
                            objectKey: I,
                            validateSpec: g
                        }, i))
                    }
                    for (const I in a)
                        u[I] || a[I].required && a[I].default === void 0 && i[I] === void 0 && y.push(new ft(t,i,`missing required property "${I}"`));
                    return y
                }
                function bl(n) {
                    const t = n.value
                      , i = n.valueSpec
                      , a = n.style
                      , u = n.styleSpec
                      , p = n.key
                      , f = n.arrayElementValidator || n.validateSpec;
                    if (ei(t) !== "array")
                        return [new ft(p,t,`array expected, ${ei(t)} found`)];
                    if (i.length && t.length !== i.length)
                        return [new ft(p,t,`array length ${i.length} expected, length ${t.length} found`)];
                    if (i["min-length"] && t.length < i["min-length"])
                        return [new ft(p,t,`array length at least ${i["min-length"]} expected, length ${t.length} found`)];
                    let g = {
                        type: i.value,
                        values: i.values
                    };
                    u.$version < 7 && (g.function = i.function),
                    ei(i.value) === "object" && (g = i.value);
                    let y = [];
                    for (let S = 0; S < t.length; S++)
                        y = y.concat(f({
                            array: t,
                            arrayIndex: S,
                            value: t[S],
                            valueSpec: g,
                            validateSpec: n.validateSpec,
                            style: a,
                            styleSpec: u,
                            key: `${p}[${S}]`
                        }));
                    return y
                }
                function Mo(n) {
                    const t = n.key
                      , i = n.value
                      , a = n.valueSpec;
                    let u = ei(i);
                    return u === "number" && i != i && (u = "NaN"),
                    u !== "number" ? [new ft(t,i,`number expected, ${u} found`)] : "minimum"in a && i < a.minimum ? [new ft(t,i,`${i} is less than the minimum value ${a.minimum}`)] : "maximum"in a && i > a.maximum ? [new ft(t,i,`${i} is greater than the maximum value ${a.maximum}`)] : []
                }
                function Vs(n) {
                    const t = n.valueSpec
                      , i = ji(n.value.type);
                    let a, u, p, f = {};
                    const g = i !== "categorical" && n.value.property === void 0
                      , y = !g
                      , S = ei(n.value.stops) === "array" && ei(n.value.stops[0]) === "array" && ei(n.value.stops[0][0]) === "object"
                      , I = la({
                        key: n.key,
                        value: n.value,
                        valueSpec: n.styleSpec.function,
                        validateSpec: n.validateSpec,
                        style: n.style,
                        styleSpec: n.styleSpec,
                        objectElementValidators: {
                            stops: function(N) {
                                if (i === "identity")
                                    return [new ft(N.key,N.value,'identity function may not have a "stops" property')];
                                let j = [];
                                const $ = N.value;
                                return j = j.concat(bl({
                                    key: N.key,
                                    value: $,
                                    valueSpec: N.valueSpec,
                                    validateSpec: N.validateSpec,
                                    style: N.style,
                                    styleSpec: N.styleSpec,
                                    arrayElementValidator: A
                                })),
                                ei($) === "array" && $.length === 0 && j.push(new ft(N.key,$,"array must have at least one stop")),
                                j
                            },
                            default: function(N) {
                                return N.validateSpec({
                                    key: N.key,
                                    value: N.value,
                                    valueSpec: t,
                                    validateSpec: N.validateSpec,
                                    style: N.style,
                                    styleSpec: N.styleSpec
                                })
                            }
                        }
                    });
                    return i === "identity" && g && I.push(new ft(n.key,n.value,'missing required property "property"')),
                    i === "identity" || n.value.stops || I.push(new ft(n.key,n.value,'missing required property "stops"')),
                    i === "exponential" && n.valueSpec.expression && !zc(n.valueSpec) && I.push(new ft(n.key,n.value,"exponential functions not supported")),
                    n.styleSpec.$version >= 8 && (y && !Ns(n.valueSpec) ? I.push(new ft(n.key,n.value,"property functions not supported")) : g && !Ec(n.valueSpec) && I.push(new ft(n.key,n.value,"zoom functions not supported"))),
                    i !== "categorical" && !S || n.value.property !== void 0 || I.push(new ft(n.key,n.value,'"property" property is required')),
                    I;
                    function A(N) {
                        let j = [];
                        const $ = N.value
                          , J = N.key;
                        if (ei($) !== "array")
                            return [new ft(J,$,`array expected, ${ei($)} found`)];
                        if ($.length !== 2)
                            return [new ft(J,$,`array length 2 expected, length ${$.length} found`)];
                        if (S) {
                            if (ei($[0]) !== "object")
                                return [new ft(J,$,`object expected, ${ei($[0])} found`)];
                            if ($[0].zoom === void 0)
                                return [new ft(J,$,"object stop key must have zoom")];
                            if ($[0].value === void 0)
                                return [new ft(J,$,"object stop key must have value")];
                            if (p && p > ji($[0].zoom))
                                return [new ft(J,$[0].zoom,"stop zoom values must appear in ascending order")];
                            ji($[0].zoom) !== p && (p = ji($[0].zoom),
                            u = void 0,
                            f = {}),
                            j = j.concat(la({
                                key: `${J}[0]`,
                                value: $[0],
                                valueSpec: {
                                    zoom: {}
                                },
                                validateSpec: N.validateSpec,
                                style: N.style,
                                styleSpec: N.styleSpec,
                                objectElementValidators: {
                                    zoom: Mo,
                                    value: R
                                }
                            }))
                        } else
                            j = j.concat(R({
                                key: `${J}[0]`,
                                value: $[0],
                                validateSpec: N.validateSpec,
                                style: N.style,
                                styleSpec: N.styleSpec
                            }, $));
                        return ml(Wa($[1])) ? j.concat([new ft(`${J}[1]`,$[1],"expressions are not allowed in function stops.")]) : j.concat(N.validateSpec({
                            key: `${J}[1]`,
                            value: $[1],
                            valueSpec: t,
                            validateSpec: N.validateSpec,
                            style: N.style,
                            styleSpec: N.styleSpec
                        }))
                    }
                    function R(N, j) {
                        const $ = ei(N.value)
                          , J = ji(N.value)
                          , se = N.value !== null ? N.value : j;
                        if (a) {
                            if ($ !== a)
                                return [new ft(N.key,se,`${$} stop domain type must match previous stop domain type ${a}`)]
                        } else
                            a = $;
                        if ($ !== "number" && $ !== "string" && $ !== "boolean")
                            return [new ft(N.key,se,"stop domain value must be a number, string, or boolean")];
                        if ($ !== "number" && i !== "categorical") {
                            let Ae = `number expected, ${$} found`;
                            return Ns(t) && i === void 0 && (Ae += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
                            [new ft(N.key,se,Ae)]
                        }
                        return i !== "categorical" || $ !== "number" || isFinite(J) && Math.floor(J) === J ? i !== "categorical" && $ === "number" && u !== void 0 && J < u ? [new ft(N.key,se,"stop domain values must appear in ascending order")] : (u = J,
                        i === "categorical" && J in f ? [new ft(N.key,se,"stop domain values must be unique")] : (f[J] = !0,
                        [])) : [new ft(N.key,se,`integer expected, found ${J}`)]
                    }
                }
                function Zs(n) {
                    const t = (n.expressionContext === "property" ? Lc : _l)(Wa(n.value), n.valueSpec);
                    if (t.result === "error")
                        return t.value.map(a => new ft(`${n.key}${a.key}`,n.value,a.message));
                    const i = t.value.expression || t.value._styleExpression.expression;
                    if (n.expressionContext === "property" && n.propertyKey === "text-font" && !i.outputDefined())
                        return [new ft(n.key,n.value,`Invalid data expression for "${n.propertyKey}". Output values must be contained as literals within the expression.`)];
                    if (n.expressionContext === "property" && n.propertyType === "layout" && !wo(i))
                        return [new ft(n.key,n.value,'"feature-state" data expressions are not supported with layout properties.')];
                    if (n.expressionContext === "filter" && !wo(i))
                        return [new ft(n.key,n.value,'"feature-state" data expressions are not supported with filters.')];
                    if (n.expressionContext && n.expressionContext.indexOf("cluster") === 0) {
                        if (!Fs(i, ["zoom", "feature-state"]))
                            return [new ft(n.key,n.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];
                        if (n.expressionContext === "cluster-initial" && !pl(i))
                            return [new ft(n.key,n.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]
                    }
                    return []
                }
                function Bc(n) {
                    const t = n.key
                      , i = n.value
                      , a = ei(i);
                    return a !== "string" ? [new ft(t,i,`color expected, ${a} found`)] : Jr.parse(String(i)) ? [] : [new ft(t,i,`color expected, "${i}" found`)]
                }
                function Ao(n) {
                    const t = n.key
                      , i = n.value
                      , a = n.valueSpec
                      , u = [];
                    return Array.isArray(a.values) ? a.values.indexOf(ji(i)) === -1 && u.push(new ft(t,i,`expected one of [${a.values.join(", ")}], ${JSON.stringify(i)} found`)) : Object.keys(a.values).indexOf(ji(i)) === -1 && u.push(new ft(t,i,`expected one of [${Object.keys(a.values).join(", ")}], ${JSON.stringify(i)} found`)),
                    u
                }
                function Fc(n) {
                    return Po(Wa(n.value)) ? Zs(Br({}, n, {
                        expressionContext: "filter",
                        valueSpec: {
                            value: "boolean"
                        }
                    })) : Zh(n)
                }
                function Zh(n) {
                    const t = n.value
                      , i = n.key;
                    if (ei(t) !== "array")
                        return [new ft(i,t,`array expected, ${ei(t)} found`)];
                    const a = n.styleSpec;
                    let u, p = [];
                    if (t.length < 1)
                        return [new ft(i,t,"filter array must have at least 1 element")];
                    switch (p = p.concat(Ao({
                        key: `${i}[0]`,
                        value: t[0],
                        valueSpec: a.filter_operator,
                        style: n.style,
                        styleSpec: n.styleSpec
                    })),
                    ji(t[0])) {
                    case "<":
                    case "<=":
                    case ">":
                    case ">=":
                        t.length >= 2 && ji(t[1]) === "$type" && p.push(new ft(i,t,`"$type" cannot be use with operator "${t[0]}"`));
                    case "==":
                    case "!=":
                        t.length !== 3 && p.push(new ft(i,t,`filter array for operator "${t[0]}" must have 3 elements`));
                    case "in":
                    case "!in":
                        t.length >= 2 && (u = ei(t[1]),
                        u !== "string" && p.push(new ft(`${i}[1]`,t[1],`string expected, ${u} found`)));
                        for (let f = 2; f < t.length; f++)
                            u = ei(t[f]),
                            ji(t[1]) === "$type" ? p = p.concat(Ao({
                                key: `${i}[${f}]`,
                                value: t[f],
                                valueSpec: a.geometry_type,
                                style: n.style,
                                styleSpec: n.styleSpec
                            })) : u !== "string" && u !== "number" && u !== "boolean" && p.push(new ft(`${i}[${f}]`,t[f],`string, number, or boolean expected, ${u} found`));
                        break;
                    case "any":
                    case "all":
                    case "none":
                        for (let f = 1; f < t.length; f++)
                            p = p.concat(Zh({
                                key: `${i}[${f}]`,
                                value: t[f],
                                style: n.style,
                                styleSpec: n.styleSpec
                            }));
                        break;
                    case "has":
                    case "!has":
                        u = ei(t[1]),
                        t.length !== 2 ? p.push(new ft(i,t,`filter array for "${t[0]}" operator must have 2 elements`)) : u !== "string" && p.push(new ft(`${i}[1]`,t[1],`string expected, ${u} found`))
                    }
                    return p
                }
                function $h(n, t) {
                    const i = n.key
                      , a = n.validateSpec
                      , u = n.style
                      , p = n.styleSpec
                      , f = n.value
                      , g = n.objectKey
                      , y = p[`${t}_${n.layerType}`];
                    if (!y)
                        return [];
                    const S = g.match(/^(.*)-transition$/);
                    if (t === "paint" && S && y[S[1]] && y[S[1]].transition)
                        return a({
                            key: i,
                            value: f,
                            valueSpec: p.transition,
                            style: u,
                            styleSpec: p
                        });
                    const I = n.valueSpec || y[g];
                    if (!I)
                        return [new ft(i,f,`unknown property "${g}"`)];
                    let A;
                    if (ei(f) === "string" && Ns(I) && !I.tokens && (A = /^{([^}]+)}$/.exec(f)))
                        return [new ft(i,f,`"${g}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(A[1])} }\`.`)];
                    const R = [];
                    return n.layerType === "symbol" && (g === "text-field" && u && !u.glyphs && R.push(new ft(i,f,'use of "text-field" requires a style "glyphs" property')),
                    g === "text-font" && fs(Wa(f)) && ji(f.type) === "identity" && R.push(new ft(i,f,'"text-font" does not support identity functions'))),
                    R.concat(a({
                        key: n.key,
                        value: f,
                        valueSpec: I,
                        style: u,
                        styleSpec: p,
                        expressionContext: "property",
                        propertyType: t,
                        propertyKey: g
                    }))
                }
                function $s(n) {
                    return $h(n, "paint")
                }
                function Us(n) {
                    return $h(n, "layout")
                }
                function $n(n) {
                    let t = [];
                    const i = n.value
                      , a = n.key
                      , u = n.style
                      , p = n.styleSpec;
                    if (ei(i) !== "object")
                        return [new ft(a,i,`object expected, ${ei(i)} found`)];
                    i.type || i.ref || t.push(new ft(a,i,'either "type" or "ref" is required'));
                    let f = ji(i.type);
                    const g = ji(i.ref);
                    if (i.id) {
                        const y = ji(i.id);
                        for (let S = 0; S < n.arrayIndex; S++) {
                            const I = u.layers[S];
                            ji(I.id) === y && t.push(new ft(a,i.id,`duplicate layer id "${i.id}", previously used at line ${I.id.__line__}`))
                        }
                    }
                    if ("ref"in i) {
                        let y;
                        ["type", "source", "source-layer", "filter", "layout"].forEach(S => {
                            S in i && t.push(new ft(a,i[S],`"${S}" is prohibited for ref layers`))
                        }
                        ),
                        u.layers.forEach(S => {
                            ji(S.id) === g && (y = S)
                        }
                        ),
                        y ? y.ref ? t.push(new ft(a,i.ref,"ref cannot reference another ref layer")) : f = ji(y.type) : t.push(new ft(a,i.ref,`ref layer "${g}" not found`))
                    } else if (f !== "background")
                        if (i.source) {
                            const y = u.sources && u.sources[i.source]
                              , S = y && ji(y.type);
                            y ? S === "vector" && f === "raster" ? t.push(new ft(a,i.source,`layer "${i.id}" requires a raster source`)) : S !== "raster-dem" && f === "hillshade" || S !== "raster-dem" && f === "color-relief" ? t.push(new ft(a,i.source,`layer "${i.id}" requires a raster-dem source`)) : S === "raster" && f !== "raster" ? t.push(new ft(a,i.source,`layer "${i.id}" requires a vector source`)) : S !== "vector" || i["source-layer"] ? S === "raster-dem" && f !== "hillshade" && f !== "color-relief" ? t.push(new ft(a,i.source,"raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : f !== "line" || !i.paint || !i.paint["line-gradient"] || S === "geojson" && y.lineMetrics || t.push(new ft(a,i,`layer "${i.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new ft(a,i,`layer "${i.id}" must specify a "source-layer"`)) : t.push(new ft(a,i.source,`source "${i.source}" not found`))
                        } else
                            t.push(new ft(a,i,'missing required property "source"'));
                    return t = t.concat(la({
                        key: a,
                        value: i,
                        valueSpec: p.layer,
                        style: n.style,
                        styleSpec: n.styleSpec,
                        validateSpec: n.validateSpec,
                        objectElementValidators: {
                            "*": () => [],
                            type: () => n.validateSpec({
                                key: `${a}.type`,
                                value: i.type,
                                valueSpec: p.layer.type,
                                style: n.style,
                                styleSpec: n.styleSpec,
                                validateSpec: n.validateSpec,
                                object: i,
                                objectKey: "type"
                            }),
                            filter: Fc,
                            layout: y => la({
                                layer: i,
                                key: y.key,
                                value: y.value,
                                style: y.style,
                                styleSpec: y.styleSpec,
                                validateSpec: y.validateSpec,
                                objectElementValidators: {
                                    "*": S => Us(Br({
                                        layerType: f
                                    }, S))
                                }
                            }),
                            paint: y => la({
                                layer: i,
                                key: y.key,
                                value: y.value,
                                style: y.style,
                                styleSpec: y.styleSpec,
                                validateSpec: y.validateSpec,
                                objectElementValidators: {
                                    "*": S => $s(Br({
                                        layerType: f
                                    }, S))
                                }
                            })
                        }
                    })),
                    t
                }
                function fa(n) {
                    const t = n.value
                      , i = n.key
                      , a = ei(t);
                    return a !== "string" ? [new ft(i,t,`string expected, ${a} found`)] : []
                }
                const Oc = {
                    promoteId: function({key: n, value: t}) {
                        if (ei(t) === "string")
                            return fa({
                                key: n,
                                value: t
                            });
                        {
                            const i = [];
                            for (const a in t)
                                i.push(...fa({
                                    key: `${n}.${a}`,
                                    value: t[a]
                                }));
                            return i
                        }
                    }
                };
                function Uh(n) {
                    const t = n.value
                      , i = n.key
                      , a = n.styleSpec
                      , u = n.style
                      , p = n.validateSpec;
                    if (!t.type)
                        return [new ft(i,t,'"type" is required')];
                    const f = ji(t.type);
                    let g;
                    switch (f) {
                    case "vector":
                    case "raster":
                        return g = la({
                            key: i,
                            value: t,
                            valueSpec: a[`source_${f.replace("-", "_")}`],
                            style: n.style,
                            styleSpec: a,
                            objectElementValidators: Oc,
                            validateSpec: p
                        }),
                        g;
                    case "raster-dem":
                        return g = function(y) {
                            var S;
                            const I = (S = y.sourceName) !== null && S !== void 0 ? S : ""
                              , A = y.value
                              , R = y.styleSpec
                              , N = R.source_raster_dem
                              , j = y.style;
                            let $ = [];
                            const J = ei(A);
                            if (A === void 0)
                                return $;
                            if (J !== "object")
                                return $.push(new ft("source_raster_dem",A,`object expected, ${J} found`)),
                                $;
                            const se = ji(A.encoding) === "custom"
                              , Ae = ["redFactor", "greenFactor", "blueFactor", "baseShift"]
                              , _e = y.value.encoding ? `"${y.value.encoding}"` : "Default";
                            for (const O in A)
                                !se && Ae.includes(O) ? $.push(new ft(O,A[O],`In "${I}": "${O}" is only valid when "encoding" is set to "custom". ${_e} encoding found`)) : N[O] ? $ = $.concat(y.validateSpec({
                                    key: O,
                                    value: A[O],
                                    valueSpec: N[O],
                                    validateSpec: y.validateSpec,
                                    style: j,
                                    styleSpec: R
                                })) : $.push(new ft(O,A[O],`unknown property "${O}"`));
                            return $
                        }({
                            sourceName: i,
                            value: t,
                            style: n.style,
                            styleSpec: a,
                            validateSpec: p
                        }),
                        g;
                    case "geojson":
                        if (g = la({
                            key: i,
                            value: t,
                            valueSpec: a.source_geojson,
                            style: u,
                            styleSpec: a,
                            validateSpec: p,
                            objectElementValidators: Oc
                        }),
                        t.cluster)
                            for (const y in t.clusterProperties) {
                                const [S,I] = t.clusterProperties[y]
                                  , A = typeof S == "string" ? [S, ["accumulated"], ["get", y]] : S;
                                g.push(...Zs({
                                    key: `${i}.${y}.map`,
                                    value: I,
                                    expressionContext: "cluster-map"
                                })),
                                g.push(...Zs({
                                    key: `${i}.${y}.reduce`,
                                    value: A,
                                    expressionContext: "cluster-reduce"
                                }))
                            }
                        return g;
                    case "video":
                        return la({
                            key: i,
                            value: t,
                            valueSpec: a.source_video,
                            style: u,
                            validateSpec: p,
                            styleSpec: a
                        });
                    case "image":
                        return la({
                            key: i,
                            value: t,
                            valueSpec: a.source_image,
                            style: u,
                            validateSpec: p,
                            styleSpec: a
                        });
                    case "canvas":
                        return [new ft(i,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];
                    default:
                        return Ao({
                            key: `${i}.type`,
                            value: t.type,
                            valueSpec: {
                                values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                            }
                        })
                    }
                }
                function Gh(n) {
                    const t = n.value
                      , i = n.styleSpec
                      , a = i.light
                      , u = n.style;
                    let p = [];
                    const f = ei(t);
                    if (t === void 0)
                        return p;
                    if (f !== "object")
                        return p = p.concat([new ft("light",t,`object expected, ${f} found`)]),
                        p;
                    for (const g in t) {
                        const y = g.match(/^(.*)-transition$/);
                        p = p.concat(y && a[y[1]] && a[y[1]].transition ? n.validateSpec({
                            key: g,
                            value: t[g],
                            valueSpec: i.transition,
                            validateSpec: n.validateSpec,
                            style: u,
                            styleSpec: i
                        }) : a[g] ? n.validateSpec({
                            key: g,
                            value: t[g],
                            valueSpec: a[g],
                            validateSpec: n.validateSpec,
                            style: u,
                            styleSpec: i
                        }) : [new ft(g,t[g],`unknown property "${g}"`)])
                    }
                    return p
                }
                function Gs(n) {
                    const t = n.value
                      , i = n.styleSpec
                      , a = i.sky
                      , u = n.style
                      , p = ei(t);
                    if (t === void 0)
                        return [];
                    if (p !== "object")
                        return [new ft("sky",t,`object expected, ${p} found`)];
                    let f = [];
                    for (const g in t)
                        f = f.concat(a[g] ? n.validateSpec({
                            key: g,
                            value: t[g],
                            valueSpec: a[g],
                            style: u,
                            styleSpec: i
                        }) : [new ft(g,t[g],`unknown property "${g}"`)]);
                    return f
                }
                function Nc(n) {
                    const t = n.value
                      , i = n.styleSpec
                      , a = i.terrain
                      , u = n.style;
                    let p = [];
                    const f = ei(t);
                    if (t === void 0)
                        return p;
                    if (f !== "object")
                        return p = p.concat([new ft("terrain",t,`object expected, ${f} found`)]),
                        p;
                    for (const g in t)
                        p = p.concat(a[g] ? n.validateSpec({
                            key: g,
                            value: t[g],
                            valueSpec: a[g],
                            validateSpec: n.validateSpec,
                            style: u,
                            styleSpec: i
                        }) : [new ft(g,t[g],`unknown property "${g}"`)]);
                    return p
                }
                function wl(n) {
                    let t = [];
                    const i = n.value
                      , a = n.key;
                    if (Array.isArray(i)) {
                        const u = []
                          , p = [];
                        for (const f in i)
                            i[f].id && u.includes(i[f].id) && t.push(new ft(a,i,`all the sprites' ids must be unique, but ${i[f].id} is duplicated`)),
                            u.push(i[f].id),
                            i[f].url && p.includes(i[f].url) && t.push(new ft(a,i,`all the sprites' URLs must be unique, but ${i[f].url} is duplicated`)),
                            p.push(i[f].url),
                            t = t.concat(la({
                                key: `${a}[${f}]`,
                                value: i[f],
                                valueSpec: {
                                    id: {
                                        type: "string",
                                        required: !0
                                    },
                                    url: {
                                        type: "string",
                                        required: !0
                                    }
                                },
                                validateSpec: n.validateSpec
                            }));
                        return t
                    }
                    return fa({
                        key: a,
                        value: i
                    })
                }
                function Hh(n) {
                    return t = n.value,
                    t && t.constructor === Object ? [] : [new ft(n.key,n.value,`object expected, ${ei(n.value)} found`)];
                    var t
                }
                const Tl = {
                    "*": () => [],
                    array: bl,
                    boolean: function(n) {
                        const t = n.value
                          , i = n.key
                          , a = ei(t);
                        return a !== "boolean" ? [new ft(i,t,`boolean expected, ${a} found`)] : []
                    },
                    number: Mo,
                    color: Bc,
                    constants: Vh,
                    enum: Ao,
                    filter: Fc,
                    function: Vs,
                    layer: $n,
                    object: la,
                    source: Uh,
                    light: Gh,
                    sky: Gs,
                    terrain: Nc,
                    projection: function(n) {
                        const t = n.value
                          , i = n.styleSpec
                          , a = i.projection
                          , u = n.style
                          , p = ei(t);
                        if (t === void 0)
                            return [];
                        if (p !== "object")
                            return [new ft("projection",t,`object expected, ${p} found`)];
                        let f = [];
                        for (const g in t)
                            f = f.concat(a[g] ? n.validateSpec({
                                key: g,
                                value: t[g],
                                valueSpec: a[g],
                                style: u,
                                styleSpec: i
                            }) : [new ft(g,t[g],`unknown property "${g}"`)]);
                        return f
                    },
                    projectionDefinition: function(n) {
                        const t = n.key;
                        let i = n.value;
                        i = i instanceof String ? i.valueOf() : i;
                        const a = ei(i);
                        return a !== "array" || function(u) {
                            return Array.isArray(u) && u.length === 3 && typeof u[0] == "string" && typeof u[1] == "string" && typeof u[2] == "number"
                        }(i) || function(u) {
                            return !!["interpolate", "step", "literal"].includes(u[0])
                        }(i) ? ["array", "string"].includes(a) ? [] : [new ft(t,i,`projection expected, invalid type "${a}" found`)] : [new ft(t,i,`projection expected, invalid array ${JSON.stringify(i)} found`)]
                    },
                    string: fa,
                    formatted: function(n) {
                        return fa(n).length === 0 ? [] : Zs(n)
                    },
                    resolvedImage: function(n) {
                        return fa(n).length === 0 ? [] : Zs(n)
                    },
                    padding: function(n) {
                        const t = n.key
                          , i = n.value;
                        if (ei(i) === "array") {
                            if (i.length < 1 || i.length > 4)
                                return [new ft(t,i,`padding requires 1 to 4 values; ${i.length} values found`)];
                            const a = {
                                type: "number"
                            };
                            let u = [];
                            for (let p = 0; p < i.length; p++)
                                u = u.concat(n.validateSpec({
                                    key: `${t}[${p}]`,
                                    value: i[p],
                                    validateSpec: n.validateSpec,
                                    valueSpec: a
                                }));
                            return u
                        }
                        return Mo({
                            key: t,
                            value: i,
                            valueSpec: {}
                        })
                    },
                    numberArray: function(n) {
                        const t = n.key
                          , i = n.value;
                        if (ei(i) === "array") {
                            const a = {
                                type: "number"
                            };
                            if (i.length < 1)
                                return [new ft(t,i,"array length at least 1 expected, length 0 found")];
                            let u = [];
                            for (let p = 0; p < i.length; p++)
                                u = u.concat(n.validateSpec({
                                    key: `${t}[${p}]`,
                                    value: i[p],
                                    validateSpec: n.validateSpec,
                                    valueSpec: a
                                }));
                            return u
                        }
                        return Mo({
                            key: t,
                            value: i,
                            valueSpec: {}
                        })
                    },
                    colorArray: function(n) {
                        const t = n.key
                          , i = n.value;
                        if (ei(i) === "array") {
                            if (i.length < 1)
                                return [new ft(t,i,"array length at least 1 expected, length 0 found")];
                            let a = [];
                            for (let u = 0; u < i.length; u++)
                                a = a.concat(Bc({
                                    key: `${t}[${u}]`,
                                    value: i[u]
                                }));
                            return a
                        }
                        return Bc({
                            key: t,
                            value: i
                        })
                    },
                    variableAnchorOffsetCollection: function(n) {
                        const t = n.key
                          , i = n.value
                          , a = ei(i)
                          , u = n.styleSpec;
                        if (a !== "array" || i.length < 1 || i.length % 2 != 0)
                            return [new ft(t,i,"variableAnchorOffsetCollection requires a non-empty array of even length")];
                        let p = [];
                        for (let f = 0; f < i.length; f += 2)
                            p = p.concat(Ao({
                                key: `${t}[${f}]`,
                                value: i[f],
                                valueSpec: u.layout_symbol["text-anchor"]
                            })),
                            p = p.concat(bl({
                                key: `${t}[${f + 1}]`,
                                value: i[f + 1],
                                valueSpec: {
                                    length: 2,
                                    value: "number"
                                },
                                validateSpec: n.validateSpec,
                                style: n.style,
                                styleSpec: u
                            }));
                        return p
                    },
                    sprite: wl,
                    state: Hh
                };
                function Cl(n) {
                    const t = n.value
                      , i = n.valueSpec
                      , a = n.styleSpec;
                    return n.validateSpec = Cl,
                    i.expression && fs(ji(t)) ? Vs(n) : i.expression && ml(Wa(t)) ? Zs(n) : i.type && Tl[i.type] ? Tl[i.type](n) : la(Br({}, n, {
                        valueSpec: i.type ? a[i.type] : i
                    }))
                }
                function Hs(n) {
                    const t = n.value
                      , i = n.key
                      , a = fa(n);
                    return a.length || (t.indexOf("{fontstack}") === -1 && a.push(new ft(i,t,'"glyphs" url must include a "{fontstack}" token')),
                    t.indexOf("{range}") === -1 && a.push(new ft(i,t,'"glyphs" url must include a "{range}" token'))),
                    a
                }
                function ca(n, t=ye) {
                    let i = [];
                    return i = i.concat(Cl({
                        key: "",
                        value: n,
                        valueSpec: t.$root,
                        styleSpec: t,
                        style: n,
                        validateSpec: Cl,
                        objectElementValidators: {
                            glyphs: Hs,
                            "*": () => []
                        }
                    })),
                    n.constants && (i = i.concat(Vh({
                        key: "constants",
                        value: n.constants
                    }))),
                    Wh(i)
                }
                function ma(n) {
                    return function(t) {
                        return n({
                            ...t,
                            validateSpec: Cl
                        })
                    }
                }
                function Wh(n) {
                    return [].concat(n).sort( (t, i) => t.line - i.line)
                }
                function zn(n) {
                    return function(...t) {
                        return Wh(n.apply(this, t))
                    }
                }
                ca.source = zn(ma(Uh)),
                ca.sprite = zn(ma(wl)),
                ca.glyphs = zn(ma(Hs)),
                ca.light = zn(ma(Gh)),
                ca.sky = zn(ma(Gs)),
                ca.terrain = zn(ma(Nc)),
                ca.state = zn(ma(Hh)),
                ca.layer = zn(ma($n)),
                ca.filter = zn(ma(Fc)),
                ca.paintProperty = zn(ma($s)),
                ca.layoutProperty = zn(ma(Us));
                const Ws = ca
                  , pp = Ws.light
                  , Sl = Ws.sky
                  , fp = Ws.paintProperty
                  , jc = Ws.layoutProperty;
                function ko(n, t) {
                    let i = !1;
                    if (t && t.length)
                        for (const a of t)
                            n.fire(new Ee(new Error(a.message))),
                            i = !0;
                    return i
                }
                class Xs {
                    constructor(t, i, a) {
                        const u = this.cells = [];
                        if (t instanceof ArrayBuffer) {
                            this.arrayBuffer = t;
                            const f = new Int32Array(this.arrayBuffer);
                            t = f[0],
                            this.d = (i = f[1]) + 2 * (a = f[2]);
                            for (let y = 0; y < this.d * this.d; y++) {
                                const S = f[3 + y]
                                  , I = f[3 + y + 1];
                                u.push(S === I ? null : f.subarray(S, I))
                            }
                            const g = f[3 + u.length + 1];
                            this.keys = f.subarray(f[3 + u.length], g),
                            this.bboxes = f.subarray(g),
                            this.insert = this._insertReadonly
                        } else {
                            this.d = i + 2 * a;
                            for (let f = 0; f < this.d * this.d; f++)
                                u.push([]);
                            this.keys = [],
                            this.bboxes = []
                        }
                        this.n = i,
                        this.extent = t,
                        this.padding = a,
                        this.scale = i / t,
                        this.uid = 0;
                        const p = a / i * t;
                        this.min = -p,
                        this.max = t + p
                    }
                    insert(t, i, a, u, p) {
                        this._forEachCell(i, a, u, p, this._insertCell, this.uid++, void 0, void 0),
                        this.keys.push(t),
                        this.bboxes.push(i),
                        this.bboxes.push(a),
                        this.bboxes.push(u),
                        this.bboxes.push(p)
                    }
                    _insertReadonly() {
                        throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")
                    }
                    _insertCell(t, i, a, u, p, f) {
                        this.cells[p].push(f)
                    }
                    query(t, i, a, u, p) {
                        const f = this.min
                          , g = this.max;
                        if (t <= f && i <= f && g <= a && g <= u && !p)
                            return Array.prototype.slice.call(this.keys);
                        {
                            const y = [];
                            return this._forEachCell(t, i, a, u, this._queryCell, y, {}, p),
                            y
                        }
                    }
                    _queryCell(t, i, a, u, p, f, g, y) {
                        const S = this.cells[p];
                        if (S !== null) {
                            const I = this.keys
                              , A = this.bboxes;
                            for (let R = 0; R < S.length; R++) {
                                const N = S[R];
                                if (g[N] === void 0) {
                                    const j = 4 * N;
                                    (y ? y(A[j + 0], A[j + 1], A[j + 2], A[j + 3]) : t <= A[j + 2] && i <= A[j + 3] && a >= A[j + 0] && u >= A[j + 1]) ? (g[N] = !0,
                                    f.push(I[N])) : g[N] = !1
                                }
                            }
                        }
                    }
                    _forEachCell(t, i, a, u, p, f, g, y) {
                        const S = this._convertToCellCoord(t)
                          , I = this._convertToCellCoord(i)
                          , A = this._convertToCellCoord(a)
                          , R = this._convertToCellCoord(u);
                        for (let N = S; N <= A; N++)
                            for (let j = I; j <= R; j++) {
                                const $ = this.d * j + N;
                                if ((!y || y(this._convertFromCellCoord(N), this._convertFromCellCoord(j), this._convertFromCellCoord(N + 1), this._convertFromCellCoord(j + 1))) && p.call(this, t, i, a, u, $, f, g, y))
                                    return
                            }
                    }
                    _convertFromCellCoord(t) {
                        return (t - this.padding) / this.scale
                    }
                    _convertToCellCoord(t) {
                        return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding))
                    }
                    toArrayBuffer() {
                        if (this.arrayBuffer)
                            return this.arrayBuffer;
                        const t = this.cells
                          , i = 3 + this.cells.length + 1 + 1;
                        let a = 0;
                        for (let f = 0; f < this.cells.length; f++)
                            a += this.cells[f].length;
                        const u = new Int32Array(i + a + this.keys.length + this.bboxes.length);
                        u[0] = this.extent,
                        u[1] = this.n,
                        u[2] = this.padding;
                        let p = i;
                        for (let f = 0; f < t.length; f++) {
                            const g = t[f];
                            u[3 + f] = p,
                            u.set(g, p),
                            p += g.length
                        }
                        return u[3 + t.length] = p,
                        u.set(this.keys, p),
                        p += this.keys.length,
                        u[3 + t.length + 1] = p,
                        u.set(this.bboxes, p),
                        p += this.bboxes.length,
                        u.buffer
                    }
                    static serialize(t, i) {
                        const a = t.toArrayBuffer();
                        return i && i.push(a),
                        {
                            buffer: a
                        }
                    }
                    static deserialize(t) {
                        return new Xs(t.buffer)
                    }
                }
                const Pa = {};
                function Wt(n, t, i={}) {
                    if (Pa[n])
                        throw new Error(`${n} is already registered.`);
                    Object.defineProperty(t, "_classRegistryKey", {
                        value: n,
                        writeable: !1
                    }),
                    Pa[n] = {
                        klass: t,
                        omit: i.omit || [],
                        shallow: i.shallow || []
                    }
                }
                Wt("Object", Object),
                Wt("Set", Set),
                Wt("TransferableGridIndex", Xs),
                Wt("Color", Jr),
                Wt("Error", Error),
                Wt("AJAXError", ae),
                Wt("ResolvedImage", qn),
                Wt("StylePropertyFunction", So),
                Wt("StyleExpression", fl, {
                    omit: ["_evaluator"]
                }),
                Wt("ZoomDependentExpression", gl),
                Wt("ZoomConstantExpression", Co),
                Wt("CompoundExpression", oa, {
                    omit: ["_evaluate"]
                });
                for (const n in Bs)
                    Bs[n]._classRegistryKey || Wt(`Expression_${n}`, Bs[n]);
                function qc(n) {
                    return n && typeof ArrayBuffer < "u" && (n instanceof ArrayBuffer || n.constructor && n.constructor.name === "ArrayBuffer")
                }
                function Eo(n) {
                    return n.$name || n.constructor._classRegistryKey
                }
                function Vc(n) {
                    return !function(t) {
                        if (t === null || typeof t != "object")
                            return !1;
                        const i = Eo(t);
                        return !(!i || i === "Object")
                    }(n) && (n == null || typeof n == "boolean" || typeof n == "number" || typeof n == "string" || n instanceof Boolean || n instanceof Number || n instanceof String || n instanceof Date || n instanceof RegExp || n instanceof Blob || n instanceof Error || qc(n) || zr(n) || ArrayBuffer.isView(n) || n instanceof ImageData)
                }
                function zo(n, t) {
                    if (Vc(n))
                        return (qc(n) || zr(n)) && t && t.push(n),
                        ArrayBuffer.isView(n) && t && t.push(n.buffer),
                        n instanceof ImageData && t && t.push(n.data.buffer),
                        n;
                    if (Array.isArray(n)) {
                        const p = [];
                        for (const f of n)
                            p.push(zo(f, t));
                        return p
                    }
                    if (typeof n != "object")
                        throw new Error("can't serialize object of type " + typeof n);
                    const i = Eo(n);
                    if (!i)
                        throw new Error(`can't serialize object of unregistered class ${n.constructor.name}`);
                    if (!Pa[i])
                        throw new Error(`${i} is not registered.`);
                    const {klass: a} = Pa[i]
                      , u = a.serialize ? a.serialize(n, t) : {};
                    if (a.serialize) {
                        if (t && u === t[t.length - 1])
                            throw new Error("statically serialized object won't survive transfer of $name property")
                    } else {
                        for (const p in n) {
                            if (!n.hasOwnProperty(p) || Pa[i].omit.indexOf(p) >= 0)
                                continue;
                            const f = n[p];
                            u[p] = Pa[i].shallow.indexOf(p) >= 0 ? f : zo(f, t)
                        }
                        n instanceof Error && (u.message = n.message)
                    }
                    if (u.$name)
                        throw new Error("$name property is reserved for worker serialization logic.");
                    return i !== "Object" && (u.$name = i),
                    u
                }
                function Ks(n) {
                    if (Vc(n))
                        return n;
                    if (Array.isArray(n))
                        return n.map(Ks);
                    if (typeof n != "object")
                        throw new Error("can't deserialize object of type " + typeof n);
                    const t = Eo(n) || "Object";
                    if (!Pa[t])
                        throw new Error(`can't deserialize unregistered class ${t}`);
                    const {klass: i} = Pa[t];
                    if (!i)
                        throw new Error(`can't deserialize unregistered class ${t}`);
                    if (i.deserialize)
                        return i.deserialize(n);
                    const a = Object.create(i.prototype);
                    for (const u of Object.keys(n)) {
                        if (u === "$name")
                            continue;
                        const p = n[u];
                        a[u] = Pa[t].shallow.indexOf(u) >= 0 ? p : Ks(p)
                    }
                    return a
                }
                class Zc {
                    constructor() {
                        this.first = !0
                    }
                    update(t, i) {
                        const a = Math.floor(t);
                        return this.first ? (this.first = !1,
                        this.lastIntegerZoom = a,
                        this.lastIntegerZoomTime = 0,
                        this.lastZoom = t,
                        this.lastFloorZoom = a,
                        !0) : (this.lastFloorZoom > a ? (this.lastIntegerZoom = a + 1,
                        this.lastIntegerZoomTime = i) : this.lastFloorZoom < a && (this.lastIntegerZoom = a,
                        this.lastIntegerZoomTime = i),
                        t !== this.lastZoom && (this.lastZoom = t,
                        this.lastFloorZoom = a,
                        !0))
                    }
                }
                const ti = {
                    "Latin-1 Supplement": n => n >= 128 && n <= 255,
                    "Hangul Jamo": n => n >= 4352 && n <= 4607,
                    Khmer: n => n >= 6016 && n <= 6143,
                    "General Punctuation": n => n >= 8192 && n <= 8303,
                    "Letterlike Symbols": n => n >= 8448 && n <= 8527,
                    "Number Forms": n => n >= 8528 && n <= 8591,
                    "Miscellaneous Technical": n => n >= 8960 && n <= 9215,
                    "Control Pictures": n => n >= 9216 && n <= 9279,
                    "Optical Character Recognition": n => n >= 9280 && n <= 9311,
                    "Enclosed Alphanumerics": n => n >= 9312 && n <= 9471,
                    "Geometric Shapes": n => n >= 9632 && n <= 9727,
                    "Miscellaneous Symbols": n => n >= 9728 && n <= 9983,
                    "Miscellaneous Symbols and Arrows": n => n >= 11008 && n <= 11263,
                    "Ideographic Description Characters": n => n >= 12272 && n <= 12287,
                    "CJK Symbols and Punctuation": n => n >= 12288 && n <= 12351,
                    Hiragana: n => n >= 12352 && n <= 12447,
                    Katakana: n => n >= 12448 && n <= 12543,
                    Kanbun: n => n >= 12688 && n <= 12703,
                    "CJK Strokes": n => n >= 12736 && n <= 12783,
                    "Enclosed CJK Letters and Months": n => n >= 12800 && n <= 13055,
                    "CJK Compatibility": n => n >= 13056 && n <= 13311,
                    "Yijing Hexagram Symbols": n => n >= 19904 && n <= 19967,
                    "CJK Unified Ideographs": n => n >= 19968 && n <= 40959,
                    "Hangul Syllables": n => n >= 44032 && n <= 55215,
                    "Private Use Area": n => n >= 57344 && n <= 63743,
                    "Vertical Forms": n => n >= 65040 && n <= 65055,
                    "CJK Compatibility Forms": n => n >= 65072 && n <= 65103,
                    "Small Form Variants": n => n >= 65104 && n <= 65135,
                    "Halfwidth and Fullwidth Forms": n => n >= 65280 && n <= 65519
                };
                function $c(n) {
                    for (const t of n)
                        if (Il(t.charCodeAt(0)))
                            return !0;
                    return !1
                }
                function Xh(n) {
                    for (const t of n)
                        if (!_p(t.charCodeAt(0)))
                            return !1;
                    return !0
                }
                function Pl(n) {
                    const t = n.map(i => {
                        try {
                            return new RegExp(`\\p{sc=${i}}`,"u").source
                        } catch {
                            return null
                        }
                    }
                    ).filter(i => i);
                    return new RegExp(t.join("|"),"u")
                }
                const mp = Pl(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
                function _p(n) {
                    return !mp.test(String.fromCodePoint(n))
                }
                const Uc = Pl(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
                function Il(n) {
                    return !(n !== 746 && n !== 747 && (n < 4352 || !(ti["CJK Compatibility Forms"](n) && !(n >= 65097 && n <= 65103) || ti["CJK Compatibility"](n) || ti["CJK Strokes"](n) || !(!ti["CJK Symbols and Punctuation"](n) || n >= 12296 && n <= 12305 || n >= 12308 && n <= 12319 || n === 12336) || ti["Enclosed CJK Letters and Months"](n) || ti["Ideographic Description Characters"](n) || ti.Kanbun(n) || ti.Katakana(n) && n !== 12540 || !(!ti["Halfwidth and Fullwidth Forms"](n) || n === 65288 || n === 65289 || n === 65293 || n >= 65306 && n <= 65310 || n === 65339 || n === 65341 || n === 65343 || n >= 65371 && n <= 65503 || n === 65507 || n >= 65512 && n <= 65519) || !(!ti["Small Form Variants"](n) || n >= 65112 && n <= 65118 || n >= 65123 && n <= 65126) || ti["Vertical Forms"](n) || ti["Yijing Hexagram Symbols"](n) || new RegExp("\\p{sc=Cans}","u").test(String.fromCodePoint(n)) || new RegExp("\\p{sc=Hang}","u").test(String.fromCodePoint(n)) || Uc.test(String.fromCodePoint(n)))))
                }
                function Gc(n) {
                    return !(Il(n) || function(t) {
                        return !!(ti["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || ti["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || ti["Letterlike Symbols"](t) || ti["Number Forms"](t) || ti["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || ti["Control Pictures"](t) && t !== 9251 || ti["Optical Character Recognition"](t) || ti["Enclosed Alphanumerics"](t) || ti["Geometric Shapes"](t) || ti["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || ti["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || ti["CJK Symbols and Punctuation"](t) || ti.Katakana(t) || ti["Private Use Area"](t) || ti["CJK Compatibility Forms"](t) || ti["Small Form Variants"](t) || ti["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533)
                    }(n))
                }
                const Kh = Pl(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
                function Lo(n) {
                    return Kh.test(String.fromCodePoint(n))
                }
                function gp(n, t) {
                    return !(!t && Lo(n) || n >= 2304 && n <= 3583 || n >= 3840 && n <= 4255 || ti.Khmer(n))
                }
                function Hc(n) {
                    for (const t of n)
                        if (Lo(t.charCodeAt(0)))
                            return !0;
                    return !1
                }
                const Xa = new class {
                    constructor() {
                        this.TIMEOUT = 5e3,
                        this.applyArabicShaping = null,
                        this.processBidirectionalText = null,
                        this.processStyledBidirectionalText = null,
                        this.pluginStatus = "unavailable",
                        this.pluginURL = null,
                        this.loadScriptResolve = () => {}
                    }
                    setState(n) {
                        this.pluginStatus = n.pluginStatus,
                        this.pluginURL = n.pluginURL
                    }
                    getState() {
                        return {
                            pluginStatus: this.pluginStatus,
                            pluginURL: this.pluginURL
                        }
                    }
                    setMethods(n) {
                        if (Xa.isParsed())
                            throw new Error("RTL text plugin already registered.");
                        this.applyArabicShaping = n.applyArabicShaping,
                        this.processBidirectionalText = n.processBidirectionalText,
                        this.processStyledBidirectionalText = n.processStyledBidirectionalText,
                        this.loadScriptResolve()
                    }
                    isParsed() {
                        return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null
                    }
                    getRTLTextPluginStatus() {
                        return this.pluginStatus
                    }
                    syncState(n, t) {
                        return o(this, void 0, void 0, function*() {
                            if (this.isParsed())
                                return this.getState();
                            if (n.pluginStatus !== "loading")
                                return this.setState(n),
                                n;
                            const i = n.pluginURL
                              , a = new Promise(p => {
                                this.loadScriptResolve = p
                            }
                            );
                            t(i);
                            const u = new Promise(p => setTimeout( () => p(), this.TIMEOUT));
                            if (yield Promise.race([a, u]),
                            this.isParsed()) {
                                const p = {
                                    pluginStatus: "loaded",
                                    pluginURL: i
                                };
                                return this.setState(p),
                                p
                            }
                            throw this.setState({
                                pluginStatus: "error",
                                pluginURL: ""
                            }),
                            new Error(`RTL Text Plugin failed to import scripts from ${i}`)
                        })
                    }
                }
                ;
                class Ei {
                    constructor(t, i) {
                        this.zoom = t,
                        i ? (this.now = i.now || 0,
                        this.fadeDuration = i.fadeDuration || 0,
                        this.zoomHistory = i.zoomHistory || new Zc,
                        this.transition = i.transition || {},
                        this.globalState = i.globalState || {}) : (this.now = 0,
                        this.fadeDuration = 0,
                        this.zoomHistory = new Zc,
                        this.transition = {},
                        this.globalState = {})
                    }
                    isSupportedScript(t) {
                        return function(i, a) {
                            for (const u of i)
                                if (!gp(u.charCodeAt(0), a))
                                    return !1;
                            return !0
                        }(t, Xa.getRTLTextPluginStatus() === "loaded")
                    }
                    crossFadingFactor() {
                        return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
                    }
                    getCrossfadeParameters() {
                        const t = this.zoom
                          , i = t - Math.floor(t)
                          , a = this.crossFadingFactor();
                        return t > this.zoomHistory.lastIntegerZoom ? {
                            fromScale: 2,
                            toScale: 1,
                            t: i + (1 - i) * a
                        } : {
                            fromScale: .5,
                            toScale: 1,
                            t: 1 - (1 - a) * i
                        }
                    }
                }
                class Do {
                    constructor(t, i) {
                        this.property = t,
                        this.value = i,
                        this.expression = function(a, u) {
                            if (fs(a))
                                return new So(a,u);
                            if (ml(a)) {
                                const p = Lc(a, u);
                                if (p.result === "error")
                                    throw new Error(p.value.map(f => `${f.key}: ${f.message}`).join(", "));
                                return p.value
                            }
                            {
                                let p = a;
                                return u.type === "color" && typeof a == "string" ? p = Jr.parse(a) : u.type !== "padding" || typeof a != "number" && !Array.isArray(a) ? u.type !== "numberArray" || typeof a != "number" && !Array.isArray(a) ? u.type !== "colorArray" || typeof a != "string" && !Array.isArray(a) ? u.type === "variableAnchorOffsetCollection" && Array.isArray(a) ? p = ai.parse(a) : u.type === "projectionDefinition" && typeof a == "string" && (p = Hr.parse(a)) : p = on.parse(a) : p = sn.parse(a) : p = Li.parse(a),
                                {
                                    globalStateRefs: new Set,
                                    kind: "constant",
                                    evaluate: () => p
                                }
                            }
                        }(i === void 0 ? t.specification.default : i, t.specification)
                    }
                    isDataDriven() {
                        return this.expression.kind === "source" || this.expression.kind === "composite"
                    }
                    getGlobalStateRefs() {
                        return this.expression.globalStateRefs || new Set
                    }
                    possiblyEvaluate(t, i, a) {
                        return this.property.possiblyEvaluate(this, t, i, a)
                    }
                }
                class Ml {
                    constructor(t) {
                        this.property = t,
                        this.value = new Do(t,void 0)
                    }
                    transitioned(t, i) {
                        return new Yh(this.property,this.value,i,Pt({}, t.transition, this.transition),t.now)
                    }
                    untransitioned() {
                        return new Yh(this.property,this.value,null,{},0)
                    }
                }
                class Wc {
                    constructor(t) {
                        this._properties = t,
                        this._values = Object.create(t.defaultTransitionablePropertyValues)
                    }
                    getValue(t) {
                        return xr(this._values[t].value.value)
                    }
                    setValue(t, i) {
                        Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Ml(this._values[t].property)),
                        this._values[t].value = new Do(this._values[t].property,i === null ? void 0 : xr(i))
                    }
                    getTransition(t) {
                        return xr(this._values[t].transition)
                    }
                    setTransition(t, i) {
                        Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Ml(this._values[t].property)),
                        this._values[t].transition = xr(i) || void 0
                    }
                    serialize() {
                        const t = {};
                        for (const i of Object.keys(this._values)) {
                            const a = this.getValue(i);
                            a !== void 0 && (t[i] = a);
                            const u = this.getTransition(i);
                            u !== void 0 && (t[`${i}-transition`] = u)
                        }
                        return t
                    }
                    transitioned(t, i) {
                        const a = new Jh(this._properties);
                        for (const u of Object.keys(this._values))
                            a._values[u] = this._values[u].transitioned(t, i._values[u]);
                        return a
                    }
                    untransitioned() {
                        const t = new Jh(this._properties);
                        for (const i of Object.keys(this._values))
                            t._values[i] = this._values[i].untransitioned();
                        return t
                    }
                }
                class Yh {
                    constructor(t, i, a, u, p) {
                        this.property = t,
                        this.value = i,
                        this.begin = p + u.delay || 0,
                        this.end = this.begin + u.duration || 0,
                        t.specification.transition && (u.delay || u.duration) && (this.prior = a)
                    }
                    possiblyEvaluate(t, i, a) {
                        const u = t.now || 0
                          , p = this.value.possiblyEvaluate(t, i, a)
                          , f = this.prior;
                        if (f) {
                            if (u > this.end)
                                return this.prior = null,
                                p;
                            if (this.value.isDataDriven())
                                return this.prior = null,
                                p;
                            if (u < this.begin)
                                return f.possiblyEvaluate(t, i, a);
                            {
                                const g = (u - this.begin) / (this.end - this.begin);
                                return this.property.interpolate(f.possiblyEvaluate(t, i, a), p, Ft(g))
                            }
                        }
                        return p
                    }
                }
                class Jh {
                    constructor(t) {
                        this._properties = t,
                        this._values = Object.create(t.defaultTransitioningPropertyValues)
                    }
                    possiblyEvaluate(t, i, a) {
                        const u = new Al(this._properties);
                        for (const p of Object.keys(this._values))
                            u._values[p] = this._values[p].possiblyEvaluate(t, i, a);
                        return u
                    }
                    hasTransition() {
                        for (const t of Object.keys(this._values))
                            if (this._values[t].prior)
                                return !0;
                        return !1
                    }
                }
                class vp {
                    constructor(t) {
                        this._properties = t,
                        this._values = Object.create(t.defaultPropertyValues)
                    }
                    hasValue(t) {
                        return this._values[t].value !== void 0
                    }
                    getValue(t) {
                        return xr(this._values[t].value)
                    }
                    setValue(t, i) {
                        this._values[t] = new Do(this._values[t].property,i === null ? void 0 : xr(i))
                    }
                    serialize() {
                        const t = {};
                        for (const i of Object.keys(this._values)) {
                            const a = this.getValue(i);
                            a !== void 0 && (t[i] = a)
                        }
                        return t
                    }
                    possiblyEvaluate(t, i, a) {
                        const u = new Al(this._properties);
                        for (const p of Object.keys(this._values))
                            u._values[p] = this._values[p].possiblyEvaluate(t, i, a);
                        return u
                    }
                }
                class Ia {
                    constructor(t, i, a) {
                        this.property = t,
                        this.value = i,
                        this.parameters = a
                    }
                    isConstant() {
                        return this.value.kind === "constant"
                    }
                    constantOr(t) {
                        return this.value.kind === "constant" ? this.value.value : t
                    }
                    evaluate(t, i, a, u) {
                        return this.property.evaluate(this.value, this.parameters, t, i, a, u)
                    }
                }
                class Al {
                    constructor(t) {
                        this._properties = t,
                        this._values = Object.create(t.defaultPossiblyEvaluatedValues)
                    }
                    get(t) {
                        return this._values[t]
                    }
                }
                class ar {
                    constructor(t) {
                        this.specification = t
                    }
                    possiblyEvaluate(t, i) {
                        if (t.isDataDriven())
                            throw new Error("Value should not be data driven");
                        return t.expression.evaluate(i)
                    }
                    interpolate(t, i, a) {
                        const u = ta[this.specification.type];
                        return u ? u(t, i, a) : t
                    }
                }
                class Rr {
                    constructor(t, i) {
                        this.specification = t,
                        this.overrides = i
                    }
                    possiblyEvaluate(t, i, a, u) {
                        return new Ia(this,t.expression.kind === "constant" || t.expression.kind === "camera" ? {
                            kind: "constant",
                            value: t.expression.evaluate(i, null, {}, a, u)
                        } : t.expression,i)
                    }
                    interpolate(t, i, a) {
                        if (t.value.kind !== "constant" || i.value.kind !== "constant")
                            return t;
                        if (t.value.value === void 0 || i.value.value === void 0)
                            return new Ia(this,{
                                kind: "constant",
                                value: void 0
                            },t.parameters);
                        const u = ta[this.specification.type];
                        if (u) {
                            const p = u(t.value.value, i.value.value, a);
                            return new Ia(this,{
                                kind: "constant",
                                value: p
                            },t.parameters)
                        }
                        return t
                    }
                    evaluate(t, i, a, u, p, f) {
                        return t.kind === "constant" ? t.value : t.evaluate(i, a, u, p, f)
                    }
                }
                class kl extends Rr {
                    possiblyEvaluate(t, i, a, u) {
                        if (t.value === void 0)
                            return new Ia(this,{
                                kind: "constant",
                                value: void 0
                            },i);
                        if (t.expression.kind === "constant") {
                            const p = t.expression.evaluate(i, null, {}, a, u)
                              , f = t.property.specification.type === "resolvedImage" && typeof p != "string" ? p.name : p
                              , g = this._calculate(f, f, f, i);
                            return new Ia(this,{
                                kind: "constant",
                                value: g
                            },i)
                        }
                        if (t.expression.kind === "camera") {
                            const p = this._calculate(t.expression.evaluate({
                                zoom: i.zoom - 1
                            }), t.expression.evaluate({
                                zoom: i.zoom
                            }), t.expression.evaluate({
                                zoom: i.zoom + 1
                            }), i);
                            return new Ia(this,{
                                kind: "constant",
                                value: p
                            },i)
                        }
                        return new Ia(this,t.expression,i)
                    }
                    evaluate(t, i, a, u, p, f) {
                        if (t.kind === "source") {
                            const g = t.evaluate(i, a, u, p, f);
                            return this._calculate(g, g, g, i)
                        }
                        return t.kind === "composite" ? this._calculate(t.evaluate({
                            zoom: Math.floor(i.zoom) - 1
                        }, a, u), t.evaluate({
                            zoom: Math.floor(i.zoom)
                        }, a, u), t.evaluate({
                            zoom: Math.floor(i.zoom) + 1
                        }, a, u), i) : t.value
                    }
                    _calculate(t, i, a, u) {
                        return u.zoom > u.zoomHistory.lastIntegerZoom ? {
                            from: t,
                            to: i
                        } : {
                            from: a,
                            to: i
                        }
                    }
                    interpolate(t) {
                        return t
                    }
                }
                class Xc {
                    constructor(t) {
                        this.specification = t
                    }
                    possiblyEvaluate(t, i, a, u) {
                        if (t.value !== void 0) {
                            if (t.expression.kind === "constant") {
                                const p = t.expression.evaluate(i, null, {}, a, u);
                                return this._calculate(p, p, p, i)
                            }
                            return this._calculate(t.expression.evaluate(new Ei(Math.floor(i.zoom - 1),i)), t.expression.evaluate(new Ei(Math.floor(i.zoom),i)), t.expression.evaluate(new Ei(Math.floor(i.zoom + 1),i)), i)
                        }
                    }
                    _calculate(t, i, a, u) {
                        return u.zoom > u.zoomHistory.lastIntegerZoom ? {
                            from: t,
                            to: i
                        } : {
                            from: a,
                            to: i
                        }
                    }
                    interpolate(t) {
                        return t
                    }
                }
                class Ro {
                    constructor(t) {
                        this.specification = t
                    }
                    possiblyEvaluate(t, i, a, u) {
                        return !!t.expression.evaluate(i, null, {}, a, u)
                    }
                    interpolate() {
                        return !1
                    }
                }
                class Ln {
                    constructor(t) {
                        this.properties = t,
                        this.defaultPropertyValues = {},
                        this.defaultTransitionablePropertyValues = {},
                        this.defaultTransitioningPropertyValues = {},
                        this.defaultPossiblyEvaluatedValues = {},
                        this.overridableProperties = [];
                        for (const i in t) {
                            const a = t[i];
                            a.specification.overridable && this.overridableProperties.push(i);
                            const u = this.defaultPropertyValues[i] = new Do(a,void 0)
                              , p = this.defaultTransitionablePropertyValues[i] = new Ml(a);
                            this.defaultTransitioningPropertyValues[i] = p.untransitioned(),
                            this.defaultPossiblyEvaluatedValues[i] = u.possiblyEvaluate({})
                        }
                    }
                }
                Wt("DataDrivenProperty", Rr),
                Wt("DataConstantProperty", ar),
                Wt("CrossFadedDataDrivenProperty", kl),
                Wt("CrossFadedProperty", Xc),
                Wt("ColorRampProperty", Ro);
                const Qh = "-transition";
                class gn extends Ke {
                    constructor(t, i) {
                        if (super(),
                        this.id = t.id,
                        this.type = t.type,
                        this._featureFilter = {
                            filter: () => !0,
                            needGeometry: !1,
                            getGlobalStateRefs: () => new Set
                        },
                        t.type !== "custom" && (this.metadata = t.metadata,
                        this.minzoom = t.minzoom,
                        this.maxzoom = t.maxzoom,
                        t.type !== "background" && (this.source = t.source,
                        this.sourceLayer = t["source-layer"],
                        this.filter = t.filter,
                        this._featureFilter = Ha(t.filter)),
                        i.layout && (this._unevaluatedLayout = new vp(i.layout)),
                        i.paint)) {
                            this._transitionablePaint = new Wc(i.paint);
                            for (const a in t.paint)
                                this.setPaintProperty(a, t.paint[a], {
                                    validate: !1
                                });
                            for (const a in t.layout)
                                this.setLayoutProperty(a, t.layout[a], {
                                    validate: !1
                                });
                            this._transitioningPaint = this._transitionablePaint.untransitioned(),
                            this.paint = new Al(i.paint)
                        }
                    }
                    setFilter(t) {
                        this.filter = t,
                        this._featureFilter = Ha(t)
                    }
                    getCrossfadeParameters() {
                        return this._crossfadeParameters
                    }
                    getLayoutProperty(t) {
                        return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t)
                    }
                    getLayoutAffectingGlobalStateRefs() {
                        const t = new Set;
                        if (this._unevaluatedLayout)
                            for (const i in this._unevaluatedLayout._values) {
                                const a = this._unevaluatedLayout._values[i];
                                for (const u of a.getGlobalStateRefs())
                                    t.add(u)
                            }
                        for (const i of this._featureFilter.getGlobalStateRefs())
                            t.add(i);
                        return t
                    }
                    setLayoutProperty(t, i, a={}) {
                        i != null && this._validate(jc, `layers.${this.id}.layout.${t}`, t, i, a) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, i) : this.visibility = i)
                    }
                    getPaintProperty(t) {
                        return t.endsWith(Qh) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t)
                    }
                    setPaintProperty(t, i, a={}) {
                        if (i != null && this._validate(fp, `layers.${this.id}.paint.${t}`, t, i, a))
                            return !1;
                        if (t.endsWith(Qh))
                            return this._transitionablePaint.setTransition(t.slice(0, -11), i || void 0),
                            !1;
                        {
                            const u = this._transitionablePaint._values[t]
                              , p = u.property.specification["property-type"] === "cross-faded-data-driven"
                              , f = u.value.isDataDriven()
                              , g = u.value;
                            this._transitionablePaint.setValue(t, i),
                            this._handleSpecialPaintPropertyUpdate(t);
                            const y = this._transitionablePaint._values[t].value;
                            return y.isDataDriven() || f || p || this._handleOverridablePaintPropertyUpdate(t, g, y)
                        }
                    }
                    _handleSpecialPaintPropertyUpdate(t) {}
                    _handleOverridablePaintPropertyUpdate(t, i, a) {
                        return !1
                    }
                    isHidden(t) {
                        return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none"
                    }
                    updateTransitions(t) {
                        this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint)
                    }
                    hasTransition() {
                        return this._transitioningPaint.hasTransition()
                    }
                    recalculate(t, i) {
                        t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()),
                        this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, i)),
                        this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, i)
                    }
                    serialize() {
                        const t = {
                            id: this.id,
                            type: this.type,
                            source: this.source,
                            "source-layer": this.sourceLayer,
                            metadata: this.metadata,
                            minzoom: this.minzoom,
                            maxzoom: this.maxzoom,
                            filter: this.filter,
                            layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                            paint: this._transitionablePaint && this._transitionablePaint.serialize()
                        };
                        return this.visibility && (t.layout = t.layout || {},
                        t.layout.visibility = this.visibility),
                        nr(t, (i, a) => !(i === void 0 || a === "layout" && !Object.keys(i).length || a === "paint" && !Object.keys(i).length))
                    }
                    _validate(t, i, a, u, p={}) {
                        return (!p || p.validate !== !1) && ko(this, t.call(Ws, {
                            key: i,
                            layerType: this.type,
                            objectKey: a,
                            value: u,
                            styleSpec: ye,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            }
                        }))
                    }
                    is3D() {
                        return !1
                    }
                    isTileClipped() {
                        return !1
                    }
                    hasOffscreenPass() {
                        return !1
                    }
                    resize() {}
                    isStateDependent() {
                        for (const t in this.paint._values) {
                            const i = this.paint.get(t);
                            if (i instanceof Ia && Ns(i.property.specification) && (i.value.kind === "source" || i.value.kind === "composite") && i.value.isStateDependent)
                                return !0
                        }
                        return !1
                    }
                }
                const ed = {
                    Int8: Int8Array,
                    Uint8: Uint8Array,
                    Int16: Int16Array,
                    Uint16: Uint16Array,
                    Int32: Int32Array,
                    Uint32: Uint32Array,
                    Float32: Float32Array
                };
                class ms {
                    constructor(t, i) {
                        this._structArray = t,
                        this._pos1 = i * this.size,
                        this._pos2 = this._pos1 / 2,
                        this._pos4 = this._pos1 / 4,
                        this._pos8 = this._pos1 / 8
                    }
                }
                class Ri {
                    constructor() {
                        this.isTransferred = !1,
                        this.capacity = -1,
                        this.resize(0)
                    }
                    static serialize(t, i) {
                        return t._trim(),
                        i && (t.isTransferred = !0,
                        i.push(t.arrayBuffer)),
                        {
                            length: t.length,
                            arrayBuffer: t.arrayBuffer
                        }
                    }
                    static deserialize(t) {
                        const i = Object.create(this.prototype);
                        return i.arrayBuffer = t.arrayBuffer,
                        i.length = t.length,
                        i.capacity = t.arrayBuffer.byteLength / i.bytesPerElement,
                        i._refreshViews(),
                        i
                    }
                    _trim() {
                        this.length !== this.capacity && (this.capacity = this.length,
                        this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement),
                        this._refreshViews())
                    }
                    clear() {
                        this.length = 0
                    }
                    resize(t) {
                        this.reserve(t),
                        this.length = t
                    }
                    reserve(t) {
                        if (t > this.capacity) {
                            this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128),
                            this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                            const i = this.uint8;
                            this._refreshViews(),
                            i && this.uint8.set(i)
                        }
                    }
                    _refreshViews() {
                        throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
                    }
                }
                function qi(n, t=1) {
                    let i = 0
                      , a = 0;
                    return {
                        members: n.map(u => {
                            const p = ed[u.type].BYTES_PER_ELEMENT
                              , f = i = td(i, Math.max(t, p))
                              , g = u.components || 1;
                            return a = Math.max(a, p),
                            i += p * g,
                            {
                                name: u.name,
                                type: u.type,
                                components: g,
                                offset: f
                            }
                        }
                        ),
                        size: td(i, Math.max(a, t)),
                        alignment: t
                    }
                }
                function td(n, t) {
                    return Math.ceil(n / t) * t
                }
                class Ka extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i) {
                        const a = this.length;
                        return this.resize(a + 1),
                        this.emplace(a, t, i)
                    }
                    emplace(t, i, a) {
                        const u = 2 * t;
                        return this.int16[u + 0] = i,
                        this.int16[u + 1] = a,
                        t
                    }
                }
                Ka.prototype.bytesPerElement = 4,
                Wt("StructArrayLayout2i4", Ka);
                class Ya extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i, a) {
                        const u = this.length;
                        return this.resize(u + 1),
                        this.emplace(u, t, i, a)
                    }
                    emplace(t, i, a, u) {
                        const p = 3 * t;
                        return this.int16[p + 0] = i,
                        this.int16[p + 1] = a,
                        this.int16[p + 2] = u,
                        t
                    }
                }
                Ya.prototype.bytesPerElement = 6,
                Wt("StructArrayLayout3i6", Ya);
                class Kc extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i, a, u) {
                        const p = this.length;
                        return this.resize(p + 1),
                        this.emplace(p, t, i, a, u)
                    }
                    emplace(t, i, a, u, p) {
                        const f = 4 * t;
                        return this.int16[f + 0] = i,
                        this.int16[f + 1] = a,
                        this.int16[f + 2] = u,
                        this.int16[f + 3] = p,
                        t
                    }
                }
                Kc.prototype.bytesPerElement = 8,
                Wt("StructArrayLayout4i8", Kc);
                class El extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i, a, u, p, f) {
                        const g = this.length;
                        return this.resize(g + 1),
                        this.emplace(g, t, i, a, u, p, f)
                    }
                    emplace(t, i, a, u, p, f, g) {
                        const y = 6 * t;
                        return this.int16[y + 0] = i,
                        this.int16[y + 1] = a,
                        this.int16[y + 2] = u,
                        this.int16[y + 3] = p,
                        this.int16[y + 4] = f,
                        this.int16[y + 5] = g,
                        t
                    }
                }
                El.prototype.bytesPerElement = 12,
                Wt("StructArrayLayout2i4i12", El);
                class _s extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i, a, u, p, f) {
                        const g = this.length;
                        return this.resize(g + 1),
                        this.emplace(g, t, i, a, u, p, f)
                    }
                    emplace(t, i, a, u, p, f, g) {
                        const y = 4 * t
                          , S = 8 * t;
                        return this.int16[y + 0] = i,
                        this.int16[y + 1] = a,
                        this.uint8[S + 4] = u,
                        this.uint8[S + 5] = p,
                        this.uint8[S + 6] = f,
                        this.uint8[S + 7] = g,
                        t
                    }
                }
                _s.prototype.bytesPerElement = 8,
                Wt("StructArrayLayout2i4ub8", _s);
                class Bo extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i) {
                        const a = this.length;
                        return this.resize(a + 1),
                        this.emplace(a, t, i)
                    }
                    emplace(t, i, a) {
                        const u = 2 * t;
                        return this.float32[u + 0] = i,
                        this.float32[u + 1] = a,
                        t
                    }
                }
                Bo.prototype.bytesPerElement = 8,
                Wt("StructArrayLayout2f8", Bo);
                class Yc extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i, a, u, p, f, g, y, S, I) {
                        const A = this.length;
                        return this.resize(A + 1),
                        this.emplace(A, t, i, a, u, p, f, g, y, S, I)
                    }
                    emplace(t, i, a, u, p, f, g, y, S, I, A) {
                        const R = 10 * t;
                        return this.uint16[R + 0] = i,
                        this.uint16[R + 1] = a,
                        this.uint16[R + 2] = u,
                        this.uint16[R + 3] = p,
                        this.uint16[R + 4] = f,
                        this.uint16[R + 5] = g,
                        this.uint16[R + 6] = y,
                        this.uint16[R + 7] = S,
                        this.uint16[R + 8] = I,
                        this.uint16[R + 9] = A,
                        t
                    }
                }
                Yc.prototype.bytesPerElement = 20,
                Wt("StructArrayLayout10ui20", Yc);
                class zl extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i, a, u, p, f, g, y, S, I, A, R) {
                        const N = this.length;
                        return this.resize(N + 1),
                        this.emplace(N, t, i, a, u, p, f, g, y, S, I, A, R)
                    }
                    emplace(t, i, a, u, p, f, g, y, S, I, A, R, N) {
                        const j = 12 * t;
                        return this.int16[j + 0] = i,
                        this.int16[j + 1] = a,
                        this.int16[j + 2] = u,
                        this.int16[j + 3] = p,
                        this.uint16[j + 4] = f,
                        this.uint16[j + 5] = g,
                        this.uint16[j + 6] = y,
                        this.uint16[j + 7] = S,
                        this.int16[j + 8] = I,
                        this.int16[j + 9] = A,
                        this.int16[j + 10] = R,
                        this.int16[j + 11] = N,
                        t
                    }
                }
                zl.prototype.bytesPerElement = 24,
                Wt("StructArrayLayout4i4ui4i24", zl);
                class Jc extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i, a) {
                        const u = this.length;
                        return this.resize(u + 1),
                        this.emplace(u, t, i, a)
                    }
                    emplace(t, i, a, u) {
                        const p = 3 * t;
                        return this.float32[p + 0] = i,
                        this.float32[p + 1] = a,
                        this.float32[p + 2] = u,
                        t
                    }
                }
                Jc.prototype.bytesPerElement = 12,
                Wt("StructArrayLayout3f12", Jc);
                class h extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer)
                    }
                    emplaceBack(t) {
                        const i = this.length;
                        return this.resize(i + 1),
                        this.emplace(i, t)
                    }
                    emplace(t, i) {
                        return this.uint32[1 * t + 0] = i,
                        t
                    }
                }
                h.prototype.bytesPerElement = 4,
                Wt("StructArrayLayout1ul4", h);
                class e extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i, a, u, p, f, g, y, S) {
                        const I = this.length;
                        return this.resize(I + 1),
                        this.emplace(I, t, i, a, u, p, f, g, y, S)
                    }
                    emplace(t, i, a, u, p, f, g, y, S, I) {
                        const A = 10 * t
                          , R = 5 * t;
                        return this.int16[A + 0] = i,
                        this.int16[A + 1] = a,
                        this.int16[A + 2] = u,
                        this.int16[A + 3] = p,
                        this.int16[A + 4] = f,
                        this.int16[A + 5] = g,
                        this.uint32[R + 3] = y,
                        this.uint16[A + 8] = S,
                        this.uint16[A + 9] = I,
                        t
                    }
                }
                e.prototype.bytesPerElement = 20,
                Wt("StructArrayLayout6i1ul2ui20", e);
                class r extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i, a, u, p, f) {
                        const g = this.length;
                        return this.resize(g + 1),
                        this.emplace(g, t, i, a, u, p, f)
                    }
                    emplace(t, i, a, u, p, f, g) {
                        const y = 6 * t;
                        return this.int16[y + 0] = i,
                        this.int16[y + 1] = a,
                        this.int16[y + 2] = u,
                        this.int16[y + 3] = p,
                        this.int16[y + 4] = f,
                        this.int16[y + 5] = g,
                        t
                    }
                }
                r.prototype.bytesPerElement = 12,
                Wt("StructArrayLayout2i2i2i12", r);
                class s extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i, a, u, p) {
                        const f = this.length;
                        return this.resize(f + 1),
                        this.emplace(f, t, i, a, u, p)
                    }
                    emplace(t, i, a, u, p, f) {
                        const g = 4 * t
                          , y = 8 * t;
                        return this.float32[g + 0] = i,
                        this.float32[g + 1] = a,
                        this.float32[g + 2] = u,
                        this.int16[y + 6] = p,
                        this.int16[y + 7] = f,
                        t
                    }
                }
                s.prototype.bytesPerElement = 16,
                Wt("StructArrayLayout2f1f2i16", s);
                class c extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i, a, u, p, f) {
                        const g = this.length;
                        return this.resize(g + 1),
                        this.emplace(g, t, i, a, u, p, f)
                    }
                    emplace(t, i, a, u, p, f, g) {
                        const y = 16 * t
                          , S = 4 * t
                          , I = 8 * t;
                        return this.uint8[y + 0] = i,
                        this.uint8[y + 1] = a,
                        this.float32[S + 1] = u,
                        this.float32[S + 2] = p,
                        this.int16[I + 6] = f,
                        this.int16[I + 7] = g,
                        t
                    }
                }
                c.prototype.bytesPerElement = 16,
                Wt("StructArrayLayout2ub2f2i16", c);
                class d extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i, a) {
                        const u = this.length;
                        return this.resize(u + 1),
                        this.emplace(u, t, i, a)
                    }
                    emplace(t, i, a, u) {
                        const p = 3 * t;
                        return this.uint16[p + 0] = i,
                        this.uint16[p + 1] = a,
                        this.uint16[p + 2] = u,
                        t
                    }
                }
                d.prototype.bytesPerElement = 6,
                Wt("StructArrayLayout3ui6", d);
                class m extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i, a, u, p, f, g, y, S, I, A, R, N, j, $, J, se) {
                        const Ae = this.length;
                        return this.resize(Ae + 1),
                        this.emplace(Ae, t, i, a, u, p, f, g, y, S, I, A, R, N, j, $, J, se)
                    }
                    emplace(t, i, a, u, p, f, g, y, S, I, A, R, N, j, $, J, se, Ae) {
                        const _e = 24 * t
                          , O = 12 * t
                          , Y = 48 * t;
                        return this.int16[_e + 0] = i,
                        this.int16[_e + 1] = a,
                        this.uint16[_e + 2] = u,
                        this.uint16[_e + 3] = p,
                        this.uint32[O + 2] = f,
                        this.uint32[O + 3] = g,
                        this.uint32[O + 4] = y,
                        this.uint16[_e + 10] = S,
                        this.uint16[_e + 11] = I,
                        this.uint16[_e + 12] = A,
                        this.float32[O + 7] = R,
                        this.float32[O + 8] = N,
                        this.uint8[Y + 36] = j,
                        this.uint8[Y + 37] = $,
                        this.uint8[Y + 38] = J,
                        this.uint32[O + 10] = se,
                        this.int16[_e + 22] = Ae,
                        t
                    }
                }
                m.prototype.bytesPerElement = 48,
                Wt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", m);
                class v extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i, a, u, p, f, g, y, S, I, A, R, N, j, $, J, se, Ae, _e, O, Y, ve, Xe, bt, Qe, ot, Et, Ct) {
                        const Dt = this.length;
                        return this.resize(Dt + 1),
                        this.emplace(Dt, t, i, a, u, p, f, g, y, S, I, A, R, N, j, $, J, se, Ae, _e, O, Y, ve, Xe, bt, Qe, ot, Et, Ct)
                    }
                    emplace(t, i, a, u, p, f, g, y, S, I, A, R, N, j, $, J, se, Ae, _e, O, Y, ve, Xe, bt, Qe, ot, Et, Ct, Dt) {
                        const pt = 32 * t
                          , ir = 16 * t;
                        return this.int16[pt + 0] = i,
                        this.int16[pt + 1] = a,
                        this.int16[pt + 2] = u,
                        this.int16[pt + 3] = p,
                        this.int16[pt + 4] = f,
                        this.int16[pt + 5] = g,
                        this.int16[pt + 6] = y,
                        this.int16[pt + 7] = S,
                        this.uint16[pt + 8] = I,
                        this.uint16[pt + 9] = A,
                        this.uint16[pt + 10] = R,
                        this.uint16[pt + 11] = N,
                        this.uint16[pt + 12] = j,
                        this.uint16[pt + 13] = $,
                        this.uint16[pt + 14] = J,
                        this.uint16[pt + 15] = se,
                        this.uint16[pt + 16] = Ae,
                        this.uint16[pt + 17] = _e,
                        this.uint16[pt + 18] = O,
                        this.uint16[pt + 19] = Y,
                        this.uint16[pt + 20] = ve,
                        this.uint16[pt + 21] = Xe,
                        this.uint16[pt + 22] = bt,
                        this.uint32[ir + 12] = Qe,
                        this.float32[ir + 13] = ot,
                        this.float32[ir + 14] = Et,
                        this.uint16[pt + 30] = Ct,
                        this.uint16[pt + 31] = Dt,
                        t
                    }
                }
                v.prototype.bytesPerElement = 64,
                Wt("StructArrayLayout8i15ui1ul2f2ui64", v);
                class b extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t) {
                        const i = this.length;
                        return this.resize(i + 1),
                        this.emplace(i, t)
                    }
                    emplace(t, i) {
                        return this.float32[1 * t + 0] = i,
                        t
                    }
                }
                b.prototype.bytesPerElement = 4,
                Wt("StructArrayLayout1f4", b);
                class P extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i, a) {
                        const u = this.length;
                        return this.resize(u + 1),
                        this.emplace(u, t, i, a)
                    }
                    emplace(t, i, a, u) {
                        const p = 3 * t;
                        return this.uint16[6 * t + 0] = i,
                        this.float32[p + 1] = a,
                        this.float32[p + 2] = u,
                        t
                    }
                }
                P.prototype.bytesPerElement = 12,
                Wt("StructArrayLayout1ui2f12", P);
                class M extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i, a) {
                        const u = this.length;
                        return this.resize(u + 1),
                        this.emplace(u, t, i, a)
                    }
                    emplace(t, i, a, u) {
                        const p = 4 * t;
                        return this.uint32[2 * t + 0] = i,
                        this.uint16[p + 2] = a,
                        this.uint16[p + 3] = u,
                        t
                    }
                }
                M.prototype.bytesPerElement = 8,
                Wt("StructArrayLayout1ul2ui8", M);
                class D extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i) {
                        const a = this.length;
                        return this.resize(a + 1),
                        this.emplace(a, t, i)
                    }
                    emplace(t, i, a) {
                        const u = 2 * t;
                        return this.uint16[u + 0] = i,
                        this.uint16[u + 1] = a,
                        t
                    }
                }
                D.prototype.bytesPerElement = 4,
                Wt("StructArrayLayout2ui4", D);
                class L extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t) {
                        const i = this.length;
                        return this.resize(i + 1),
                        this.emplace(i, t)
                    }
                    emplace(t, i) {
                        return this.uint16[1 * t + 0] = i,
                        t
                    }
                }
                L.prototype.bytesPerElement = 2,
                Wt("StructArrayLayout1ui2", L);
                class B extends Ri {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, i, a, u) {
                        const p = this.length;
                        return this.resize(p + 1),
                        this.emplace(p, t, i, a, u)
                    }
                    emplace(t, i, a, u, p) {
                        const f = 4 * t;
                        return this.float32[f + 0] = i,
                        this.float32[f + 1] = a,
                        this.float32[f + 2] = u,
                        this.float32[f + 3] = p,
                        t
                    }
                }
                B.prototype.bytesPerElement = 16,
                Wt("StructArrayLayout4f16", B);
                class Z extends ms {
                    get anchorPointX() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get anchorPointY() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get x1() {
                        return this._structArray.int16[this._pos2 + 2]
                    }
                    get y1() {
                        return this._structArray.int16[this._pos2 + 3]
                    }
                    get x2() {
                        return this._structArray.int16[this._pos2 + 4]
                    }
                    get y2() {
                        return this._structArray.int16[this._pos2 + 5]
                    }
                    get featureIndex() {
                        return this._structArray.uint32[this._pos4 + 3]
                    }
                    get sourceLayerIndex() {
                        return this._structArray.uint16[this._pos2 + 8]
                    }
                    get bucketIndex() {
                        return this._structArray.uint16[this._pos2 + 9]
                    }
                    get anchorPoint() {
                        return new le(this.anchorPointX,this.anchorPointY)
                    }
                }
                Z.prototype.size = 20;
                class te extends e {
                    get(t) {
                        return new Z(this,t)
                    }
                }
                Wt("CollisionBoxArray", te);
                class ee extends ms {
                    get anchorX() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get anchorY() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get glyphStartIndex() {
                        return this._structArray.uint16[this._pos2 + 2]
                    }
                    get numGlyphs() {
                        return this._structArray.uint16[this._pos2 + 3]
                    }
                    get vertexStartIndex() {
                        return this._structArray.uint32[this._pos4 + 2]
                    }
                    get lineStartIndex() {
                        return this._structArray.uint32[this._pos4 + 3]
                    }
                    get lineLength() {
                        return this._structArray.uint32[this._pos4 + 4]
                    }
                    get segment() {
                        return this._structArray.uint16[this._pos2 + 10]
                    }
                    get lowerSize() {
                        return this._structArray.uint16[this._pos2 + 11]
                    }
                    get upperSize() {
                        return this._structArray.uint16[this._pos2 + 12]
                    }
                    get lineOffsetX() {
                        return this._structArray.float32[this._pos4 + 7]
                    }
                    get lineOffsetY() {
                        return this._structArray.float32[this._pos4 + 8]
                    }
                    get writingMode() {
                        return this._structArray.uint8[this._pos1 + 36]
                    }
                    get placedOrientation() {
                        return this._structArray.uint8[this._pos1 + 37]
                    }
                    set placedOrientation(t) {
                        this._structArray.uint8[this._pos1 + 37] = t
                    }
                    get hidden() {
                        return this._structArray.uint8[this._pos1 + 38]
                    }
                    set hidden(t) {
                        this._structArray.uint8[this._pos1 + 38] = t
                    }
                    get crossTileID() {
                        return this._structArray.uint32[this._pos4 + 10]
                    }
                    set crossTileID(t) {
                        this._structArray.uint32[this._pos4 + 10] = t
                    }
                    get associatedIconIndex() {
                        return this._structArray.int16[this._pos2 + 22]
                    }
                }
                ee.prototype.size = 48;
                class ne extends m {
                    get(t) {
                        return new ee(this,t)
                    }
                }
                Wt("PlacedSymbolArray", ne);
                class oe extends ms {
                    get anchorX() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get anchorY() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get rightJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 2]
                    }
                    get centerJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 3]
                    }
                    get leftJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 4]
                    }
                    get verticalPlacedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 5]
                    }
                    get placedIconSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 6]
                    }
                    get verticalPlacedIconSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 7]
                    }
                    get key() {
                        return this._structArray.uint16[this._pos2 + 8]
                    }
                    get textBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 9]
                    }
                    get textBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 10]
                    }
                    get verticalTextBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 11]
                    }
                    get verticalTextBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 12]
                    }
                    get iconBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 13]
                    }
                    get iconBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 14]
                    }
                    get verticalIconBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 15]
                    }
                    get verticalIconBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 16]
                    }
                    get featureIndex() {
                        return this._structArray.uint16[this._pos2 + 17]
                    }
                    get numHorizontalGlyphVertices() {
                        return this._structArray.uint16[this._pos2 + 18]
                    }
                    get numVerticalGlyphVertices() {
                        return this._structArray.uint16[this._pos2 + 19]
                    }
                    get numIconVertices() {
                        return this._structArray.uint16[this._pos2 + 20]
                    }
                    get numVerticalIconVertices() {
                        return this._structArray.uint16[this._pos2 + 21]
                    }
                    get useRuntimeCollisionCircles() {
                        return this._structArray.uint16[this._pos2 + 22]
                    }
                    get crossTileID() {
                        return this._structArray.uint32[this._pos4 + 12]
                    }
                    set crossTileID(t) {
                        this._structArray.uint32[this._pos4 + 12] = t
                    }
                    get textBoxScale() {
                        return this._structArray.float32[this._pos4 + 13]
                    }
                    get collisionCircleDiameter() {
                        return this._structArray.float32[this._pos4 + 14]
                    }
                    get textAnchorOffsetStartIndex() {
                        return this._structArray.uint16[this._pos2 + 30]
                    }
                    get textAnchorOffsetEndIndex() {
                        return this._structArray.uint16[this._pos2 + 31]
                    }
                }
                oe.prototype.size = 64;
                class me extends v {
                    get(t) {
                        return new oe(this,t)
                    }
                }
                Wt("SymbolInstanceArray", me);
                class ce extends b {
                    getoffsetX(t) {
                        return this.float32[1 * t + 0]
                    }
                }
                Wt("GlyphOffsetArray", ce);
                class Te extends Ya {
                    getx(t) {
                        return this.int16[3 * t + 0]
                    }
                    gety(t) {
                        return this.int16[3 * t + 1]
                    }
                    gettileUnitDistanceFromAnchor(t) {
                        return this.int16[3 * t + 2]
                    }
                }
                Wt("SymbolLineVertexArray", Te);
                class Pe extends ms {
                    get textAnchor() {
                        return this._structArray.uint16[this._pos2 + 0]
                    }
                    get textOffset0() {
                        return this._structArray.float32[this._pos4 + 1]
                    }
                    get textOffset1() {
                        return this._structArray.float32[this._pos4 + 2]
                    }
                }
                Pe.prototype.size = 12;
                class pe extends P {
                    get(t) {
                        return new Pe(this,t)
                    }
                }
                Wt("TextAnchorOffsetArray", pe);
                class Fe extends ms {
                    get featureIndex() {
                        return this._structArray.uint32[this._pos4 + 0]
                    }
                    get sourceLayerIndex() {
                        return this._structArray.uint16[this._pos2 + 2]
                    }
                    get bucketIndex() {
                        return this._structArray.uint16[this._pos2 + 3]
                    }
                }
                Fe.prototype.size = 8;
                class Ye extends M {
                    get(t) {
                        return new Fe(this,t)
                    }
                }
                Wt("FeatureIndexArray", Ye);
                class $e extends Ka {
                }
                class He extends Ka {
                }
                class Je extends Ka {
                }
                class qt extends El {
                }
                class Nt extends _s {
                }
                class wt extends Bo {
                }
                class rr extends Yc {
                }
                class Kr extends zl {
                }
                class fi extends Jc {
                }
                class Bi extends h {
                }
                class xi extends r {
                }
                class Fi extends c {
                }
                class Ti extends d {
                }
                class bi extends D {
                }
                const Ci = qi([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , {members: vn} = Ci;
                class li {
                    constructor(t=[]) {
                        this._forceNewSegmentOnNextPrepare = !1,
                        this.segments = t
                    }
                    prepareSegment(t, i, a, u) {
                        const p = this.segments[this.segments.length - 1];
                        return t > li.MAX_VERTEX_ARRAY_LENGTH && Qt(`Max vertices per segment is ${li.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${li.MAX_VERTEX_ARRAY_LENGTH} vertices.`),
                        this._forceNewSegmentOnNextPrepare || !p || p.vertexLength + t > li.MAX_VERTEX_ARRAY_LENGTH || p.sortKey !== u ? this.createNewSegment(i, a, u) : p
                    }
                    createNewSegment(t, i, a) {
                        const u = {
                            vertexOffset: t.length,
                            primitiveOffset: i.length,
                            vertexLength: 0,
                            primitiveLength: 0,
                            vaos: {}
                        };
                        return a !== void 0 && (u.sortKey = a),
                        this._forceNewSegmentOnNextPrepare = !1,
                        this.segments.push(u),
                        u
                    }
                    getOrCreateLatestSegment(t, i, a) {
                        return this.prepareSegment(0, t, i, a)
                    }
                    forceNewSegmentOnNextPrepare() {
                        this._forceNewSegmentOnNextPrepare = !0
                    }
                    get() {
                        return this.segments
                    }
                    destroy() {
                        for (const t of this.segments)
                            for (const i in t.vaos)
                                t.vaos[i].destroy()
                    }
                    static simpleSegment(t, i, a, u) {
                        return new li([{
                            vertexOffset: t,
                            primitiveOffset: i,
                            vertexLength: a,
                            primitiveLength: u,
                            vaos: {},
                            sortKey: 0
                        }])
                    }
                }
                function cn(n, t) {
                    return 256 * (n = kt(Math.floor(n), 0, 255)) + kt(Math.floor(t), 0, 255)
                }
                li.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1,
                Wt("SegmentVector", li);
                const yn = qi([{
                    name: "a_pattern_from",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_pattern_to",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_pixel_ratio_from",
                    components: 1,
                    type: "Uint16"
                }, {
                    name: "a_pixel_ratio_to",
                    components: 1,
                    type: "Uint16"
                }]);
                var Ja, Qa, es, Ma = {
                    exports: {}
                }, Fo = {
                    exports: {}
                }, Oo = {
                    exports: {}
                }, Ys = function() {
                    if (es)
                        return Ma.exports;
                    es = 1;
                    var n = (Ja || (Ja = 1,
                    Fo.exports = function(i, a) {
                        var u, p, f, g, y, S, I, A;
                        for (p = i.length - (u = 3 & i.length),
                        f = a,
                        y = 3432918353,
                        S = 461845907,
                        A = 0; A < p; )
                            I = 255 & i.charCodeAt(A) | (255 & i.charCodeAt(++A)) << 8 | (255 & i.charCodeAt(++A)) << 16 | (255 & i.charCodeAt(++A)) << 24,
                            ++A,
                            f = 27492 + (65535 & (g = 5 * (65535 & (f = (f ^= I = (65535 & (I = (I = (65535 & I) * y + (((I >>> 16) * y & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * S + (((I >>> 16) * S & 65535) << 16) & 4294967295) << 13 | f >>> 19)) + ((5 * (f >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (g >>> 16) & 65535) << 16);
                        switch (I = 0,
                        u) {
                        case 3:
                            I ^= (255 & i.charCodeAt(A + 2)) << 16;
                        case 2:
                            I ^= (255 & i.charCodeAt(A + 1)) << 8;
                        case 1:
                            f ^= I = (65535 & (I = (I = (65535 & (I ^= 255 & i.charCodeAt(A))) * y + (((I >>> 16) * y & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * S + (((I >>> 16) * S & 65535) << 16) & 4294967295
                        }
                        return f ^= i.length,
                        f = 2246822507 * (65535 & (f ^= f >>> 16)) + ((2246822507 * (f >>> 16) & 65535) << 16) & 4294967295,
                        f = 3266489909 * (65535 & (f ^= f >>> 13)) + ((3266489909 * (f >>> 16) & 65535) << 16) & 4294967295,
                        (f ^= f >>> 16) >>> 0
                    }
                    ),
                    Fo.exports)
                      , t = (Qa || (Qa = 1,
                    Oo.exports = function(i, a) {
                        for (var u, p = i.length, f = a ^ p, g = 0; p >= 4; )
                            u = 1540483477 * (65535 & (u = 255 & i.charCodeAt(g) | (255 & i.charCodeAt(++g)) << 8 | (255 & i.charCodeAt(++g)) << 16 | (255 & i.charCodeAt(++g)) << 24)) + ((1540483477 * (u >>> 16) & 65535) << 16),
                            f = 1540483477 * (65535 & f) + ((1540483477 * (f >>> 16) & 65535) << 16) ^ (u = 1540483477 * (65535 & (u ^= u >>> 24)) + ((1540483477 * (u >>> 16) & 65535) << 16)),
                            p -= 4,
                            ++g;
                        switch (p) {
                        case 3:
                            f ^= (255 & i.charCodeAt(g + 2)) << 16;
                        case 2:
                            f ^= (255 & i.charCodeAt(g + 1)) << 8;
                        case 1:
                            f = 1540483477 * (65535 & (f ^= 255 & i.charCodeAt(g))) + ((1540483477 * (f >>> 16) & 65535) << 16)
                        }
                        return f = 1540483477 * (65535 & (f ^= f >>> 13)) + ((1540483477 * (f >>> 16) & 65535) << 16),
                        (f ^= f >>> 15) >>> 0
                    }
                    ),
                    Oo.exports);
                    return Ma.exports = n,
                    Ma.exports.murmur3 = n,
                    Ma.exports.murmur2 = t,
                    Ma.exports
                }(), Un = W(Ys);
                class _a {
                    constructor() {
                        this.ids = [],
                        this.positions = [],
                        this.indexed = !1
                    }
                    add(t, i, a, u) {
                        this.ids.push(ts(t)),
                        this.positions.push(i, a, u)
                    }
                    getPositions(t) {
                        if (!this.indexed)
                            throw new Error("Trying to get index, but feature positions are not indexed");
                        const i = ts(t);
                        let a = 0
                          , u = this.ids.length - 1;
                        for (; a < u; ) {
                            const f = a + u >> 1;
                            this.ids[f] >= i ? u = f : a = f + 1
                        }
                        const p = [];
                        for (; this.ids[a] === i; )
                            p.push({
                                index: this.positions[3 * a],
                                start: this.positions[3 * a + 1],
                                end: this.positions[3 * a + 2]
                            }),
                            a++;
                        return p
                    }
                    static serialize(t, i) {
                        const a = new Float64Array(t.ids)
                          , u = new Uint32Array(t.positions);
                        return gs(a, u, 0, a.length - 1),
                        i && i.push(a.buffer, u.buffer),
                        {
                            ids: a,
                            positions: u
                        }
                    }
                    static deserialize(t) {
                        const i = new _a;
                        return i.ids = t.ids,
                        i.positions = t.positions,
                        i.indexed = !0,
                        i
                    }
                }
                function ts(n) {
                    const t = +n;
                    return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : Un(String(n))
                }
                function gs(n, t, i, a) {
                    for (; i < a; ) {
                        const u = n[i + a >> 1];
                        let p = i - 1
                          , f = a + 1;
                        for (; ; ) {
                            do
                                p++;
                            while (n[p] < u);
                            do
                                f--;
                            while (n[f] > u);
                            if (p >= f)
                                break;
                            Zi(n, p, f),
                            Zi(t, 3 * p, 3 * f),
                            Zi(t, 3 * p + 1, 3 * f + 1),
                            Zi(t, 3 * p + 2, 3 * f + 2)
                        }
                        f - i < a - f ? (gs(n, t, i, f),
                        i = f + 1) : (gs(n, t, f + 1, a),
                        a = f)
                    }
                }
                function Zi(n, t, i) {
                    const a = n[t];
                    n[t] = n[i],
                    n[i] = a
                }
                Wt("FeaturePositionMap", _a);
                class Mi {
                    constructor(t, i) {
                        this.gl = t.gl,
                        this.location = i
                    }
                }
                class Dn extends Mi {
                    constructor(t, i) {
                        super(t, i),
                        this.current = 0
                    }
                    set(t) {
                        this.current !== t && (this.current = t,
                        this.gl.uniform1f(this.location, t))
                    }
                }
                class tn extends Mi {
                    constructor(t, i) {
                        super(t, i),
                        this.current = [0, 0, 0, 0]
                    }
                    set(t) {
                        t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t,
                        this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]))
                    }
                }
                class rd extends Mi {
                    constructor(t, i) {
                        super(t, i),
                        this.current = Jr.transparent
                    }
                    set(t) {
                        t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t,
                        this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a))
                    }
                }
                const yp = new Float32Array(16);
                function Qc(n) {
                    return [cn(255 * n.r, 255 * n.g), cn(255 * n.b, 255 * n.a)]
                }
                class No {
                    constructor(t, i, a) {
                        this.value = t,
                        this.uniformNames = i.map(u => `u_${u}`),
                        this.type = a
                    }
                    setUniform(t, i, a) {
                        t.set(a.constantOr(this.value))
                    }
                    getBinding(t, i, a) {
                        return this.type === "color" ? new rd(t,i) : new Dn(t,i)
                    }
                }
                class Js {
                    constructor(t, i) {
                        this.uniformNames = i.map(a => `u_${a}`),
                        this.patternFrom = null,
                        this.patternTo = null,
                        this.pixelRatioFrom = 1,
                        this.pixelRatioTo = 1
                    }
                    setConstantPatternPositions(t, i) {
                        this.pixelRatioFrom = i.pixelRatio,
                        this.pixelRatioTo = t.pixelRatio,
                        this.patternFrom = i.tlbr,
                        this.patternTo = t.tlbr
                    }
                    setUniform(t, i, a, u) {
                        const p = u === "u_pattern_to" ? this.patternTo : u === "u_pattern_from" ? this.patternFrom : u === "u_pixel_ratio_to" ? this.pixelRatioTo : u === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
                        p && t.set(p)
                    }
                    getBinding(t, i, a) {
                        return a.substr(0, 9) === "u_pattern" ? new tn(t,i) : new Dn(t,i)
                    }
                }
                class Ba {
                    constructor(t, i, a, u) {
                        this.expression = t,
                        this.type = a,
                        this.maxValue = 0,
                        this.paintVertexAttributes = i.map(p => ({
                            name: `a_${p}`,
                            type: "Float32",
                            components: a === "color" ? 2 : 1,
                            offset: 0
                        })),
                        this.paintVertexArray = new u
                    }
                    populatePaintArray(t, i, a, u, p) {
                        const f = this.paintVertexArray.length
                          , g = this.expression.evaluate(new Ei(0), i, {}, u, [], p);
                        this.paintVertexArray.resize(t),
                        this._setPaintValue(f, t, g)
                    }
                    updatePaintArray(t, i, a, u) {
                        const p = this.expression.evaluate({
                            zoom: 0
                        }, a, u);
                        this._setPaintValue(t, i, p)
                    }
                    _setPaintValue(t, i, a) {
                        if (this.type === "color") {
                            const u = Qc(a);
                            for (let p = t; p < i; p++)
                                this.paintVertexArray.emplace(p, u[0], u[1])
                        } else {
                            for (let u = t; u < i; u++)
                                this.paintVertexArray.emplace(u, a);
                            this.maxValue = Math.max(this.maxValue, Math.abs(a))
                        }
                    }
                    upload(t) {
                        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                    }
                    destroy() {
                        this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                    }
                }
                class xn {
                    constructor(t, i, a, u, p, f) {
                        this.expression = t,
                        this.uniformNames = i.map(g => `u_${g}_t`),
                        this.type = a,
                        this.useIntegerZoom = u,
                        this.zoom = p,
                        this.maxValue = 0,
                        this.paintVertexAttributes = i.map(g => ({
                            name: `a_${g}`,
                            type: "Float32",
                            components: a === "color" ? 4 : 2,
                            offset: 0
                        })),
                        this.paintVertexArray = new f
                    }
                    populatePaintArray(t, i, a, u, p) {
                        const f = this.expression.evaluate(new Ei(this.zoom), i, {}, u, [], p)
                          , g = this.expression.evaluate(new Ei(this.zoom + 1), i, {}, u, [], p)
                          , y = this.paintVertexArray.length;
                        this.paintVertexArray.resize(t),
                        this._setPaintValue(y, t, f, g)
                    }
                    updatePaintArray(t, i, a, u) {
                        const p = this.expression.evaluate({
                            zoom: this.zoom
                        }, a, u)
                          , f = this.expression.evaluate({
                            zoom: this.zoom + 1
                        }, a, u);
                        this._setPaintValue(t, i, p, f)
                    }
                    _setPaintValue(t, i, a, u) {
                        if (this.type === "color") {
                            const p = Qc(a)
                              , f = Qc(u);
                            for (let g = t; g < i; g++)
                                this.paintVertexArray.emplace(g, p[0], p[1], f[0], f[1])
                        } else {
                            for (let p = t; p < i; p++)
                                this.paintVertexArray.emplace(p, a, u);
                            this.maxValue = Math.max(this.maxValue, Math.abs(a), Math.abs(u))
                        }
                    }
                    upload(t) {
                        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                    }
                    destroy() {
                        this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                    }
                    setUniform(t, i) {
                        const a = this.useIntegerZoom ? Math.floor(i.zoom) : i.zoom
                          , u = kt(this.expression.interpolationFactor(a, this.zoom, this.zoom + 1), 0, 1);
                        t.set(u)
                    }
                    getBinding(t, i, a) {
                        return new Dn(t,i)
                    }
                }
                class Fa {
                    constructor(t, i, a, u, p, f) {
                        this.expression = t,
                        this.type = i,
                        this.useIntegerZoom = a,
                        this.zoom = u,
                        this.layerId = f,
                        this.zoomInPaintVertexArray = new p,
                        this.zoomOutPaintVertexArray = new p
                    }
                    populatePaintArray(t, i, a) {
                        const u = this.zoomInPaintVertexArray.length;
                        this.zoomInPaintVertexArray.resize(t),
                        this.zoomOutPaintVertexArray.resize(t),
                        this._setPaintValues(u, t, i.patterns && i.patterns[this.layerId], a)
                    }
                    updatePaintArray(t, i, a, u, p) {
                        this._setPaintValues(t, i, a.patterns && a.patterns[this.layerId], p)
                    }
                    _setPaintValues(t, i, a, u) {
                        if (!u || !a)
                            return;
                        const {min: p, mid: f, max: g} = a
                          , y = u[p]
                          , S = u[f]
                          , I = u[g];
                        if (y && S && I)
                            for (let A = t; A < i; A++)
                                this.zoomInPaintVertexArray.emplace(A, S.tl[0], S.tl[1], S.br[0], S.br[1], y.tl[0], y.tl[1], y.br[0], y.br[1], S.pixelRatio, y.pixelRatio),
                                this.zoomOutPaintVertexArray.emplace(A, S.tl[0], S.tl[1], S.br[0], S.br[1], I.tl[0], I.tl[1], I.br[0], I.br[1], S.pixelRatio, I.pixelRatio)
                    }
                    upload(t) {
                        this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, yn.members, this.expression.isStateDependent),
                        this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, yn.members, this.expression.isStateDependent))
                    }
                    destroy() {
                        this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(),
                        this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy()
                    }
                }
                class eu {
                    constructor(t, i, a) {
                        this.binders = {},
                        this._buffers = [];
                        const u = [];
                        for (const p in t.paint._values) {
                            if (!a(p))
                                continue;
                            const f = t.paint.get(p);
                            if (!(f instanceof Ia && Ns(f.property.specification)))
                                continue;
                            const g = tu(p, t.type)
                              , y = f.value
                              , S = f.property.specification.type
                              , I = f.property.useIntegerZoom
                              , A = f.property.specification["property-type"]
                              , R = A === "cross-faded" || A === "cross-faded-data-driven";
                            if (y.kind === "constant")
                                this.binders[p] = R ? new Js(y.value,g) : new No(y.value,g,S),
                                u.push(`/u_${p}`);
                            else if (y.kind === "source" || R) {
                                const N = ru(p, S, "source");
                                this.binders[p] = R ? new Fa(y,S,I,i,N,t.id) : new Ba(y,g,S,N),
                                u.push(`/a_${p}`)
                            } else {
                                const N = ru(p, S, "composite");
                                this.binders[p] = new xn(y,g,S,I,i,N),
                                u.push(`/z_${p}`)
                            }
                        }
                        this.cacheKey = u.sort().join("")
                    }
                    getMaxValue(t) {
                        const i = this.binders[t];
                        return i instanceof Ba || i instanceof xn ? i.maxValue : 0
                    }
                    populatePaintArrays(t, i, a, u, p) {
                        for (const f in this.binders) {
                            const g = this.binders[f];
                            (g instanceof Ba || g instanceof xn || g instanceof Fa) && g.populatePaintArray(t, i, a, u, p)
                        }
                    }
                    setConstantPatternPositions(t, i) {
                        for (const a in this.binders) {
                            const u = this.binders[a];
                            u instanceof Js && u.setConstantPatternPositions(t, i)
                        }
                    }
                    updatePaintArrays(t, i, a, u, p) {
                        let f = !1;
                        for (const g in t) {
                            const y = i.getPositions(g);
                            for (const S of y) {
                                const I = a.feature(S.index);
                                for (const A in this.binders) {
                                    const R = this.binders[A];
                                    if ((R instanceof Ba || R instanceof xn || R instanceof Fa) && R.expression.isStateDependent === !0) {
                                        const N = u.paint.get(A);
                                        R.expression = N.value,
                                        R.updatePaintArray(S.start, S.end, I, t[g], p),
                                        f = !0
                                    }
                                }
                            }
                        }
                        return f
                    }
                    defines() {
                        const t = [];
                        for (const i in this.binders) {
                            const a = this.binders[i];
                            (a instanceof No || a instanceof Js) && t.push(...a.uniformNames.map(u => `#define HAS_UNIFORM_${u}`))
                        }
                        return t
                    }
                    getBinderAttributes() {
                        const t = [];
                        for (const i in this.binders) {
                            const a = this.binders[i];
                            if (a instanceof Ba || a instanceof xn)
                                for (let u = 0; u < a.paintVertexAttributes.length; u++)
                                    t.push(a.paintVertexAttributes[u].name);
                            else if (a instanceof Fa)
                                for (let u = 0; u < yn.members.length; u++)
                                    t.push(yn.members[u].name)
                        }
                        return t
                    }
                    getBinderUniforms() {
                        const t = [];
                        for (const i in this.binders) {
                            const a = this.binders[i];
                            if (a instanceof No || a instanceof Js || a instanceof xn)
                                for (const u of a.uniformNames)
                                    t.push(u)
                        }
                        return t
                    }
                    getPaintVertexBuffers() {
                        return this._buffers
                    }
                    getUniforms(t, i) {
                        const a = [];
                        for (const u in this.binders) {
                            const p = this.binders[u];
                            if (p instanceof No || p instanceof Js || p instanceof xn) {
                                for (const f of p.uniformNames)
                                    if (i[f]) {
                                        const g = p.getBinding(t, i[f], f);
                                        a.push({
                                            name: f,
                                            property: u,
                                            binding: g
                                        })
                                    }
                            }
                        }
                        return a
                    }
                    setUniforms(t, i, a, u) {
                        for (const {name: p, property: f, binding: g} of i)
                            this.binders[f].setUniform(g, u, a.get(f), p)
                    }
                    updatePaintBuffers(t) {
                        this._buffers = [];
                        for (const i in this.binders) {
                            const a = this.binders[i];
                            if (t && a instanceof Fa) {
                                const u = t.fromScale === 2 ? a.zoomInPaintVertexBuffer : a.zoomOutPaintVertexBuffer;
                                u && this._buffers.push(u)
                            } else
                                (a instanceof Ba || a instanceof xn) && a.paintVertexBuffer && this._buffers.push(a.paintVertexBuffer)
                        }
                    }
                    upload(t) {
                        for (const i in this.binders) {
                            const a = this.binders[i];
                            (a instanceof Ba || a instanceof xn || a instanceof Fa) && a.upload(t)
                        }
                        this.updatePaintBuffers()
                    }
                    destroy() {
                        for (const t in this.binders) {
                            const i = this.binders[t];
                            (i instanceof Ba || i instanceof xn || i instanceof Fa) && i.destroy()
                        }
                    }
                }
                class rs {
                    constructor(t, i, a= () => !0) {
                        this.programConfigurations = {};
                        for (const u of t)
                            this.programConfigurations[u.id] = new eu(u,i,a);
                        this.needsUpload = !1,
                        this._featureMap = new _a,
                        this._bufferOffset = 0
                    }
                    populatePaintArrays(t, i, a, u, p, f) {
                        for (const g in this.programConfigurations)
                            this.programConfigurations[g].populatePaintArrays(t, i, u, p, f);
                        i.id !== void 0 && this._featureMap.add(i.id, a, this._bufferOffset, t),
                        this._bufferOffset = t,
                        this.needsUpload = !0
                    }
                    updatePaintArrays(t, i, a, u) {
                        for (const p of a)
                            this.needsUpload = this.programConfigurations[p.id].updatePaintArrays(t, this._featureMap, i, p, u) || this.needsUpload
                    }
                    get(t) {
                        return this.programConfigurations[t]
                    }
                    upload(t) {
                        if (this.needsUpload) {
                            for (const i in this.programConfigurations)
                                this.programConfigurations[i].upload(t);
                            this.needsUpload = !1
                        }
                    }
                    destroy() {
                        for (const t in this.programConfigurations)
                            this.programConfigurations[t].destroy()
                    }
                }
                function tu(n, t) {
                    return {
                        "text-opacity": ["opacity"],
                        "icon-opacity": ["opacity"],
                        "text-color": ["fill_color"],
                        "icon-color": ["fill_color"],
                        "text-halo-color": ["halo_color"],
                        "icon-halo-color": ["halo_color"],
                        "text-halo-blur": ["halo_blur"],
                        "icon-halo-blur": ["halo_blur"],
                        "text-halo-width": ["halo_width"],
                        "icon-halo-width": ["halo_width"],
                        "line-gap-width": ["gapwidth"],
                        "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
                        "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
                        "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]
                    }[n] || [n.replace(`${t}-`, "").replace(/-/g, "_")]
                }
                function ru(n, t, i) {
                    const a = {
                        color: {
                            source: Bo,
                            composite: B
                        },
                        number: {
                            source: b,
                            composite: Bo
                        }
                    }
                      , u = function(p) {
                        return {
                            "line-pattern": {
                                source: rr,
                                composite: rr
                            },
                            "fill-pattern": {
                                source: rr,
                                composite: rr
                            },
                            "fill-extrusion-pattern": {
                                source: rr,
                                composite: rr
                            }
                        }[p]
                    }(n);
                    return u && u[i] || a[t][i]
                }
                Wt("ConstantBinder", No),
                Wt("CrossFadedConstantBinder", Js),
                Wt("SourceExpressionBinder", Ba),
                Wt("CrossFadedCompositeBinder", Fa),
                Wt("CompositeExpressionBinder", xn),
                Wt("ProgramConfiguration", eu, {
                    omit: ["_buffers"]
                }),
                Wt("ProgramConfigurationSet", rs);
                const jo = Math.pow(2, 14) - 1
                  , km = -jo - 1;
                function qo(n) {
                    const t = We / n.extent
                      , i = n.loadGeometry();
                    for (let a = 0; a < i.length; a++) {
                        const u = i[a];
                        for (let p = 0; p < u.length; p++) {
                            const f = u[p]
                              , g = Math.round(f.x * t)
                              , y = Math.round(f.y * t);
                            f.x = kt(g, km, jo),
                            f.y = kt(y, km, jo),
                            (g < f.x || g > f.x + 1 || y < f.y || y > f.y + 1) && Qt("Geometry exceeds allowed extent, reduce your vector tile buffer size")
                        }
                    }
                    return i
                }
                function Vo(n, t) {
                    return {
                        type: n.type,
                        id: n.id,
                        properties: n.properties,
                        geometry: t ? qo(n) : []
                    }
                }
                const Em = -32768;
                function Uv(n, t, i, a, u) {
                    n.emplaceBack(Em + 8 * t + a, Em + 8 * i + u)
                }
                class xp {
                    constructor(t) {
                        this.zoom = t.zoom,
                        this.globalState = t.globalState,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map(i => i.id),
                        this.index = t.index,
                        this.hasPattern = !1,
                        this.layoutVertexArray = new He,
                        this.indexArray = new Ti,
                        this.segments = new li,
                        this.programConfigurations = new rs(t.layers,t.zoom),
                        this.stateDependentLayerIds = this.layers.filter(i => i.isStateDependent()).map(i => i.id)
                    }
                    populate(t, i, a) {
                        const u = this.layers[0]
                          , p = [];
                        let f = null
                          , g = !1
                          , y = u.type === "heatmap";
                        if (u.type === "circle") {
                            const I = u;
                            f = I.layout.get("circle-sort-key"),
                            g = !f.isConstant(),
                            y = y || I.paint.get("circle-pitch-alignment") === "map"
                        }
                        const S = y ? i.subdivisionGranularity.circle : 1;
                        for (const {feature: I, id: A, index: R, sourceLayerIndex: N} of t) {
                            const j = this.layers[0]._featureFilter.needGeometry
                              , $ = Vo(I, j);
                            if (!this.layers[0]._featureFilter.filter(new Ei(this.zoom,{
                                globalState: this.globalState
                            }), $, a))
                                continue;
                            const J = g ? f.evaluate($, {}, a) : void 0
                              , se = {
                                id: A,
                                properties: I.properties,
                                type: I.type,
                                sourceLayerIndex: N,
                                index: R,
                                geometry: j ? $.geometry : qo(I),
                                patterns: {},
                                sortKey: J
                            };
                            p.push(se)
                        }
                        g && p.sort( (I, A) => I.sortKey - A.sortKey);
                        for (const I of p) {
                            const {geometry: A, index: R, sourceLayerIndex: N} = I
                              , j = t[R].feature;
                            this.addFeature(I, A, R, a, S),
                            i.featureIndex.insert(j, A, R, N, this.index)
                        }
                    }
                    update(t, i, a) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, i, this.stateDependentLayers, a)
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, vn),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray)),
                        this.programConfigurations.upload(t),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy())
                    }
                    addFeature(t, i, a, u, p=1) {
                        let f;
                        switch (p) {
                        case 1:
                            f = [0, 7];
                            break;
                        case 3:
                            f = [0, 2, 5, 7];
                            break;
                        case 5:
                            f = [0, 1, 3, 4, 6, 7];
                            break;
                        case 7:
                            f = [0, 1, 2, 3, 4, 5, 6, 7];
                            break;
                        default:
                            throw new Error(`Invalid circle bucket granularity: ${p}; valid values are 1, 3, 5, 7.`)
                        }
                        const g = f.length;
                        for (const y of i)
                            for (const S of y) {
                                const I = S.x
                                  , A = S.y;
                                if (I < 0 || I >= We || A < 0 || A >= We)
                                    continue;
                                const R = this.segments.prepareSegment(g * g, this.layoutVertexArray, this.indexArray, t.sortKey)
                                  , N = R.vertexLength;
                                for (let j = 0; j < g; j++)
                                    for (let $ = 0; $ < g; $++)
                                        Uv(this.layoutVertexArray, I, A, f[$], f[j]);
                                for (let j = 0; j < g - 1; j++)
                                    for (let $ = 0; $ < g - 1; $++) {
                                        const J = N + j * g + $
                                          , se = N + (j + 1) * g + $;
                                        this.indexArray.emplaceBack(J, se + 1, J + 1),
                                        this.indexArray.emplaceBack(J, se, se + 1)
                                    }
                                R.vertexLength += g * g,
                                R.primitiveLength += (g - 1) * (g - 1) * 2
                            }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, {}, u)
                    }
                }
                function zm(n, t) {
                    for (let i = 0; i < n.length; i++)
                        if (Ll(t, n[i]))
                            return !0;
                    for (let i = 0; i < t.length; i++)
                        if (Ll(n, t[i]))
                            return !0;
                    return !!bp(n, t)
                }
                function Gv(n, t, i) {
                    return !!Ll(n, t) || !!wp(t, n, i)
                }
                function Lm(n, t) {
                    if (n.length === 1)
                        return Rm(t, n[0]);
                    for (let i = 0; i < t.length; i++) {
                        const a = t[i];
                        for (let u = 0; u < a.length; u++)
                            if (Ll(n, a[u]))
                                return !0
                    }
                    for (let i = 0; i < n.length; i++)
                        if (Rm(t, n[i]))
                            return !0;
                    for (let i = 0; i < t.length; i++)
                        if (bp(n, t[i]))
                            return !0;
                    return !1
                }
                function Hv(n, t, i) {
                    if (n.length > 1) {
                        if (bp(n, t))
                            return !0;
                        for (let a = 0; a < t.length; a++)
                            if (wp(t[a], n, i))
                                return !0
                    }
                    for (let a = 0; a < n.length; a++)
                        if (wp(n[a], t, i))
                            return !0;
                    return !1
                }
                function bp(n, t) {
                    if (n.length === 0 || t.length === 0)
                        return !1;
                    for (let i = 0; i < n.length - 1; i++) {
                        const a = n[i]
                          , u = n[i + 1];
                        for (let p = 0; p < t.length - 1; p++)
                            if (Wv(a, u, t[p], t[p + 1]))
                                return !0
                    }
                    return !1
                }
                function Wv(n, t, i, a) {
                    return $t(n, i, a) !== $t(t, i, a) && $t(n, t, i) !== $t(n, t, a)
                }
                function wp(n, t, i) {
                    const a = i * i;
                    if (t.length === 1)
                        return n.distSqr(t[0]) < a;
                    for (let u = 1; u < t.length; u++)
                        if (Dm(n, t[u - 1], t[u]) < a)
                            return !0;
                    return !1
                }
                function Dm(n, t, i) {
                    const a = t.distSqr(i);
                    if (a === 0)
                        return n.distSqr(t);
                    const u = ((n.x - t.x) * (i.x - t.x) + (n.y - t.y) * (i.y - t.y)) / a;
                    return n.distSqr(u < 0 ? t : u > 1 ? i : i.sub(t)._mult(u)._add(t))
                }
                function Rm(n, t) {
                    let i, a, u, p = !1;
                    for (let f = 0; f < n.length; f++) {
                        i = n[f];
                        for (let g = 0, y = i.length - 1; g < i.length; y = g++)
                            a = i[g],
                            u = i[y],
                            a.y > t.y != u.y > t.y && t.x < (u.x - a.x) * (t.y - a.y) / (u.y - a.y) + a.x && (p = !p)
                    }
                    return p
                }
                function Ll(n, t) {
                    let i = !1;
                    for (let a = 0, u = n.length - 1; a < n.length; u = a++) {
                        const p = n[a]
                          , f = n[u];
                        p.y > t.y != f.y > t.y && t.x < (f.x - p.x) * (t.y - p.y) / (f.y - p.y) + p.x && (i = !i)
                    }
                    return i
                }
                function Xv(n, t, i) {
                    const a = i[0]
                      , u = i[2];
                    if (n.x < a.x && t.x < a.x || n.x > u.x && t.x > u.x || n.y < a.y && t.y < a.y || n.y > u.y && t.y > u.y)
                        return !1;
                    const p = $t(n, t, i[0]);
                    return p !== $t(n, t, i[1]) || p !== $t(n, t, i[2]) || p !== $t(n, t, i[3])
                }
                function iu(n, t, i) {
                    const a = t.paint.get(n).value;
                    return a.kind === "constant" ? a.value : i.programConfigurations.get(t.id).getMaxValue(n)
                }
                function id(n) {
                    return Math.sqrt(n[0] * n[0] + n[1] * n[1])
                }
                function nd(n, t, i, a, u) {
                    if (!t[0] && !t[1])
                        return n;
                    const p = le.convert(t)._mult(u);
                    i === "viewport" && p._rotate(-a);
                    const f = [];
                    for (let g = 0; g < n.length; g++)
                        f.push(n[g].sub(p));
                    return f
                }
                let Bm, Fm;
                Wt("CircleBucket", xp, {
                    omit: ["layers"]
                });
                var Kv = {
                    get paint() {
                        return Fm = Fm || new Ln({
                            "circle-radius": new Rr(ye.paint_circle["circle-radius"]),
                            "circle-color": new Rr(ye.paint_circle["circle-color"]),
                            "circle-blur": new Rr(ye.paint_circle["circle-blur"]),
                            "circle-opacity": new Rr(ye.paint_circle["circle-opacity"]),
                            "circle-translate": new ar(ye.paint_circle["circle-translate"]),
                            "circle-translate-anchor": new ar(ye.paint_circle["circle-translate-anchor"]),
                            "circle-pitch-scale": new ar(ye.paint_circle["circle-pitch-scale"]),
                            "circle-pitch-alignment": new ar(ye.paint_circle["circle-pitch-alignment"]),
                            "circle-stroke-width": new Rr(ye.paint_circle["circle-stroke-width"]),
                            "circle-stroke-color": new Rr(ye.paint_circle["circle-stroke-color"]),
                            "circle-stroke-opacity": new Rr(ye.paint_circle["circle-stroke-opacity"])
                        })
                    },
                    get layout() {
                        return Bm = Bm || new Ln({
                            "circle-sort-key": new Rr(ye.layout_circle["circle-sort-key"])
                        })
                    }
                };
                class Yv extends gn {
                    constructor(t) {
                        super(t, Kv)
                    }
                    createBucket(t) {
                        return new xp(t)
                    }
                    queryRadius(t) {
                        const i = t;
                        return iu("circle-radius", this, i) + iu("circle-stroke-width", this, i) + id(this.paint.get("circle-translate"))
                    }
                    queryIntersectsFeature({queryGeometry: t, feature: i, featureState: a, geometry: u, transform: p, pixelsToTileUnits: f, unwrappedTileID: g, getElevation: y}) {
                        const S = nd(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -p.bearingInRadians, f)
                          , I = this.paint.get("circle-radius").evaluate(i, a) + this.paint.get("circle-stroke-width").evaluate(i, a)
                          , A = this.paint.get("circle-pitch-alignment") === "map"
                          , R = A ? S : function(j, $, J, se) {
                            return j.map(Ae => Om(Ae, $, J, se))
                        }(S, p, g, y)
                          , N = A ? I * f : I;
                        for (const j of u)
                            for (const $ of j) {
                                const J = A ? $ : Om($, p, g, y);
                                let se = N;
                                const Ae = p.projectTileCoordinates($.x, $.y, g, y).signedDistanceFromCamera;
                                if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? se *= Ae / p.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (se *= p.cameraToCenterDistance / Ae),
                                Gv(R, J, se))
                                    return !0
                            }
                        return !1
                    }
                }
                function Om(n, t, i, a) {
                    const u = t.projectTileCoordinates(n.x, n.y, i, a).point;
                    return new le((.5 * u.x + .5) * t.width,(.5 * -u.y + .5) * t.height)
                }
                class Nm extends xp {
                }
                let jm;
                Wt("HeatmapBucket", Nm, {
                    omit: ["layers"]
                });
                var Jv = {
                    get paint() {
                        return jm = jm || new Ln({
                            "heatmap-radius": new Rr(ye.paint_heatmap["heatmap-radius"]),
                            "heatmap-weight": new Rr(ye.paint_heatmap["heatmap-weight"]),
                            "heatmap-intensity": new ar(ye.paint_heatmap["heatmap-intensity"]),
                            "heatmap-color": new Ro(ye.paint_heatmap["heatmap-color"]),
                            "heatmap-opacity": new ar(ye.paint_heatmap["heatmap-opacity"])
                        })
                    }
                };
                function Tp(n, {width: t, height: i}, a, u) {
                    if (u) {
                        if (u instanceof Uint8ClampedArray)
                            u = new Uint8Array(u.buffer);
                        else if (u.length !== t * i * a)
                            throw new RangeError(`mismatched image size. expected: ${u.length} but got: ${t * i * a}`)
                    } else
                        u = new Uint8Array(t * i * a);
                    return n.width = t,
                    n.height = i,
                    n.data = u,
                    n
                }
                function qm(n, {width: t, height: i}, a) {
                    if (t === n.width && i === n.height)
                        return;
                    const u = Tp({}, {
                        width: t,
                        height: i
                    }, a);
                    Cp(n, u, {
                        x: 0,
                        y: 0
                    }, {
                        x: 0,
                        y: 0
                    }, {
                        width: Math.min(n.width, t),
                        height: Math.min(n.height, i)
                    }, a),
                    n.width = t,
                    n.height = i,
                    n.data = u.data
                }
                function Cp(n, t, i, a, u, p) {
                    if (u.width === 0 || u.height === 0)
                        return t;
                    if (u.width > n.width || u.height > n.height || i.x > n.width - u.width || i.y > n.height - u.height)
                        throw new RangeError("out of range source coordinates for image copy");
                    if (u.width > t.width || u.height > t.height || a.x > t.width - u.width || a.y > t.height - u.height)
                        throw new RangeError("out of range destination coordinates for image copy");
                    const f = n.data
                      , g = t.data;
                    if (f === g)
                        throw new Error("srcData equals dstData, so image is already copied");
                    for (let y = 0; y < u.height; y++) {
                        const S = ((i.y + y) * n.width + i.x) * p
                          , I = ((a.y + y) * t.width + a.x) * p;
                        for (let A = 0; A < u.width * p; A++)
                            g[I + A] = f[S + A]
                    }
                    return t
                }
                class nu {
                    constructor(t, i) {
                        Tp(this, t, 1, i)
                    }
                    resize(t) {
                        qm(this, t, 1)
                    }
                    clone() {
                        return new nu({
                            width: this.width,
                            height: this.height
                        },new Uint8Array(this.data))
                    }
                    static copy(t, i, a, u, p) {
                        Cp(t, i, a, u, p, 1)
                    }
                }
                class ra {
                    constructor(t, i) {
                        Tp(this, t, 4, i)
                    }
                    resize(t) {
                        qm(this, t, 4)
                    }
                    replace(t, i) {
                        i ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t
                    }
                    clone() {
                        return new ra({
                            width: this.width,
                            height: this.height
                        },new Uint8Array(this.data))
                    }
                    static copy(t, i, a, u, p) {
                        Cp(t, i, a, u, p, 4)
                    }
                    setPixel(t, i, a) {
                        const u = 4 * (t * this.width + i);
                        this.data[u + 0] = Math.round(255 * a.r / a.a),
                        this.data[u + 1] = Math.round(255 * a.g / a.a),
                        this.data[u + 2] = Math.round(255 * a.b / a.a),
                        this.data[u + 3] = Math.round(255 * a.a)
                    }
                }
                function Vm(n) {
                    const t = {}
                      , i = n.resolution || 256
                      , a = n.clips ? n.clips.length : 1
                      , u = n.image || new ra({
                        width: i,
                        height: a
                    });
                    if (Math.log(i) / Math.LN2 % 1 != 0)
                        throw new Error(`width is not a power of 2 - ${i}`);
                    const p = (f, g, y) => {
                        t[n.evaluationKey] = y;
                        const S = n.expression.evaluate(t);
                        u.setPixel(f / 4 / i, g / 4, S)
                    }
                    ;
                    if (n.clips)
                        for (let f = 0, g = 0; f < a; ++f,
                        g += 4 * i)
                            for (let y = 0, S = 0; y < i; y++,
                            S += 4) {
                                const I = y / (i - 1)
                                  , {start: A, end: R} = n.clips[f];
                                p(g, S, A * (1 - I) + R * I)
                            }
                    else
                        for (let f = 0, g = 0; f < i; f++,
                        g += 4)
                            p(0, g, f / (i - 1));
                    return u
                }
                Wt("AlphaImage", nu),
                Wt("RGBAImage", ra);
                const Sp = "big-fb";
                class Qv extends gn {
                    createBucket(t) {
                        return new Nm(t)
                    }
                    constructor(t) {
                        super(t, Jv),
                        this.heatmapFbos = new Map,
                        this._updateColorRamp()
                    }
                    _handleSpecialPaintPropertyUpdate(t) {
                        t === "heatmap-color" && this._updateColorRamp()
                    }
                    _updateColorRamp() {
                        this.colorRamp = Vm({
                            expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                            evaluationKey: "heatmapDensity",
                            image: this.colorRamp
                        }),
                        this.colorRampTexture = null
                    }
                    resize() {
                        this.heatmapFbos.has(Sp) && this.heatmapFbos.delete(Sp)
                    }
                    queryRadius() {
                        return 0
                    }
                    queryIntersectsFeature() {
                        return !1
                    }
                    hasOffscreenPass() {
                        return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
                    }
                }
                let Zm;
                var e0 = {
                    get paint() {
                        return Zm = Zm || new Ln({
                            "hillshade-illumination-direction": new ar(ye.paint_hillshade["hillshade-illumination-direction"]),
                            "hillshade-illumination-altitude": new ar(ye.paint_hillshade["hillshade-illumination-altitude"]),
                            "hillshade-illumination-anchor": new ar(ye.paint_hillshade["hillshade-illumination-anchor"]),
                            "hillshade-exaggeration": new ar(ye.paint_hillshade["hillshade-exaggeration"]),
                            "hillshade-shadow-color": new ar(ye.paint_hillshade["hillshade-shadow-color"]),
                            "hillshade-highlight-color": new ar(ye.paint_hillshade["hillshade-highlight-color"]),
                            "hillshade-accent-color": new ar(ye.paint_hillshade["hillshade-accent-color"]),
                            "hillshade-method": new ar(ye.paint_hillshade["hillshade-method"])
                        })
                    }
                };
                class t0 extends gn {
                    constructor(t) {
                        super(t, e0),
                        this.recalculate({
                            zoom: 0,
                            zoomHistory: {}
                        }, void 0)
                    }
                    getIlluminationProperties() {
                        let t = this.paint.get("hillshade-illumination-direction").values
                          , i = this.paint.get("hillshade-illumination-altitude").values
                          , a = this.paint.get("hillshade-highlight-color").values
                          , u = this.paint.get("hillshade-shadow-color").values;
                        const p = Math.max(t.length, i.length, a.length, u.length);
                        t = t.concat(Array(p - t.length).fill(t.at(-1))),
                        i = i.concat(Array(p - i.length).fill(i.at(-1))),
                        a = a.concat(Array(p - a.length).fill(a.at(-1))),
                        u = u.concat(Array(p - u.length).fill(u.at(-1)));
                        const f = i.map(vr);
                        return {
                            directionRadians: t.map(vr),
                            altitudeRadians: f,
                            shadowColor: u,
                            highlightColor: a
                        }
                    }
                    hasOffscreenPass() {
                        return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
                    }
                }
                let $m;
                var r0 = {
                    get paint() {
                        return $m = $m || new Ln({
                            "color-relief-opacity": new ar(ye["paint_color-relief"]["color-relief-opacity"]),
                            "color-relief-color": new Ro(ye["paint_color-relief"]["color-relief-color"])
                        })
                    }
                };
                class Pp {
                    constructor(t, i, a, u) {
                        this.context = t,
                        this.format = a,
                        this.texture = t.gl.createTexture(),
                        this.update(i, u)
                    }
                    update(t, i, a) {
                        const {width: u, height: p} = t
                          , f = !(this.size && this.size[0] === u && this.size[1] === p || a)
                          , {context: g} = this
                          , {gl: y} = g;
                        if (this.useMipmap = !!(i && i.useMipmap),
                        y.bindTexture(y.TEXTURE_2D, this.texture),
                        g.pixelStoreUnpackFlipY.set(!1),
                        g.pixelStoreUnpack.set(1),
                        g.pixelStoreUnpackPremultiplyAlpha.set(this.format === y.RGBA && (!i || i.premultiply !== !1)),
                        f)
                            this.size = [u, p],
                            t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || zr(t) ? y.texImage2D(y.TEXTURE_2D, 0, this.format, this.format, y.UNSIGNED_BYTE, t) : y.texImage2D(y.TEXTURE_2D, 0, this.format, u, p, 0, this.format, y.UNSIGNED_BYTE, t.data);
                        else {
                            const {x: S, y: I} = a || {
                                x: 0,
                                y: 0
                            };
                            t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || zr(t) ? y.texSubImage2D(y.TEXTURE_2D, 0, S, I, y.RGBA, y.UNSIGNED_BYTE, t) : y.texSubImage2D(y.TEXTURE_2D, 0, S, I, u, p, y.RGBA, y.UNSIGNED_BYTE, t.data)
                        }
                        this.useMipmap && this.isSizePowerOfTwo() && y.generateMipmap(y.TEXTURE_2D),
                        g.pixelStoreUnpackFlipY.setDefault(),
                        g.pixelStoreUnpack.setDefault(),
                        g.pixelStoreUnpackPremultiplyAlpha.setDefault()
                    }
                    bind(t, i, a) {
                        const {context: u} = this
                          , {gl: p} = u;
                        p.bindTexture(p.TEXTURE_2D, this.texture),
                        a !== p.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (a = p.LINEAR),
                        t !== this.filter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, t),
                        p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, a || t),
                        this.filter = t),
                        i !== this.wrap && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, i),
                        p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, i),
                        this.wrap = i)
                    }
                    isSizePowerOfTwo() {
                        return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
                    }
                    destroy() {
                        const {gl: t} = this.context;
                        t.deleteTexture(this.texture),
                        this.texture = null
                    }
                }
                class Um {
                    constructor(t, i, a, u=1, p=1, f=1, g=0) {
                        if (this.uid = t,
                        i.height !== i.width)
                            throw new RangeError("DEM tiles must be square");
                        if (a && !["mapbox", "terrarium", "custom"].includes(a))
                            return void Qt(`"${a}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
                        this.stride = i.height;
                        const y = this.dim = i.height - 2;
                        switch (this.data = new Uint32Array(i.data.buffer),
                        a) {
                        case "terrarium":
                            this.redFactor = 256,
                            this.greenFactor = 1,
                            this.blueFactor = 1 / 256,
                            this.baseShift = 32768;
                            break;
                        case "custom":
                            this.redFactor = u,
                            this.greenFactor = p,
                            this.blueFactor = f,
                            this.baseShift = g;
                            break;
                        default:
                            this.redFactor = 6553.6,
                            this.greenFactor = 25.6,
                            this.blueFactor = .1,
                            this.baseShift = 1e4
                        }
                        for (let S = 0; S < y; S++)
                            this.data[this._idx(-1, S)] = this.data[this._idx(0, S)],
                            this.data[this._idx(y, S)] = this.data[this._idx(y - 1, S)],
                            this.data[this._idx(S, -1)] = this.data[this._idx(S, 0)],
                            this.data[this._idx(S, y)] = this.data[this._idx(S, y - 1)];
                        this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)],
                        this.data[this._idx(y, -1)] = this.data[this._idx(y - 1, 0)],
                        this.data[this._idx(-1, y)] = this.data[this._idx(0, y - 1)],
                        this.data[this._idx(y, y)] = this.data[this._idx(y - 1, y - 1)],
                        this.min = Number.MAX_SAFE_INTEGER,
                        this.max = Number.MIN_SAFE_INTEGER;
                        for (let S = 0; S < y; S++)
                            for (let I = 0; I < y; I++) {
                                const A = this.get(S, I);
                                A > this.max && (this.max = A),
                                A < this.min && (this.min = A)
                            }
                    }
                    get(t, i) {
                        const a = new Uint8Array(this.data.buffer)
                          , u = 4 * this._idx(t, i);
                        return this.unpack(a[u], a[u + 1], a[u + 2])
                    }
                    getUnpackVector() {
                        return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift]
                    }
                    _idx(t, i) {
                        if (t < -1 || t >= this.dim + 1 || i < -1 || i >= this.dim + 1)
                            throw new RangeError("out of range source coordinates for DEM data");
                        return (i + 1) * this.stride + (t + 1)
                    }
                    unpack(t, i, a) {
                        return t * this.redFactor + i * this.greenFactor + a * this.blueFactor - this.baseShift
                    }
                    pack(t) {
                        return Gm(t, this.getUnpackVector())
                    }
                    getPixels() {
                        return new ra({
                            width: this.stride,
                            height: this.stride
                        },new Uint8Array(this.data.buffer))
                    }
                    backfillBorder(t, i, a) {
                        if (this.dim !== t.dim)
                            throw new Error("dem dimension mismatch");
                        let u = i * this.dim
                          , p = i * this.dim + this.dim
                          , f = a * this.dim
                          , g = a * this.dim + this.dim;
                        switch (i) {
                        case -1:
                            u = p - 1;
                            break;
                        case 1:
                            p = u + 1
                        }
                        switch (a) {
                        case -1:
                            f = g - 1;
                            break;
                        case 1:
                            g = f + 1
                        }
                        const y = -i * this.dim
                          , S = -a * this.dim;
                        for (let I = f; I < g; I++)
                            for (let A = u; A < p; A++)
                                this.data[this._idx(A, I)] = t.data[this._idx(A + y, I + S)]
                    }
                }
                function Gm(n, t) {
                    const i = t[0]
                      , a = t[1]
                      , u = t[2]
                      , p = t[3]
                      , f = Math.min(i, a, u)
                      , g = Math.round((n + p) / f);
                    return {
                        r: Math.floor(g * f / i) % 256,
                        g: Math.floor(g * f / a) % 256,
                        b: Math.floor(g * f / u) % 256
                    }
                }
                Wt("DEMData", Um);
                class i0 extends gn {
                    constructor(t) {
                        super(t, r0)
                    }
                    _createColorRamp(t) {
                        const i = {
                            elevationStops: [],
                            colorStops: []
                        }
                          , a = this._transitionablePaint._values["color-relief-color"].value.expression;
                        if (a instanceof Co && a._styleExpression.expression instanceof En) {
                            this.colorRampExpression = a;
                            const f = a._styleExpression.expression;
                            i.elevationStops = f.labels,
                            i.colorStops = [];
                            for (const g of i.elevationStops)
                                i.colorStops.push(f.evaluate({
                                    globals: {
                                        elevation: g
                                    }
                                }))
                        }
                        if (i.elevationStops.length < 1 && (i.elevationStops = [0],
                        i.colorStops = [Jr.transparent]),
                        i.elevationStops.length < 2 && (i.elevationStops.push(i.elevationStops[0] + 1),
                        i.colorStops.push(i.colorStops[0])),
                        i.elevationStops.length <= t)
                            return i;
                        const u = {
                            elevationStops: [],
                            colorStops: []
                        }
                          , p = (i.elevationStops.length - 1) / (t - 1);
                        for (let f = 0; f < i.elevationStops.length - .5; f += p)
                            u.elevationStops.push(i.elevationStops[Math.round(f)]),
                            u.colorStops.push(i.colorStops[Math.round(f)]);
                        return Qt(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`),
                        u
                    }
                    _colorRampChanged() {
                        return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression
                    }
                    getColorRampTextures(t, i, a) {
                        if (this.colorRampTextures && !this._colorRampChanged())
                            return this.colorRampTextures;
                        const u = this._createColorRamp(i)
                          , p = new ra({
                            width: u.colorStops.length,
                            height: 1
                        })
                          , f = new ra({
                            width: u.colorStops.length,
                            height: 1
                        });
                        for (let g = 0; g < u.elevationStops.length; g++) {
                            const y = Gm(u.elevationStops[g], a);
                            f.setPixel(0, g, new Jr(y.r / 255,y.g / 255,y.b / 255,1)),
                            p.setPixel(0, g, u.colorStops[g])
                        }
                        return this.colorRampTextures = {
                            elevationTexture: new Pp(t,f,t.gl.RGBA),
                            colorTexture: new Pp(t,p,t.gl.RGBA)
                        },
                        this.colorRampTextures
                    }
                    hasOffscreenPass() {
                        return this.visibility !== "none" && !!this.colorRampTextures
                    }
                }
                const n0 = qi([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , {members: a0} = n0;
                function Ip(n, t, i) {
                    const a = i.patternDependencies;
                    let u = !1;
                    for (const p of t) {
                        const f = p.paint.get(`${n}-pattern`);
                        f.isConstant() || (u = !0);
                        const g = f.constantOr(null);
                        g && (u = !0,
                        a[g.to] = !0,
                        a[g.from] = !0)
                    }
                    return u
                }
                function Mp(n, t, i, a, u) {
                    const p = u.patternDependencies;
                    for (const f of t) {
                        const g = f.paint.get(`${n}-pattern`).value;
                        if (g.kind !== "constant") {
                            let y = g.evaluate({
                                zoom: a - 1
                            }, i, {}, u.availableImages)
                              , S = g.evaluate({
                                zoom: a
                            }, i, {}, u.availableImages)
                              , I = g.evaluate({
                                zoom: a + 1
                            }, i, {}, u.availableImages);
                            y = y && y.name ? y.name : y,
                            S = S && S.name ? S.name : S,
                            I = I && I.name ? I.name : I,
                            p[y] = !0,
                            p[S] = !0,
                            p[I] = !0,
                            i.patterns[f.id] = {
                                min: y,
                                mid: S,
                                max: I
                            }
                        }
                    }
                    return i
                }
                function Hm(n, t, i, a, u) {
                    let p;
                    if (u === function(f, g, y, S) {
                        let I = 0;
                        for (let A = g, R = y - S; A < y; A += S)
                            I += (f[R] - f[A]) * (f[A + 1] + f[R + 1]),
                            R = A;
                        return I
                    }(n, t, i, a) > 0)
                        for (let f = t; f < i; f += a)
                            p = Ym(f / a | 0, n[f], n[f + 1], p);
                    else
                        for (let f = i - a; f >= t; f -= a)
                            p = Ym(f / a | 0, n[f], n[f + 1], p);
                    return p && Dl(p, p.next) && (lu(p),
                    p = p.next),
                    p
                }
                function Zo(n, t) {
                    if (!n)
                        return n;
                    t || (t = n);
                    let i, a = n;
                    do
                        if (i = !1,
                        a.steiner || !Dl(a, a.next) && Hi(a.prev, a, a.next) !== 0)
                            a = a.next;
                        else {
                            if (lu(a),
                            a = t = a.prev,
                            a === a.next)
                                break;
                            i = !0
                        }
                    while (i || a !== t);
                    return t
                }
                function au(n, t, i, a, u, p, f) {
                    if (!n)
                        return;
                    !f && p && function(y, S, I, A) {
                        let R = y;
                        do
                            R.z === 0 && (R.z = Ap(R.x, R.y, S, I, A)),
                            R.prevZ = R.prev,
                            R.nextZ = R.next,
                            R = R.next;
                        while (R !== y);
                        R.prevZ.nextZ = null,
                        R.prevZ = null,
                        function(N) {
                            let j, $ = 1;
                            do {
                                let J, se = N;
                                N = null;
                                let Ae = null;
                                for (j = 0; se; ) {
                                    j++;
                                    let _e = se
                                      , O = 0;
                                    for (let ve = 0; ve < $ && (O++,
                                    _e = _e.nextZ,
                                    _e); ve++)
                                        ;
                                    let Y = $;
                                    for (; O > 0 || Y > 0 && _e; )
                                        O !== 0 && (Y === 0 || !_e || se.z <= _e.z) ? (J = se,
                                        se = se.nextZ,
                                        O--) : (J = _e,
                                        _e = _e.nextZ,
                                        Y--),
                                        Ae ? Ae.nextZ = J : N = J,
                                        J.prevZ = Ae,
                                        Ae = J;
                                    se = _e
                                }
                                Ae.nextZ = null,
                                $ *= 2
                            } while (j > 1)
                        }(R)
                    }(n, a, u, p);
                    let g = n;
                    for (; n.prev !== n.next; ) {
                        const y = n.prev
                          , S = n.next;
                        if (p ? o0(n, a, u, p) : s0(n))
                            t.push(y.i, n.i, S.i),
                            lu(n),
                            n = S.next,
                            g = S.next;
                        else if ((n = S) === g) {
                            f ? f === 1 ? au(n = l0(Zo(n), t), t, i, a, u, p, 2) : f === 2 && c0(n, t, i, a, u, p) : au(Zo(n), t, i, a, u, p, 1);
                            break
                        }
                    }
                }
                function s0(n) {
                    const t = n.prev
                      , i = n
                      , a = n.next;
                    if (Hi(t, i, a) >= 0)
                        return !1;
                    const u = t.x
                      , p = i.x
                      , f = a.x
                      , g = t.y
                      , y = i.y
                      , S = a.y
                      , I = Math.min(u, p, f)
                      , A = Math.min(g, y, S)
                      , R = Math.max(u, p, f)
                      , N = Math.max(g, y, S);
                    let j = a.next;
                    for (; j !== t; ) {
                        if (j.x >= I && j.x <= R && j.y >= A && j.y <= N && su(u, g, p, y, f, S, j.x, j.y) && Hi(j.prev, j, j.next) >= 0)
                            return !1;
                        j = j.next
                    }
                    return !0
                }
                function o0(n, t, i, a) {
                    const u = n.prev
                      , p = n
                      , f = n.next;
                    if (Hi(u, p, f) >= 0)
                        return !1;
                    const g = u.x
                      , y = p.x
                      , S = f.x
                      , I = u.y
                      , A = p.y
                      , R = f.y
                      , N = Math.min(g, y, S)
                      , j = Math.min(I, A, R)
                      , $ = Math.max(g, y, S)
                      , J = Math.max(I, A, R)
                      , se = Ap(N, j, t, i, a)
                      , Ae = Ap($, J, t, i, a);
                    let _e = n.prevZ
                      , O = n.nextZ;
                    for (; _e && _e.z >= se && O && O.z <= Ae; ) {
                        if (_e.x >= N && _e.x <= $ && _e.y >= j && _e.y <= J && _e !== u && _e !== f && su(g, I, y, A, S, R, _e.x, _e.y) && Hi(_e.prev, _e, _e.next) >= 0 || (_e = _e.prevZ,
                        O.x >= N && O.x <= $ && O.y >= j && O.y <= J && O !== u && O !== f && su(g, I, y, A, S, R, O.x, O.y) && Hi(O.prev, O, O.next) >= 0))
                            return !1;
                        O = O.nextZ
                    }
                    for (; _e && _e.z >= se; ) {
                        if (_e.x >= N && _e.x <= $ && _e.y >= j && _e.y <= J && _e !== u && _e !== f && su(g, I, y, A, S, R, _e.x, _e.y) && Hi(_e.prev, _e, _e.next) >= 0)
                            return !1;
                        _e = _e.prevZ
                    }
                    for (; O && O.z <= Ae; ) {
                        if (O.x >= N && O.x <= $ && O.y >= j && O.y <= J && O !== u && O !== f && su(g, I, y, A, S, R, O.x, O.y) && Hi(O.prev, O, O.next) >= 0)
                            return !1;
                        O = O.nextZ
                    }
                    return !0
                }
                function l0(n, t) {
                    let i = n;
                    do {
                        const a = i.prev
                          , u = i.next.next;
                        !Dl(a, u) && Xm(a, i, i.next, u) && ou(a, u) && ou(u, a) && (t.push(a.i, i.i, u.i),
                        lu(i),
                        lu(i.next),
                        i = n = u),
                        i = i.next
                    } while (i !== n);
                    return Zo(i)
                }
                function c0(n, t, i, a, u, p) {
                    let f = n;
                    do {
                        let g = f.next.next;
                        for (; g !== f.prev; ) {
                            if (f.i !== g.i && f0(f, g)) {
                                let y = Km(f, g);
                                return f = Zo(f, f.next),
                                y = Zo(y, y.next),
                                au(f, t, i, a, u, p, 0),
                                void au(y, t, i, a, u, p, 0)
                            }
                            g = g.next
                        }
                        f = f.next
                    } while (f !== n)
                }
                function u0(n, t) {
                    let i = n.x - t.x;
                    return i === 0 && (i = n.y - t.y,
                    i === 0) && (i = (n.next.y - n.y) / (n.next.x - n.x) - (t.next.y - t.y) / (t.next.x - t.x)),
                    i
                }
                function h0(n, t) {
                    const i = function(u, p) {
                        let f = p;
                        const g = u.x
                          , y = u.y;
                        let S, I = -1 / 0;
                        if (Dl(u, f))
                            return f;
                        do {
                            if (Dl(u, f.next))
                                return f.next;
                            if (y <= f.y && y >= f.next.y && f.next.y !== f.y) {
                                const $ = f.x + (y - f.y) * (f.next.x - f.x) / (f.next.y - f.y);
                                if ($ <= g && $ > I && (I = $,
                                S = f.x < f.next.x ? f : f.next,
                                $ === g))
                                    return S
                            }
                            f = f.next
                        } while (f !== p);
                        if (!S)
                            return null;
                        const A = S
                          , R = S.x
                          , N = S.y;
                        let j = 1 / 0;
                        f = S;
                        do {
                            if (g >= f.x && f.x >= R && g !== f.x && Wm(y < N ? g : I, y, R, N, y < N ? I : g, y, f.x, f.y)) {
                                const $ = Math.abs(y - f.y) / (g - f.x);
                                ou(f, u) && ($ < j || $ === j && (f.x > S.x || f.x === S.x && d0(S, f))) && (S = f,
                                j = $)
                            }
                            f = f.next
                        } while (f !== A);
                        return S
                    }(n, t);
                    if (!i)
                        return t;
                    const a = Km(i, n);
                    return Zo(a, a.next),
                    Zo(i, i.next)
                }
                function d0(n, t) {
                    return Hi(n.prev, n, t.prev) < 0 && Hi(t.next, n, n.next) < 0
                }
                function Ap(n, t, i, a, u) {
                    return (n = 1431655765 & ((n = 858993459 & ((n = 252645135 & ((n = 16711935 & ((n = (n - i) * u | 0) | n << 8)) | n << 4)) | n << 2)) | n << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - a) * u | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
                }
                function p0(n) {
                    let t = n
                      , i = n;
                    do
                        (t.x < i.x || t.x === i.x && t.y < i.y) && (i = t),
                        t = t.next;
                    while (t !== n);
                    return i
                }
                function Wm(n, t, i, a, u, p, f, g) {
                    return (u - f) * (t - g) >= (n - f) * (p - g) && (n - f) * (a - g) >= (i - f) * (t - g) && (i - f) * (p - g) >= (u - f) * (a - g)
                }
                function su(n, t, i, a, u, p, f, g) {
                    return !(n === f && t === g) && Wm(n, t, i, a, u, p, f, g)
                }
                function f0(n, t) {
                    return n.next.i !== t.i && n.prev.i !== t.i && !function(i, a) {
                        let u = i;
                        do {
                            if (u.i !== i.i && u.next.i !== i.i && u.i !== a.i && u.next.i !== a.i && Xm(u, u.next, i, a))
                                return !0;
                            u = u.next
                        } while (u !== i);
                        return !1
                    }(n, t) && (ou(n, t) && ou(t, n) && function(i, a) {
                        let u = i
                          , p = !1;
                        const f = (i.x + a.x) / 2
                          , g = (i.y + a.y) / 2;
                        do
                            u.y > g != u.next.y > g && u.next.y !== u.y && f < (u.next.x - u.x) * (g - u.y) / (u.next.y - u.y) + u.x && (p = !p),
                            u = u.next;
                        while (u !== i);
                        return p
                    }(n, t) && (Hi(n.prev, n, t.prev) || Hi(n, t.prev, t)) || Dl(n, t) && Hi(n.prev, n, n.next) > 0 && Hi(t.prev, t, t.next) > 0)
                }
                function Hi(n, t, i) {
                    return (t.y - n.y) * (i.x - t.x) - (t.x - n.x) * (i.y - t.y)
                }
                function Dl(n, t) {
                    return n.x === t.x && n.y === t.y
                }
                function Xm(n, t, i, a) {
                    const u = sd(Hi(n, t, i))
                      , p = sd(Hi(n, t, a))
                      , f = sd(Hi(i, a, n))
                      , g = sd(Hi(i, a, t));
                    return u !== p && f !== g || !(u !== 0 || !ad(n, i, t)) || !(p !== 0 || !ad(n, a, t)) || !(f !== 0 || !ad(i, n, a)) || !(g !== 0 || !ad(i, t, a))
                }
                function ad(n, t, i) {
                    return t.x <= Math.max(n.x, i.x) && t.x >= Math.min(n.x, i.x) && t.y <= Math.max(n.y, i.y) && t.y >= Math.min(n.y, i.y)
                }
                function sd(n) {
                    return n > 0 ? 1 : n < 0 ? -1 : 0
                }
                function ou(n, t) {
                    return Hi(n.prev, n, n.next) < 0 ? Hi(n, t, n.next) >= 0 && Hi(n, n.prev, t) >= 0 : Hi(n, t, n.prev) < 0 || Hi(n, n.next, t) < 0
                }
                function Km(n, t) {
                    const i = kp(n.i, n.x, n.y)
                      , a = kp(t.i, t.x, t.y)
                      , u = n.next
                      , p = t.prev;
                    return n.next = t,
                    t.prev = n,
                    i.next = u,
                    u.prev = i,
                    a.next = i,
                    i.prev = a,
                    p.next = a,
                    a.prev = p,
                    a
                }
                function Ym(n, t, i, a) {
                    const u = kp(n, t, i);
                    return a ? (u.next = a.next,
                    u.prev = a,
                    a.next.prev = u,
                    a.next = u) : (u.prev = u,
                    u.next = u),
                    u
                }
                function lu(n) {
                    n.next.prev = n.prev,
                    n.prev.next = n.next,
                    n.prevZ && (n.prevZ.nextZ = n.nextZ),
                    n.nextZ && (n.nextZ.prevZ = n.prevZ)
                }
                function kp(n, t, i) {
                    return {
                        i: n,
                        x: t,
                        y: i,
                        prev: null,
                        next: null,
                        z: 0,
                        prevZ: null,
                        nextZ: null,
                        steiner: !1
                    }
                }
                class Rl {
                    constructor(t, i) {
                        if (i > t)
                            throw new Error("Min granularity must not be greater than base granularity.");
                        this._baseZoomGranularity = t,
                        this._minGranularity = i
                    }
                    getGranularityForZoomLevel(t) {
                        return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1)
                    }
                }
                class od {
                    constructor(t) {
                        this.fill = t.fill,
                        this.line = t.line,
                        this.tile = t.tile,
                        this.stencil = t.stencil,
                        this.circle = t.circle
                    }
                }
                od.noSubdivision = new od({
                    fill: new Rl(0,0),
                    line: new Rl(0,0),
                    tile: new Rl(0,0),
                    stencil: new Rl(0,0),
                    circle: 1
                }),
                Wt("SubdivisionGranularityExpression", Rl),
                Wt("SubdivisionGranularitySetting", od);
                const Bl = -32768
                  , cu = 32767;
                class m0 {
                    constructor(t, i) {
                        this._vertexBuffer = [],
                        this._vertexDictionary = new Map,
                        this._used = !1,
                        this._granularity = t,
                        this._granularityCellSize = We / t,
                        this._canonical = i
                    }
                    _getKey(t, i) {
                        return (t += 32768) << 16 | i + 32768
                    }
                    _vertexToIndex(t, i) {
                        if (t < -32768 || i < -32768 || t > 32767 || i > 32767)
                            throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
                        const a = 0 | Math.round(t)
                          , u = 0 | Math.round(i)
                          , p = this._getKey(a, u);
                        if (this._vertexDictionary.has(p))
                            return this._vertexDictionary.get(p);
                        const f = this._vertexBuffer.length / 2;
                        return this._vertexDictionary.set(p, f),
                        this._vertexBuffer.push(a, u),
                        f
                    }
                    _subdivideTrianglesScanline(t) {
                        if (this._granularity < 2)
                            return function(u, p) {
                                const f = [];
                                for (let g = 0; g < p.length; g += 3) {
                                    const y = p[g]
                                      , S = p[g + 1]
                                      , I = p[g + 2]
                                      , A = u[2 * y]
                                      , R = u[2 * y + 1];
                                    (u[2 * S] - A) * (u[2 * I + 1] - R) - (u[2 * S + 1] - R) * (u[2 * I] - A) > 0 ? (f.push(y),
                                    f.push(I),
                                    f.push(S)) : (f.push(y),
                                    f.push(S),
                                    f.push(I))
                                }
                                return f
                            }(this._vertexBuffer, t);
                        const i = []
                          , a = t.length;
                        for (let u = 0; u < a; u += 3) {
                            const p = [t[u + 0], t[u + 1], t[u + 2]]
                              , f = [this._vertexBuffer[2 * t[u + 0] + 0], this._vertexBuffer[2 * t[u + 0] + 1], this._vertexBuffer[2 * t[u + 1] + 0], this._vertexBuffer[2 * t[u + 1] + 1], this._vertexBuffer[2 * t[u + 2] + 0], this._vertexBuffer[2 * t[u + 2] + 1]];
                            let g = 1 / 0
                              , y = 1 / 0
                              , S = -1 / 0
                              , I = -1 / 0;
                            for (let $ = 0; $ < 3; $++) {
                                const J = f[2 * $]
                                  , se = f[2 * $ + 1];
                                g = Math.min(g, J),
                                S = Math.max(S, J),
                                y = Math.min(y, se),
                                I = Math.max(I, se)
                            }
                            if (g === S || y === I)
                                continue;
                            const A = Math.floor(g / this._granularityCellSize)
                              , R = Math.ceil(S / this._granularityCellSize)
                              , N = Math.floor(y / this._granularityCellSize)
                              , j = Math.ceil(I / this._granularityCellSize);
                            if (A !== R || N !== j)
                                for (let $ = N; $ < j; $++) {
                                    const J = this._scanlineGenerateVertexRingForCellRow($, f, p);
                                    _0(this._vertexBuffer, J, i)
                                }
                            else
                                i.push(...p)
                        }
                        return i
                    }
                    _scanlineGenerateVertexRingForCellRow(t, i, a) {
                        const u = t * this._granularityCellSize
                          , p = u + this._granularityCellSize
                          , f = [];
                        for (let g = 0; g < 3; g++) {
                            const y = i[2 * g]
                              , S = i[2 * g + 1]
                              , I = i[2 * (g + 1) % 6]
                              , A = i[(2 * (g + 1) + 1) % 6]
                              , R = i[2 * (g + 2) % 6]
                              , N = i[(2 * (g + 2) + 1) % 6]
                              , j = I - y
                              , $ = A - S
                              , J = j === 0
                              , se = $ === 0
                              , Ae = (u - S) / $
                              , _e = (p - S) / $
                              , O = Math.min(Ae, _e)
                              , Y = Math.max(Ae, _e);
                            if (!se && (O >= 1 || Y <= 0) || se && (S < u || S > p)) {
                                A >= u && A <= p && f.push(a[(g + 1) % 3]);
                                continue
                            }
                            !se && O > 0 && f.push(this._vertexToIndex(y + j * O, S + $ * O));
                            const ve = y + j * Math.max(O, 0)
                              , Xe = y + j * Math.min(Y, 1);
                            J || this._generateIntraEdgeVertices(f, y, S, I, A, ve, Xe),
                            !se && Y < 1 && f.push(this._vertexToIndex(y + j * Y, S + $ * Y)),
                            (se || A >= u && A <= p) && f.push(a[(g + 1) % 3]),
                            !se && (A <= u || A >= p) && this._generateInterEdgeVertices(f, y, S, I, A, R, N, Xe, u, p)
                        }
                        return f
                    }
                    _generateIntraEdgeVertices(t, i, a, u, p, f, g) {
                        const y = u - i
                          , S = p - a
                          , I = S === 0
                          , A = I ? Math.min(i, u) : Math.min(f, g)
                          , R = I ? Math.max(i, u) : Math.max(f, g)
                          , N = Math.floor(A / this._granularityCellSize) + 1
                          , j = Math.ceil(R / this._granularityCellSize) - 1;
                        if (I ? i < u : f < g)
                            for (let $ = N; $ <= j; $++) {
                                const J = $ * this._granularityCellSize;
                                t.push(this._vertexToIndex(J, a + S * (J - i) / y))
                            }
                        else
                            for (let $ = j; $ >= N; $--) {
                                const J = $ * this._granularityCellSize;
                                t.push(this._vertexToIndex(J, a + S * (J - i) / y))
                            }
                    }
                    _generateInterEdgeVertices(t, i, a, u, p, f, g, y, S, I) {
                        const A = p - a
                          , R = f - u
                          , N = g - p
                          , j = (S - p) / N
                          , $ = (I - p) / N
                          , J = Math.min(j, $)
                          , se = Math.max(j, $)
                          , Ae = u + R * J;
                        let _e = Math.floor(Math.min(Ae, y) / this._granularityCellSize) + 1
                          , O = Math.ceil(Math.max(Ae, y) / this._granularityCellSize) - 1
                          , Y = y < Ae;
                        const ve = N === 0;
                        if (ve && (g === S || g === I))
                            return;
                        if (ve || J >= 1 || se <= 0) {
                            const bt = a - g
                              , Qe = f + (i - f) * Math.min((S - g) / bt, (I - g) / bt);
                            _e = Math.floor(Math.min(Qe, y) / this._granularityCellSize) + 1,
                            O = Math.ceil(Math.max(Qe, y) / this._granularityCellSize) - 1,
                            Y = y < Qe
                        }
                        const Xe = A > 0 ? I : S;
                        if (Y)
                            for (let bt = _e; bt <= O; bt++)
                                t.push(this._vertexToIndex(bt * this._granularityCellSize, Xe));
                        else
                            for (let bt = O; bt >= _e; bt--)
                                t.push(this._vertexToIndex(bt * this._granularityCellSize, Xe))
                    }
                    _generateOutline(t) {
                        const i = [];
                        for (const a of t) {
                            const u = $o(a, this._granularity, !0)
                              , p = this._pointArrayToIndices(u)
                              , f = [];
                            for (let g = 1; g < p.length; g++)
                                f.push(p[g - 1]),
                                f.push(p[g]);
                            i.push(f)
                        }
                        return i
                    }
                    _handlePoles(t) {
                        let i = !1
                          , a = !1;
                        this._canonical && (this._canonical.y === 0 && (i = !0),
                        this._canonical.y === (1 << this._canonical.z) - 1 && (a = !0)),
                        (i || a) && this._fillPoles(t, i, a)
                    }
                    _ensureNoPoleVertices() {
                        const t = this._vertexBuffer;
                        for (let i = 0; i < t.length; i += 2) {
                            const a = t[i + 1];
                            a === Bl && (t[i + 1] = -32767),
                            a === cu && (t[i + 1] = 32766)
                        }
                    }
                    _generatePoleQuad(t, i, a, u, p, f) {
                        u > p != (f === Bl) ? (t.push(i),
                        t.push(a),
                        t.push(this._vertexToIndex(u, f)),
                        t.push(a),
                        t.push(this._vertexToIndex(p, f)),
                        t.push(this._vertexToIndex(u, f))) : (t.push(a),
                        t.push(i),
                        t.push(this._vertexToIndex(u, f)),
                        t.push(this._vertexToIndex(p, f)),
                        t.push(a),
                        t.push(this._vertexToIndex(u, f)))
                    }
                    _fillPoles(t, i, a) {
                        const u = this._vertexBuffer
                          , p = We
                          , f = t.length;
                        for (let g = 2; g < f; g += 3) {
                            const y = t[g - 2]
                              , S = t[g - 1]
                              , I = t[g]
                              , A = u[2 * y]
                              , R = u[2 * y + 1]
                              , N = u[2 * S]
                              , j = u[2 * S + 1]
                              , $ = u[2 * I]
                              , J = u[2 * I + 1];
                            i && (R === 0 && j === 0 && this._generatePoleQuad(t, y, S, A, N, Bl),
                            j === 0 && J === 0 && this._generatePoleQuad(t, S, I, N, $, Bl),
                            J === 0 && R === 0 && this._generatePoleQuad(t, I, y, $, A, Bl)),
                            a && (R === p && j === p && this._generatePoleQuad(t, y, S, A, N, cu),
                            j === p && J === p && this._generatePoleQuad(t, S, I, N, $, cu),
                            J === p && R === p && this._generatePoleQuad(t, I, y, $, A, cu))
                        }
                    }
                    _initializeVertices(t) {
                        for (let i = 0; i < t.length; i += 2)
                            this._vertexToIndex(t[i], t[i + 1])
                    }
                    subdividePolygonInternal(t, i) {
                        if (this._used)
                            throw new Error("Subdivision: multiple use not allowed.");
                        this._used = !0;
                        const {flattened: a, holeIndices: u} = function(g) {
                            const y = []
                              , S = [];
                            for (const I of g)
                                if (I.length !== 0) {
                                    I !== g[0] && y.push(S.length / 2);
                                    for (let A = 0; A < I.length; A++)
                                        S.push(I[A].x),
                                        S.push(I[A].y)
                                }
                            return {
                                flattened: S,
                                holeIndices: y
                            }
                        }(t);
                        let p;
                        this._initializeVertices(a);
                        try {
                            const g = function(S, I, A=2) {
                                const R = I && I.length
                                  , N = R ? I[0] * A : S.length;
                                let j = Hm(S, 0, N, A, !0);
                                const $ = [];
                                if (!j || j.next === j.prev)
                                    return $;
                                let J, se, Ae;
                                if (R && (j = function(_e, O, Y, ve) {
                                    const Xe = [];
                                    for (let bt = 0, Qe = O.length; bt < Qe; bt++) {
                                        const ot = Hm(_e, O[bt] * ve, bt < Qe - 1 ? O[bt + 1] * ve : _e.length, ve, !1);
                                        ot === ot.next && (ot.steiner = !0),
                                        Xe.push(p0(ot))
                                    }
                                    Xe.sort(u0);
                                    for (let bt = 0; bt < Xe.length; bt++)
                                        Y = h0(Xe[bt], Y);
                                    return Y
                                }(S, I, j, A)),
                                S.length > 80 * A) {
                                    J = 1 / 0,
                                    se = 1 / 0;
                                    let _e = -1 / 0
                                      , O = -1 / 0;
                                    for (let Y = A; Y < N; Y += A) {
                                        const ve = S[Y]
                                          , Xe = S[Y + 1];
                                        ve < J && (J = ve),
                                        Xe < se && (se = Xe),
                                        ve > _e && (_e = ve),
                                        Xe > O && (O = Xe)
                                    }
                                    Ae = Math.max(_e - J, O - se),
                                    Ae = Ae !== 0 ? 32767 / Ae : 0
                                }
                                return au(j, $, A, J, se, Ae, 0),
                                $
                            }(a, u)
                              , y = this._convertIndices(a, g);
                            p = this._subdivideTrianglesScanline(y)
                        } catch (g) {
                            console.error(g)
                        }
                        let f = [];
                        return i && (f = this._generateOutline(t)),
                        this._ensureNoPoleVertices(),
                        this._handlePoles(p),
                        {
                            verticesFlattened: this._vertexBuffer,
                            indicesTriangles: p,
                            indicesLineList: f
                        }
                    }
                    _convertIndices(t, i) {
                        const a = [];
                        for (let u = 0; u < i.length; u++)
                            a.push(this._vertexToIndex(t[2 * i[u]], t[2 * i[u] + 1]));
                        return a
                    }
                    _pointArrayToIndices(t) {
                        const i = [];
                        for (let a = 0; a < t.length; a++) {
                            const u = t[a];
                            i.push(this._vertexToIndex(u.x, u.y))
                        }
                        return i
                    }
                }
                function Jm(n, t, i, a=!0) {
                    return new m0(i,t).subdividePolygonInternal(n, a)
                }
                function $o(n, t, i=!1) {
                    if (!n || n.length < 1)
                        return [];
                    if (n.length < 2)
                        return [];
                    const a = n[0]
                      , u = n[n.length - 1]
                      , p = i && (a.x !== u.x || a.y !== u.y);
                    if (t < 2)
                        return p ? [...n, n[0]] : [...n];
                    const f = Math.floor(We / t)
                      , g = [];
                    g.push(new le(n[0].x,n[0].y));
                    const y = n.length
                      , S = p ? y : y - 1;
                    for (let I = 0; I < S; I++) {
                        const A = n[I]
                          , R = I < y - 1 ? n[I + 1] : n[0]
                          , N = A.x
                          , j = A.y
                          , $ = R.x
                          , J = R.y
                          , se = N !== $
                          , Ae = j !== J;
                        if (!se && !Ae)
                            continue;
                        const _e = $ - N
                          , O = J - j
                          , Y = Math.abs(_e)
                          , ve = Math.abs(O);
                        let Xe = N
                          , bt = j;
                        for (; ; ) {
                            const ot = _e > 0 ? (Math.floor(Xe / f) + 1) * f : (Math.ceil(Xe / f) - 1) * f
                              , Et = O > 0 ? (Math.floor(bt / f) + 1) * f : (Math.ceil(bt / f) - 1) * f
                              , Ct = Math.abs(Xe - ot)
                              , Dt = Math.abs(bt - Et)
                              , pt = Math.abs(Xe - $)
                              , ir = Math.abs(bt - J)
                              , Er = se ? Ct / Y : Number.POSITIVE_INFINITY
                              , Cr = Ae ? Dt / ve : Number.POSITIVE_INFINITY;
                            if ((pt <= Ct || !se) && (ir <= Dt || !Ae))
                                break;
                            if (Er < Cr && se || !Ae) {
                                Xe = ot,
                                bt += O * Er;
                                const ur = new le(Xe,Math.round(bt));
                                g[g.length - 1].x === ur.x && g[g.length - 1].y === ur.y || g.push(ur)
                            } else {
                                Xe += _e * Cr,
                                bt = Et;
                                const ur = new le(Math.round(Xe),bt);
                                g[g.length - 1].x === ur.x && g[g.length - 1].y === ur.y || g.push(ur)
                            }
                        }
                        const Qe = new le($,J);
                        g[g.length - 1].x === Qe.x && g[g.length - 1].y === Qe.y || g.push(Qe)
                    }
                    return g
                }
                function _0(n, t, i) {
                    if (t.length === 0)
                        throw new Error("Subdivision vertex ring is empty.");
                    let a = 0
                      , u = n[2 * t[0]];
                    for (let y = 1; y < t.length; y++) {
                        const S = n[2 * t[y]];
                        S < u && (u = S,
                        a = y)
                    }
                    const p = t.length;
                    let f = a
                      , g = (f + 1) % p;
                    for (; ; ) {
                        const y = f - 1 >= 0 ? f - 1 : p - 1
                          , S = (g + 1) % p
                          , I = n[2 * t[y]]
                          , A = n[2 * t[S]]
                          , R = n[2 * t[f]]
                          , N = n[2 * t[f] + 1]
                          , j = n[2 * t[g] + 1];
                        let $ = !1;
                        if (I < A)
                            $ = !0;
                        else if (I > A)
                            $ = !1;
                        else {
                            const J = j - N
                              , se = -(n[2 * t[g]] - R)
                              , Ae = N < j ? 1 : -1;
                            ((I - R) * J + (n[2 * t[y] + 1] - N) * se) * Ae > ((A - R) * J + (n[2 * t[S] + 1] - N) * se) * Ae && ($ = !0)
                        }
                        if ($) {
                            const J = t[y]
                              , se = t[f]
                              , Ae = t[g];
                            J !== se && J !== Ae && se !== Ae && i.push(Ae, se, J),
                            f--,
                            f < 0 && (f = p - 1)
                        } else {
                            const J = t[S]
                              , se = t[f]
                              , Ae = t[g];
                            J !== se && J !== Ae && se !== Ae && i.push(Ae, se, J),
                            g++,
                            g >= p && (g = 0)
                        }
                        if (y === S)
                            break
                    }
                }
                function Qm(n, t, i, a, u, p, f, g, y) {
                    const S = u.length / 2
                      , I = f && g && y;
                    if (S < li.MAX_VERTEX_ARRAY_LENGTH) {
                        const A = t.prepareSegment(S, i, a)
                          , R = A.vertexLength;
                        for (let $ = 0; $ < p.length; $ += 3)
                            a.emplaceBack(R + p[$], R + p[$ + 1], R + p[$ + 2]);
                        let N, j;
                        A.vertexLength += S,
                        A.primitiveLength += p.length / 3,
                        I && (j = f.prepareSegment(S, i, g),
                        N = j.vertexLength,
                        j.vertexLength += S);
                        for (let $ = 0; $ < u.length; $ += 2)
                            n(u[$], u[$ + 1]);
                        if (I)
                            for (let $ = 0; $ < y.length; $++) {
                                const J = y[$];
                                for (let se = 1; se < J.length; se += 2)
                                    g.emplaceBack(N + J[se - 1], N + J[se]);
                                j.primitiveLength += J.length / 2
                            }
                    } else
                        (function(A, R, N, j, $, J) {
                            const se = [];
                            for (let ve = 0; ve < j.length / 2; ve++)
                                se.push(-1);
                            const Ae = {
                                count: 0
                            };
                            let _e = 0
                              , O = A.getOrCreateLatestSegment(R, N)
                              , Y = O.vertexLength;
                            for (let ve = 2; ve < $.length; ve += 3) {
                                const Xe = $[ve - 2]
                                  , bt = $[ve - 1]
                                  , Qe = $[ve];
                                let ot = se[Xe] < _e
                                  , Et = se[bt] < _e
                                  , Ct = se[Qe] < _e;
                                O.vertexLength + ((ot ? 1 : 0) + (Et ? 1 : 0) + (Ct ? 1 : 0)) > li.MAX_VERTEX_ARRAY_LENGTH && (O = A.createNewSegment(R, N),
                                _e = Ae.count,
                                ot = !0,
                                Et = !0,
                                Ct = !0,
                                Y = 0);
                                const Dt = uu(se, j, J, Ae, Xe, ot, O)
                                  , pt = uu(se, j, J, Ae, bt, Et, O)
                                  , ir = uu(se, j, J, Ae, Qe, Ct, O);
                                N.emplaceBack(Y + Dt - _e, Y + pt - _e, Y + ir - _e),
                                O.primitiveLength++
                            }
                        }
                        )(t, i, a, u, p, n),
                        I && function(A, R, N, j, $, J) {
                            const se = [];
                            for (let ve = 0; ve < j.length / 2; ve++)
                                se.push(-1);
                            const Ae = {
                                count: 0
                            };
                            let _e = 0
                              , O = A.getOrCreateLatestSegment(R, N)
                              , Y = O.vertexLength;
                            for (let ve = 0; ve < $.length; ve++) {
                                const Xe = $[ve];
                                for (let bt = 1; bt < $[ve].length; bt += 2) {
                                    const Qe = Xe[bt - 1]
                                      , ot = Xe[bt];
                                    let Et = se[Qe] < _e
                                      , Ct = se[ot] < _e;
                                    O.vertexLength + ((Et ? 1 : 0) + (Ct ? 1 : 0)) > li.MAX_VERTEX_ARRAY_LENGTH && (O = A.createNewSegment(R, N),
                                    _e = Ae.count,
                                    Et = !0,
                                    Ct = !0,
                                    Y = 0);
                                    const Dt = uu(se, j, J, Ae, Qe, Et, O)
                                      , pt = uu(se, j, J, Ae, ot, Ct, O);
                                    N.emplaceBack(Y + Dt - _e, Y + pt - _e),
                                    O.primitiveLength++
                                }
                            }
                        }(f, i, g, u, y, n),
                        t.forceNewSegmentOnNextPrepare(),
                        f == null || f.forceNewSegmentOnNextPrepare()
                }
                function uu(n, t, i, a, u, p, f) {
                    if (p) {
                        const g = a.count;
                        return i(t[2 * u], t[2 * u + 1]),
                        n[u] = a.count,
                        a.count++,
                        f.vertexLength++,
                        g
                    }
                    return n[u]
                }
                class Ep {
                    constructor(t) {
                        this.zoom = t.zoom,
                        this.globalState = t.globalState,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map(i => i.id),
                        this.index = t.index,
                        this.hasPattern = !1,
                        this.patternFeatures = [],
                        this.layoutVertexArray = new Je,
                        this.indexArray = new Ti,
                        this.indexArray2 = new bi,
                        this.programConfigurations = new rs(t.layers,t.zoom),
                        this.segments = new li,
                        this.segments2 = new li,
                        this.stateDependentLayerIds = this.layers.filter(i => i.isStateDependent()).map(i => i.id)
                    }
                    populate(t, i, a) {
                        this.hasPattern = Ip("fill", this.layers, i);
                        const u = this.layers[0].layout.get("fill-sort-key")
                          , p = !u.isConstant()
                          , f = [];
                        for (const {feature: g, id: y, index: S, sourceLayerIndex: I} of t) {
                            const A = this.layers[0]._featureFilter.needGeometry
                              , R = Vo(g, A);
                            if (!this.layers[0]._featureFilter.filter(new Ei(this.zoom,{
                                globalState: this.globalState
                            }), R, a))
                                continue;
                            const N = p ? u.evaluate(R, {}, a, i.availableImages) : void 0
                              , j = {
                                id: y,
                                properties: g.properties,
                                type: g.type,
                                sourceLayerIndex: I,
                                index: S,
                                geometry: A ? R.geometry : qo(g),
                                patterns: {},
                                sortKey: N
                            };
                            f.push(j)
                        }
                        p && f.sort( (g, y) => g.sortKey - y.sortKey);
                        for (const g of f) {
                            const {geometry: y, index: S, sourceLayerIndex: I} = g;
                            if (this.hasPattern) {
                                const A = Mp("fill", this.layers, g, this.zoom, i);
                                this.patternFeatures.push(A)
                            } else
                                this.addFeature(g, y, S, a, {}, i.subdivisionGranularity);
                            i.featureIndex.insert(t[S].feature, y, S, I, this.index)
                        }
                    }
                    update(t, i, a) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, i, this.stateDependentLayers, a)
                    }
                    addFeatures(t, i, a) {
                        for (const u of this.patternFeatures)
                            this.addFeature(u, u.geometry, u.index, i, a, t.subdivisionGranularity)
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, a0),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray),
                        this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)),
                        this.programConfigurations.upload(t),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.indexBuffer2.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.segments2.destroy())
                    }
                    addFeature(t, i, a, u, p, f) {
                        for (const g of ol(i, 500)) {
                            const y = Jm(g, u, f.fill.getGranularityForZoomLevel(u.z))
                              , S = this.layoutVertexArray;
                            Qm( (I, A) => {
                                S.emplaceBack(I, A)
                            }
                            , this.segments, this.layoutVertexArray, this.indexArray, y.verticesFlattened, y.indicesTriangles, this.segments2, this.indexArray2, y.indicesLineList)
                        }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, p, u)
                    }
                }
                let e_, t_;
                Wt("FillBucket", Ep, {
                    omit: ["layers", "patternFeatures"]
                });
                var g0 = {
                    get paint() {
                        return t_ = t_ || new Ln({
                            "fill-antialias": new ar(ye.paint_fill["fill-antialias"]),
                            "fill-opacity": new Rr(ye.paint_fill["fill-opacity"]),
                            "fill-color": new Rr(ye.paint_fill["fill-color"]),
                            "fill-outline-color": new Rr(ye.paint_fill["fill-outline-color"]),
                            "fill-translate": new ar(ye.paint_fill["fill-translate"]),
                            "fill-translate-anchor": new ar(ye.paint_fill["fill-translate-anchor"]),
                            "fill-pattern": new kl(ye.paint_fill["fill-pattern"])
                        })
                    },
                    get layout() {
                        return e_ = e_ || new Ln({
                            "fill-sort-key": new Rr(ye.layout_fill["fill-sort-key"])
                        })
                    }
                };
                class v0 extends gn {
                    constructor(t) {
                        super(t, g0)
                    }
                    recalculate(t, i) {
                        super.recalculate(t, i);
                        const a = this.paint._values["fill-outline-color"];
                        a.value.kind === "constant" && a.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
                    }
                    createBucket(t) {
                        return new Ep(t)
                    }
                    queryRadius() {
                        return id(this.paint.get("fill-translate"))
                    }
                    queryIntersectsFeature({queryGeometry: t, geometry: i, transform: a, pixelsToTileUnits: u}) {
                        return Lm(nd(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -a.bearingInRadians, u), i)
                    }
                    isTileClipped() {
                        return !0
                    }
                }
                const y0 = qi([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_normal_ed",
                    components: 4,
                    type: "Int16"
                }], 4)
                  , x0 = qi([{
                    name: "a_centroid",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , {members: b0} = y0;
                var zp, r_, Lp, i_, Dp, n_, a_, ld = {};
                function s_() {
                    if (r_)
                        return zp;
                    r_ = 1;
                    var n = de();
                    function t(u, p, f, g, y) {
                        this.properties = {},
                        this.extent = f,
                        this.type = 0,
                        this._pbf = u,
                        this._geometry = -1,
                        this._keys = g,
                        this._values = y,
                        u.readFields(i, this, p)
                    }
                    function i(u, p, f) {
                        u == 1 ? p.id = f.readVarint() : u == 2 ? function(g, y) {
                            for (var S = g.readVarint() + g.pos; g.pos < S; ) {
                                var I = y._keys[g.readVarint()]
                                  , A = y._values[g.readVarint()];
                                y.properties[I] = A
                            }
                        }(f, p) : u == 3 ? p.type = f.readVarint() : u == 4 && (p._geometry = f.pos)
                    }
                    function a(u) {
                        for (var p, f, g = 0, y = 0, S = u.length, I = S - 1; y < S; I = y++)
                            g += ((f = u[I]).x - (p = u[y]).x) * (p.y + f.y);
                        return g
                    }
                    return zp = t,
                    t.types = ["Unknown", "Point", "LineString", "Polygon"],
                    t.prototype.loadGeometry = function() {
                        var u = this._pbf;
                        u.pos = this._geometry;
                        for (var p, f = u.readVarint() + u.pos, g = 1, y = 0, S = 0, I = 0, A = []; u.pos < f; ) {
                            if (y <= 0) {
                                var R = u.readVarint();
                                g = 7 & R,
                                y = R >> 3
                            }
                            if (y--,
                            g === 1 || g === 2)
                                S += u.readSVarint(),
                                I += u.readSVarint(),
                                g === 1 && (p && A.push(p),
                                p = []),
                                p.push(new n(S,I));
                            else {
                                if (g !== 7)
                                    throw new Error("unknown command " + g);
                                p && p.push(p[0].clone())
                            }
                        }
                        return p && A.push(p),
                        A
                    }
                    ,
                    t.prototype.bbox = function() {
                        var u = this._pbf;
                        u.pos = this._geometry;
                        for (var p = u.readVarint() + u.pos, f = 1, g = 0, y = 0, S = 0, I = 1 / 0, A = -1 / 0, R = 1 / 0, N = -1 / 0; u.pos < p; ) {
                            if (g <= 0) {
                                var j = u.readVarint();
                                f = 7 & j,
                                g = j >> 3
                            }
                            if (g--,
                            f === 1 || f === 2)
                                (y += u.readSVarint()) < I && (I = y),
                                y > A && (A = y),
                                (S += u.readSVarint()) < R && (R = S),
                                S > N && (N = S);
                            else if (f !== 7)
                                throw new Error("unknown command " + f)
                        }
                        return [I, R, A, N]
                    }
                    ,
                    t.prototype.toGeoJSON = function(u, p, f) {
                        var g, y, S = this.extent * Math.pow(2, f), I = this.extent * u, A = this.extent * p, R = this.loadGeometry(), N = t.types[this.type];
                        function j(se) {
                            for (var Ae = 0; Ae < se.length; Ae++) {
                                var _e = se[Ae];
                                se[Ae] = [360 * (_e.x + I) / S - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (_e.y + A) / S) * Math.PI / 180)) - 90]
                            }
                        }
                        switch (this.type) {
                        case 1:
                            var $ = [];
                            for (g = 0; g < R.length; g++)
                                $[g] = R[g][0];
                            j(R = $);
                            break;
                        case 2:
                            for (g = 0; g < R.length; g++)
                                j(R[g]);
                            break;
                        case 3:
                            for (R = function(se) {
                                var Ae = se.length;
                                if (Ae <= 1)
                                    return [se];
                                for (var _e, O, Y = [], ve = 0; ve < Ae; ve++) {
                                    var Xe = a(se[ve]);
                                    Xe !== 0 && (O === void 0 && (O = Xe < 0),
                                    O === Xe < 0 ? (_e && Y.push(_e),
                                    _e = [se[ve]]) : _e.push(se[ve]))
                                }
                                return _e && Y.push(_e),
                                Y
                            }(R),
                            g = 0; g < R.length; g++)
                                for (y = 0; y < R[g].length; y++)
                                    j(R[g][y])
                        }
                        R.length === 1 ? R = R[0] : N = "Multi" + N;
                        var J = {
                            type: "Feature",
                            geometry: {
                                type: N,
                                coordinates: R
                            },
                            properties: this.properties
                        };
                        return "id"in this && (J.id = this.id),
                        J
                    }
                    ,
                    zp
                }
                function o_() {
                    if (i_)
                        return Lp;
                    i_ = 1;
                    var n = s_();
                    function t(a, u) {
                        this.version = 1,
                        this.name = null,
                        this.extent = 4096,
                        this.length = 0,
                        this._pbf = a,
                        this._keys = [],
                        this._values = [],
                        this._features = [],
                        a.readFields(i, this, u),
                        this.length = this._features.length
                    }
                    function i(a, u, p) {
                        a === 15 ? u.version = p.readVarint() : a === 1 ? u.name = p.readString() : a === 5 ? u.extent = p.readVarint() : a === 2 ? u._features.push(p.pos) : a === 3 ? u._keys.push(p.readString()) : a === 4 && u._values.push(function(f) {
                            for (var g = null, y = f.readVarint() + f.pos; f.pos < y; ) {
                                var S = f.readVarint() >> 3;
                                g = S === 1 ? f.readString() : S === 2 ? f.readFloat() : S === 3 ? f.readDouble() : S === 4 ? f.readVarint64() : S === 5 ? f.readVarint() : S === 6 ? f.readSVarint() : S === 7 ? f.readBoolean() : null
                            }
                            return g
                        }(p))
                    }
                    return Lp = t,
                    t.prototype.feature = function(a) {
                        if (a < 0 || a >= this._features.length)
                            throw new Error("feature index out of bounds");
                        this._pbf.pos = this._features[a];
                        var u = this._pbf.readVarint() + this._pbf.pos;
                        return new n(this._pbf,u,this.extent,this._keys,this._values)
                    }
                    ,
                    Lp
                }
                function l_() {
                    return a_ || (a_ = 1,
                    ld.VectorTile = function() {
                        if (n_)
                            return Dp;
                        n_ = 1;
                        var n = o_();
                        function t(i, a, u) {
                            if (i === 3) {
                                var p = new n(u,u.readVarint() + u.pos);
                                p.length && (a[p.name] = p)
                            }
                        }
                        return Dp = function(i, a) {
                            this.layers = i.readFields(t, {}, a)
                        }
                        ,
                        Dp
                    }(),
                    ld.VectorTileFeature = s_(),
                    ld.VectorTileLayer = o_()),
                    ld
                }
                var hu = W(l_());
                const w0 = hu.VectorTileFeature.types
                  , Rp = Math.pow(2, 13);
                function du(n, t, i, a, u, p, f, g) {
                    n.emplaceBack(t, i, 2 * Math.floor(a * Rp) + f, u * Rp * 2, p * Rp * 2, Math.round(g))
                }
                class Bp {
                    constructor(t) {
                        this.zoom = t.zoom,
                        this.globalState = t.globalState,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map(i => i.id),
                        this.index = t.index,
                        this.hasPattern = !1,
                        this.layoutVertexArray = new qt,
                        this.centroidVertexArray = new $e,
                        this.indexArray = new Ti,
                        this.programConfigurations = new rs(t.layers,t.zoom),
                        this.segments = new li,
                        this.stateDependentLayerIds = this.layers.filter(i => i.isStateDependent()).map(i => i.id)
                    }
                    populate(t, i, a) {
                        this.features = [],
                        this.hasPattern = Ip("fill-extrusion", this.layers, i);
                        for (const {feature: u, id: p, index: f, sourceLayerIndex: g} of t) {
                            const y = this.layers[0]._featureFilter.needGeometry
                              , S = Vo(u, y);
                            if (!this.layers[0]._featureFilter.filter(new Ei(this.zoom,{
                                globalState: this.globalState
                            }), S, a))
                                continue;
                            const I = {
                                id: p,
                                sourceLayerIndex: g,
                                index: f,
                                geometry: y ? S.geometry : qo(u),
                                properties: u.properties,
                                type: u.type,
                                patterns: {}
                            };
                            this.hasPattern ? this.features.push(Mp("fill-extrusion", this.layers, I, this.zoom, i)) : this.addFeature(I, I.geometry, f, a, {}, i.subdivisionGranularity),
                            i.featureIndex.insert(u, I.geometry, f, g, this.index, !0)
                        }
                    }
                    addFeatures(t, i, a) {
                        for (const u of this.features) {
                            const {geometry: p} = u;
                            this.addFeature(u, p, u.index, i, a, t.subdivisionGranularity)
                        }
                    }
                    update(t, i, a) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, i, this.stateDependentLayers, a)
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, b0),
                        this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, x0.members, !0),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray)),
                        this.programConfigurations.upload(t),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.centroidVertexBuffer.destroy())
                    }
                    addFeature(t, i, a, u, p, f) {
                        for (const g of ol(i, 500)) {
                            const y = {
                                x: 0,
                                y: 0,
                                sampleCount: 0
                            }
                              , S = this.layoutVertexArray.length;
                            this.processPolygon(y, u, t, g, f);
                            const I = this.layoutVertexArray.length - S
                              , A = Math.floor(y.x / y.sampleCount)
                              , R = Math.floor(y.y / y.sampleCount);
                            for (let N = 0; N < I; N++)
                                this.centroidVertexArray.emplaceBack(A, R)
                        }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, p, u)
                    }
                    processPolygon(t, i, a, u, p) {
                        if (u.length < 1 || c_(u[0]))
                            return;
                        for (const A of u)
                            A.length !== 0 && T0(t, A);
                        const f = {
                            segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)
                        }
                          , g = p.fill.getGranularityForZoomLevel(i.z)
                          , y = w0[a.type] === "Polygon";
                        for (const A of u) {
                            if (A.length === 0 || c_(A))
                                continue;
                            const R = $o(A, g, y);
                            this._generateSideFaces(R, f)
                        }
                        if (!y)
                            return;
                        const S = Jm(u, i, g, !1)
                          , I = this.layoutVertexArray;
                        Qm( (A, R) => {
                            du(I, A, R, 0, 0, 1, 1, 0)
                        }
                        , this.segments, this.layoutVertexArray, this.indexArray, S.verticesFlattened, S.indicesTriangles)
                    }
                    _generateSideFaces(t, i) {
                        let a = 0;
                        for (let u = 1; u < t.length; u++) {
                            const p = t[u]
                              , f = t[u - 1];
                            if (C0(p, f))
                                continue;
                            i.segment.vertexLength + 4 > li.MAX_VERTEX_ARRAY_LENGTH && (i.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                            const g = p.sub(f)._perp()._unit()
                              , y = f.dist(p);
                            a + y > 32768 && (a = 0),
                            du(this.layoutVertexArray, p.x, p.y, g.x, g.y, 0, 0, a),
                            du(this.layoutVertexArray, p.x, p.y, g.x, g.y, 0, 1, a),
                            a += y,
                            du(this.layoutVertexArray, f.x, f.y, g.x, g.y, 0, 0, a),
                            du(this.layoutVertexArray, f.x, f.y, g.x, g.y, 0, 1, a);
                            const S = i.segment.vertexLength;
                            this.indexArray.emplaceBack(S, S + 2, S + 1),
                            this.indexArray.emplaceBack(S + 1, S + 2, S + 3),
                            i.segment.vertexLength += 4,
                            i.segment.primitiveLength += 2
                        }
                    }
                }
                function T0(n, t) {
                    for (let i = 0; i < t.length; i++) {
                        const a = t[i];
                        i === t.length - 1 && t[0].x === a.x && t[0].y === a.y || (n.x += a.x,
                        n.y += a.y,
                        n.sampleCount++)
                    }
                }
                function C0(n, t) {
                    return n.x === t.x && (n.x < 0 || n.x > We) || n.y === t.y && (n.y < 0 || n.y > We)
                }
                function c_(n) {
                    return n.every(t => t.x < 0) || n.every(t => t.x > We) || n.every(t => t.y < 0) || n.every(t => t.y > We)
                }
                let u_;
                Wt("FillExtrusionBucket", Bp, {
                    omit: ["layers", "features"]
                });
                var S0 = {
                    get paint() {
                        return u_ = u_ || new Ln({
                            "fill-extrusion-opacity": new ar(ye["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                            "fill-extrusion-color": new Rr(ye["paint_fill-extrusion"]["fill-extrusion-color"]),
                            "fill-extrusion-translate": new ar(ye["paint_fill-extrusion"]["fill-extrusion-translate"]),
                            "fill-extrusion-translate-anchor": new ar(ye["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                            "fill-extrusion-pattern": new kl(ye["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                            "fill-extrusion-height": new Rr(ye["paint_fill-extrusion"]["fill-extrusion-height"]),
                            "fill-extrusion-base": new Rr(ye["paint_fill-extrusion"]["fill-extrusion-base"]),
                            "fill-extrusion-vertical-gradient": new ar(ye["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
                        })
                    }
                };
                class P0 extends gn {
                    constructor(t) {
                        super(t, S0)
                    }
                    createBucket(t) {
                        return new Bp(t)
                    }
                    queryRadius() {
                        return id(this.paint.get("fill-extrusion-translate"))
                    }
                    is3D() {
                        return !0
                    }
                    queryIntersectsFeature({queryGeometry: t, feature: i, featureState: a, geometry: u, transform: p, pixelsToTileUnits: f, pixelPosMatrix: g}) {
                        const y = nd(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -p.bearingInRadians, f)
                          , S = this.paint.get("fill-extrusion-height").evaluate(i, a)
                          , I = this.paint.get("fill-extrusion-base").evaluate(i, a)
                          , A = function(N, j) {
                            const $ = [];
                            for (const J of N) {
                                const se = [J.x, J.y, 0, 1];
                                ie(se, se, j),
                                $.push(new le(se[0] / se[3],se[1] / se[3]))
                            }
                            return $
                        }(y, g)
                          , R = function(N, j, $, J) {
                            const se = []
                              , Ae = []
                              , _e = J[8] * j
                              , O = J[9] * j
                              , Y = J[10] * j
                              , ve = J[11] * j
                              , Xe = J[8] * $
                              , bt = J[9] * $
                              , Qe = J[10] * $
                              , ot = J[11] * $;
                            for (const Et of N) {
                                const Ct = []
                                  , Dt = [];
                                for (const pt of Et) {
                                    const ir = pt.x
                                      , Er = pt.y
                                      , Cr = J[0] * ir + J[4] * Er + J[12]
                                      , ur = J[1] * ir + J[5] * Er + J[13]
                                      , ii = J[2] * ir + J[6] * Er + J[14]
                                      , Vi = J[3] * ir + J[7] * Er + J[15]
                                      , rn = ii + Y
                                      , In = Vi + ve
                                      , va = Cr + Xe
                                      , ia = ur + bt
                                      , bn = ii + Qe
                                      , Oi = Vi + ot
                                      , hn = new le((Cr + _e) / In,(ur + O) / In);
                                    hn.z = rn / In,
                                    Ct.push(hn);
                                    const wn = new le(va / Oi,ia / Oi);
                                    wn.z = bn / Oi,
                                    Dt.push(wn)
                                }
                                se.push(Ct),
                                Ae.push(Dt)
                            }
                            return [se, Ae]
                        }(u, I, S, g);
                        return function(N, j, $) {
                            let J = 1 / 0;
                            Lm($, j) && (J = h_($, j[0]));
                            for (let se = 0; se < j.length; se++) {
                                const Ae = j[se]
                                  , _e = N[se];
                                for (let O = 0; O < Ae.length - 1; O++) {
                                    const Y = Ae[O]
                                      , ve = [Y, Ae[O + 1], _e[O + 1], _e[O], Y];
                                    zm($, ve) && (J = Math.min(J, h_($, ve)))
                                }
                            }
                            return J !== 1 / 0 && J
                        }(R[0], R[1], A)
                    }
                }
                function pu(n, t) {
                    return n.x * t.x + n.y * t.y
                }
                function h_(n, t) {
                    if (n.length === 1) {
                        let i = 0;
                        const a = t[i++];
                        let u;
                        for (; !u || a.equals(u); )
                            if (u = t[i++],
                            !u)
                                return 1 / 0;
                        for (; i < t.length; i++) {
                            const p = t[i]
                              , f = n[0]
                              , g = u.sub(a)
                              , y = p.sub(a)
                              , S = f.sub(a)
                              , I = pu(g, g)
                              , A = pu(g, y)
                              , R = pu(y, y)
                              , N = pu(S, g)
                              , j = pu(S, y)
                              , $ = I * R - A * A
                              , J = (R * N - A * j) / $
                              , se = (I * j - A * N) / $
                              , Ae = a.z * (1 - J - se) + u.z * J + p.z * se;
                            if (isFinite(Ae))
                                return Ae
                        }
                        return 1 / 0
                    }
                    {
                        let i = 1 / 0;
                        for (const a of t)
                            i = Math.min(i, a.z);
                        return i
                    }
                }
                const I0 = qi([{
                    name: "a_pos_normal",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_data",
                    components: 4,
                    type: "Uint8"
                }], 4)
                  , {members: M0} = I0
                  , A0 = qi([{
                    name: "a_uv_x",
                    components: 1,
                    type: "Float32"
                }, {
                    name: "a_split_index",
                    components: 1,
                    type: "Float32"
                }])
                  , {members: k0} = A0
                  , E0 = hu.VectorTileFeature.types
                  , z0 = Math.cos(Math.PI / 180 * 37.5)
                  , d_ = Math.pow(2, 14) / .5;
                class Fp {
                    constructor(t) {
                        this.zoom = t.zoom,
                        this.globalState = t.globalState,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map(i => i.id),
                        this.index = t.index,
                        this.hasPattern = !1,
                        this.patternFeatures = [],
                        this.lineClipsArray = [],
                        this.gradients = {},
                        this.layers.forEach(i => {
                            this.gradients[i.id] = {}
                        }
                        ),
                        this.layoutVertexArray = new Nt,
                        this.layoutVertexArray2 = new wt,
                        this.indexArray = new Ti,
                        this.programConfigurations = new rs(t.layers,t.zoom),
                        this.segments = new li,
                        this.maxLineLength = 0,
                        this.stateDependentLayerIds = this.layers.filter(i => i.isStateDependent()).map(i => i.id)
                    }
                    populate(t, i, a) {
                        this.hasPattern = Ip("line", this.layers, i);
                        const u = this.layers[0].layout.get("line-sort-key")
                          , p = !u.isConstant()
                          , f = [];
                        for (const {feature: g, id: y, index: S, sourceLayerIndex: I} of t) {
                            const A = this.layers[0]._featureFilter.needGeometry
                              , R = Vo(g, A);
                            if (!this.layers[0]._featureFilter.filter(new Ei(this.zoom,{
                                globalState: this.globalState
                            }), R, a))
                                continue;
                            const N = p ? u.evaluate(R, {}, a) : void 0
                              , j = {
                                id: y,
                                properties: g.properties,
                                type: g.type,
                                sourceLayerIndex: I,
                                index: S,
                                geometry: A ? R.geometry : qo(g),
                                patterns: {},
                                sortKey: N
                            };
                            f.push(j)
                        }
                        p && f.sort( (g, y) => g.sortKey - y.sortKey);
                        for (const g of f) {
                            const {geometry: y, index: S, sourceLayerIndex: I} = g;
                            if (this.hasPattern) {
                                const A = Mp("line", this.layers, g, this.zoom, i);
                                this.patternFeatures.push(A)
                            } else
                                this.addFeature(g, y, S, a, {}, i.subdivisionGranularity);
                            i.featureIndex.insert(t[S].feature, y, S, I, this.index)
                        }
                    }
                    update(t, i, a) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, i, this.stateDependentLayers, a)
                    }
                    addFeatures(t, i, a) {
                        for (const u of this.patternFeatures)
                            this.addFeature(u, u.geometry, u.index, i, a, t.subdivisionGranularity)
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, k0)),
                        this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, M0),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray)),
                        this.programConfigurations.upload(t),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy())
                    }
                    lineFeatureClips(t) {
                        if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end"))
                            return {
                                start: +t.properties.mapbox_clip_start,
                                end: +t.properties.mapbox_clip_end
                            }
                    }
                    addFeature(t, i, a, u, p, f) {
                        const g = this.layers[0].layout
                          , y = g.get("line-join").evaluate(t, {})
                          , S = g.get("line-cap")
                          , I = g.get("line-miter-limit")
                          , A = g.get("line-round-limit");
                        this.lineClips = this.lineFeatureClips(t);
                        for (const R of i)
                            this.addLine(R, t, y, S, I, A, u, f);
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, a, p, u)
                    }
                    addLine(t, i, a, u, p, f, g, y) {
                        if (this.distance = 0,
                        this.scaledDistance = 0,
                        this.totalDistance = 0,
                        t = $o(t, g ? y.line.getGranularityForZoomLevel(g.z) : 1),
                        this.lineClips) {
                            this.lineClipsArray.push(this.lineClips);
                            for (let _e = 0; _e < t.length - 1; _e++)
                                this.totalDistance += t[_e].dist(t[_e + 1]);
                            this.updateScaledDistance(),
                            this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
                        }
                        const S = E0[i.type] === "Polygon";
                        let I = t.length;
                        for (; I >= 2 && t[I - 1].equals(t[I - 2]); )
                            I--;
                        let A = 0;
                        for (; A < I - 1 && t[A].equals(t[A + 1]); )
                            A++;
                        if (I < (S ? 3 : 2))
                            return;
                        a === "bevel" && (p = 1.05);
                        const R = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0
                          , N = this.segments.prepareSegment(10 * I, this.layoutVertexArray, this.indexArray);
                        let j, $, J, se, Ae;
                        this.e1 = this.e2 = -1,
                        S && (j = t[I - 2],
                        Ae = t[A].sub(j)._unit()._perp());
                        for (let _e = A; _e < I; _e++) {
                            if (J = _e === I - 1 ? S ? t[A + 1] : void 0 : t[_e + 1],
                            J && t[_e].equals(J))
                                continue;
                            Ae && (se = Ae),
                            j && ($ = j),
                            j = t[_e],
                            Ae = J ? J.sub(j)._unit()._perp() : se,
                            se = se || Ae;
                            let O = se.add(Ae);
                            O.x === 0 && O.y === 0 || O._unit();
                            const Y = se.x * Ae.x + se.y * Ae.y
                              , ve = O.x * Ae.x + O.y * Ae.y
                              , Xe = ve !== 0 ? 1 / ve : 1 / 0
                              , bt = 2 * Math.sqrt(2 - 2 * ve)
                              , Qe = ve < z0 && $ && J
                              , ot = se.x * Ae.y - se.y * Ae.x > 0;
                            if (Qe && _e > A) {
                                const Dt = j.dist($);
                                if (Dt > 2 * R) {
                                    const pt = j.sub(j.sub($)._mult(R / Dt)._round());
                                    this.updateDistance($, pt),
                                    this.addCurrentVertex(pt, se, 0, 0, N),
                                    $ = pt
                                }
                            }
                            const Et = $ && J;
                            let Ct = Et ? a : S ? "butt" : u;
                            if (Et && Ct === "round" && (Xe < f ? Ct = "miter" : Xe <= 2 && (Ct = "fakeround")),
                            Ct === "miter" && Xe > p && (Ct = "bevel"),
                            Ct === "bevel" && (Xe > 2 && (Ct = "flipbevel"),
                            Xe < p && (Ct = "miter")),
                            $ && this.updateDistance($, j),
                            Ct === "miter")
                                O._mult(Xe),
                                this.addCurrentVertex(j, O, 0, 0, N);
                            else if (Ct === "flipbevel") {
                                if (Xe > 100)
                                    O = Ae.mult(-1);
                                else {
                                    const Dt = Xe * se.add(Ae).mag() / se.sub(Ae).mag();
                                    O._perp()._mult(Dt * (ot ? -1 : 1))
                                }
                                this.addCurrentVertex(j, O, 0, 0, N),
                                this.addCurrentVertex(j, O.mult(-1), 0, 0, N)
                            } else if (Ct === "bevel" || Ct === "fakeround") {
                                const Dt = -Math.sqrt(Xe * Xe - 1)
                                  , pt = ot ? Dt : 0
                                  , ir = ot ? 0 : Dt;
                                if ($ && this.addCurrentVertex(j, se, pt, ir, N),
                                Ct === "fakeround") {
                                    const Er = Math.round(180 * bt / Math.PI / 20);
                                    for (let Cr = 1; Cr < Er; Cr++) {
                                        let ur = Cr / Er;
                                        if (ur !== .5) {
                                            const Vi = ur - .5;
                                            ur += ur * Vi * (ur - 1) * ((1.0904 + Y * (Y * (3.55645 - 1.43519 * Y) - 3.2452)) * Vi * Vi + (.848013 + Y * (.215638 * Y - 1.06021)))
                                        }
                                        const ii = Ae.sub(se)._mult(ur)._add(se)._unit()._mult(ot ? -1 : 1);
                                        this.addHalfVertex(j, ii.x, ii.y, !1, ot, 0, N)
                                    }
                                }
                                J && this.addCurrentVertex(j, Ae, -pt, -ir, N)
                            } else if (Ct === "butt")
                                this.addCurrentVertex(j, O, 0, 0, N);
                            else if (Ct === "square") {
                                const Dt = $ ? 1 : -1;
                                this.addCurrentVertex(j, O, Dt, Dt, N)
                            } else
                                Ct === "round" && ($ && (this.addCurrentVertex(j, se, 0, 0, N),
                                this.addCurrentVertex(j, se, 1, 1, N, !0)),
                                J && (this.addCurrentVertex(j, Ae, -1, -1, N, !0),
                                this.addCurrentVertex(j, Ae, 0, 0, N)));
                            if (Qe && _e < I - 1) {
                                const Dt = j.dist(J);
                                if (Dt > 2 * R) {
                                    const pt = j.add(J.sub(j)._mult(R / Dt)._round());
                                    this.updateDistance(j, pt),
                                    this.addCurrentVertex(pt, Ae, 0, 0, N),
                                    j = pt
                                }
                            }
                        }
                    }
                    addCurrentVertex(t, i, a, u, p, f=!1) {
                        const g = i.y * u - i.x
                          , y = -i.y - i.x * u;
                        this.addHalfVertex(t, i.x + i.y * a, i.y - i.x * a, f, !1, a, p),
                        this.addHalfVertex(t, g, y, f, !0, -u, p),
                        this.distance > d_ / 2 && this.totalDistance === 0 && (this.distance = 0,
                        this.updateScaledDistance(),
                        this.addCurrentVertex(t, i, a, u, p, f))
                    }
                    addHalfVertex({x: t, y: i}, a, u, p, f, g, y) {
                        const S = .5 * (this.lineClips ? this.scaledDistance * (d_ - 1) : this.scaledDistance);
                        this.layoutVertexArray.emplaceBack((t << 1) + (p ? 1 : 0), (i << 1) + (f ? 1 : 0), Math.round(63 * a) + 128, Math.round(63 * u) + 128, 1 + (g === 0 ? 0 : g < 0 ? -1 : 1) | (63 & S) << 2, S >> 6),
                        this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
                        const I = y.vertexLength++;
                        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, I, this.e2),
                        y.primitiveLength++),
                        f ? this.e2 = I : this.e1 = I
                    }
                    updateScaledDistance() {
                        this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance
                    }
                    updateDistance(t, i) {
                        this.distance += t.dist(i),
                        this.updateScaledDistance()
                    }
                }
                let p_, f_;
                Wt("LineBucket", Fp, {
                    omit: ["layers", "patternFeatures"]
                });
                var m_ = {
                    get paint() {
                        return f_ = f_ || new Ln({
                            "line-opacity": new Rr(ye.paint_line["line-opacity"]),
                            "line-color": new Rr(ye.paint_line["line-color"]),
                            "line-translate": new ar(ye.paint_line["line-translate"]),
                            "line-translate-anchor": new ar(ye.paint_line["line-translate-anchor"]),
                            "line-width": new Rr(ye.paint_line["line-width"]),
                            "line-gap-width": new Rr(ye.paint_line["line-gap-width"]),
                            "line-offset": new Rr(ye.paint_line["line-offset"]),
                            "line-blur": new Rr(ye.paint_line["line-blur"]),
                            "line-dasharray": new Xc(ye.paint_line["line-dasharray"]),
                            "line-pattern": new kl(ye.paint_line["line-pattern"]),
                            "line-gradient": new Ro(ye.paint_line["line-gradient"])
                        })
                    },
                    get layout() {
                        return p_ = p_ || new Ln({
                            "line-cap": new ar(ye.layout_line["line-cap"]),
                            "line-join": new Rr(ye.layout_line["line-join"]),
                            "line-miter-limit": new ar(ye.layout_line["line-miter-limit"]),
                            "line-round-limit": new ar(ye.layout_line["line-round-limit"]),
                            "line-sort-key": new Rr(ye.layout_line["line-sort-key"])
                        })
                    }
                };
                class L0 extends Rr {
                    possiblyEvaluate(t, i) {
                        return i = new Ei(Math.floor(i.zoom),{
                            now: i.now,
                            fadeDuration: i.fadeDuration,
                            zoomHistory: i.zoomHistory,
                            transition: i.transition
                        }),
                        super.possiblyEvaluate(t, i)
                    }
                    evaluate(t, i, a, u) {
                        return i = Pt({}, i, {
                            zoom: Math.floor(i.zoom)
                        }),
                        super.evaluate(t, i, a, u)
                    }
                }
                let cd;
                class D0 extends gn {
                    constructor(t) {
                        super(t, m_),
                        this.gradientVersion = 0,
                        cd || (cd = new L0(m_.paint.properties["line-width"].specification),
                        cd.useIntegerZoom = !0)
                    }
                    _handleSpecialPaintPropertyUpdate(t) {
                        if (t === "line-gradient") {
                            const i = this.gradientExpression();
                            this.stepInterpolant = !!function(a) {
                                return a._styleExpression !== void 0
                            }(i) && i._styleExpression.expression instanceof Es,
                            this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
                        }
                    }
                    gradientExpression() {
                        return this._transitionablePaint._values["line-gradient"].value.expression
                    }
                    recalculate(t, i) {
                        super.recalculate(t, i),
                        this.paint._values["line-floorwidth"] = cd.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t)
                    }
                    createBucket(t) {
                        return new Fp(t)
                    }
                    queryRadius(t) {
                        const i = t
                          , a = __(iu("line-width", this, i), iu("line-gap-width", this, i))
                          , u = iu("line-offset", this, i);
                        return a / 2 + Math.abs(u) + id(this.paint.get("line-translate"))
                    }
                    queryIntersectsFeature({queryGeometry: t, feature: i, featureState: a, geometry: u, transform: p, pixelsToTileUnits: f}) {
                        const g = nd(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -p.bearingInRadians, f)
                          , y = f / 2 * __(this.paint.get("line-width").evaluate(i, a), this.paint.get("line-gap-width").evaluate(i, a))
                          , S = this.paint.get("line-offset").evaluate(i, a);
                        return S && (u = function(I, A) {
                            const R = [];
                            for (let N = 0; N < I.length; N++) {
                                const j = I[N]
                                  , $ = [];
                                for (let J = 0; J < j.length; J++) {
                                    const se = j[J - 1]
                                      , Ae = j[J]
                                      , _e = j[J + 1]
                                      , O = J === 0 ? new le(0,0) : Ae.sub(se)._unit()._perp()
                                      , Y = J === j.length - 1 ? new le(0,0) : _e.sub(Ae)._unit()._perp()
                                      , ve = O._add(Y)._unit()
                                      , Xe = ve.x * Y.x + ve.y * Y.y;
                                    Xe !== 0 && ve._mult(1 / Xe),
                                    $.push(ve._mult(A)._add(Ae))
                                }
                                R.push($)
                            }
                            return R
                        }(u, S * f)),
                        function(I, A, R) {
                            for (let N = 0; N < A.length; N++) {
                                const j = A[N];
                                if (I.length >= 3) {
                                    for (let $ = 0; $ < j.length; $++)
                                        if (Ll(I, j[$]))
                                            return !0
                                }
                                if (Hv(I, j, R))
                                    return !0
                            }
                            return !1
                        }(g, u, y)
                    }
                    isTileClipped() {
                        return !0
                    }
                }
                function __(n, t) {
                    return t > 0 ? t + 2 * n : n
                }
                const R0 = qi([{
                    name: "a_pos_offset",
                    components: 4,
                    type: "Int16"
                }, {
                    name: "a_data",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_pixeloffset",
                    components: 4,
                    type: "Int16"
                }], 4)
                  , B0 = qi([{
                    name: "a_projected_pos",
                    components: 3,
                    type: "Float32"
                }], 4);
                qi([{
                    name: "a_fade_opacity",
                    components: 1,
                    type: "Uint32"
                }], 4);
                const F0 = qi([{
                    name: "a_placed",
                    components: 2,
                    type: "Uint8"
                }, {
                    name: "a_shift",
                    components: 2,
                    type: "Float32"
                }, {
                    name: "a_box_real",
                    components: 2,
                    type: "Int16"
                }]);
                qi([{
                    type: "Int16",
                    name: "anchorPointX"
                }, {
                    type: "Int16",
                    name: "anchorPointY"
                }, {
                    type: "Int16",
                    name: "x1"
                }, {
                    type: "Int16",
                    name: "y1"
                }, {
                    type: "Int16",
                    name: "x2"
                }, {
                    type: "Int16",
                    name: "y2"
                }, {
                    type: "Uint32",
                    name: "featureIndex"
                }, {
                    type: "Uint16",
                    name: "sourceLayerIndex"
                }, {
                    type: "Uint16",
                    name: "bucketIndex"
                }]);
                const g_ = qi([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_anchor_pos",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_extrude",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , O0 = qi([{
                    name: "a_pos",
                    components: 2,
                    type: "Float32"
                }, {
                    name: "a_radius",
                    components: 1,
                    type: "Float32"
                }, {
                    name: "a_flags",
                    components: 2,
                    type: "Int16"
                }], 4);
                function N0(n, t, i) {
                    return n.sections.forEach(a => {
                        a.text = function(u, p, f) {
                            const g = p.layout.get("text-transform").evaluate(f, {});
                            return g === "uppercase" ? u = u.toLocaleUpperCase() : g === "lowercase" && (u = u.toLocaleLowerCase()),
                            Xa.applyArabicShaping && (u = Xa.applyArabicShaping(u)),
                            u
                        }(a.text, t, i)
                    }
                    ),
                    n
                }
                qi([{
                    name: "triangle",
                    components: 3,
                    type: "Uint16"
                }]),
                qi([{
                    type: "Int16",
                    name: "anchorX"
                }, {
                    type: "Int16",
                    name: "anchorY"
                }, {
                    type: "Uint16",
                    name: "glyphStartIndex"
                }, {
                    type: "Uint16",
                    name: "numGlyphs"
                }, {
                    type: "Uint32",
                    name: "vertexStartIndex"
                }, {
                    type: "Uint32",
                    name: "lineStartIndex"
                }, {
                    type: "Uint32",
                    name: "lineLength"
                }, {
                    type: "Uint16",
                    name: "segment"
                }, {
                    type: "Uint16",
                    name: "lowerSize"
                }, {
                    type: "Uint16",
                    name: "upperSize"
                }, {
                    type: "Float32",
                    name: "lineOffsetX"
                }, {
                    type: "Float32",
                    name: "lineOffsetY"
                }, {
                    type: "Uint8",
                    name: "writingMode"
                }, {
                    type: "Uint8",
                    name: "placedOrientation"
                }, {
                    type: "Uint8",
                    name: "hidden"
                }, {
                    type: "Uint32",
                    name: "crossTileID"
                }, {
                    type: "Int16",
                    name: "associatedIconIndex"
                }]),
                qi([{
                    type: "Int16",
                    name: "anchorX"
                }, {
                    type: "Int16",
                    name: "anchorY"
                }, {
                    type: "Int16",
                    name: "rightJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "centerJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "leftJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "verticalPlacedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "placedIconSymbolIndex"
                }, {
                    type: "Int16",
                    name: "verticalPlacedIconSymbolIndex"
                }, {
                    type: "Uint16",
                    name: "key"
                }, {
                    type: "Uint16",
                    name: "textBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "textBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "verticalTextBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "verticalTextBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "iconBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "iconBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "verticalIconBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "verticalIconBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "featureIndex"
                }, {
                    type: "Uint16",
                    name: "numHorizontalGlyphVertices"
                }, {
                    type: "Uint16",
                    name: "numVerticalGlyphVertices"
                }, {
                    type: "Uint16",
                    name: "numIconVertices"
                }, {
                    type: "Uint16",
                    name: "numVerticalIconVertices"
                }, {
                    type: "Uint16",
                    name: "useRuntimeCollisionCircles"
                }, {
                    type: "Uint32",
                    name: "crossTileID"
                }, {
                    type: "Float32",
                    name: "textBoxScale"
                }, {
                    type: "Float32",
                    name: "collisionCircleDiameter"
                }, {
                    type: "Uint16",
                    name: "textAnchorOffsetStartIndex"
                }, {
                    type: "Uint16",
                    name: "textAnchorOffsetEndIndex"
                }]),
                qi([{
                    type: "Float32",
                    name: "offsetX"
                }]),
                qi([{
                    type: "Int16",
                    name: "x"
                }, {
                    type: "Int16",
                    name: "y"
                }, {
                    type: "Int16",
                    name: "tileUnitDistanceFromAnchor"
                }]),
                qi([{
                    type: "Uint16",
                    name: "textAnchor"
                }, {
                    type: "Float32",
                    components: 2,
                    name: "textOffset"
                }]);
                const fu = {
                    "!": "ï¸•",
                    "#": "ï¼ƒ",
                    $: "ï¼„",
                    "%": "ï¼…",
                    "&": "ï¼†",
                    "(": "ï¸µ",
                    ")": "ï¸¶",
                    "*": "ï¼Š",
                    "+": "ï¼‹",
                    ",": "ï¸",
                    "-": "ï¸²",
                    ".": "ãƒ»",
                    "/": "ï¼",
                    ":": "ï¸“",
                    ";": "ï¸”",
                    "<": "ï¸¿",
                    "=": "ï¼",
                    ">": "ï¹€",
                    "?": "ï¸–",
                    "@": "ï¼ ",
                    "[": "ï¹‡",
                    "\\": "ï¼¼",
                    "]": "ï¹ˆ",
                    "^": "ï¼¾",
                    _: "ï¸³",
                    "`": "ï½€",
                    "{": "ï¸·",
                    "|": "â€•",
                    "}": "ï¸¸",
                    "~": "ï½ž",
                    "Â¢": "ï¿ ",
                    "Â£": "ï¿¡",
                    "Â¥": "ï¿¥",
                    "Â¦": "ï¿¤",
                    "Â¬": "ï¿¢",
                    "Â¯": "ï¿£",
                    "â€“": "ï¸²",
                    "â€”": "ï¸±",
                    "â€˜": "ï¹ƒ",
                    "â€™": "ï¹„",
                    "â€œ": "ï¹",
                    "â€": "ï¹‚",
                    "â€¦": "ï¸™",
                    "â€§": "ãƒ»",
                    "â‚©": "ï¿¦",
                    "ã€": "ï¸‘",
                    "ã€‚": "ï¸’",
                    "ã€ˆ": "ï¸¿",
                    "ã€‰": "ï¹€",
                    "ã€Š": "ï¸½",
                    "ã€‹": "ï¸¾",
                    "ã€Œ": "ï¹",
                    "ã€": "ï¹‚",
                    "ã€Ž": "ï¹ƒ",
                    "ã€": "ï¹„",
                    "ã€": "ï¸»",
                    "ã€‘": "ï¸¼",
                    "ã€”": "ï¸¹",
                    "ã€•": "ï¸º",
                    "ã€–": "ï¸—",
                    "ã€—": "ï¸˜",
                    "ï¼": "ï¸•",
                    "ï¼ˆ": "ï¸µ",
                    "ï¼‰": "ï¸¶",
                    "ï¼Œ": "ï¸",
                    "ï¼": "ï¸²",
                    "ï¼Ž": "ãƒ»",
                    "ï¼š": "ï¸“",
                    "ï¼›": "ï¸”",
                    "ï¼œ": "ï¸¿",
                    "ï¼ž": "ï¹€",
                    "ï¼Ÿ": "ï¸–",
                    "ï¼»": "ï¹‡",
                    "ï¼½": "ï¹ˆ",
                    "ï¼¿": "ï¸³",
                    "ï½›": "ï¸·",
                    "ï½œ": "â€•",
                    "ï½": "ï¸¸",
                    "ï½Ÿ": "ï¸µ",
                    "ï½ ": "ï¸¶",
                    "ï½¡": "ï¸’",
                    "ï½¢": "ï¹",
                    "ï½£": "ï¹‚"
                };
                var v_, Op, y_, un = 24, Np = {};
                function j0() {
                    return v_ || (v_ = 1,
                    Np.read = function(n, t, i, a, u) {
                        var p, f, g = 8 * u - a - 1, y = (1 << g) - 1, S = y >> 1, I = -7, A = i ? u - 1 : 0, R = i ? -1 : 1, N = n[t + A];
                        for (A += R,
                        p = N & (1 << -I) - 1,
                        N >>= -I,
                        I += g; I > 0; p = 256 * p + n[t + A],
                        A += R,
                        I -= 8)
                            ;
                        for (f = p & (1 << -I) - 1,
                        p >>= -I,
                        I += a; I > 0; f = 256 * f + n[t + A],
                        A += R,
                        I -= 8)
                            ;
                        if (p === 0)
                            p = 1 - S;
                        else {
                            if (p === y)
                                return f ? NaN : 1 / 0 * (N ? -1 : 1);
                            f += Math.pow(2, a),
                            p -= S
                        }
                        return (N ? -1 : 1) * f * Math.pow(2, p - a)
                    }
                    ,
                    Np.write = function(n, t, i, a, u, p) {
                        var f, g, y, S = 8 * p - u - 1, I = (1 << S) - 1, A = I >> 1, R = u === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, N = a ? 0 : p - 1, j = a ? 1 : -1, $ = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
                        for (t = Math.abs(t),
                        isNaN(t) || t === 1 / 0 ? (g = isNaN(t) ? 1 : 0,
                        f = I) : (f = Math.floor(Math.log(t) / Math.LN2),
                        t * (y = Math.pow(2, -f)) < 1 && (f--,
                        y *= 2),
                        (t += f + A >= 1 ? R / y : R * Math.pow(2, 1 - A)) * y >= 2 && (f++,
                        y /= 2),
                        f + A >= I ? (g = 0,
                        f = I) : f + A >= 1 ? (g = (t * y - 1) * Math.pow(2, u),
                        f += A) : (g = t * Math.pow(2, A - 1) * Math.pow(2, u),
                        f = 0)); u >= 8; n[i + N] = 255 & g,
                        N += j,
                        g /= 256,
                        u -= 8)
                            ;
                        for (f = f << u | g,
                        S += u; S > 0; n[i + N] = 255 & f,
                        N += j,
                        f /= 256,
                        S -= 8)
                            ;
                        n[i + N - j] |= 128 * $
                    }
                    ),
                    Np
                }
                function x_() {
                    if (y_)
                        return Op;
                    y_ = 1,
                    Op = t;
                    var n = j0();
                    function t(O) {
                        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(O) ? O : new Uint8Array(O || 0),
                        this.pos = 0,
                        this.type = 0,
                        this.length = this.buf.length
                    }
                    t.Varint = 0,
                    t.Fixed64 = 1,
                    t.Bytes = 2,
                    t.Fixed32 = 5;
                    var i = 4294967296
                      , a = 1 / i
                      , u = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
                    function p(O) {
                        return O.type === t.Bytes ? O.readVarint() + O.pos : O.pos + 1
                    }
                    function f(O, Y, ve) {
                        return ve ? 4294967296 * Y + (O >>> 0) : 4294967296 * (Y >>> 0) + (O >>> 0)
                    }
                    function g(O, Y, ve) {
                        var Xe = Y <= 16383 ? 1 : Y <= 2097151 ? 2 : Y <= 268435455 ? 3 : Math.floor(Math.log(Y) / (7 * Math.LN2));
                        ve.realloc(Xe);
                        for (var bt = ve.pos - 1; bt >= O; bt--)
                            ve.buf[bt + Xe] = ve.buf[bt]
                    }
                    function y(O, Y) {
                        for (var ve = 0; ve < O.length; ve++)
                            Y.writeVarint(O[ve])
                    }
                    function S(O, Y) {
                        for (var ve = 0; ve < O.length; ve++)
                            Y.writeSVarint(O[ve])
                    }
                    function I(O, Y) {
                        for (var ve = 0; ve < O.length; ve++)
                            Y.writeFloat(O[ve])
                    }
                    function A(O, Y) {
                        for (var ve = 0; ve < O.length; ve++)
                            Y.writeDouble(O[ve])
                    }
                    function R(O, Y) {
                        for (var ve = 0; ve < O.length; ve++)
                            Y.writeBoolean(O[ve])
                    }
                    function N(O, Y) {
                        for (var ve = 0; ve < O.length; ve++)
                            Y.writeFixed32(O[ve])
                    }
                    function j(O, Y) {
                        for (var ve = 0; ve < O.length; ve++)
                            Y.writeSFixed32(O[ve])
                    }
                    function $(O, Y) {
                        for (var ve = 0; ve < O.length; ve++)
                            Y.writeFixed64(O[ve])
                    }
                    function J(O, Y) {
                        for (var ve = 0; ve < O.length; ve++)
                            Y.writeSFixed64(O[ve])
                    }
                    function se(O, Y) {
                        return (O[Y] | O[Y + 1] << 8 | O[Y + 2] << 16) + 16777216 * O[Y + 3]
                    }
                    function Ae(O, Y, ve) {
                        O[ve] = Y,
                        O[ve + 1] = Y >>> 8,
                        O[ve + 2] = Y >>> 16,
                        O[ve + 3] = Y >>> 24
                    }
                    function _e(O, Y) {
                        return (O[Y] | O[Y + 1] << 8 | O[Y + 2] << 16) + (O[Y + 3] << 24)
                    }
                    return t.prototype = {
                        destroy: function() {
                            this.buf = null
                        },
                        readFields: function(O, Y, ve) {
                            for (ve = ve || this.length; this.pos < ve; ) {
                                var Xe = this.readVarint()
                                  , bt = Xe >> 3
                                  , Qe = this.pos;
                                this.type = 7 & Xe,
                                O(bt, Y, this),
                                this.pos === Qe && this.skip(Xe)
                            }
                            return Y
                        },
                        readMessage: function(O, Y) {
                            return this.readFields(O, Y, this.readVarint() + this.pos)
                        },
                        readFixed32: function() {
                            var O = se(this.buf, this.pos);
                            return this.pos += 4,
                            O
                        },
                        readSFixed32: function() {
                            var O = _e(this.buf, this.pos);
                            return this.pos += 4,
                            O
                        },
                        readFixed64: function() {
                            var O = se(this.buf, this.pos) + se(this.buf, this.pos + 4) * i;
                            return this.pos += 8,
                            O
                        },
                        readSFixed64: function() {
                            var O = se(this.buf, this.pos) + _e(this.buf, this.pos + 4) * i;
                            return this.pos += 8,
                            O
                        },
                        readFloat: function() {
                            var O = n.read(this.buf, this.pos, !0, 23, 4);
                            return this.pos += 4,
                            O
                        },
                        readDouble: function() {
                            var O = n.read(this.buf, this.pos, !0, 52, 8);
                            return this.pos += 8,
                            O
                        },
                        readVarint: function(O) {
                            var Y, ve, Xe = this.buf;
                            return Y = 127 & (ve = Xe[this.pos++]),
                            ve < 128 ? Y : (Y |= (127 & (ve = Xe[this.pos++])) << 7,
                            ve < 128 ? Y : (Y |= (127 & (ve = Xe[this.pos++])) << 14,
                            ve < 128 ? Y : (Y |= (127 & (ve = Xe[this.pos++])) << 21,
                            ve < 128 ? Y : function(bt, Qe, ot) {
                                var Et, Ct, Dt = ot.buf;
                                if (Et = (112 & (Ct = Dt[ot.pos++])) >> 4,
                                Ct < 128 || (Et |= (127 & (Ct = Dt[ot.pos++])) << 3,
                                Ct < 128) || (Et |= (127 & (Ct = Dt[ot.pos++])) << 10,
                                Ct < 128) || (Et |= (127 & (Ct = Dt[ot.pos++])) << 17,
                                Ct < 128) || (Et |= (127 & (Ct = Dt[ot.pos++])) << 24,
                                Ct < 128) || (Et |= (1 & (Ct = Dt[ot.pos++])) << 31,
                                Ct < 128))
                                    return f(bt, Et, Qe);
                                throw new Error("Expected varint not more than 10 bytes")
                            }(Y |= (15 & (ve = Xe[this.pos])) << 28, O, this))))
                        },
                        readVarint64: function() {
                            return this.readVarint(!0)
                        },
                        readSVarint: function() {
                            var O = this.readVarint();
                            return O % 2 == 1 ? (O + 1) / -2 : O / 2
                        },
                        readBoolean: function() {
                            return !!this.readVarint()
                        },
                        readString: function() {
                            var O = this.readVarint() + this.pos
                              , Y = this.pos;
                            return this.pos = O,
                            O - Y >= 12 && u ? function(ve, Xe, bt) {
                                return u.decode(ve.subarray(Xe, bt))
                            }(this.buf, Y, O) : function(ve, Xe, bt) {
                                for (var Qe = "", ot = Xe; ot < bt; ) {
                                    var Et, Ct, Dt, pt = ve[ot], ir = null, Er = pt > 239 ? 4 : pt > 223 ? 3 : pt > 191 ? 2 : 1;
                                    if (ot + Er > bt)
                                        break;
                                    Er === 1 ? pt < 128 && (ir = pt) : Er === 2 ? (192 & (Et = ve[ot + 1])) == 128 && (ir = (31 & pt) << 6 | 63 & Et) <= 127 && (ir = null) : Er === 3 ? (Ct = ve[ot + 2],
                                    (192 & (Et = ve[ot + 1])) == 128 && (192 & Ct) == 128 && ((ir = (15 & pt) << 12 | (63 & Et) << 6 | 63 & Ct) <= 2047 || ir >= 55296 && ir <= 57343) && (ir = null)) : Er === 4 && (Ct = ve[ot + 2],
                                    Dt = ve[ot + 3],
                                    (192 & (Et = ve[ot + 1])) == 128 && (192 & Ct) == 128 && (192 & Dt) == 128 && ((ir = (15 & pt) << 18 | (63 & Et) << 12 | (63 & Ct) << 6 | 63 & Dt) <= 65535 || ir >= 1114112) && (ir = null)),
                                    ir === null ? (ir = 65533,
                                    Er = 1) : ir > 65535 && (ir -= 65536,
                                    Qe += String.fromCharCode(ir >>> 10 & 1023 | 55296),
                                    ir = 56320 | 1023 & ir),
                                    Qe += String.fromCharCode(ir),
                                    ot += Er
                                }
                                return Qe
                            }(this.buf, Y, O)
                        },
                        readBytes: function() {
                            var O = this.readVarint() + this.pos
                              , Y = this.buf.subarray(this.pos, O);
                            return this.pos = O,
                            Y
                        },
                        readPackedVarint: function(O, Y) {
                            if (this.type !== t.Bytes)
                                return O.push(this.readVarint(Y));
                            var ve = p(this);
                            for (O = O || []; this.pos < ve; )
                                O.push(this.readVarint(Y));
                            return O
                        },
                        readPackedSVarint: function(O) {
                            if (this.type !== t.Bytes)
                                return O.push(this.readSVarint());
                            var Y = p(this);
                            for (O = O || []; this.pos < Y; )
                                O.push(this.readSVarint());
                            return O
                        },
                        readPackedBoolean: function(O) {
                            if (this.type !== t.Bytes)
                                return O.push(this.readBoolean());
                            var Y = p(this);
                            for (O = O || []; this.pos < Y; )
                                O.push(this.readBoolean());
                            return O
                        },
                        readPackedFloat: function(O) {
                            if (this.type !== t.Bytes)
                                return O.push(this.readFloat());
                            var Y = p(this);
                            for (O = O || []; this.pos < Y; )
                                O.push(this.readFloat());
                            return O
                        },
                        readPackedDouble: function(O) {
                            if (this.type !== t.Bytes)
                                return O.push(this.readDouble());
                            var Y = p(this);
                            for (O = O || []; this.pos < Y; )
                                O.push(this.readDouble());
                            return O
                        },
                        readPackedFixed32: function(O) {
                            if (this.type !== t.Bytes)
                                return O.push(this.readFixed32());
                            var Y = p(this);
                            for (O = O || []; this.pos < Y; )
                                O.push(this.readFixed32());
                            return O
                        },
                        readPackedSFixed32: function(O) {
                            if (this.type !== t.Bytes)
                                return O.push(this.readSFixed32());
                            var Y = p(this);
                            for (O = O || []; this.pos < Y; )
                                O.push(this.readSFixed32());
                            return O
                        },
                        readPackedFixed64: function(O) {
                            if (this.type !== t.Bytes)
                                return O.push(this.readFixed64());
                            var Y = p(this);
                            for (O = O || []; this.pos < Y; )
                                O.push(this.readFixed64());
                            return O
                        },
                        readPackedSFixed64: function(O) {
                            if (this.type !== t.Bytes)
                                return O.push(this.readSFixed64());
                            var Y = p(this);
                            for (O = O || []; this.pos < Y; )
                                O.push(this.readSFixed64());
                            return O
                        },
                        skip: function(O) {
                            var Y = 7 & O;
                            if (Y === t.Varint)
                                for (; this.buf[this.pos++] > 127; )
                                    ;
                            else if (Y === t.Bytes)
                                this.pos = this.readVarint() + this.pos;
                            else if (Y === t.Fixed32)
                                this.pos += 4;
                            else {
                                if (Y !== t.Fixed64)
                                    throw new Error("Unimplemented type: " + Y);
                                this.pos += 8
                            }
                        },
                        writeTag: function(O, Y) {
                            this.writeVarint(O << 3 | Y)
                        },
                        realloc: function(O) {
                            for (var Y = this.length || 16; Y < this.pos + O; )
                                Y *= 2;
                            if (Y !== this.length) {
                                var ve = new Uint8Array(Y);
                                ve.set(this.buf),
                                this.buf = ve,
                                this.length = Y
                            }
                        },
                        finish: function() {
                            return this.length = this.pos,
                            this.pos = 0,
                            this.buf.subarray(0, this.length)
                        },
                        writeFixed32: function(O) {
                            this.realloc(4),
                            Ae(this.buf, O, this.pos),
                            this.pos += 4
                        },
                        writeSFixed32: function(O) {
                            this.realloc(4),
                            Ae(this.buf, O, this.pos),
                            this.pos += 4
                        },
                        writeFixed64: function(O) {
                            this.realloc(8),
                            Ae(this.buf, -1 & O, this.pos),
                            Ae(this.buf, Math.floor(O * a), this.pos + 4),
                            this.pos += 8
                        },
                        writeSFixed64: function(O) {
                            this.realloc(8),
                            Ae(this.buf, -1 & O, this.pos),
                            Ae(this.buf, Math.floor(O * a), this.pos + 4),
                            this.pos += 8
                        },
                        writeVarint: function(O) {
                            (O = +O || 0) > 268435455 || O < 0 ? function(Y, ve) {
                                var Xe, bt;
                                if (Y >= 0 ? (Xe = Y % 4294967296 | 0,
                                bt = Y / 4294967296 | 0) : (bt = ~(-Y / 4294967296),
                                4294967295 ^ (Xe = ~(-Y % 4294967296)) ? Xe = Xe + 1 | 0 : (Xe = 0,
                                bt = bt + 1 | 0)),
                                Y >= 18446744073709552e3 || Y < -18446744073709552e3)
                                    throw new Error("Given varint doesn't fit into 10 bytes");
                                ve.realloc(10),
                                function(Qe, ot, Et) {
                                    Et.buf[Et.pos++] = 127 & Qe | 128,
                                    Qe >>>= 7,
                                    Et.buf[Et.pos++] = 127 & Qe | 128,
                                    Qe >>>= 7,
                                    Et.buf[Et.pos++] = 127 & Qe | 128,
                                    Qe >>>= 7,
                                    Et.buf[Et.pos++] = 127 & Qe | 128,
                                    Et.buf[Et.pos] = 127 & (Qe >>>= 7)
                                }(Xe, 0, ve),
                                function(Qe, ot) {
                                    var Et = (7 & Qe) << 4;
                                    ot.buf[ot.pos++] |= Et | ((Qe >>>= 3) ? 128 : 0),
                                    Qe && (ot.buf[ot.pos++] = 127 & Qe | ((Qe >>>= 7) ? 128 : 0),
                                    Qe && (ot.buf[ot.pos++] = 127 & Qe | ((Qe >>>= 7) ? 128 : 0),
                                    Qe && (ot.buf[ot.pos++] = 127 & Qe | ((Qe >>>= 7) ? 128 : 0),
                                    Qe && (ot.buf[ot.pos++] = 127 & Qe | ((Qe >>>= 7) ? 128 : 0),
                                    Qe && (ot.buf[ot.pos++] = 127 & Qe)))))
                                }(bt, ve)
                            }(O, this) : (this.realloc(4),
                            this.buf[this.pos++] = 127 & O | (O > 127 ? 128 : 0),
                            O <= 127 || (this.buf[this.pos++] = 127 & (O >>>= 7) | (O > 127 ? 128 : 0),
                            O <= 127 || (this.buf[this.pos++] = 127 & (O >>>= 7) | (O > 127 ? 128 : 0),
                            O <= 127 || (this.buf[this.pos++] = O >>> 7 & 127))))
                        },
                        writeSVarint: function(O) {
                            this.writeVarint(O < 0 ? 2 * -O - 1 : 2 * O)
                        },
                        writeBoolean: function(O) {
                            this.writeVarint(!!O)
                        },
                        writeString: function(O) {
                            O = String(O),
                            this.realloc(4 * O.length),
                            this.pos++;
                            var Y = this.pos;
                            this.pos = function(Xe, bt, Qe) {
                                for (var ot, Et, Ct = 0; Ct < bt.length; Ct++) {
                                    if ((ot = bt.charCodeAt(Ct)) > 55295 && ot < 57344) {
                                        if (!Et) {
                                            ot > 56319 || Ct + 1 === bt.length ? (Xe[Qe++] = 239,
                                            Xe[Qe++] = 191,
                                            Xe[Qe++] = 189) : Et = ot;
                                            continue
                                        }
                                        if (ot < 56320) {
                                            Xe[Qe++] = 239,
                                            Xe[Qe++] = 191,
                                            Xe[Qe++] = 189,
                                            Et = ot;
                                            continue
                                        }
                                        ot = Et - 55296 << 10 | ot - 56320 | 65536,
                                        Et = null
                                    } else
                                        Et && (Xe[Qe++] = 239,
                                        Xe[Qe++] = 191,
                                        Xe[Qe++] = 189,
                                        Et = null);
                                    ot < 128 ? Xe[Qe++] = ot : (ot < 2048 ? Xe[Qe++] = ot >> 6 | 192 : (ot < 65536 ? Xe[Qe++] = ot >> 12 | 224 : (Xe[Qe++] = ot >> 18 | 240,
                                    Xe[Qe++] = ot >> 12 & 63 | 128),
                                    Xe[Qe++] = ot >> 6 & 63 | 128),
                                    Xe[Qe++] = 63 & ot | 128)
                                }
                                return Qe
                            }(this.buf, O, this.pos);
                            var ve = this.pos - Y;
                            ve >= 128 && g(Y, ve, this),
                            this.pos = Y - 1,
                            this.writeVarint(ve),
                            this.pos += ve
                        },
                        writeFloat: function(O) {
                            this.realloc(4),
                            n.write(this.buf, O, this.pos, !0, 23, 4),
                            this.pos += 4
                        },
                        writeDouble: function(O) {
                            this.realloc(8),
                            n.write(this.buf, O, this.pos, !0, 52, 8),
                            this.pos += 8
                        },
                        writeBytes: function(O) {
                            var Y = O.length;
                            this.writeVarint(Y),
                            this.realloc(Y);
                            for (var ve = 0; ve < Y; ve++)
                                this.buf[this.pos++] = O[ve]
                        },
                        writeRawMessage: function(O, Y) {
                            this.pos++;
                            var ve = this.pos;
                            O(Y, this);
                            var Xe = this.pos - ve;
                            Xe >= 128 && g(ve, Xe, this),
                            this.pos = ve - 1,
                            this.writeVarint(Xe),
                            this.pos += Xe
                        },
                        writeMessage: function(O, Y, ve) {
                            this.writeTag(O, t.Bytes),
                            this.writeRawMessage(Y, ve)
                        },
                        writePackedVarint: function(O, Y) {
                            Y.length && this.writeMessage(O, y, Y)
                        },
                        writePackedSVarint: function(O, Y) {
                            Y.length && this.writeMessage(O, S, Y)
                        },
                        writePackedBoolean: function(O, Y) {
                            Y.length && this.writeMessage(O, R, Y)
                        },
                        writePackedFloat: function(O, Y) {
                            Y.length && this.writeMessage(O, I, Y)
                        },
                        writePackedDouble: function(O, Y) {
                            Y.length && this.writeMessage(O, A, Y)
                        },
                        writePackedFixed32: function(O, Y) {
                            Y.length && this.writeMessage(O, N, Y)
                        },
                        writePackedSFixed32: function(O, Y) {
                            Y.length && this.writeMessage(O, j, Y)
                        },
                        writePackedFixed64: function(O, Y) {
                            Y.length && this.writeMessage(O, $, Y)
                        },
                        writePackedSFixed64: function(O, Y) {
                            Y.length && this.writeMessage(O, J, Y)
                        },
                        writeBytesField: function(O, Y) {
                            this.writeTag(O, t.Bytes),
                            this.writeBytes(Y)
                        },
                        writeFixed32Field: function(O, Y) {
                            this.writeTag(O, t.Fixed32),
                            this.writeFixed32(Y)
                        },
                        writeSFixed32Field: function(O, Y) {
                            this.writeTag(O, t.Fixed32),
                            this.writeSFixed32(Y)
                        },
                        writeFixed64Field: function(O, Y) {
                            this.writeTag(O, t.Fixed64),
                            this.writeFixed64(Y)
                        },
                        writeSFixed64Field: function(O, Y) {
                            this.writeTag(O, t.Fixed64),
                            this.writeSFixed64(Y)
                        },
                        writeVarintField: function(O, Y) {
                            this.writeTag(O, t.Varint),
                            this.writeVarint(Y)
                        },
                        writeSVarintField: function(O, Y) {
                            this.writeTag(O, t.Varint),
                            this.writeSVarint(Y)
                        },
                        writeStringField: function(O, Y) {
                            this.writeTag(O, t.Bytes),
                            this.writeString(Y)
                        },
                        writeFloatField: function(O, Y) {
                            this.writeTag(O, t.Fixed32),
                            this.writeFloat(Y)
                        },
                        writeDoubleField: function(O, Y) {
                            this.writeTag(O, t.Fixed64),
                            this.writeDouble(Y)
                        },
                        writeBooleanField: function(O, Y) {
                            this.writeVarintField(O, !!Y)
                        }
                    },
                    Op
                }
                var Qs, jp = W(x_());
                function q0(n, t, i) {
                    n === 1 && i.readMessage(V0, t)
                }
                function V0(n, t, i) {
                    if (n === 3) {
                        const {id: a, bitmap: u, width: p, height: f, left: g, top: y, advance: S} = i.readMessage(Z0, {});
                        t.push({
                            id: a,
                            bitmap: new nu({
                                width: p + 6,
                                height: f + 6
                            },u),
                            metrics: {
                                width: p,
                                height: f,
                                left: g,
                                top: y,
                                advance: S
                            }
                        })
                    }
                }
                function Z0(n, t, i) {
                    n === 1 ? t.id = i.readVarint() : n === 2 ? t.bitmap = i.readBytes() : n === 3 ? t.width = i.readVarint() : n === 4 ? t.height = i.readVarint() : n === 5 ? t.left = i.readSVarint() : n === 6 ? t.top = i.readSVarint() : n === 7 && (t.advance = i.readVarint())
                }
                function b_(n) {
                    let t = 0
                      , i = 0;
                    for (const f of n)
                        t += f.w * f.h,
                        i = Math.max(i, f.w);
                    n.sort( (f, g) => g.h - f.h);
                    const a = [{
                        x: 0,
                        y: 0,
                        w: Math.max(Math.ceil(Math.sqrt(t / .95)), i),
                        h: 1 / 0
                    }];
                    let u = 0
                      , p = 0;
                    for (const f of n)
                        for (let g = a.length - 1; g >= 0; g--) {
                            const y = a[g];
                            if (!(f.w > y.w || f.h > y.h)) {
                                if (f.x = y.x,
                                f.y = y.y,
                                p = Math.max(p, f.y + f.h),
                                u = Math.max(u, f.x + f.w),
                                f.w === y.w && f.h === y.h) {
                                    const S = a.pop();
                                    g < a.length && (a[g] = S)
                                } else
                                    f.h === y.h ? (y.x += f.w,
                                    y.w -= f.w) : f.w === y.w ? (y.y += f.h,
                                    y.h -= f.h) : (a.push({
                                        x: y.x + f.w,
                                        y: y.y,
                                        w: y.w - f.w,
                                        h: f.h
                                    }),
                                    y.y += f.h,
                                    y.h -= f.h);
                                break
                            }
                        }
                    return {
                        w: u,
                        h: p,
                        fill: t / (u * p) || 0
                    }
                }
                class qp {
                    constructor(t, {pixelRatio: i, version: a, stretchX: u, stretchY: p, content: f, textFitWidth: g, textFitHeight: y}) {
                        this.paddedRect = t,
                        this.pixelRatio = i,
                        this.stretchX = u,
                        this.stretchY = p,
                        this.content = f,
                        this.version = a,
                        this.textFitWidth = g,
                        this.textFitHeight = y
                    }
                    get tl() {
                        return [this.paddedRect.x + 1, this.paddedRect.y + 1]
                    }
                    get br() {
                        return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
                    }
                    get tlbr() {
                        return this.tl.concat(this.br)
                    }
                    get displaySize() {
                        return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
                    }
                }
                class w_ {
                    constructor(t, i) {
                        const a = {}
                          , u = {};
                        this.haveRenderCallbacks = [];
                        const p = [];
                        this.addImages(t, a, p),
                        this.addImages(i, u, p);
                        const {w: f, h: g} = b_(p)
                          , y = new ra({
                            width: f || 1,
                            height: g || 1
                        });
                        for (const S in t) {
                            const I = t[S]
                              , A = a[S].paddedRect;
                            ra.copy(I.data, y, {
                                x: 0,
                                y: 0
                            }, {
                                x: A.x + 1,
                                y: A.y + 1
                            }, I.data)
                        }
                        for (const S in i) {
                            const I = i[S]
                              , A = u[S].paddedRect
                              , R = A.x + 1
                              , N = A.y + 1
                              , j = I.data.width
                              , $ = I.data.height;
                            ra.copy(I.data, y, {
                                x: 0,
                                y: 0
                            }, {
                                x: R,
                                y: N
                            }, I.data),
                            ra.copy(I.data, y, {
                                x: 0,
                                y: $ - 1
                            }, {
                                x: R,
                                y: N - 1
                            }, {
                                width: j,
                                height: 1
                            }),
                            ra.copy(I.data, y, {
                                x: 0,
                                y: 0
                            }, {
                                x: R,
                                y: N + $
                            }, {
                                width: j,
                                height: 1
                            }),
                            ra.copy(I.data, y, {
                                x: j - 1,
                                y: 0
                            }, {
                                x: R - 1,
                                y: N
                            }, {
                                width: 1,
                                height: $
                            }),
                            ra.copy(I.data, y, {
                                x: 0,
                                y: 0
                            }, {
                                x: R + j,
                                y: N
                            }, {
                                width: 1,
                                height: $
                            })
                        }
                        this.image = y,
                        this.iconPositions = a,
                        this.patternPositions = u
                    }
                    addImages(t, i, a) {
                        for (const u in t) {
                            const p = t[u]
                              , f = {
                                x: 0,
                                y: 0,
                                w: p.data.width + 2,
                                h: p.data.height + 2
                            };
                            a.push(f),
                            i[u] = new qp(f,p),
                            p.hasRenderCallback && this.haveRenderCallbacks.push(u)
                        }
                    }
                    patchUpdatedImages(t, i) {
                        t.dispatchRenderCallbacks(this.haveRenderCallbacks);
                        for (const a in t.updatedImages)
                            this.patchUpdatedImage(this.iconPositions[a], t.getImage(a), i),
                            this.patchUpdatedImage(this.patternPositions[a], t.getImage(a), i)
                    }
                    patchUpdatedImage(t, i, a) {
                        if (!t || !i || t.version === i.version)
                            return;
                        t.version = i.version;
                        const [u,p] = t.tl;
                        a.update(i.data, void 0, {
                            x: u,
                            y: p
                        })
                    }
                }
                Wt("ImagePosition", qp),
                Wt("ImageAtlas", w_),
                C.an = void 0,
                (Qs = C.an || (C.an = {}))[Qs.none = 0] = "none",
                Qs[Qs.horizontal = 1] = "horizontal",
                Qs[Qs.vertical = 2] = "vertical",
                Qs[Qs.horizontalOnly = 3] = "horizontalOnly";
                class mu {
                    constructor() {
                        this.scale = 1,
                        this.fontStack = "",
                        this.imageName = null,
                        this.verticalAlign = "bottom"
                    }
                    static forText(t, i, a) {
                        const u = new mu;
                        return u.scale = t || 1,
                        u.fontStack = i,
                        u.verticalAlign = a || "bottom",
                        u
                    }
                    static forImage(t, i) {
                        const a = new mu;
                        return a.imageName = t,
                        a.verticalAlign = i || "bottom",
                        a
                    }
                }
                class Fl {
                    constructor() {
                        this.text = "",
                        this.sectionIndex = [],
                        this.sections = [],
                        this.imageSectionID = null
                    }
                    static fromFeature(t, i) {
                        const a = new Fl;
                        for (let u = 0; u < t.sections.length; u++) {
                            const p = t.sections[u];
                            p.image ? a.addImageSection(p) : a.addTextSection(p, i)
                        }
                        return a
                    }
                    length() {
                        return this.text.length
                    }
                    getSection(t) {
                        return this.sections[this.sectionIndex[t]]
                    }
                    getSectionIndex(t) {
                        return this.sectionIndex[t]
                    }
                    getCharCode(t) {
                        return this.text.charCodeAt(t)
                    }
                    verticalizePunctuation() {
                        this.text = function(t) {
                            let i = "";
                            for (let a = 0; a < t.length; a++) {
                                const u = t.charCodeAt(a + 1) || null
                                  , p = t.charCodeAt(a - 1) || null;
                                i += u && Gc(u) && !fu[t[a + 1]] || p && Gc(p) && !fu[t[a - 1]] || !fu[t[a]] ? t[a] : fu[t[a]]
                            }
                            return i
                        }(this.text)
                    }
                    trim() {
                        let t = 0;
                        for (let a = 0; a < this.text.length && hd[this.text.charCodeAt(a)]; a++)
                            t++;
                        let i = this.text.length;
                        for (let a = this.text.length - 1; a >= 0 && a >= t && hd[this.text.charCodeAt(a)]; a--)
                            i--;
                        this.text = this.text.substring(t, i),
                        this.sectionIndex = this.sectionIndex.slice(t, i)
                    }
                    substring(t, i) {
                        const a = new Fl;
                        return a.text = this.text.substring(t, i),
                        a.sectionIndex = this.sectionIndex.slice(t, i),
                        a.sections = this.sections,
                        a
                    }
                    toString() {
                        return this.text
                    }
                    getMaxScale() {
                        return this.sectionIndex.reduce( (t, i) => Math.max(t, this.sections[i].scale), 0)
                    }
                    getMaxImageSize(t) {
                        let i = 0
                          , a = 0;
                        for (let u = 0; u < this.length(); u++) {
                            const p = this.getSection(u);
                            if (p.imageName) {
                                const f = t[p.imageName];
                                if (!f)
                                    continue;
                                const g = f.displaySize;
                                i = Math.max(i, g[0]),
                                a = Math.max(a, g[1])
                            }
                        }
                        return {
                            maxImageWidth: i,
                            maxImageHeight: a
                        }
                    }
                    addTextSection(t, i) {
                        this.text += t.text,
                        this.sections.push(mu.forText(t.scale, t.fontStack || i, t.verticalAlign));
                        const a = this.sections.length - 1;
                        for (let u = 0; u < t.text.length; ++u)
                            this.sectionIndex.push(a)
                    }
                    addImageSection(t) {
                        const i = t.image ? t.image.name : "";
                        if (i.length === 0)
                            return void Qt("Can't add FormattedSection with an empty image.");
                        const a = this.getNextImageSectionCharCode();
                        a ? (this.text += String.fromCharCode(a),
                        this.sections.push(mu.forImage(i, t.verticalAlign)),
                        this.sectionIndex.push(this.sections.length - 1)) : Qt("Reached maximum number of images 6401")
                    }
                    getNextImageSectionCharCode() {
                        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344,
                        this.imageSectionID)
                    }
                }
                function ud(n, t, i, a, u, p, f, g, y, S, I, A, R, N, j) {
                    const $ = Fl.fromFeature(n, u);
                    let J;
                    A === C.an.vertical && $.verticalizePunctuation();
                    const {processBidirectionalText: se, processStyledBidirectionalText: Ae} = Xa;
                    if (se && $.sections.length === 1) {
                        J = [];
                        const Y = se($.toString(), Vp($, S, p, t, a, N));
                        for (const ve of Y) {
                            const Xe = new Fl;
                            Xe.text = ve,
                            Xe.sections = $.sections;
                            for (let bt = 0; bt < ve.length; bt++)
                                Xe.sectionIndex.push(0);
                            J.push(Xe)
                        }
                    } else if (Ae) {
                        J = [];
                        const Y = Ae($.text, $.sectionIndex, Vp($, S, p, t, a, N));
                        for (const ve of Y) {
                            const Xe = new Fl;
                            Xe.text = ve[0],
                            Xe.sectionIndex = ve[1],
                            Xe.sections = $.sections,
                            J.push(Xe)
                        }
                    } else
                        J = function(Y, ve) {
                            const Xe = []
                              , bt = Y.text;
                            let Qe = 0;
                            for (const ot of ve)
                                Xe.push(Y.substring(Qe, ot)),
                                Qe = ot;
                            return Qe < bt.length && Xe.push(Y.substring(Qe, bt.length)),
                            Xe
                        }($, Vp($, S, p, t, a, N));
                    const _e = []
                      , O = {
                        positionedLines: _e,
                        text: $.toString(),
                        top: I[1],
                        bottom: I[1],
                        left: I[0],
                        right: I[0],
                        writingMode: A,
                        iconsInText: !1,
                        verticalizable: !1
                    };
                    return function(Y, ve, Xe, bt, Qe, ot, Et, Ct, Dt, pt, ir, Er) {
                        let Cr = 0
                          , ur = 0
                          , ii = 0
                          , Vi = 0;
                        const rn = Ct === "right" ? 1 : Ct === "left" ? 0 : .5
                          , In = un / Er;
                        let va = 0;
                        for (const Oi of Qe) {
                            Oi.trim();
                            const hn = Oi.getMaxScale()
                              , wn = {
                                positionedGlyphs: [],
                                lineOffset: 0
                            };
                            Y.positionedLines[va] = wn;
                            const Tn = wn.positionedGlyphs;
                            let Gn = 0;
                            if (!Oi.length()) {
                                ur += ot,
                                ++va;
                                continue
                            }
                            const ya = H0(bt, Oi, In);
                            for (let na = 0; na < Oi.length(); na++) {
                                const nn = Oi.getSection(na)
                                  , pn = Oi.getSectionIndex(na)
                                  , fn = Oi.getCharCode(na)
                                  , Ji = W0(Dt, ir, fn);
                                let Ai;
                                if (nn.imageName) {
                                    if (Y.iconsInText = !0,
                                    nn.scale = nn.scale * In,
                                    Ai = K0(nn, Ji, hn, ya, bt),
                                    !Ai)
                                        continue;
                                    Gn = Math.max(Gn, Ai.imageOffset)
                                } else if (Ai = X0(nn, fn, Ji, ya, ve, Xe),
                                !Ai)
                                    continue;
                                const {rect: Oa, metrics: ql, baselineOffset: Na} = Ai;
                                Tn.push({
                                    glyph: fn,
                                    imageName: nn.imageName,
                                    x: Cr,
                                    y: ur + Na + -17,
                                    vertical: Ji,
                                    scale: nn.scale,
                                    fontStack: nn.fontStack,
                                    sectionIndex: pn,
                                    metrics: ql,
                                    rect: Oa
                                }),
                                Ji ? (Y.verticalizable = !0,
                                Cr += (nn.imageName ? ql.advance : un) * nn.scale + pt) : Cr += ql.advance * nn.scale + pt
                            }
                            Tn.length !== 0 && (ii = Math.max(Cr - pt, ii),
                            Y0(Tn, 0, Tn.length - 1, rn)),
                            Cr = 0,
                            wn.lineOffset = Math.max(Gn, (hn - 1) * un);
                            const dn = ot * hn + Gn;
                            ur += dn,
                            Vi = Math.max(dn, Vi),
                            ++va
                        }
                        const {horizontalAlign: ia, verticalAlign: bn} = Zp(Et);
                        (function(Oi, hn, wn, Tn, Gn, ya, dn, na, nn) {
                            const pn = (hn - wn) * Gn;
                            let fn = 0;
                            fn = ya !== dn ? -na * Tn - -17 : -Tn * nn * dn + .5 * dn;
                            for (const Ji of Oi)
                                for (const Ai of Ji.positionedGlyphs)
                                    Ai.x += pn,
                                    Ai.y += fn
                        }
                        )(Y.positionedLines, rn, ia, bn, ii, Vi, ot, ur, Qe.length),
                        Y.top += -bn * ur,
                        Y.bottom = Y.top + ur,
                        Y.left += -ia * ii,
                        Y.right = Y.left + ii
                    }(O, t, i, a, J, f, g, y, A, S, R, j),
                    !function(Y) {
                        for (const ve of Y)
                            if (ve.positionedGlyphs.length !== 0)
                                return !1;
                        return !0
                    }(_e) && O
                }
                const hd = {
                    9: !0,
                    10: !0,
                    11: !0,
                    12: !0,
                    13: !0,
                    32: !0
                }
                  , $0 = {
                    10: !0,
                    32: !0,
                    38: !0,
                    41: !0,
                    43: !0,
                    45: !0,
                    47: !0,
                    173: !0,
                    183: !0,
                    8203: !0,
                    8208: !0,
                    8211: !0,
                    8231: !0
                }
                  , U0 = {
                    40: !0
                };
                function T_(n, t, i, a, u, p) {
                    if (t.imageName) {
                        const f = a[t.imageName];
                        return f ? f.displaySize[0] * t.scale * un / p + u : 0
                    }
                    {
                        const f = i[t.fontStack]
                          , g = f && f[n];
                        return g ? g.metrics.advance * t.scale + u : 0
                    }
                }
                function C_(n, t, i, a) {
                    const u = Math.pow(n - t, 2);
                    return a ? n < t ? u / 2 : 2 * u : u + Math.abs(i) * i
                }
                function G0(n, t, i) {
                    let a = 0;
                    return n === 10 && (a -= 1e4),
                    i && (a += 150),
                    n !== 40 && n !== 65288 || (a += 50),
                    t !== 41 && t !== 65289 || (a += 50),
                    a
                }
                function S_(n, t, i, a, u, p) {
                    let f = null
                      , g = C_(t, i, u, p);
                    for (const y of a) {
                        const S = C_(t - y.x, i, u, p) + y.badness;
                        S <= g && (f = y,
                        g = S)
                    }
                    return {
                        index: n,
                        x: t,
                        priorBreak: f,
                        badness: g
                    }
                }
                function P_(n) {
                    return n ? P_(n.priorBreak).concat(n.index) : []
                }
                function Vp(n, t, i, a, u, p) {
                    if (!n)
                        return [];
                    const f = []
                      , g = function(A, R, N, j, $, J) {
                        let se = 0;
                        for (let Ae = 0; Ae < A.length(); Ae++) {
                            const _e = A.getSection(Ae);
                            se += T_(A.getCharCode(Ae), _e, j, $, R, J)
                        }
                        return se / Math.max(1, Math.ceil(se / N))
                    }(n, t, i, a, u, p)
                      , y = n.text.indexOf("â€‹") >= 0;
                    let S = 0;
                    for (let A = 0; A < n.length(); A++) {
                        const R = n.getSection(A)
                          , N = n.getCharCode(A);
                        if (hd[N] || (S += T_(N, R, a, u, t, p)),
                        A < n.length() - 1) {
                            const j = !((I = N) < 11904) && (!!ti["CJK Compatibility Forms"](I) || !!ti["CJK Compatibility"](I) || !!ti["CJK Strokes"](I) || !!ti["CJK Symbols and Punctuation"](I) || !!ti["Enclosed CJK Letters and Months"](I) || !!ti["Halfwidth and Fullwidth Forms"](I) || !!ti["Ideographic Description Characters"](I) || !!ti["Vertical Forms"](I) || Uc.test(String.fromCodePoint(I)));
                            ($0[N] || j || R.imageName || A !== n.length() - 2 && U0[n.getCharCode(A + 1)]) && f.push(S_(A + 1, S, g, f, G0(N, n.getCharCode(A + 1), j && y), !1))
                        }
                    }
                    var I;
                    return P_(S_(n.length(), S, g, f, 0, !0))
                }
                function Zp(n) {
                    let t = .5
                      , i = .5;
                    switch (n) {
                    case "right":
                    case "top-right":
                    case "bottom-right":
                        t = 1;
                        break;
                    case "left":
                    case "top-left":
                    case "bottom-left":
                        t = 0
                    }
                    switch (n) {
                    case "bottom":
                    case "bottom-right":
                    case "bottom-left":
                        i = 1;
                        break;
                    case "top":
                    case "top-right":
                    case "top-left":
                        i = 0
                    }
                    return {
                        horizontalAlign: t,
                        verticalAlign: i
                    }
                }
                function H0(n, t, i) {
                    const a = t.getMaxScale() * un
                      , {maxImageWidth: u, maxImageHeight: p} = t.getMaxImageSize(n)
                      , f = Math.max(a, p * i);
                    return {
                        verticalLineContentWidth: Math.max(a, u * i),
                        horizontalLineContentHeight: f
                    }
                }
                function I_(n) {
                    switch (n) {
                    case "top":
                        return 0;
                    case "center":
                        return .5;
                    default:
                        return 1
                    }
                }
                function W0(n, t, i) {
                    return !(n === C.an.horizontal || !t && !Il(i) || t && (hd[i] || (a = i,
                    new RegExp("\\p{sc=Arab}","u").test(String.fromCodePoint(a)))));
                    var a
                }
                function X0(n, t, i, a, u, p) {
                    const f = p[n.fontStack]
                      , g = function(S, I, A, R) {
                        if (S && S.rect)
                            return S;
                        const N = I[A.fontStack]
                          , j = N && N[R];
                        return j ? {
                            rect: null,
                            metrics: j.metrics
                        } : null
                    }(f && f[t], u, n, t);
                    if (g === null)
                        return null;
                    let y;
                    if (i)
                        y = a.verticalLineContentWidth - n.scale * un;
                    else {
                        const S = I_(n.verticalAlign);
                        y = (a.horizontalLineContentHeight - n.scale * un) * S
                    }
                    return {
                        rect: g.rect,
                        metrics: g.metrics,
                        baselineOffset: y
                    }
                }
                function K0(n, t, i, a, u) {
                    const p = u[n.imageName];
                    if (!p)
                        return null;
                    const f = p.paddedRect
                      , g = p.displaySize
                      , y = {
                        width: g[0],
                        height: g[1],
                        left: 1,
                        top: -3,
                        advance: t ? g[1] : g[0]
                    };
                    let S;
                    if (t)
                        S = a.verticalLineContentWidth - g[1] * n.scale;
                    else {
                        const I = I_(n.verticalAlign);
                        S = (a.horizontalLineContentHeight - g[1] * n.scale) * I
                    }
                    return {
                        rect: f,
                        metrics: y,
                        baselineOffset: S,
                        imageOffset: (t ? g[0] : g[1]) * n.scale - un * i
                    }
                }
                function Y0(n, t, i, a) {
                    if (a === 0)
                        return;
                    const u = n[i]
                      , p = (n[i].x + u.metrics.advance * u.scale) * a;
                    for (let f = t; f <= i; f++)
                        n[f].x -= p
                }
                function J0(n, t, i) {
                    const {horizontalAlign: a, verticalAlign: u} = Zp(i)
                      , p = t[0] - n.displaySize[0] * a
                      , f = t[1] - n.displaySize[1] * u;
                    return {
                        image: n,
                        top: f,
                        bottom: f + n.displaySize[1],
                        left: p,
                        right: p + n.displaySize[0]
                    }
                }
                function M_(n) {
                    var t, i;
                    let a = n.left
                      , u = n.top
                      , p = n.right - a
                      , f = n.bottom - u;
                    const g = (t = n.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink"
                      , y = (i = n.image.textFitHeight) !== null && i !== void 0 ? i : "stretchOrShrink"
                      , S = (n.image.content[2] - n.image.content[0]) / (n.image.content[3] - n.image.content[1]);
                    if (y === "proportional") {
                        if (g === "stretchOnly" && p / f < S || g === "proportional") {
                            const I = Math.ceil(f * S);
                            a *= I / p,
                            p = I
                        }
                    } else if (g === "proportional" && y === "stretchOnly" && S !== 0 && p / f > S) {
                        const I = Math.ceil(p / S);
                        u *= I / f,
                        f = I
                    }
                    return {
                        x1: a,
                        y1: u,
                        x2: a + p,
                        y2: u + f
                    }
                }
                function A_(n, t, i, a, u, p) {
                    const f = n.image;
                    let g;
                    if (f.content) {
                        const J = f.content
                          , se = f.pixelRatio || 1;
                        g = [J[0] / se, J[1] / se, f.displaySize[0] - J[2] / se, f.displaySize[1] - J[3] / se]
                    }
                    const y = t.left * p
                      , S = t.right * p;
                    let I, A, R, N;
                    i === "width" || i === "both" ? (N = u[0] + y - a[3],
                    A = u[0] + S + a[1]) : (N = u[0] + (y + S - f.displaySize[0]) / 2,
                    A = N + f.displaySize[0]);
                    const j = t.top * p
                      , $ = t.bottom * p;
                    return i === "height" || i === "both" ? (I = u[1] + j - a[0],
                    R = u[1] + $ + a[2]) : (I = u[1] + (j + $ - f.displaySize[1]) / 2,
                    R = I + f.displaySize[1]),
                    {
                        image: f,
                        top: I,
                        right: A,
                        bottom: R,
                        left: N,
                        collisionPadding: g
                    }
                }
                const vs = 128
                  , eo = 32640;
                function k_(n, t) {
                    const {expression: i} = t;
                    if (i.kind === "constant")
                        return {
                            kind: "constant",
                            layoutSize: i.evaluate(new Ei(n + 1))
                        };
                    if (i.kind === "source")
                        return {
                            kind: "source"
                        };
                    {
                        const {zoomStops: a, interpolationType: u} = i;
                        let p = 0;
                        for (; p < a.length && a[p] <= n; )
                            p++;
                        p = Math.max(0, p - 1);
                        let f = p;
                        for (; f < a.length && a[f] < n + 1; )
                            f++;
                        f = Math.min(a.length - 1, f);
                        const g = a[p]
                          , y = a[f];
                        return i.kind === "composite" ? {
                            kind: "composite",
                            minZoom: g,
                            maxZoom: y,
                            interpolationType: u
                        } : {
                            kind: "camera",
                            minZoom: g,
                            maxZoom: y,
                            minSize: i.evaluate(new Ei(g)),
                            maxSize: i.evaluate(new Ei(y)),
                            interpolationType: u
                        }
                    }
                }
                function $p(n, t, i) {
                    let a = "never";
                    const u = n.get(t);
                    return u ? a = u : n.get(i) && (a = "always"),
                    a
                }
                const Q0 = hu.VectorTileFeature.types
                  , ey = [{
                    name: "a_fade_opacity",
                    components: 1,
                    type: "Uint8",
                    offset: 0
                }];
                function dd(n, t, i, a, u, p, f, g, y, S, I, A, R) {
                    const N = g ? Math.min(eo, Math.round(g[0])) : 0
                      , j = g ? Math.min(eo, Math.round(g[1])) : 0;
                    n.emplaceBack(t, i, Math.round(32 * a), Math.round(32 * u), p, f, (N << 1) + (y ? 1 : 0), j, 16 * S, 16 * I, 256 * A, 256 * R)
                }
                function Up(n, t, i) {
                    n.emplaceBack(t.x, t.y, i),
                    n.emplaceBack(t.x, t.y, i),
                    n.emplaceBack(t.x, t.y, i),
                    n.emplaceBack(t.x, t.y, i)
                }
                function ty(n) {
                    for (const t of n.sections)
                        if (Hc(t.text))
                            return !0;
                    return !1
                }
                class Gp {
                    constructor(t) {
                        this.layoutVertexArray = new Kr,
                        this.indexArray = new Ti,
                        this.programConfigurations = t,
                        this.segments = new li,
                        this.dynamicLayoutVertexArray = new fi,
                        this.opacityVertexArray = new Bi,
                        this.hasVisibleVertices = !1,
                        this.placedSymbolArray = new ne
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0
                    }
                    upload(t, i, a, u) {
                        this.isEmpty() || (a && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, R0.members),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray, i),
                        this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, B0.members, !0),
                        this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, ey, !0),
                        this.opacityVertexBuffer.itemSize = 1),
                        (a || u) && this.programConfigurations.upload(t))
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.dynamicLayoutVertexBuffer.destroy(),
                        this.opacityVertexBuffer.destroy())
                    }
                }
                Wt("SymbolBuffers", Gp);
                class Hp {
                    constructor(t, i, a) {
                        this.layoutVertexArray = new t,
                        this.layoutAttributes = i,
                        this.indexArray = new a,
                        this.segments = new li,
                        this.collisionVertexArray = new Fi
                    }
                    upload(t) {
                        this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray),
                        this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, F0.members, !0)
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.segments.destroy(),
                        this.collisionVertexBuffer.destroy())
                    }
                }
                Wt("CollisionBuffers", Hp);
                class Ol {
                    constructor(t) {
                        this.collisionBoxArray = t.collisionBoxArray,
                        this.zoom = t.zoom,
                        this.globalState = t.globalState,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map(f => f.id),
                        this.index = t.index,
                        this.pixelRatio = t.pixelRatio,
                        this.sourceLayerIndex = t.sourceLayerIndex,
                        this.hasPattern = !1,
                        this.hasRTLText = !1,
                        this.sortKeyRanges = [],
                        this.collisionCircleArray = [];
                        const i = this.layers[0]._unevaluatedLayout._values;
                        this.textSizeData = k_(this.zoom, i["text-size"]),
                        this.iconSizeData = k_(this.zoom, i["icon-size"]);
                        const a = this.layers[0].layout
                          , u = a.get("symbol-sort-key")
                          , p = a.get("symbol-z-order");
                        this.canOverlap = $p(a, "text-overlap", "text-allow-overlap") !== "never" || $p(a, "icon-overlap", "icon-allow-overlap") !== "never" || a.get("text-ignore-placement") || a.get("icon-ignore-placement"),
                        this.sortFeaturesByKey = p !== "viewport-y" && !u.isConstant(),
                        this.sortFeaturesByY = (p === "viewport-y" || p === "auto" && !this.sortFeaturesByKey) && this.canOverlap,
                        a.get("symbol-placement") === "point" && (this.writingModes = a.get("text-writing-mode").map(f => C.an[f])),
                        this.stateDependentLayerIds = this.layers.filter(f => f.isStateDependent()).map(f => f.id),
                        this.sourceID = t.sourceID
                    }
                    createArrays() {
                        this.text = new Gp(new rs(this.layers,this.zoom,t => /^text/.test(t))),
                        this.icon = new Gp(new rs(this.layers,this.zoom,t => /^icon/.test(t))),
                        this.glyphOffsetArray = new ce,
                        this.lineVertexArray = new Te,
                        this.symbolInstances = new me,
                        this.textAnchorOffsets = new pe
                    }
                    calculateGlyphDependencies(t, i, a, u, p) {
                        for (let f = 0; f < t.length; f++)
                            if (i[t.charCodeAt(f)] = !0,
                            (a || u) && p) {
                                const g = fu[t.charAt(f)];
                                g && (i[g.charCodeAt(0)] = !0)
                            }
                    }
                    populate(t, i, a) {
                        const u = this.layers[0]
                          , p = u.layout
                          , f = p.get("text-font")
                          , g = p.get("text-field")
                          , y = p.get("icon-image")
                          , S = (g.value.kind !== "constant" || g.value.value instanceof Gi && !g.value.value.isEmpty() || g.value.value.toString().length > 0) && (f.value.kind !== "constant" || f.value.value.length > 0)
                          , I = y.value.kind !== "constant" || !!y.value.value || Object.keys(y.parameters).length > 0
                          , A = p.get("symbol-sort-key");
                        if (this.features = [],
                        !S && !I)
                            return;
                        const R = i.iconDependencies
                          , N = i.glyphDependencies
                          , j = i.availableImages
                          , $ = new Ei(this.zoom,{
                            globalState: this.globalState
                        });
                        for (const {feature: J, id: se, index: Ae, sourceLayerIndex: _e} of t) {
                            const O = u._featureFilter.needGeometry
                              , Y = Vo(J, O);
                            if (!u._featureFilter.filter($, Y, a))
                                continue;
                            let ve, Xe;
                            if (O || (Y.geometry = qo(J)),
                            S) {
                                const Qe = u.getValueAndResolveTokens("text-field", Y, a, j)
                                  , ot = Gi.factory(Qe)
                                  , Et = this.hasRTLText = this.hasRTLText || ty(ot);
                                (!Et || Xa.getRTLTextPluginStatus() === "unavailable" || Et && Xa.isParsed()) && (ve = N0(ot, u, Y))
                            }
                            if (I) {
                                const Qe = u.getValueAndResolveTokens("icon-image", Y, a, j);
                                Xe = Qe instanceof qn ? Qe : qn.fromString(Qe)
                            }
                            if (!ve && !Xe)
                                continue;
                            const bt = this.sortFeaturesByKey ? A.evaluate(Y, {}, a) : void 0;
                            if (this.features.push({
                                id: se,
                                text: ve,
                                icon: Xe,
                                index: Ae,
                                sourceLayerIndex: _e,
                                geometry: Y.geometry,
                                properties: J.properties,
                                type: Q0[J.type],
                                sortKey: bt
                            }),
                            Xe && (R[Xe.name] = !0),
                            ve) {
                                const Qe = f.evaluate(Y, {}, a).join(",")
                                  , ot = p.get("text-rotation-alignment") !== "viewport" && p.get("symbol-placement") !== "point";
                                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(C.an.vertical) >= 0;
                                for (const Et of ve.sections)
                                    if (Et.image)
                                        R[Et.image.name] = !0;
                                    else {
                                        const Ct = $c(ve.toString())
                                          , Dt = Et.fontStack || Qe
                                          , pt = N[Dt] = N[Dt] || {};
                                        this.calculateGlyphDependencies(Et.text, pt, ot, this.allowVerticalPlacement, Ct)
                                    }
                            }
                        }
                        p.get("symbol-placement") === "line" && (this.features = function(J) {
                            const se = {}
                              , Ae = {}
                              , _e = [];
                            let O = 0;
                            function Y(Qe) {
                                _e.push(J[Qe]),
                                O++
                            }
                            function ve(Qe, ot, Et) {
                                const Ct = Ae[Qe];
                                return delete Ae[Qe],
                                Ae[ot] = Ct,
                                _e[Ct].geometry[0].pop(),
                                _e[Ct].geometry[0] = _e[Ct].geometry[0].concat(Et[0]),
                                Ct
                            }
                            function Xe(Qe, ot, Et) {
                                const Ct = se[ot];
                                return delete se[ot],
                                se[Qe] = Ct,
                                _e[Ct].geometry[0].shift(),
                                _e[Ct].geometry[0] = Et[0].concat(_e[Ct].geometry[0]),
                                Ct
                            }
                            function bt(Qe, ot, Et) {
                                const Ct = Et ? ot[0][ot[0].length - 1] : ot[0][0];
                                return `${Qe}:${Ct.x}:${Ct.y}`
                            }
                            for (let Qe = 0; Qe < J.length; Qe++) {
                                const ot = J[Qe]
                                  , Et = ot.geometry
                                  , Ct = ot.text ? ot.text.toString() : null;
                                if (!Ct) {
                                    Y(Qe);
                                    continue
                                }
                                const Dt = bt(Ct, Et)
                                  , pt = bt(Ct, Et, !0);
                                if (Dt in Ae && pt in se && Ae[Dt] !== se[pt]) {
                                    const ir = Xe(Dt, pt, Et)
                                      , Er = ve(Dt, pt, _e[ir].geometry);
                                    delete se[Dt],
                                    delete Ae[pt],
                                    Ae[bt(Ct, _e[Er].geometry, !0)] = Er,
                                    _e[ir].geometry = null
                                } else
                                    Dt in Ae ? ve(Dt, pt, Et) : pt in se ? Xe(Dt, pt, Et) : (Y(Qe),
                                    se[Dt] = O - 1,
                                    Ae[pt] = O - 1)
                            }
                            return _e.filter(Qe => Qe.geometry)
                        }(this.features)),
                        this.sortFeaturesByKey && this.features.sort( (J, se) => J.sortKey - se.sortKey)
                    }
                    update(t, i, a) {
                        this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, i, this.layers, a),
                        this.icon.programConfigurations.updatePaintArrays(t, i, this.layers, a))
                    }
                    isEmpty() {
                        return this.symbolInstances.length === 0 && !this.hasRTLText
                    }
                    uploadPending() {
                        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
                    }
                    upload(t) {
                        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t),
                        this.iconCollisionBox.upload(t)),
                        this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload),
                        this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload),
                        this.uploaded = !0
                    }
                    destroyDebugData() {
                        this.textCollisionBox.destroy(),
                        this.iconCollisionBox.destroy()
                    }
                    destroy() {
                        this.text.destroy(),
                        this.icon.destroy(),
                        this.hasDebugData() && this.destroyDebugData()
                    }
                    addToLineVertexArray(t, i) {
                        const a = this.lineVertexArray.length;
                        if (t.segment !== void 0) {
                            let u = t.dist(i[t.segment + 1])
                              , p = t.dist(i[t.segment]);
                            const f = {};
                            for (let g = t.segment + 1; g < i.length; g++)
                                f[g] = {
                                    x: i[g].x,
                                    y: i[g].y,
                                    tileUnitDistanceFromAnchor: u
                                },
                                g < i.length - 1 && (u += i[g + 1].dist(i[g]));
                            for (let g = t.segment || 0; g >= 0; g--)
                                f[g] = {
                                    x: i[g].x,
                                    y: i[g].y,
                                    tileUnitDistanceFromAnchor: p
                                },
                                g > 0 && (p += i[g - 1].dist(i[g]));
                            for (let g = 0; g < i.length; g++) {
                                const y = f[g];
                                this.lineVertexArray.emplaceBack(y.x, y.y, y.tileUnitDistanceFromAnchor)
                            }
                        }
                        return {
                            lineStartIndex: a,
                            lineLength: this.lineVertexArray.length - a
                        }
                    }
                    addSymbols(t, i, a, u, p, f, g, y, S, I, A, R) {
                        const N = t.indexArray
                          , j = t.layoutVertexArray
                          , $ = t.segments.prepareSegment(4 * i.length, j, N, this.canOverlap ? f.sortKey : void 0)
                          , J = this.glyphOffsetArray.length
                          , se = $.vertexLength
                          , Ae = this.allowVerticalPlacement && g === C.an.vertical ? Math.PI / 2 : 0
                          , _e = f.text && f.text.sections;
                        for (let O = 0; O < i.length; O++) {
                            const {tl: Y, tr: ve, bl: Xe, br: bt, tex: Qe, pixelOffsetTL: ot, pixelOffsetBR: Et, minFontScaleX: Ct, minFontScaleY: Dt, glyphOffset: pt, isSDF: ir, sectionIndex: Er} = i[O]
                              , Cr = $.vertexLength
                              , ur = pt[1];
                            dd(j, y.x, y.y, Y.x, ur + Y.y, Qe.x, Qe.y, a, ir, ot.x, ot.y, Ct, Dt),
                            dd(j, y.x, y.y, ve.x, ur + ve.y, Qe.x + Qe.w, Qe.y, a, ir, Et.x, ot.y, Ct, Dt),
                            dd(j, y.x, y.y, Xe.x, ur + Xe.y, Qe.x, Qe.y + Qe.h, a, ir, ot.x, Et.y, Ct, Dt),
                            dd(j, y.x, y.y, bt.x, ur + bt.y, Qe.x + Qe.w, Qe.y + Qe.h, a, ir, Et.x, Et.y, Ct, Dt),
                            Up(t.dynamicLayoutVertexArray, y, Ae),
                            N.emplaceBack(Cr, Cr + 2, Cr + 1),
                            N.emplaceBack(Cr + 1, Cr + 2, Cr + 3),
                            $.vertexLength += 4,
                            $.primitiveLength += 2,
                            this.glyphOffsetArray.emplaceBack(pt[0]),
                            O !== i.length - 1 && Er === i[O + 1].sectionIndex || t.programConfigurations.populatePaintArrays(j.length, f, f.index, {}, R, _e && _e[Er])
                        }
                        t.placedSymbolArray.emplaceBack(y.x, y.y, J, this.glyphOffsetArray.length - J, se, S, I, y.segment, a ? a[0] : 0, a ? a[1] : 0, u[0], u[1], g, 0, !1, 0, A)
                    }
                    _addCollisionDebugVertex(t, i, a, u, p, f) {
                        return i.emplaceBack(0, 0),
                        t.emplaceBack(a.x, a.y, u, p, Math.round(f.x), Math.round(f.y))
                    }
                    addCollisionDebugVertices(t, i, a, u, p, f, g) {
                        const y = p.segments.prepareSegment(4, p.layoutVertexArray, p.indexArray)
                          , S = y.vertexLength
                          , I = p.layoutVertexArray
                          , A = p.collisionVertexArray
                          , R = g.anchorX
                          , N = g.anchorY;
                        this._addCollisionDebugVertex(I, A, f, R, N, new le(t,i)),
                        this._addCollisionDebugVertex(I, A, f, R, N, new le(a,i)),
                        this._addCollisionDebugVertex(I, A, f, R, N, new le(a,u)),
                        this._addCollisionDebugVertex(I, A, f, R, N, new le(t,u)),
                        y.vertexLength += 4;
                        const j = p.indexArray;
                        j.emplaceBack(S, S + 1),
                        j.emplaceBack(S + 1, S + 2),
                        j.emplaceBack(S + 2, S + 3),
                        j.emplaceBack(S + 3, S),
                        y.primitiveLength += 4
                    }
                    addDebugCollisionBoxes(t, i, a, u) {
                        for (let p = t; p < i; p++) {
                            const f = this.collisionBoxArray.get(p);
                            this.addCollisionDebugVertices(f.x1, f.y1, f.x2, f.y2, u ? this.textCollisionBox : this.iconCollisionBox, f.anchorPoint, a)
                        }
                    }
                    generateCollisionDebugBuffers() {
                        this.hasDebugData() && this.destroyDebugData(),
                        this.textCollisionBox = new Hp(xi,g_.members,bi),
                        this.iconCollisionBox = new Hp(xi,g_.members,bi);
                        for (let t = 0; t < this.symbolInstances.length; t++) {
                            const i = this.symbolInstances.get(t);
                            this.addDebugCollisionBoxes(i.textBoxStartIndex, i.textBoxEndIndex, i, !0),
                            this.addDebugCollisionBoxes(i.verticalTextBoxStartIndex, i.verticalTextBoxEndIndex, i, !0),
                            this.addDebugCollisionBoxes(i.iconBoxStartIndex, i.iconBoxEndIndex, i, !1),
                            this.addDebugCollisionBoxes(i.verticalIconBoxStartIndex, i.verticalIconBoxEndIndex, i, !1)
                        }
                    }
                    _deserializeCollisionBoxesForSymbol(t, i, a, u, p, f, g, y, S) {
                        const I = {};
                        for (let A = i; A < a; A++) {
                            const R = t.get(A);
                            I.textBox = {
                                x1: R.x1,
                                y1: R.y1,
                                x2: R.x2,
                                y2: R.y2,
                                anchorPointX: R.anchorPointX,
                                anchorPointY: R.anchorPointY
                            },
                            I.textFeatureIndex = R.featureIndex;
                            break
                        }
                        for (let A = u; A < p; A++) {
                            const R = t.get(A);
                            I.verticalTextBox = {
                                x1: R.x1,
                                y1: R.y1,
                                x2: R.x2,
                                y2: R.y2,
                                anchorPointX: R.anchorPointX,
                                anchorPointY: R.anchorPointY
                            },
                            I.verticalTextFeatureIndex = R.featureIndex;
                            break
                        }
                        for (let A = f; A < g; A++) {
                            const R = t.get(A);
                            I.iconBox = {
                                x1: R.x1,
                                y1: R.y1,
                                x2: R.x2,
                                y2: R.y2,
                                anchorPointX: R.anchorPointX,
                                anchorPointY: R.anchorPointY
                            },
                            I.iconFeatureIndex = R.featureIndex;
                            break
                        }
                        for (let A = y; A < S; A++) {
                            const R = t.get(A);
                            I.verticalIconBox = {
                                x1: R.x1,
                                y1: R.y1,
                                x2: R.x2,
                                y2: R.y2,
                                anchorPointX: R.anchorPointX,
                                anchorPointY: R.anchorPointY
                            },
                            I.verticalIconFeatureIndex = R.featureIndex;
                            break
                        }
                        return I
                    }
                    deserializeCollisionBoxes(t) {
                        this.collisionArrays = [];
                        for (let i = 0; i < this.symbolInstances.length; i++) {
                            const a = this.symbolInstances.get(i);
                            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, a.textBoxStartIndex, a.textBoxEndIndex, a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a.iconBoxStartIndex, a.iconBoxEndIndex, a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex))
                        }
                    }
                    hasTextData() {
                        return this.text.segments.get().length > 0
                    }
                    hasIconData() {
                        return this.icon.segments.get().length > 0
                    }
                    hasDebugData() {
                        return this.textCollisionBox && this.iconCollisionBox
                    }
                    hasTextCollisionBoxData() {
                        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
                    }
                    hasIconCollisionBoxData() {
                        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
                    }
                    addIndicesForPlacedSymbol(t, i) {
                        const a = t.placedSymbolArray.get(i)
                          , u = a.vertexStartIndex + 4 * a.numGlyphs;
                        for (let p = a.vertexStartIndex; p < u; p += 4)
                            t.indexArray.emplaceBack(p, p + 2, p + 1),
                            t.indexArray.emplaceBack(p + 1, p + 2, p + 3)
                    }
                    getSortedSymbolIndexes(t) {
                        if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0)
                            return this.symbolInstanceIndexes;
                        const i = Math.sin(t)
                          , a = Math.cos(t)
                          , u = []
                          , p = []
                          , f = [];
                        for (let g = 0; g < this.symbolInstances.length; ++g) {
                            f.push(g);
                            const y = this.symbolInstances.get(g);
                            u.push(0 | Math.round(i * y.anchorX + a * y.anchorY)),
                            p.push(y.featureIndex)
                        }
                        return f.sort( (g, y) => u[g] - u[y] || p[y] - p[g]),
                        f
                    }
                    addToSortKeyRanges(t, i) {
                        const a = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                        a && a.sortKey === i ? a.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
                            sortKey: i,
                            symbolInstanceStart: t,
                            symbolInstanceEnd: t + 1
                        })
                    }
                    sortFeatures(t) {
                        if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t),
                            this.sortedAngle = t,
                            this.text.indexArray.clear(),
                            this.icon.indexArray.clear(),
                            this.featureSortOrder = [];
                            for (const i of this.symbolInstanceIndexes) {
                                const a = this.symbolInstances.get(i);
                                this.featureSortOrder.push(a.featureIndex),
                                [a.rightJustifiedTextSymbolIndex, a.centerJustifiedTextSymbolIndex, a.leftJustifiedTextSymbolIndex].forEach( (u, p, f) => {
                                    u >= 0 && f.indexOf(u) === p && this.addIndicesForPlacedSymbol(this.text, u)
                                }
                                ),
                                a.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, a.verticalPlacedTextSymbolIndex),
                                a.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.placedIconSymbolIndex),
                                a.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.verticalPlacedIconSymbolIndex)
                            }
                            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray),
                            this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
                        }
                    }
                }
                let E_, z_;
                Wt("SymbolBucket", Ol, {
                    omit: ["layers", "collisionBoxArray", "features", "compareText"]
                }),
                Ol.MAX_GLYPHS = 65535,
                Ol.addDynamicAttributes = Up;
                var Wp = {
                    get paint() {
                        return z_ = z_ || new Ln({
                            "icon-opacity": new Rr(ye.paint_symbol["icon-opacity"]),
                            "icon-color": new Rr(ye.paint_symbol["icon-color"]),
                            "icon-halo-color": new Rr(ye.paint_symbol["icon-halo-color"]),
                            "icon-halo-width": new Rr(ye.paint_symbol["icon-halo-width"]),
                            "icon-halo-blur": new Rr(ye.paint_symbol["icon-halo-blur"]),
                            "icon-translate": new ar(ye.paint_symbol["icon-translate"]),
                            "icon-translate-anchor": new ar(ye.paint_symbol["icon-translate-anchor"]),
                            "text-opacity": new Rr(ye.paint_symbol["text-opacity"]),
                            "text-color": new Rr(ye.paint_symbol["text-color"],{
                                runtimeType: hi,
                                getOverride: n => n.textColor,
                                hasOverride: n => !!n.textColor
                            }),
                            "text-halo-color": new Rr(ye.paint_symbol["text-halo-color"]),
                            "text-halo-width": new Rr(ye.paint_symbol["text-halo-width"]),
                            "text-halo-blur": new Rr(ye.paint_symbol["text-halo-blur"]),
                            "text-translate": new ar(ye.paint_symbol["text-translate"]),
                            "text-translate-anchor": new ar(ye.paint_symbol["text-translate-anchor"])
                        })
                    },
                    get layout() {
                        return E_ = E_ || new Ln({
                            "symbol-placement": new ar(ye.layout_symbol["symbol-placement"]),
                            "symbol-spacing": new ar(ye.layout_symbol["symbol-spacing"]),
                            "symbol-avoid-edges": new ar(ye.layout_symbol["symbol-avoid-edges"]),
                            "symbol-sort-key": new Rr(ye.layout_symbol["symbol-sort-key"]),
                            "symbol-z-order": new ar(ye.layout_symbol["symbol-z-order"]),
                            "icon-allow-overlap": new ar(ye.layout_symbol["icon-allow-overlap"]),
                            "icon-overlap": new ar(ye.layout_symbol["icon-overlap"]),
                            "icon-ignore-placement": new ar(ye.layout_symbol["icon-ignore-placement"]),
                            "icon-optional": new ar(ye.layout_symbol["icon-optional"]),
                            "icon-rotation-alignment": new ar(ye.layout_symbol["icon-rotation-alignment"]),
                            "icon-size": new Rr(ye.layout_symbol["icon-size"]),
                            "icon-text-fit": new ar(ye.layout_symbol["icon-text-fit"]),
                            "icon-text-fit-padding": new ar(ye.layout_symbol["icon-text-fit-padding"]),
                            "icon-image": new Rr(ye.layout_symbol["icon-image"]),
                            "icon-rotate": new Rr(ye.layout_symbol["icon-rotate"]),
                            "icon-padding": new Rr(ye.layout_symbol["icon-padding"]),
                            "icon-keep-upright": new ar(ye.layout_symbol["icon-keep-upright"]),
                            "icon-offset": new Rr(ye.layout_symbol["icon-offset"]),
                            "icon-anchor": new Rr(ye.layout_symbol["icon-anchor"]),
                            "icon-pitch-alignment": new ar(ye.layout_symbol["icon-pitch-alignment"]),
                            "text-pitch-alignment": new ar(ye.layout_symbol["text-pitch-alignment"]),
                            "text-rotation-alignment": new ar(ye.layout_symbol["text-rotation-alignment"]),
                            "text-field": new Rr(ye.layout_symbol["text-field"]),
                            "text-font": new Rr(ye.layout_symbol["text-font"]),
                            "text-size": new Rr(ye.layout_symbol["text-size"]),
                            "text-max-width": new Rr(ye.layout_symbol["text-max-width"]),
                            "text-line-height": new ar(ye.layout_symbol["text-line-height"]),
                            "text-letter-spacing": new Rr(ye.layout_symbol["text-letter-spacing"]),
                            "text-justify": new Rr(ye.layout_symbol["text-justify"]),
                            "text-radial-offset": new Rr(ye.layout_symbol["text-radial-offset"]),
                            "text-variable-anchor": new ar(ye.layout_symbol["text-variable-anchor"]),
                            "text-variable-anchor-offset": new Rr(ye.layout_symbol["text-variable-anchor-offset"]),
                            "text-anchor": new Rr(ye.layout_symbol["text-anchor"]),
                            "text-max-angle": new ar(ye.layout_symbol["text-max-angle"]),
                            "text-writing-mode": new ar(ye.layout_symbol["text-writing-mode"]),
                            "text-rotate": new Rr(ye.layout_symbol["text-rotate"]),
                            "text-padding": new ar(ye.layout_symbol["text-padding"]),
                            "text-keep-upright": new ar(ye.layout_symbol["text-keep-upright"]),
                            "text-transform": new Rr(ye.layout_symbol["text-transform"]),
                            "text-offset": new Rr(ye.layout_symbol["text-offset"]),
                            "text-allow-overlap": new ar(ye.layout_symbol["text-allow-overlap"]),
                            "text-overlap": new ar(ye.layout_symbol["text-overlap"]),
                            "text-ignore-placement": new ar(ye.layout_symbol["text-ignore-placement"]),
                            "text-optional": new ar(ye.layout_symbol["text-optional"])
                        })
                    }
                };
                class L_ {
                    constructor(t) {
                        if (t.property.overrides === void 0)
                            throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
                        this.type = t.property.overrides ? t.property.overrides.runtimeType : ui,
                        this.defaultValue = t
                    }
                    evaluate(t) {
                        if (t.formattedSection) {
                            const i = this.defaultValue.property.overrides;
                            if (i && i.hasOverride(t.formattedSection))
                                return i.getOverride(t.formattedSection)
                        }
                        return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default
                    }
                    eachChild(t) {
                        this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        return null
                    }
                }
                Wt("FormatSectionOverride", L_, {
                    omit: ["defaultValue"]
                });
                class pd extends gn {
                    constructor(t) {
                        super(t, Wp)
                    }
                    recalculate(t, i) {
                        if (super.recalculate(t, i),
                        this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"),
                        this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"),
                        this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"),
                        this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")),
                        this.layout.get("symbol-placement") === "point") {
                            const a = this.layout.get("text-writing-mode");
                            if (a) {
                                const u = [];
                                for (const p of a)
                                    u.indexOf(p) < 0 && u.push(p);
                                this.layout._values["text-writing-mode"] = u
                            } else
                                this.layout._values["text-writing-mode"] = ["horizontal"]
                        }
                        this._setPaintOverrides()
                    }
                    getValueAndResolveTokens(t, i, a, u) {
                        const p = this.layout.get(t).evaluate(i, {}, a, u)
                          , f = this._unevaluatedLayout._values[t];
                        return f.isDataDriven() || ml(f.value) || !p ? p : function(g, y) {
                            return y.replace(/{([^{}]+)}/g, (S, I) => g && I in g ? String(g[I]) : "")
                        }(i.properties, p)
                    }
                    createBucket(t) {
                        return new Ol(t)
                    }
                    queryRadius() {
                        return 0
                    }
                    queryIntersectsFeature() {
                        throw new Error("Should take a different path in FeatureIndex")
                    }
                    _setPaintOverrides() {
                        for (const t of Wp.paint.overridableProperties) {
                            if (!pd.hasPaintOverride(this.layout, t))
                                continue;
                            const i = this.paint.get(t)
                              , a = new L_(i)
                              , u = new fl(a,i.property.specification);
                            let p = null;
                            p = i.value.kind === "constant" || i.value.kind === "source" ? new Co("source",u) : new gl("composite",u,i.value.zoomStops),
                            this.paint._values[t] = new Ia(i.property,p,i.parameters)
                        }
                    }
                    _handleOverridablePaintPropertyUpdate(t, i, a) {
                        return !(!this.layout || i.isDataDriven() || a.isDataDriven()) && pd.hasPaintOverride(this.layout, t)
                    }
                    static hasPaintOverride(t, i) {
                        const a = t.get("text-field")
                          , u = Wp.paint.properties[i];
                        let p = !1;
                        const f = g => {
                            for (const y of g)
                                if (u.overrides && u.overrides.hasOverride(y))
                                    return void (p = !0)
                        }
                        ;
                        if (a.value.kind === "constant" && a.value.value instanceof Gi)
                            f(a.value.value.sections);
                        else if (a.value.kind === "source") {
                            const g = S => {
                                p || (S instanceof kn && qr(S.value) === On ? f(S.value.sections) : S instanceof go ? f(S.sections) : S.eachChild(g))
                            }
                              , y = a.value;
                            y._styleExpression && g(y._styleExpression.expression)
                        }
                        return p
                    }
                }
                let D_;
                var ry = {
                    get paint() {
                        return D_ = D_ || new Ln({
                            "background-color": new ar(ye.paint_background["background-color"]),
                            "background-pattern": new Xc(ye.paint_background["background-pattern"]),
                            "background-opacity": new ar(ye.paint_background["background-opacity"])
                        })
                    }
                };
                class iy extends gn {
                    constructor(t) {
                        super(t, ry)
                    }
                }
                let R_;
                var ny = {
                    get paint() {
                        return R_ = R_ || new Ln({
                            "raster-opacity": new ar(ye.paint_raster["raster-opacity"]),
                            "raster-hue-rotate": new ar(ye.paint_raster["raster-hue-rotate"]),
                            "raster-brightness-min": new ar(ye.paint_raster["raster-brightness-min"]),
                            "raster-brightness-max": new ar(ye.paint_raster["raster-brightness-max"]),
                            "raster-saturation": new ar(ye.paint_raster["raster-saturation"]),
                            "raster-contrast": new ar(ye.paint_raster["raster-contrast"]),
                            "raster-resampling": new ar(ye.paint_raster["raster-resampling"]),
                            "raster-fade-duration": new ar(ye.paint_raster["raster-fade-duration"])
                        })
                    }
                };
                class ay extends gn {
                    constructor(t) {
                        super(t, ny)
                    }
                }
                class sy extends gn {
                    constructor(t) {
                        super(t, {}),
                        this.onAdd = i => {
                            this.implementation.onAdd && this.implementation.onAdd(i, i.painter.context.gl)
                        }
                        ,
                        this.onRemove = i => {
                            this.implementation.onRemove && this.implementation.onRemove(i, i.painter.context.gl)
                        }
                        ,
                        this.implementation = t
                    }
                    is3D() {
                        return this.implementation.renderingMode === "3d"
                    }
                    hasOffscreenPass() {
                        return this.implementation.prerender !== void 0
                    }
                    recalculate() {}
                    updateTransitions() {}
                    hasTransition() {
                        return !1
                    }
                    serialize() {
                        throw new Error("Custom layers cannot be serialized")
                    }
                }
                class oy {
                    constructor(t) {
                        this._methodToThrottle = t,
                        this._triggered = !1,
                        typeof MessageChannel < "u" && (this._channel = new MessageChannel,
                        this._channel.port2.onmessage = () => {
                            this._triggered = !1,
                            this._methodToThrottle()
                        }
                        )
                    }
                    trigger() {
                        this._triggered || (this._triggered = !0,
                        this._channel ? this._channel.port1.postMessage(!0) : setTimeout( () => {
                            this._triggered = !1,
                            this._methodToThrottle()
                        }
                        , 0))
                    }
                    remove() {
                        delete this._channel,
                        this._methodToThrottle = () => {}
                    }
                }
                const ly = {
                    once: !0
                }
                  , Xp = 63710088e-1;
                class to {
                    constructor(t, i) {
                        if (isNaN(t) || isNaN(i))
                            throw new Error(`Invalid LngLat object: (${t}, ${i})`);
                        if (this.lng = +t,
                        this.lat = +i,
                        this.lat > 90 || this.lat < -90)
                            throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
                    }
                    wrap() {
                        return new to(xt(this.lng, -180, 180),this.lat)
                    }
                    toArray() {
                        return [this.lng, this.lat]
                    }
                    toString() {
                        return `LngLat(${this.lng}, ${this.lat})`
                    }
                    distanceTo(t) {
                        const i = Math.PI / 180
                          , a = this.lat * i
                          , u = t.lat * i
                          , p = Math.sin(a) * Math.sin(u) + Math.cos(a) * Math.cos(u) * Math.cos((t.lng - this.lng) * i);
                        return Xp * Math.acos(Math.min(p, 1))
                    }
                    static convert(t) {
                        if (t instanceof to)
                            return t;
                        if (Array.isArray(t) && (t.length === 2 || t.length === 3))
                            return new to(Number(t[0]),Number(t[1]));
                        if (!Array.isArray(t) && typeof t == "object" && t !== null)
                            return new to(Number("lng"in t ? t.lng : t.lon),Number(t.lat));
                        throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
                    }
                }
                const B_ = 2 * Math.PI * Xp;
                function F_(n) {
                    return B_ * Math.cos(n * Math.PI / 180)
                }
                function O_(n) {
                    return (180 + n) / 360
                }
                function N_(n) {
                    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n * Math.PI / 360))) / 360
                }
                function j_(n, t) {
                    return n / F_(t)
                }
                function Kp(n) {
                    return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n) * Math.PI / 180)) - 90
                }
                function q_(n, t) {
                    return n * F_(Kp(t))
                }
                class _u {
                    constructor(t, i, a=0) {
                        this.x = +t,
                        this.y = +i,
                        this.z = +a
                    }
                    static fromLngLat(t, i=0) {
                        const a = to.convert(t);
                        return new _u(O_(a.lng),N_(a.lat),j_(i, a.lat))
                    }
                    toLngLat() {
                        return new to(360 * this.x - 180,Kp(this.y))
                    }
                    toAltitude() {
                        return q_(this.z, this.y)
                    }
                    meterInMercatorCoordinateUnits() {
                        return 1 / B_ * (t = Kp(this.y),
                        1 / Math.cos(t * Math.PI / 180));
                        var t
                    }
                }
                function V_(n, t, i) {
                    var a = 2 * Math.PI * 6378137 / 256 / Math.pow(2, i);
                    return [n * a - 2 * Math.PI * 6378137 / 2, t * a - 2 * Math.PI * 6378137 / 2]
                }
                class Yp {
                    constructor(t, i, a) {
                        if (!function(u, p, f) {
                            return !(u < 0 || u > 25 || f < 0 || f >= Math.pow(2, u) || p < 0 || p >= Math.pow(2, u))
                        }(t, i, a))
                            throw new Error(`x=${i}, y=${a}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `);
                        this.z = t,
                        this.x = i,
                        this.y = a,
                        this.key = Nl(0, t, t, i, a)
                    }
                    equals(t) {
                        return this.z === t.z && this.x === t.x && this.y === t.y
                    }
                    url(t, i, a) {
                        const u = (f = this.y,
                        g = this.z,
                        y = V_(256 * (p = this.x), 256 * (f = Math.pow(2, g) - f - 1), g),
                        S = V_(256 * (p + 1), 256 * (f + 1), g),
                        y[0] + "," + y[1] + "," + S[0] + "," + S[1]);
                        var p, f, g, y, S;
                        const I = function(A, R, N) {
                            let j, $ = "";
                            for (let J = A; J > 0; J--)
                                j = 1 << J - 1,
                                $ += (R & j ? 1 : 0) + (N & j ? 2 : 0);
                            return $
                        }(this.z, this.x, this.y);
                        return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(a === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, i > 1 ? "@2x" : "").replace(/{quadkey}/g, I).replace(/{bbox-epsg-3857}/g, u)
                    }
                    isChildOf(t) {
                        const i = this.z - t.z;
                        return i > 0 && t.x === this.x >> i && t.y === this.y >> i
                    }
                    getTilePoint(t) {
                        const i = Math.pow(2, this.z);
                        return new le((t.x * i - this.x) * We,(t.y * i - this.y) * We)
                    }
                    toString() {
                        return `${this.z}/${this.x}/${this.y}`
                    }
                }
                class Z_ {
                    constructor(t, i) {
                        this.wrap = t,
                        this.canonical = i,
                        this.key = Nl(t, i.z, i.z, i.x, i.y)
                    }
                }
                class ga {
                    constructor(t, i, a, u, p) {
                        if (this.terrainRttPosMatrix32f = null,
                        t < a)
                            throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${a}`);
                        this.overscaledZ = t,
                        this.wrap = i,
                        this.canonical = new Yp(a,+u,+p),
                        this.key = Nl(i, t, a, u, p)
                    }
                    clone() {
                        return new ga(this.overscaledZ,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)
                    }
                    equals(t) {
                        return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical)
                    }
                    scaledTo(t) {
                        if (t > this.overscaledZ)
                            throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
                        const i = this.canonical.z - t;
                        return t > this.canonical.z ? new ga(t,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y) : new ga(t,this.wrap,t,this.canonical.x >> i,this.canonical.y >> i)
                    }
                    calculateScaledKey(t, i) {
                        if (t > this.overscaledZ)
                            throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
                        const a = this.canonical.z - t;
                        return t > this.canonical.z ? Nl(this.wrap * +i, t, this.canonical.z, this.canonical.x, this.canonical.y) : Nl(this.wrap * +i, t, t, this.canonical.x >> a, this.canonical.y >> a)
                    }
                    isChildOf(t) {
                        if (t.wrap !== this.wrap)
                            return !1;
                        const i = this.canonical.z - t.canonical.z;
                        return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> i && t.canonical.y === this.canonical.y >> i
                    }
                    children(t) {
                        if (this.overscaledZ >= t)
                            return [new ga(this.overscaledZ + 1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];
                        const i = this.canonical.z + 1
                          , a = 2 * this.canonical.x
                          , u = 2 * this.canonical.y;
                        return [new ga(i,this.wrap,i,a,u), new ga(i,this.wrap,i,a + 1,u), new ga(i,this.wrap,i,a,u + 1), new ga(i,this.wrap,i,a + 1,u + 1)]
                    }
                    isLessThan(t) {
                        return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y))
                    }
                    wrapped() {
                        return new ga(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)
                    }
                    unwrapTo(t) {
                        return new ga(this.overscaledZ,t,this.canonical.z,this.canonical.x,this.canonical.y)
                    }
                    overscaleFactor() {
                        return Math.pow(2, this.overscaledZ - this.canonical.z)
                    }
                    toUnwrapped() {
                        return new Z_(this.wrap,this.canonical)
                    }
                    toString() {
                        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
                    }
                    getTilePoint(t) {
                        return this.canonical.getTilePoint(new _u(t.x - this.wrap,t.y))
                    }
                }
                function Nl(n, t, i, a, u) {
                    (n *= 2) < 0 && (n = -1 * n - 1);
                    const p = 1 << i;
                    return (p * p * n + p * u + a).toString(36) + i.toString(36) + t.toString(36)
                }
                Wt("CanonicalTileID", Yp),
                Wt("OverscaledTileID", ga, {
                    omit: ["terrainRttPosMatrix32f"]
                });
                class Uo {
                    constructor() {
                        this.minX = 1 / 0,
                        this.maxX = -1 / 0,
                        this.minY = 1 / 0,
                        this.maxY = -1 / 0
                    }
                    extend(t) {
                        return this.minX = Math.min(this.minX, t.x),
                        this.minY = Math.min(this.minY, t.y),
                        this.maxX = Math.max(this.maxX, t.x),
                        this.maxY = Math.max(this.maxY, t.y),
                        this
                    }
                    expandBy(t) {
                        return this.minX -= t,
                        this.minY -= t,
                        this.maxX += t,
                        this.maxY += t,
                        (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0,
                        this.maxX = -1 / 0,
                        this.minY = 1 / 0,
                        this.maxY = -1 / 0),
                        this
                    }
                    shrinkBy(t) {
                        return this.expandBy(-t)
                    }
                    map(t) {
                        const i = new Uo;
                        return i.extend(t(new le(this.minX,this.minY))),
                        i.extend(t(new le(this.maxX,this.minY))),
                        i.extend(t(new le(this.minX,this.maxY))),
                        i.extend(t(new le(this.maxX,this.maxY))),
                        i
                    }
                    static fromPoints(t) {
                        const i = new Uo;
                        for (const a of t)
                            i.extend(a);
                        return i
                    }
                    contains(t) {
                        return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY
                    }
                    empty() {
                        return this.minX > this.maxX
                    }
                    width() {
                        return this.maxX - this.minX
                    }
                    height() {
                        return this.maxY - this.minY
                    }
                    covers(t) {
                        return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY
                    }
                    intersects(t) {
                        return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY
                    }
                }
                class $_ {
                    constructor(t) {
                        this._stringToNumber = {},
                        this._numberToString = [];
                        for (let i = 0; i < t.length; i++) {
                            const a = t[i];
                            this._stringToNumber[a] = i,
                            this._numberToString[i] = a
                        }
                    }
                    encode(t) {
                        return this._stringToNumber[t]
                    }
                    decode(t) {
                        if (t >= this._numberToString.length)
                            throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
                        return this._numberToString[t]
                    }
                }
                class U_ {
                    constructor(t, i, a, u, p) {
                        this.type = "Feature",
                        this._vectorTileFeature = t,
                        t._z = i,
                        t._x = a,
                        t._y = u,
                        this.properties = t.properties,
                        this.id = p
                    }
                    get geometry() {
                        return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry),
                        this._geometry
                    }
                    set geometry(t) {
                        this._geometry = t
                    }
                    toJSON() {
                        const t = {
                            geometry: this.geometry
                        };
                        for (const i in this)
                            i !== "_geometry" && i !== "_vectorTileFeature" && (t[i] = this[i]);
                        return t
                    }
                }
                class G_ {
                    constructor(t, i) {
                        this.tileID = t,
                        this.x = t.canonical.x,
                        this.y = t.canonical.y,
                        this.z = t.canonical.z,
                        this.grid = new Xs(We,16,0),
                        this.grid3D = new Xs(We,16,0),
                        this.featureIndexArray = new Ye,
                        this.promoteId = i
                    }
                    insert(t, i, a, u, p, f) {
                        const g = this.featureIndexArray.length;
                        this.featureIndexArray.emplaceBack(a, u, p);
                        const y = f ? this.grid3D : this.grid;
                        for (let S = 0; S < i.length; S++) {
                            const I = i[S]
                              , A = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                            for (let R = 0; R < I.length; R++) {
                                const N = I[R];
                                A[0] = Math.min(A[0], N.x),
                                A[1] = Math.min(A[1], N.y),
                                A[2] = Math.max(A[2], N.x),
                                A[3] = Math.max(A[3], N.y)
                            }
                            A[0] < We && A[1] < We && A[2] >= 0 && A[3] >= 0 && y.insert(g, A[0], A[1], A[2], A[3])
                        }
                    }
                    loadVTLayers() {
                        return this.vtLayers || (this.vtLayers = new hu.VectorTile(new jp(this.rawTileData)).layers,
                        this.sourceLayerCoder = new $_(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])),
                        this.vtLayers
                    }
                    query(t, i, a, u) {
                        this.loadVTLayers();
                        const p = t.params
                          , f = We / t.tileSize / t.scale
                          , g = Ha(p.filter)
                          , y = t.queryGeometry
                          , S = t.queryPadding * f
                          , I = Uo.fromPoints(y)
                          , A = this.grid.query(I.minX - S, I.minY - S, I.maxX + S, I.maxY + S)
                          , R = Uo.fromPoints(t.cameraQueryGeometry).expandBy(S)
                          , N = this.grid3D.query(R.minX, R.minY, R.maxX, R.maxY, (J, se, Ae, _e) => function(O, Y, ve, Xe, bt) {
                            for (const ot of O)
                                if (Y <= ot.x && ve <= ot.y && Xe >= ot.x && bt >= ot.y)
                                    return !0;
                            const Qe = [new le(Y,ve), new le(Y,bt), new le(Xe,bt), new le(Xe,ve)];
                            if (O.length > 2) {
                                for (const ot of Qe)
                                    if (Ll(O, ot))
                                        return !0
                            }
                            for (let ot = 0; ot < O.length - 1; ot++)
                                if (Xv(O[ot], O[ot + 1], Qe))
                                    return !0;
                            return !1
                        }(t.cameraQueryGeometry, J - S, se - S, Ae + S, _e + S));
                        for (const J of N)
                            A.push(J);
                        A.sort(cy);
                        const j = {};
                        let $;
                        for (let J = 0; J < A.length; J++) {
                            const se = A[J];
                            if (se === $)
                                continue;
                            $ = se;
                            const Ae = this.featureIndexArray.get(se);
                            let _e = null;
                            this.loadMatchingFeature(j, Ae.bucketIndex, Ae.sourceLayerIndex, Ae.featureIndex, g, p.layers, p.availableImages, i, a, u, (O, Y, ve) => (_e || (_e = qo(O)),
                            Y.queryIntersectsFeature({
                                queryGeometry: y,
                                feature: O,
                                featureState: ve,
                                geometry: _e,
                                zoom: this.z,
                                transform: t.transform,
                                pixelsToTileUnits: f,
                                pixelPosMatrix: t.pixelPosMatrix,
                                unwrappedTileID: this.tileID.toUnwrapped(),
                                getElevation: t.getElevation
                            })))
                        }
                        return j
                    }
                    loadMatchingFeature(t, i, a, u, p, f, g, y, S, I, A) {
                        const R = this.bucketLayerIDs[i];
                        if (f && !R.some(J => f.has(J)))
                            return;
                        const N = this.sourceLayerCoder.decode(a)
                          , j = this.vtLayers[N].feature(u);
                        if (p.needGeometry) {
                            const J = Vo(j, !0);
                            if (!p.filter(new Ei(this.tileID.overscaledZ), J, this.tileID.canonical))
                                return
                        } else if (!p.filter(new Ei(this.tileID.overscaledZ), j))
                            return;
                        const $ = this.getId(j, N);
                        for (let J = 0; J < R.length; J++) {
                            const se = R[J];
                            if (f && !f.has(se))
                                continue;
                            const Ae = y[se];
                            if (!Ae)
                                continue;
                            let _e = {};
                            $ && I && (_e = I.getState(Ae.sourceLayer || "_geojsonTileLayer", $));
                            const O = Pt({}, S[se]);
                            O.paint = H_(O.paint, Ae.paint, j, _e, g),
                            O.layout = H_(O.layout, Ae.layout, j, _e, g);
                            const Y = !A || A(j, Ae, _e);
                            if (!Y)
                                continue;
                            const ve = new U_(j,this.z,this.x,this.y,$);
                            ve.layer = O;
                            let Xe = t[se];
                            Xe === void 0 && (Xe = t[se] = []),
                            Xe.push({
                                featureIndex: u,
                                feature: ve,
                                intersectionZ: Y
                            })
                        }
                    }
                    lookupSymbolFeatures(t, i, a, u, p, f, g, y) {
                        const S = {};
                        this.loadVTLayers();
                        const I = Ha(p);
                        for (const A of t)
                            this.loadMatchingFeature(S, a, u, A, I, f, g, y, i);
                        return S
                    }
                    hasLayer(t) {
                        for (const i of this.bucketLayerIDs)
                            for (const a of i)
                                if (t === a)
                                    return !0;
                        return !1
                    }
                    getId(t, i) {
                        var a;
                        let u = t.id;
                        return this.promoteId && (u = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[i]],
                        typeof u == "boolean" && (u = Number(u)),
                        u === void 0 && (!((a = t.properties) === null || a === void 0) && a.cluster) && this.promoteId && (u = Number(t.properties.cluster_id))),
                        u
                    }
                }
                function H_(n, t, i, a, u) {
                    return Lt(n, (p, f) => {
                        const g = t instanceof Al ? t.get(f) : null;
                        return g && g.evaluate ? g.evaluate(i, a, u) : g
                    }
                    )
                }
                function cy(n, t) {
                    return t - n
                }
                function W_(n, t, i, a, u) {
                    const p = [];
                    for (let f = 0; f < n.length; f++) {
                        const g = n[f];
                        let y;
                        for (let S = 0; S < g.length - 1; S++) {
                            let I = g[S]
                              , A = g[S + 1];
                            I.x < t && A.x < t || (I.x < t ? I = new le(t,I.y + (t - I.x) / (A.x - I.x) * (A.y - I.y))._round() : A.x < t && (A = new le(t,I.y + (t - I.x) / (A.x - I.x) * (A.y - I.y))._round()),
                            I.y < i && A.y < i || (I.y < i ? I = new le(I.x + (i - I.y) / (A.y - I.y) * (A.x - I.x),i)._round() : A.y < i && (A = new le(I.x + (i - I.y) / (A.y - I.y) * (A.x - I.x),i)._round()),
                            I.x >= a && A.x >= a || (I.x >= a ? I = new le(a,I.y + (a - I.x) / (A.x - I.x) * (A.y - I.y))._round() : A.x >= a && (A = new le(a,I.y + (a - I.x) / (A.x - I.x) * (A.y - I.y))._round()),
                            I.y >= u && A.y >= u || (I.y >= u ? I = new le(I.x + (u - I.y) / (A.y - I.y) * (A.x - I.x),u)._round() : A.y >= u && (A = new le(I.x + (u - I.y) / (A.y - I.y) * (A.x - I.x),u)._round()),
                            y && I.equals(y[y.length - 1]) || (y = [I],
                            p.push(y)),
                            y.push(A)))))
                        }
                    }
                    return p
                }
                Wt("FeatureIndex", G_, {
                    omit: ["rawTileData", "sourceLayerCoder"]
                });
                class ro extends le {
                    constructor(t, i, a, u) {
                        super(t, i),
                        this.angle = a,
                        u !== void 0 && (this.segment = u)
                    }
                    clone() {
                        return new ro(this.x,this.y,this.angle,this.segment)
                    }
                }
                function X_(n, t, i, a, u) {
                    if (t.segment === void 0 || i === 0)
                        return !0;
                    let p = t
                      , f = t.segment + 1
                      , g = 0;
                    for (; g > -i / 2; ) {
                        if (f--,
                        f < 0)
                            return !1;
                        g -= n[f].dist(p),
                        p = n[f]
                    }
                    g += n[f].dist(n[f + 1]),
                    f++;
                    const y = [];
                    let S = 0;
                    for (; g < i / 2; ) {
                        const I = n[f]
                          , A = n[f + 1];
                        if (!A)
                            return !1;
                        let R = n[f - 1].angleTo(I) - I.angleTo(A);
                        for (R = Math.abs((R + 3 * Math.PI) % (2 * Math.PI) - Math.PI),
                        y.push({
                            distance: g,
                            angleDelta: R
                        }),
                        S += R; g - y[0].distance > a; )
                            S -= y.shift().angleDelta;
                        if (S > u)
                            return !1;
                        f++,
                        g += I.dist(A)
                    }
                    return !0
                }
                function K_(n) {
                    let t = 0;
                    for (let i = 0; i < n.length - 1; i++)
                        t += n[i].dist(n[i + 1]);
                    return t
                }
                function Y_(n, t, i) {
                    return n ? .6 * t * i : 0
                }
                function J_(n, t) {
                    return Math.max(n ? n.right - n.left : 0, t ? t.right - t.left : 0)
                }
                function uy(n, t, i, a, u, p) {
                    const f = Y_(i, u, p)
                      , g = J_(i, a) * p;
                    let y = 0;
                    const S = K_(n) / 2;
                    for (let I = 0; I < n.length - 1; I++) {
                        const A = n[I]
                          , R = n[I + 1]
                          , N = A.dist(R);
                        if (y + N > S) {
                            const j = (S - y) / N
                              , $ = ta.number(A.x, R.x, j)
                              , J = ta.number(A.y, R.y, j)
                              , se = new ro($,J,R.angleTo(A),I);
                            return se._round(),
                            !f || X_(n, se, g, f, t) ? se : void 0
                        }
                        y += N
                    }
                }
                function hy(n, t, i, a, u, p, f, g, y) {
                    const S = Y_(a, p, f)
                      , I = J_(a, u)
                      , A = I * f
                      , R = n[0].x === 0 || n[0].x === y || n[0].y === 0 || n[0].y === y;
                    return t - A < t / 4 && (t = A + t / 4),
                    Q_(n, R ? t / 2 * g % t : (I / 2 + 2 * p) * f * g % t, t, S, i, A, R, !1, y)
                }
                function Q_(n, t, i, a, u, p, f, g, y) {
                    const S = p / 2
                      , I = K_(n);
                    let A = 0
                      , R = t - i
                      , N = [];
                    for (let j = 0; j < n.length - 1; j++) {
                        const $ = n[j]
                          , J = n[j + 1]
                          , se = $.dist(J)
                          , Ae = J.angleTo($);
                        for (; R + i < A + se; ) {
                            R += i;
                            const _e = (R - A) / se
                              , O = ta.number($.x, J.x, _e)
                              , Y = ta.number($.y, J.y, _e);
                            if (O >= 0 && O < y && Y >= 0 && Y < y && R - S >= 0 && R + S <= I) {
                                const ve = new ro(O,Y,Ae,j);
                                ve._round(),
                                a && !X_(n, ve, p, a, u) || N.push(ve)
                            }
                        }
                        A += se
                    }
                    return g || N.length || f || (N = Q_(n, A / 2, i, a, u, p, f, !0, y)),
                    N
                }
                function eg(n, t, i, a) {
                    const u = []
                      , p = n.image
                      , f = p.pixelRatio
                      , g = p.paddedRect.w - 2
                      , y = p.paddedRect.h - 2;
                    let S = {
                        x1: n.left,
                        y1: n.top,
                        x2: n.right,
                        y2: n.bottom
                    };
                    const I = p.stretchX || [[0, g]]
                      , A = p.stretchY || [[0, y]]
                      , R = (pt, ir) => pt + ir[1] - ir[0]
                      , N = I.reduce(R, 0)
                      , j = A.reduce(R, 0)
                      , $ = g - N
                      , J = y - j;
                    let se = 0
                      , Ae = N
                      , _e = 0
                      , O = j
                      , Y = 0
                      , ve = $
                      , Xe = 0
                      , bt = J;
                    if (p.content && a) {
                        const pt = p.content
                          , ir = pt[2] - pt[0]
                          , Er = pt[3] - pt[1];
                        (p.textFitWidth || p.textFitHeight) && (S = M_(n)),
                        se = fd(I, 0, pt[0]),
                        _e = fd(A, 0, pt[1]),
                        Ae = fd(I, pt[0], pt[2]),
                        O = fd(A, pt[1], pt[3]),
                        Y = pt[0] - se,
                        Xe = pt[1] - _e,
                        ve = ir - Ae,
                        bt = Er - O
                    }
                    const Qe = S.x1
                      , ot = S.y1
                      , Et = S.x2 - Qe
                      , Ct = S.y2 - ot
                      , Dt = (pt, ir, Er, Cr) => {
                        const ur = md(pt.stretch - se, Ae, Et, Qe)
                          , ii = _d(pt.fixed - Y, ve, pt.stretch, N)
                          , Vi = md(ir.stretch - _e, O, Ct, ot)
                          , rn = _d(ir.fixed - Xe, bt, ir.stretch, j)
                          , In = md(Er.stretch - se, Ae, Et, Qe)
                          , va = _d(Er.fixed - Y, ve, Er.stretch, N)
                          , ia = md(Cr.stretch - _e, O, Ct, ot)
                          , bn = _d(Cr.fixed - Xe, bt, Cr.stretch, j)
                          , Oi = new le(ur,Vi)
                          , hn = new le(In,Vi)
                          , wn = new le(In,ia)
                          , Tn = new le(ur,ia)
                          , Gn = new le(ii / f,rn / f)
                          , ya = new le(va / f,bn / f)
                          , dn = t * Math.PI / 180;
                        if (dn) {
                            const pn = Math.sin(dn)
                              , fn = Math.cos(dn)
                              , Ji = [fn, -pn, pn, fn];
                            Oi._matMult(Ji),
                            hn._matMult(Ji),
                            Tn._matMult(Ji),
                            wn._matMult(Ji)
                        }
                        const na = pt.stretch + pt.fixed
                          , nn = ir.stretch + ir.fixed;
                        return {
                            tl: Oi,
                            tr: hn,
                            bl: Tn,
                            br: wn,
                            tex: {
                                x: p.paddedRect.x + 1 + na,
                                y: p.paddedRect.y + 1 + nn,
                                w: Er.stretch + Er.fixed - na,
                                h: Cr.stretch + Cr.fixed - nn
                            },
                            writingMode: void 0,
                            glyphOffset: [0, 0],
                            sectionIndex: 0,
                            pixelOffsetTL: Gn,
                            pixelOffsetBR: ya,
                            minFontScaleX: ve / f / Et,
                            minFontScaleY: bt / f / Ct,
                            isSDF: i
                        }
                    }
                    ;
                    if (a && (p.stretchX || p.stretchY)) {
                        const pt = tg(I, $, N)
                          , ir = tg(A, J, j);
                        for (let Er = 0; Er < pt.length - 1; Er++) {
                            const Cr = pt[Er]
                              , ur = pt[Er + 1];
                            for (let ii = 0; ii < ir.length - 1; ii++)
                                u.push(Dt(Cr, ir[ii], ur, ir[ii + 1]))
                        }
                    } else
                        u.push(Dt({
                            fixed: 0,
                            stretch: -1
                        }, {
                            fixed: 0,
                            stretch: -1
                        }, {
                            fixed: 0,
                            stretch: g + 1
                        }, {
                            fixed: 0,
                            stretch: y + 1
                        }));
                    return u
                }
                function fd(n, t, i) {
                    let a = 0;
                    for (const u of n)
                        a += Math.max(t, Math.min(i, u[1])) - Math.max(t, Math.min(i, u[0]));
                    return a
                }
                function tg(n, t, i) {
                    const a = [{
                        fixed: -1,
                        stretch: 0
                    }];
                    for (const [u,p] of n) {
                        const f = a[a.length - 1];
                        a.push({
                            fixed: u - f.stretch,
                            stretch: f.stretch
                        }),
                        a.push({
                            fixed: u - f.stretch,
                            stretch: f.stretch + (p - u)
                        })
                    }
                    return a.push({
                        fixed: t + 1,
                        stretch: i
                    }),
                    a
                }
                function md(n, t, i, a) {
                    return n / t * i + a
                }
                function _d(n, t, i, a) {
                    return n - t * i / a
                }
                Wt("Anchor", ro);
                class gd {
                    constructor(t, i, a, u, p, f, g, y, S, I) {
                        var A;
                        if (this.boxStartIndex = t.length,
                        S) {
                            let R = f.top
                              , N = f.bottom;
                            const j = f.collisionPadding;
                            j && (R -= j[1],
                            N += j[3]);
                            let $ = N - R;
                            $ > 0 && ($ = Math.max(10, $),
                            this.circleDiameter = $)
                        } else {
                            const R = !((A = f.image) === null || A === void 0) && A.content && (f.image.textFitWidth || f.image.textFitHeight) ? M_(f) : {
                                x1: f.left,
                                y1: f.top,
                                x2: f.right,
                                y2: f.bottom
                            };
                            R.y1 = R.y1 * g - y[0],
                            R.y2 = R.y2 * g + y[2],
                            R.x1 = R.x1 * g - y[3],
                            R.x2 = R.x2 * g + y[1];
                            const N = f.collisionPadding;
                            if (N && (R.x1 -= N[0] * g,
                            R.y1 -= N[1] * g,
                            R.x2 += N[2] * g,
                            R.y2 += N[3] * g),
                            I) {
                                const j = new le(R.x1,R.y1)
                                  , $ = new le(R.x2,R.y1)
                                  , J = new le(R.x1,R.y2)
                                  , se = new le(R.x2,R.y2)
                                  , Ae = I * Math.PI / 180;
                                j._rotate(Ae),
                                $._rotate(Ae),
                                J._rotate(Ae),
                                se._rotate(Ae),
                                R.x1 = Math.min(j.x, $.x, J.x, se.x),
                                R.x2 = Math.max(j.x, $.x, J.x, se.x),
                                R.y1 = Math.min(j.y, $.y, J.y, se.y),
                                R.y2 = Math.max(j.y, $.y, J.y, se.y)
                            }
                            t.emplaceBack(i.x, i.y, R.x1, R.y1, R.x2, R.y2, a, u, p)
                        }
                        this.boxEndIndex = t.length
                    }
                }
                class dy {
                    constructor(t=[], i= (a, u) => a < u ? -1 : a > u ? 1 : 0) {
                        if (this.data = t,
                        this.length = this.data.length,
                        this.compare = i,
                        this.length > 0)
                            for (let a = (this.length >> 1) - 1; a >= 0; a--)
                                this._down(a)
                    }
                    push(t) {
                        this.data.push(t),
                        this._up(this.length++)
                    }
                    pop() {
                        if (this.length === 0)
                            return;
                        const t = this.data[0]
                          , i = this.data.pop();
                        return --this.length > 0 && (this.data[0] = i,
                        this._down(0)),
                        t
                    }
                    peek() {
                        return this.data[0]
                    }
                    _up(t) {
                        const {data: i, compare: a} = this
                          , u = i[t];
                        for (; t > 0; ) {
                            const p = t - 1 >> 1
                              , f = i[p];
                            if (a(u, f) >= 0)
                                break;
                            i[t] = f,
                            t = p
                        }
                        i[t] = u
                    }
                    _down(t) {
                        const {data: i, compare: a} = this
                          , u = this.length >> 1
                          , p = i[t];
                        for (; t < u; ) {
                            let f = 1 + (t << 1);
                            const g = f + 1;
                            if (g < this.length && a(i[g], i[f]) < 0 && (f = g),
                            a(i[f], p) >= 0)
                                break;
                            i[t] = i[f],
                            t = f
                        }
                        i[t] = p
                    }
                }
                function py(n, t=1, i=!1) {
                    const a = Uo.fromPoints(n[0])
                      , u = Math.min(a.width(), a.height());
                    let p = u / 2;
                    const f = new dy([],fy)
                      , {minX: g, minY: y, maxX: S, maxY: I} = a;
                    if (u === 0)
                        return new le(g,y);
                    for (let N = g; N < S; N += u)
                        for (let j = y; j < I; j += u)
                            f.push(new jl(N + p,j + p,p,n));
                    let A = function(N) {
                        let j = 0
                          , $ = 0
                          , J = 0;
                        const se = N[0];
                        for (let Ae = 0, _e = se.length, O = _e - 1; Ae < _e; O = Ae++) {
                            const Y = se[Ae]
                              , ve = se[O]
                              , Xe = Y.x * ve.y - ve.x * Y.y;
                            $ += (Y.x + ve.x) * Xe,
                            J += (Y.y + ve.y) * Xe,
                            j += 3 * Xe
                        }
                        return new jl($ / j,J / j,0,N)
                    }(n)
                      , R = f.length;
                    for (; f.length; ) {
                        const N = f.pop();
                        (N.d > A.d || !A.d) && (A = N,
                        i && console.log("found best %d after %d probes", Math.round(1e4 * N.d) / 1e4, R)),
                        N.max - A.d <= t || (p = N.h / 2,
                        f.push(new jl(N.p.x - p,N.p.y - p,p,n)),
                        f.push(new jl(N.p.x + p,N.p.y - p,p,n)),
                        f.push(new jl(N.p.x - p,N.p.y + p,p,n)),
                        f.push(new jl(N.p.x + p,N.p.y + p,p,n)),
                        R += 4)
                    }
                    return i && (console.log(`num probes: ${R}`),
                    console.log(`best distance: ${A.d}`)),
                    A.p
                }
                function fy(n, t) {
                    return t.max - n.max
                }
                function jl(n, t, i, a) {
                    this.p = new le(n,t),
                    this.h = i,
                    this.d = function(u, p) {
                        let f = !1
                          , g = 1 / 0;
                        for (let y = 0; y < p.length; y++) {
                            const S = p[y];
                            for (let I = 0, A = S.length, R = A - 1; I < A; R = I++) {
                                const N = S[I]
                                  , j = S[R];
                                N.y > u.y != j.y > u.y && u.x < (j.x - N.x) * (u.y - N.y) / (j.y - N.y) + N.x && (f = !f),
                                g = Math.min(g, Dm(u, N, j))
                            }
                        }
                        return (f ? 1 : -1) * Math.sqrt(g)
                    }(this.p, a),
                    this.max = this.d + this.h * Math.SQRT2
                }
                var Pn;
                C.aD = void 0,
                (Pn = C.aD || (C.aD = {}))[Pn.center = 1] = "center",
                Pn[Pn.left = 2] = "left",
                Pn[Pn.right = 3] = "right",
                Pn[Pn.top = 4] = "top",
                Pn[Pn.bottom = 5] = "bottom",
                Pn[Pn["top-left"] = 6] = "top-left",
                Pn[Pn["top-right"] = 7] = "top-right",
                Pn[Pn["bottom-left"] = 8] = "bottom-left",
                Pn[Pn["bottom-right"] = 9] = "bottom-right";
                const Jp = Number.POSITIVE_INFINITY;
                function rg(n, t) {
                    return t[1] !== Jp ? function(i, a, u) {
                        let p = 0
                          , f = 0;
                        switch (a = Math.abs(a),
                        u = Math.abs(u),
                        i) {
                        case "top-right":
                        case "top-left":
                        case "top":
                            f = u - 7;
                            break;
                        case "bottom-right":
                        case "bottom-left":
                        case "bottom":
                            f = 7 - u
                        }
                        switch (i) {
                        case "top-right":
                        case "bottom-right":
                        case "right":
                            p = -a;
                            break;
                        case "top-left":
                        case "bottom-left":
                        case "left":
                            p = a
                        }
                        return [p, f]
                    }(n, t[0], t[1]) : function(i, a) {
                        let u = 0
                          , p = 0;
                        a < 0 && (a = 0);
                        const f = a / Math.SQRT2;
                        switch (i) {
                        case "top-right":
                        case "top-left":
                            p = f - 7;
                            break;
                        case "bottom-right":
                        case "bottom-left":
                            p = 7 - f;
                            break;
                        case "bottom":
                            p = 7 - a;
                            break;
                        case "top":
                            p = a - 7
                        }
                        switch (i) {
                        case "top-right":
                        case "bottom-right":
                            u = -f;
                            break;
                        case "top-left":
                        case "bottom-left":
                            u = f;
                            break;
                        case "left":
                            u = a;
                            break;
                        case "right":
                            u = -a
                        }
                        return [u, p]
                    }(n, t[0])
                }
                function ig(n, t, i) {
                    var a;
                    const u = n.layout
                      , p = (a = u.get("text-variable-anchor-offset")) === null || a === void 0 ? void 0 : a.evaluate(t, {}, i);
                    if (p) {
                        const g = p.values
                          , y = [];
                        for (let S = 0; S < g.length; S += 2) {
                            const I = y[S] = g[S]
                              , A = g[S + 1].map(R => R * un);
                            I.startsWith("top") ? A[1] -= 7 : I.startsWith("bottom") && (A[1] += 7),
                            y[S + 1] = A
                        }
                        return new ai(y)
                    }
                    const f = u.get("text-variable-anchor");
                    if (f) {
                        let g;
                        g = n._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [u.get("text-radial-offset").evaluate(t, {}, i) * un, Jp] : u.get("text-offset").evaluate(t, {}, i).map(S => S * un);
                        const y = [];
                        for (const S of f)
                            y.push(S, rg(S, g));
                        return new ai(y)
                    }
                    return null
                }
                function Qp(n) {
                    switch (n) {
                    case "right":
                    case "top-right":
                    case "bottom-right":
                        return "right";
                    case "left":
                    case "top-left":
                    case "bottom-left":
                        return "left"
                    }
                    return "center"
                }
                function my(n, t, i, a, u, p, f, g, y, S, I, A) {
                    let R = p.textMaxSize.evaluate(t, {});
                    R === void 0 && (R = f);
                    const N = n.layers[0].layout
                      , j = N.get("icon-offset").evaluate(t, {}, I)
                      , $ = ag(i.horizontal)
                      , J = f / 24
                      , se = n.tilePixelRatio * J
                      , Ae = n.tilePixelRatio * R / 24
                      , _e = n.tilePixelRatio * g
                      , O = n.tilePixelRatio * N.get("symbol-spacing")
                      , Y = N.get("text-padding") * n.tilePixelRatio
                      , ve = function(Er, Cr, ur, ii=1) {
                        const Vi = Er.get("icon-padding").evaluate(Cr, {}, ur)
                          , rn = Vi && Vi.values;
                        return [rn[0] * ii, rn[1] * ii, rn[2] * ii, rn[3] * ii]
                    }(N, t, I, n.tilePixelRatio)
                      , Xe = N.get("text-max-angle") / 180 * Math.PI
                      , bt = N.get("text-rotation-alignment") !== "viewport" && N.get("symbol-placement") !== "point"
                      , Qe = N.get("icon-rotation-alignment") === "map" && N.get("symbol-placement") !== "point"
                      , ot = N.get("symbol-placement")
                      , Et = O / 2
                      , Ct = N.get("icon-text-fit");
                    let Dt;
                    a && Ct !== "none" && (n.allowVerticalPlacement && i.vertical && (Dt = A_(a, i.vertical, Ct, N.get("icon-text-fit-padding"), j, J)),
                    $ && (a = A_(a, $, Ct, N.get("icon-text-fit-padding"), j, J)));
                    const pt = I ? A.line.getGranularityForZoomLevel(I.z) : 1
                      , ir = (Er, Cr) => {
                        Cr.x < 0 || Cr.x >= We || Cr.y < 0 || Cr.y >= We || function(ur, ii, Vi, rn, In, va, ia, bn, Oi, hn, wn, Tn, Gn, ya, dn, na, nn, pn, fn, Ji, Ai, Oa, ql, Na, vy) {
                            const Vl = ur.addToLineVertexArray(ii, Vi);
                            let Go, Zl, $l, Ul, cg = 0, ug = 0, hg = 0, dg = 0, lf = -1, cf = -1;
                            const ys = {};
                            let pg = Un("");
                            if (ur.allowVerticalPlacement && rn.vertical) {
                                const Rn = bn.layout.get("text-rotate").evaluate(Ai, {}, Na) + 90;
                                $l = new gd(Oi,ii,hn,wn,Tn,rn.vertical,Gn,ya,dn,Rn),
                                ia && (Ul = new gd(Oi,ii,hn,wn,Tn,ia,nn,pn,dn,Rn))
                            }
                            if (In) {
                                const Rn = bn.layout.get("icon-rotate").evaluate(Ai, {})
                                  , xa = bn.layout.get("icon-text-fit") !== "none"
                                  , Ho = eg(In, Rn, ql, xa)
                                  , qa = ia ? eg(ia, Rn, ql, xa) : void 0;
                                Zl = new gd(Oi,ii,hn,wn,Tn,In,nn,pn,!1,Rn),
                                cg = 4 * Ho.length;
                                const Wo = ur.iconSizeData;
                                let is = null;
                                Wo.kind === "source" ? (is = [vs * bn.layout.get("icon-size").evaluate(Ai, {})],
                                is[0] > eo && Qt(`${ur.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : Wo.kind === "composite" && (is = [vs * Oa.compositeIconSizes[0].evaluate(Ai, {}, Na), vs * Oa.compositeIconSizes[1].evaluate(Ai, {}, Na)],
                                (is[0] > eo || is[1] > eo) && Qt(`${ur.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)),
                                ur.addSymbols(ur.icon, Ho, is, Ji, fn, Ai, C.an.none, ii, Vl.lineStartIndex, Vl.lineLength, -1, Na),
                                lf = ur.icon.placedSymbolArray.length - 1,
                                qa && (ug = 4 * qa.length,
                                ur.addSymbols(ur.icon, qa, is, Ji, fn, Ai, C.an.vertical, ii, Vl.lineStartIndex, Vl.lineLength, -1, Na),
                                cf = ur.icon.placedSymbolArray.length - 1)
                            }
                            const fg = Object.keys(rn.horizontal);
                            for (const Rn of fg) {
                                const xa = rn.horizontal[Rn];
                                if (!Go) {
                                    pg = Un(xa.text);
                                    const qa = bn.layout.get("text-rotate").evaluate(Ai, {}, Na);
                                    Go = new gd(Oi,ii,hn,wn,Tn,xa,Gn,ya,dn,qa)
                                }
                                const Ho = xa.positionedLines.length === 1;
                                if (hg += ng(ur, ii, xa, va, bn, dn, Ai, na, Vl, rn.vertical ? C.an.horizontal : C.an.horizontalOnly, Ho ? fg : [Rn], ys, lf, Oa, Na),
                                Ho)
                                    break
                            }
                            rn.vertical && (dg += ng(ur, ii, rn.vertical, va, bn, dn, Ai, na, Vl, C.an.vertical, ["vertical"], ys, cf, Oa, Na));
                            const yy = Go ? Go.boxStartIndex : ur.collisionBoxArray.length
                              , xy = Go ? Go.boxEndIndex : ur.collisionBoxArray.length
                              , by = $l ? $l.boxStartIndex : ur.collisionBoxArray.length
                              , wy = $l ? $l.boxEndIndex : ur.collisionBoxArray.length
                              , Ty = Zl ? Zl.boxStartIndex : ur.collisionBoxArray.length
                              , Cy = Zl ? Zl.boxEndIndex : ur.collisionBoxArray.length
                              , Sy = Ul ? Ul.boxStartIndex : ur.collisionBoxArray.length
                              , Py = Ul ? Ul.boxEndIndex : ur.collisionBoxArray.length;
                            let ja = -1;
                            const yd = (Rn, xa) => Rn && Rn.circleDiameter ? Math.max(Rn.circleDiameter, xa) : xa;
                            ja = yd(Go, ja),
                            ja = yd($l, ja),
                            ja = yd(Zl, ja),
                            ja = yd(Ul, ja);
                            const mg = ja > -1 ? 1 : 0;
                            mg && (ja *= vy / un),
                            ur.glyphOffsetArray.length >= Ol.MAX_GLYPHS && Qt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),
                            Ai.sortKey !== void 0 && ur.addToSortKeyRanges(ur.symbolInstances.length, Ai.sortKey);
                            const Iy = ig(bn, Ai, Na)
                              , [My,Ay] = function(Rn, xa) {
                                const Ho = Rn.length
                                  , qa = xa == null ? void 0 : xa.values;
                                if ((qa == null ? void 0 : qa.length) > 0)
                                    for (let Wo = 0; Wo < qa.length; Wo += 2) {
                                        const is = qa[Wo + 1];
                                        Rn.emplaceBack(C.aD[qa[Wo]], is[0], is[1])
                                    }
                                return [Ho, Rn.length]
                            }(ur.textAnchorOffsets, Iy);
                            ur.symbolInstances.emplaceBack(ii.x, ii.y, ys.right >= 0 ? ys.right : -1, ys.center >= 0 ? ys.center : -1, ys.left >= 0 ? ys.left : -1, ys.vertical || -1, lf, cf, pg, yy, xy, by, wy, Ty, Cy, Sy, Py, hn, hg, dg, cg, ug, mg, 0, Gn, ja, My, Ay)
                        }(n, Cr, Er, i, a, u, Dt, n.layers[0], n.collisionBoxArray, t.index, t.sourceLayerIndex, n.index, se, [Y, Y, Y, Y], bt, y, _e, ve, Qe, j, t, p, S, I, f)
                    }
                    ;
                    if (ot === "line")
                        for (const Er of W_(t.geometry, 0, 0, We, We)) {
                            const Cr = $o(Er, pt)
                              , ur = hy(Cr, O, Xe, i.vertical || $, a, 24, Ae, n.overscaling, We);
                            for (const ii of ur)
                                $ && _y(n, $.text, Et, ii) || ir(Cr, ii)
                        }
                    else if (ot === "line-center") {
                        for (const Er of t.geometry)
                            if (Er.length > 1) {
                                const Cr = $o(Er, pt)
                                  , ur = uy(Cr, Xe, i.vertical || $, a, 24, Ae);
                                ur && ir(Cr, ur)
                            }
                    } else if (t.type === "Polygon")
                        for (const Er of ol(t.geometry, 0)) {
                            const Cr = py(Er, 16);
                            ir($o(Er[0], pt, !0), new ro(Cr.x,Cr.y,0))
                        }
                    else if (t.type === "LineString")
                        for (const Er of t.geometry) {
                            const Cr = $o(Er, pt);
                            ir(Cr, new ro(Cr[0].x,Cr[0].y,0))
                        }
                    else if (t.type === "Point")
                        for (const Er of t.geometry)
                            for (const Cr of Er)
                                ir([Cr], new ro(Cr.x,Cr.y,0))
                }
                function ng(n, t, i, a, u, p, f, g, y, S, I, A, R, N, j) {
                    const $ = function(Ae, _e, O, Y, ve, Xe, bt, Qe) {
                        const ot = Y.layout.get("text-rotate").evaluate(Xe, {}) * Math.PI / 180
                          , Et = [];
                        for (const Ct of _e.positionedLines)
                            for (const Dt of Ct.positionedGlyphs) {
                                if (!Dt.rect)
                                    continue;
                                const pt = Dt.rect || {};
                                let ir = 4
                                  , Er = !0
                                  , Cr = 1
                                  , ur = 0;
                                const ii = (ve || Qe) && Dt.vertical
                                  , Vi = Dt.metrics.advance * Dt.scale / 2;
                                if (Qe && _e.verticalizable && (ur = Ct.lineOffset / 2 - (Dt.imageName ? -(un - Dt.metrics.width * Dt.scale) / 2 : (Dt.scale - 1) * un)),
                                Dt.imageName) {
                                    const pn = bt[Dt.imageName];
                                    Er = pn.sdf,
                                    Cr = pn.pixelRatio,
                                    ir = 1 / Cr
                                }
                                const rn = ve ? [Dt.x + Vi, Dt.y] : [0, 0];
                                let In = ve ? [0, 0] : [Dt.x + Vi + O[0], Dt.y + O[1] - ur]
                                  , va = [0, 0];
                                ii && (va = In,
                                In = [0, 0]);
                                const ia = Dt.metrics.isDoubleResolution ? 2 : 1
                                  , bn = (Dt.metrics.left - ir) * Dt.scale - Vi + In[0]
                                  , Oi = (-Dt.metrics.top - ir) * Dt.scale + In[1]
                                  , hn = bn + pt.w / ia * Dt.scale / Cr
                                  , wn = Oi + pt.h / ia * Dt.scale / Cr
                                  , Tn = new le(bn,Oi)
                                  , Gn = new le(hn,Oi)
                                  , ya = new le(bn,wn)
                                  , dn = new le(hn,wn);
                                if (ii) {
                                    const pn = new le(-Vi,Vi - -17)
                                      , fn = -Math.PI / 2
                                      , Ji = 12 - Vi
                                      , Ai = new le(22 - Ji,-(Dt.imageName ? Ji : 0))
                                      , Oa = new le(...va);
                                    Tn._rotateAround(fn, pn)._add(Ai)._add(Oa),
                                    Gn._rotateAround(fn, pn)._add(Ai)._add(Oa),
                                    ya._rotateAround(fn, pn)._add(Ai)._add(Oa),
                                    dn._rotateAround(fn, pn)._add(Ai)._add(Oa)
                                }
                                if (ot) {
                                    const pn = Math.sin(ot)
                                      , fn = Math.cos(ot)
                                      , Ji = [fn, -pn, pn, fn];
                                    Tn._matMult(Ji),
                                    Gn._matMult(Ji),
                                    ya._matMult(Ji),
                                    dn._matMult(Ji)
                                }
                                const na = new le(0,0)
                                  , nn = new le(0,0);
                                Et.push({
                                    tl: Tn,
                                    tr: Gn,
                                    bl: ya,
                                    br: dn,
                                    tex: pt,
                                    writingMode: _e.writingMode,
                                    glyphOffset: rn,
                                    sectionIndex: Dt.sectionIndex,
                                    isSDF: Er,
                                    pixelOffsetTL: na,
                                    pixelOffsetBR: nn,
                                    minFontScaleX: 0,
                                    minFontScaleY: 0
                                })
                            }
                        return Et
                    }(0, i, g, u, p, f, a, n.allowVerticalPlacement)
                      , J = n.textSizeData;
                    let se = null;
                    J.kind === "source" ? (se = [vs * u.layout.get("text-size").evaluate(f, {})],
                    se[0] > eo && Qt(`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : J.kind === "composite" && (se = [vs * N.compositeTextSizes[0].evaluate(f, {}, j), vs * N.compositeTextSizes[1].evaluate(f, {}, j)],
                    (se[0] > eo || se[1] > eo) && Qt(`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)),
                    n.addSymbols(n.text, $, se, g, p, f, S, t, y.lineStartIndex, y.lineLength, R, j);
                    for (const Ae of I)
                        A[Ae] = n.text.placedSymbolArray.length - 1;
                    return 4 * $.length
                }
                function ag(n) {
                    for (const t in n)
                        return n[t];
                    return null
                }
                function _y(n, t, i, a) {
                    const u = n.compareText;
                    if (t in u) {
                        const p = u[t];
                        for (let f = p.length - 1; f >= 0; f--)
                            if (a.dist(p[f]) < i)
                                return !0
                    } else
                        u[t] = [];
                    return u[t].push(a),
                    !1
                }
                const sg = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
                class ef {
                    static from(t) {
                        if (!(t instanceof ArrayBuffer))
                            throw new Error("Data must be an instance of ArrayBuffer.");
                        const [i,a] = new Uint8Array(t,0,2);
                        if (i !== 219)
                            throw new Error("Data does not appear to be in a KDBush format.");
                        const u = a >> 4;
                        if (u !== 1)
                            throw new Error(`Got v${u} data when expected v1.`);
                        const p = sg[15 & a];
                        if (!p)
                            throw new Error("Unrecognized array type.");
                        const [f] = new Uint16Array(t,2,1)
                          , [g] = new Uint32Array(t,4,1);
                        return new ef(g,f,p,t)
                    }
                    constructor(t, i=64, a=Float64Array, u) {
                        if (isNaN(t) || t < 0)
                            throw new Error(`Unpexpected numItems value: ${t}.`);
                        this.numItems = +t,
                        this.nodeSize = Math.min(Math.max(+i, 2), 65535),
                        this.ArrayType = a,
                        this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
                        const p = sg.indexOf(this.ArrayType)
                          , f = 2 * t * this.ArrayType.BYTES_PER_ELEMENT
                          , g = t * this.IndexArrayType.BYTES_PER_ELEMENT
                          , y = (8 - g % 8) % 8;
                        if (p < 0)
                            throw new Error(`Unexpected typed array class: ${a}.`);
                        u && u instanceof ArrayBuffer ? (this.data = u,
                        this.ids = new this.IndexArrayType(this.data,8,t),
                        this.coords = new this.ArrayType(this.data,8 + g + y,2 * t),
                        this._pos = 2 * t,
                        this._finished = !0) : (this.data = new ArrayBuffer(8 + f + g + y),
                        this.ids = new this.IndexArrayType(this.data,8,t),
                        this.coords = new this.ArrayType(this.data,8 + g + y,2 * t),
                        this._pos = 0,
                        this._finished = !1,
                        new Uint8Array(this.data,0,2).set([219, 16 + p]),
                        new Uint16Array(this.data,2,1)[0] = i,
                        new Uint32Array(this.data,4,1)[0] = t)
                    }
                    add(t, i) {
                        const a = this._pos >> 1;
                        return this.ids[a] = a,
                        this.coords[this._pos++] = t,
                        this.coords[this._pos++] = i,
                        a
                    }
                    finish() {
                        const t = this._pos >> 1;
                        if (t !== this.numItems)
                            throw new Error(`Added ${t} items when expected ${this.numItems}.`);
                        return tf(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0),
                        this._finished = !0,
                        this
                    }
                    range(t, i, a, u) {
                        if (!this._finished)
                            throw new Error("Data not yet indexed - call index.finish().");
                        const {ids: p, coords: f, nodeSize: g} = this
                          , y = [0, p.length - 1, 0]
                          , S = [];
                        for (; y.length; ) {
                            const I = y.pop() || 0
                              , A = y.pop() || 0
                              , R = y.pop() || 0;
                            if (A - R <= g) {
                                for (let J = R; J <= A; J++) {
                                    const se = f[2 * J]
                                      , Ae = f[2 * J + 1];
                                    se >= t && se <= a && Ae >= i && Ae <= u && S.push(p[J])
                                }
                                continue
                            }
                            const N = R + A >> 1
                              , j = f[2 * N]
                              , $ = f[2 * N + 1];
                            j >= t && j <= a && $ >= i && $ <= u && S.push(p[N]),
                            (I === 0 ? t <= j : i <= $) && (y.push(R),
                            y.push(N - 1),
                            y.push(1 - I)),
                            (I === 0 ? a >= j : u >= $) && (y.push(N + 1),
                            y.push(A),
                            y.push(1 - I))
                        }
                        return S
                    }
                    within(t, i, a) {
                        if (!this._finished)
                            throw new Error("Data not yet indexed - call index.finish().");
                        const {ids: u, coords: p, nodeSize: f} = this
                          , g = [0, u.length - 1, 0]
                          , y = []
                          , S = a * a;
                        for (; g.length; ) {
                            const I = g.pop() || 0
                              , A = g.pop() || 0
                              , R = g.pop() || 0;
                            if (A - R <= f) {
                                for (let J = R; J <= A; J++)
                                    lg(p[2 * J], p[2 * J + 1], t, i) <= S && y.push(u[J]);
                                continue
                            }
                            const N = R + A >> 1
                              , j = p[2 * N]
                              , $ = p[2 * N + 1];
                            lg(j, $, t, i) <= S && y.push(u[N]),
                            (I === 0 ? t - a <= j : i - a <= $) && (g.push(R),
                            g.push(N - 1),
                            g.push(1 - I)),
                            (I === 0 ? t + a >= j : i + a >= $) && (g.push(N + 1),
                            g.push(A),
                            g.push(1 - I))
                        }
                        return y
                    }
                }
                function tf(n, t, i, a, u, p) {
                    if (u - a <= i)
                        return;
                    const f = a + u >> 1;
                    og(n, t, f, a, u, p),
                    tf(n, t, i, a, f - 1, 1 - p),
                    tf(n, t, i, f + 1, u, 1 - p)
                }
                function og(n, t, i, a, u, p) {
                    for (; u > a; ) {
                        if (u - a > 600) {
                            const S = u - a + 1
                              , I = i - a + 1
                              , A = Math.log(S)
                              , R = .5 * Math.exp(2 * A / 3)
                              , N = .5 * Math.sqrt(A * R * (S - R) / S) * (I - S / 2 < 0 ? -1 : 1);
                            og(n, t, i, Math.max(a, Math.floor(i - I * R / S + N)), Math.min(u, Math.floor(i + (S - I) * R / S + N)), p)
                        }
                        const f = t[2 * i + p];
                        let g = a
                          , y = u;
                        for (gu(n, t, a, i),
                        t[2 * u + p] > f && gu(n, t, a, u); g < y; ) {
                            for (gu(n, t, g, y),
                            g++,
                            y--; t[2 * g + p] < f; )
                                g++;
                            for (; t[2 * y + p] > f; )
                                y--
                        }
                        t[2 * a + p] === f ? gu(n, t, a, y) : (y++,
                        gu(n, t, y, u)),
                        y <= i && (a = y + 1),
                        i <= y && (u = y - 1)
                    }
                }
                function gu(n, t, i, a) {
                    rf(n, i, a),
                    rf(t, 2 * i, 2 * a),
                    rf(t, 2 * i + 1, 2 * a + 1)
                }
                function rf(n, t, i) {
                    const a = n[t];
                    n[t] = n[i],
                    n[i] = a
                }
                function lg(n, t, i, a) {
                    const u = n - i
                      , p = t - a;
                    return u * u + p * p
                }
                var nf;
                C.cw = void 0,
                (nf = C.cw || (C.cw = {})).create = "create",
                nf.load = "load",
                nf.fullLoad = "fullLoad";
                let vd = null
                  , vu = [];
                const af = 1e3 / 60
                  , sf = "loadTime"
                  , of = "fullLoadTime"
                  , gy = {
                    mark(n) {
                        performance.mark(n)
                    },
                    frame(n) {
                        const t = n;
                        vd != null && vu.push(t - vd),
                        vd = t
                    },
                    clearMetrics() {
                        vd = null,
                        vu = [],
                        performance.clearMeasures(sf),
                        performance.clearMeasures(of);
                        for (const n in C.cw)
                            performance.clearMarks(C.cw[n])
                    },
                    getPerformanceMetrics() {
                        performance.measure(sf, C.cw.create, C.cw.load),
                        performance.measure(of, C.cw.create, C.cw.fullLoad);
                        const n = performance.getEntriesByName(sf)[0].duration
                          , t = performance.getEntriesByName(of)[0].duration
                          , i = vu.length
                          , a = 1 / (vu.reduce( (p, f) => p + f, 0) / i / 1e3)
                          , u = vu.filter(p => p > af).reduce( (p, f) => p + (f - af) / af, 0);
                        return {
                            loadTime: n,
                            fullLoadTime: t,
                            fps: a,
                            percentDroppedFrames: u / (i + u) * 100,
                            totalFrames: i
                        }
                    }
                };
                C.$ = We,
                C.A = rt,
                C.B = function([n,t,i]) {
                    return t += 90,
                    t *= Math.PI / 180,
                    i *= Math.PI / 180,
                    {
                        x: n * Math.cos(t) * Math.sin(i),
                        y: n * Math.sin(t) * Math.sin(i),
                        z: n * Math.cos(i)
                    }
                }
                ,
                C.C = ta,
                C.D = ar,
                C.E = Ke,
                C.F = Ei,
                C.G = Sl,
                C.H = function(n) {
                    if ($r == null) {
                        const t = n.navigator ? n.navigator.userAgent : null;
                        $r = !!n.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")))
                    }
                    return $r
                }
                ,
                C.I = qp,
                C.J = class {
                    constructor(n, t) {
                        this.target = n,
                        this.mapId = t,
                        this.resolveRejects = {},
                        this.tasks = {},
                        this.taskQueue = [],
                        this.abortControllers = {},
                        this.messageHandlers = {},
                        this.invoker = new oy( () => this.process()),
                        this.subscription = mr(this.target, "message", i => this.receive(i), !1),
                        this.globalScope = tr(self) ? n : window
                    }
                    registerMessageHandler(n, t) {
                        this.messageHandlers[n] = t
                    }
                    sendAsync(n, t) {
                        return new Promise( (i, a) => {
                            const u = Math.round(1e18 * Math.random()).toString(36).substring(0, 10)
                              , p = t ? mr(t.signal, "abort", () => {
                                p == null || p.unsubscribe(),
                                delete this.resolveRejects[u];
                                const y = {
                                    id: u,
                                    type: "<cancel>",
                                    origin: location.origin,
                                    targetMapId: n.targetMapId,
                                    sourceMapId: this.mapId
                                };
                                this.target.postMessage(y)
                            }
                            , ly) : null;
                            this.resolveRejects[u] = {
                                resolve: y => {
                                    p == null || p.unsubscribe(),
                                    i(y)
                                }
                                ,
                                reject: y => {
                                    p == null || p.unsubscribe(),
                                    a(y)
                                }
                            };
                            const f = []
                              , g = Object.assign(Object.assign({}, n), {
                                id: u,
                                sourceMapId: this.mapId,
                                origin: location.origin,
                                data: zo(n.data, f)
                            });
                            this.target.postMessage(g, {
                                transfer: f
                            })
                        }
                        )
                    }
                    receive(n) {
                        const t = n.data
                          , i = t.id;
                        if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
                            if (t.type === "<cancel>") {
                                delete this.tasks[i];
                                const a = this.abortControllers[i];
                                return delete this.abortControllers[i],
                                void (a && a.abort())
                            }
                            if (tr(self) || t.mustQueue)
                                return this.tasks[i] = t,
                                this.taskQueue.push(i),
                                void this.invoker.trigger();
                            this.processTask(i, t)
                        }
                    }
                    process() {
                        if (this.taskQueue.length === 0)
                            return;
                        const n = this.taskQueue.shift()
                          , t = this.tasks[n];
                        delete this.tasks[n],
                        this.taskQueue.length > 0 && this.invoker.trigger(),
                        t && this.processTask(n, t)
                    }
                    processTask(n, t) {
                        return o(this, void 0, void 0, function*() {
                            if (t.type === "<response>") {
                                const u = this.resolveRejects[n];
                                return delete this.resolveRejects[n],
                                u ? void (t.error ? u.reject(Ks(t.error)) : u.resolve(Ks(t.data))) : void 0
                            }
                            if (!this.messageHandlers[t.type])
                                return void this.completeTask(n, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
                            const i = Ks(t.data)
                              , a = new AbortController;
                            this.abortControllers[n] = a;
                            try {
                                const u = yield this.messageHandlers[t.type](t.sourceMapId, i, a);
                                this.completeTask(n, null, u)
                            } catch (u) {
                                this.completeTask(n, u)
                            }
                        })
                    }
                    completeTask(n, t, i) {
                        const a = [];
                        delete this.abortControllers[n];
                        const u = {
                            id: n,
                            type: "<response>",
                            sourceMapId: this.mapId,
                            origin: location.origin,
                            error: t ? zo(t) : null,
                            data: zo(i, a)
                        };
                        this.target.postMessage(u, {
                            transfer: a
                        })
                    }
                    remove() {
                        this.invoker.remove(),
                        this.subscription.unsubscribe()
                    }
                }
                ,
                C.K = K,
                C.L = function() {
                    var n = new rt(16);
                    return rt != Float32Array && (n[1] = 0,
                    n[2] = 0,
                    n[3] = 0,
                    n[4] = 0,
                    n[6] = 0,
                    n[7] = 0,
                    n[8] = 0,
                    n[9] = 0,
                    n[11] = 0,
                    n[12] = 0,
                    n[13] = 0,
                    n[14] = 0),
                    n[0] = 1,
                    n[5] = 1,
                    n[10] = 1,
                    n[15] = 1,
                    n
                }
                ,
                C.M = function(n, t, i) {
                    var a, u, p, f, g, y, S, I, A, R, N, j, $ = i[0], J = i[1], se = i[2];
                    return t === n ? (n[12] = t[0] * $ + t[4] * J + t[8] * se + t[12],
                    n[13] = t[1] * $ + t[5] * J + t[9] * se + t[13],
                    n[14] = t[2] * $ + t[6] * J + t[10] * se + t[14],
                    n[15] = t[3] * $ + t[7] * J + t[11] * se + t[15]) : (u = t[1],
                    p = t[2],
                    f = t[3],
                    g = t[4],
                    y = t[5],
                    S = t[6],
                    I = t[7],
                    A = t[8],
                    R = t[9],
                    N = t[10],
                    j = t[11],
                    n[0] = a = t[0],
                    n[1] = u,
                    n[2] = p,
                    n[3] = f,
                    n[4] = g,
                    n[5] = y,
                    n[6] = S,
                    n[7] = I,
                    n[8] = A,
                    n[9] = R,
                    n[10] = N,
                    n[11] = j,
                    n[12] = a * $ + g * J + A * se + t[12],
                    n[13] = u * $ + y * J + R * se + t[13],
                    n[14] = p * $ + S * J + N * se + t[14],
                    n[15] = f * $ + I * J + j * se + t[15]),
                    n
                }
                ,
                C.N = function(n, t, i) {
                    var a = i[0]
                      , u = i[1]
                      , p = i[2];
                    return n[0] = t[0] * a,
                    n[1] = t[1] * a,
                    n[2] = t[2] * a,
                    n[3] = t[3] * a,
                    n[4] = t[4] * u,
                    n[5] = t[5] * u,
                    n[6] = t[6] * u,
                    n[7] = t[7] * u,
                    n[8] = t[8] * p,
                    n[9] = t[9] * p,
                    n[10] = t[10] * p,
                    n[11] = t[11] * p,
                    n[12] = t[12],
                    n[13] = t[13],
                    n[14] = t[14],
                    n[15] = t[15],
                    n
                }
                ,
                C.O = function(n, t, i) {
                    var a = t[0]
                      , u = t[1]
                      , p = t[2]
                      , f = t[3]
                      , g = t[4]
                      , y = t[5]
                      , S = t[6]
                      , I = t[7]
                      , A = t[8]
                      , R = t[9]
                      , N = t[10]
                      , j = t[11]
                      , $ = t[12]
                      , J = t[13]
                      , se = t[14]
                      , Ae = t[15]
                      , _e = i[0]
                      , O = i[1]
                      , Y = i[2]
                      , ve = i[3];
                    return n[0] = _e * a + O * g + Y * A + ve * $,
                    n[1] = _e * u + O * y + Y * R + ve * J,
                    n[2] = _e * p + O * S + Y * N + ve * se,
                    n[3] = _e * f + O * I + Y * j + ve * Ae,
                    n[4] = (_e = i[4]) * a + (O = i[5]) * g + (Y = i[6]) * A + (ve = i[7]) * $,
                    n[5] = _e * u + O * y + Y * R + ve * J,
                    n[6] = _e * p + O * S + Y * N + ve * se,
                    n[7] = _e * f + O * I + Y * j + ve * Ae,
                    n[8] = (_e = i[8]) * a + (O = i[9]) * g + (Y = i[10]) * A + (ve = i[11]) * $,
                    n[9] = _e * u + O * y + Y * R + ve * J,
                    n[10] = _e * p + O * S + Y * N + ve * se,
                    n[11] = _e * f + O * I + Y * j + ve * Ae,
                    n[12] = (_e = i[12]) * a + (O = i[13]) * g + (Y = i[14]) * A + (ve = i[15]) * $,
                    n[13] = _e * u + O * y + Y * R + ve * J,
                    n[14] = _e * p + O * S + Y * N + ve * se,
                    n[15] = _e * f + O * I + Y * j + ve * Ae,
                    n
                }
                ,
                C.P = le,
                C.Q = function(n, t) {
                    const i = {};
                    for (let a = 0; a < t.length; a++) {
                        const u = t[a];
                        u in n && (i[u] = n[u])
                    }
                    return i
                }
                ,
                C.R = ra,
                C.S = to,
                C.T = Pp,
                C.U = N_,
                C.V = O_,
                C.W = Ne,
                C.X = Ze,
                C.Y = sr,
                C.Z = ga,
                C._ = o,
                C.a = q,
                C.a$ = function(n, t, i) {
                    return n[0] = t[0] * i,
                    n[1] = t[1] * i,
                    n[2] = t[2] * i,
                    n[3] = t[3] * i,
                    n
                }
                ,
                C.a0 = _u,
                C.a1 = Uo,
                C.a2 = 25,
                C.a3 = Yp,
                C.a4 = n => {
                    const t = window.document.createElement("video");
                    return t.muted = !0,
                    new Promise(i => {
                        t.onloadstart = () => {
                            i(t)
                        }
                        ;
                        for (const a of n) {
                            const u = window.document.createElement("source");
                            ke(a) || (t.crossOrigin = "Anonymous"),
                            u.src = a,
                            t.appendChild(u)
                        }
                    }
                    )
                }
                ,
                C.a5 = ft,
                C.a6 = function() {
                    return jt++
                }
                ,
                C.a7 = te,
                C.a8 = Ol,
                C.a9 = Ha,
                C.aA = un,
                C.aB = it,
                C.aC = function(n, t, i, a, u=!1) {
                    if (!i[0] && !i[1])
                        return [0, 0];
                    const p = u ? a === "map" ? -n.bearingInRadians : 0 : a === "viewport" ? n.bearingInRadians : 0;
                    if (p) {
                        const f = Math.sin(p)
                          , g = Math.cos(p);
                        i = [i[0] * g - i[1] * f, i[0] * f + i[1] * g]
                    }
                    return [u ? i[0] : it(t, i[0], n.zoom), u ? i[1] : it(t, i[1], n.zoom)]
                }
                ,
                C.aE = $p,
                C.aF = Qp,
                C.aG = Zp,
                C.aH = ef,
                C.aI = qi,
                C.aJ = od,
                C.aK = $e,
                C.aL = li,
                C.aM = Ti,
                C.aN = xt,
                C.aO = br,
                C.aP = q_,
                C.aQ = ct,
                C.aR = dt,
                C.aS = function(n) {
                    var t = new rt(3);
                    return t[0] = n[0],
                    t[1] = n[1],
                    t[2] = n[2],
                    t
                }
                ,
                C.aT = function(n, t, i) {
                    return n[0] = t[0] - i[0],
                    n[1] = t[1] - i[1],
                    n[2] = t[2] - i[2],
                    n
                }
                ,
                C.aU = function(n, t) {
                    var i = t[0]
                      , a = t[1]
                      , u = t[2]
                      , p = i * i + a * a + u * u;
                    return p > 0 && (p = 1 / Math.sqrt(p)),
                    n[0] = t[0] * p,
                    n[1] = t[1] * p,
                    n[2] = t[2] * p,
                    n
                }
                ,
                C.aV = ze,
                C.aW = function(n, t) {
                    return n[0] * t[0] + n[1] * t[1] + n[2] * t[2]
                }
                ,
                C.aX = function(n, t, i) {
                    return n[0] = t[0] * i[0],
                    n[1] = t[1] * i[1],
                    n[2] = t[2] * i[2],
                    n[3] = t[3] * i[3],
                    n
                }
                ,
                C.aY = Ve,
                C.aZ = function(n, t, i) {
                    const a = t[0] * i[0] + t[1] * i[1] + t[2] * i[2];
                    return a === 0 ? null : (-(n[0] * i[0] + n[1] * i[1] + n[2] * i[2]) - i[3]) / a
                }
                ,
                C.a_ = Q,
                C.aa = Vo,
                C.ab = U_,
                C.ac = function(n) {
                    const t = {};
                    if (n.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (i, a, u, p) => {
                        const f = u || p;
                        return t[a] = !f || f.toLowerCase(),
                        ""
                    }
                    ),
                    t["max-age"]) {
                        const i = parseInt(t["max-age"], 10);
                        isNaN(i) ? delete t["max-age"] : t["max-age"] = i
                    }
                    return t
                }
                ,
                C.ad = vr,
                C.ae = function(n) {
                    return Math.pow(2, n)
                }
                ,
                C.af = lt,
                C.ag = kt,
                C.ah = 85.051129,
                C.ai = j_,
                C.aj = function(n) {
                    return Math.log(n) / Math.LN2
                }
                ,
                C.ak = function(n) {
                    var t = n[0]
                      , i = n[1];
                    return t * t + i * i
                }
                ,
                C.al = function(n, t) {
                    const i = [];
                    for (const a in n)
                        a in t || i.push(a);
                    return i
                }
                ,
                C.am = function(n, t) {
                    let i = 0
                      , a = 0;
                    if (n.kind === "constant")
                        a = n.layoutSize;
                    else if (n.kind !== "source") {
                        const {interpolationType: u, minZoom: p, maxZoom: f} = n
                          , g = u ? kt(En.interpolationFactor(u, t, p, f), 0, 1) : 0;
                        n.kind === "camera" ? a = ta.number(n.minSize, n.maxSize, g) : i = g
                    }
                    return {
                        uSizeT: i,
                        uSize: a
                    }
                }
                ,
                C.ao = function(n, {uSize: t, uSizeT: i}, {lowerSize: a, upperSize: u}) {
                    return n.kind === "source" ? a / vs : n.kind === "composite" ? ta.number(a / vs, u / vs, i) : t
                }
                ,
                C.ap = function(n, t) {
                    var i = t[0]
                      , a = t[1]
                      , u = t[2]
                      , p = t[3]
                      , f = t[4]
                      , g = t[5]
                      , y = t[6]
                      , S = t[7]
                      , I = t[8]
                      , A = t[9]
                      , R = t[10]
                      , N = t[11]
                      , j = t[12]
                      , $ = t[13]
                      , J = t[14]
                      , se = t[15]
                      , Ae = i * g - a * f
                      , _e = i * y - u * f
                      , O = i * S - p * f
                      , Y = a * y - u * g
                      , ve = a * S - p * g
                      , Xe = u * S - p * y
                      , bt = I * $ - A * j
                      , Qe = I * J - R * j
                      , ot = I * se - N * j
                      , Et = A * J - R * $
                      , Ct = A * se - N * $
                      , Dt = R * se - N * J
                      , pt = Ae * Dt - _e * Ct + O * Et + Y * ot - ve * Qe + Xe * bt;
                    return pt ? (n[0] = (g * Dt - y * Ct + S * Et) * (pt = 1 / pt),
                    n[1] = (u * Ct - a * Dt - p * Et) * pt,
                    n[2] = ($ * Xe - J * ve + se * Y) * pt,
                    n[3] = (R * ve - A * Xe - N * Y) * pt,
                    n[4] = (y * ot - f * Dt - S * Qe) * pt,
                    n[5] = (i * Dt - u * ot + p * Qe) * pt,
                    n[6] = (J * O - j * Xe - se * _e) * pt,
                    n[7] = (I * Xe - R * O + N * _e) * pt,
                    n[8] = (f * Ct - g * ot + S * bt) * pt,
                    n[9] = (a * ot - i * Ct - p * bt) * pt,
                    n[10] = (j * ve - $ * O + se * Ae) * pt,
                    n[11] = (A * O - I * ve - N * Ae) * pt,
                    n[12] = (g * Qe - f * Et - y * bt) * pt,
                    n[13] = (i * Et - a * Qe + u * bt) * pt,
                    n[14] = ($ * _e - j * Y - J * Ae) * pt,
                    n[15] = (I * Y - A * _e + R * Ae) * pt,
                    n) : null
                }
                ,
                C.aq = Le,
                C.ar = function(n) {
                    return Math.hypot(n[0], n[1])
                }
                ,
                C.as = function(n) {
                    return n[0] = 0,
                    n[1] = 0,
                    n
                }
                ,
                C.at = function(n, t, i) {
                    return n[0] = t[0] * i,
                    n[1] = t[1] * i,
                    n
                }
                ,
                C.au = Up,
                C.av = ie,
                C.aw = function(n, t, i, a) {
                    const u = t.y - n.y
                      , p = t.x - n.x
                      , f = a.y - i.y
                      , g = a.x - i.x
                      , y = f * p - g * u;
                    if (y === 0)
                        return null;
                    const S = (g * (n.y - i.y) - f * (n.x - i.x)) / y;
                    return new le(n.x + S * p,n.y + S * u)
                }
                ,
                C.ax = W_,
                C.ay = zm,
                C.az = function(n) {
                    let t = 1 / 0
                      , i = 1 / 0
                      , a = -1 / 0
                      , u = -1 / 0;
                    for (const p of n)
                        t = Math.min(t, p.x),
                        i = Math.min(i, p.y),
                        a = Math.max(a, p.x),
                        u = Math.max(u, p.y);
                    return [t, i, a, u]
                }
                ,
                C.b = zr,
                C.b$ = O0,
                C.b0 = function(n, t) {
                    return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] + n[3]
                }
                ,
                C.b1 = Z_,
                C.b2 = Nl,
                C.b3 = function(n, t, i, a, u) {
                    var p, f = 1 / Math.tan(t / 2);
                    return n[0] = f / i,
                    n[1] = 0,
                    n[2] = 0,
                    n[3] = 0,
                    n[4] = 0,
                    n[5] = f,
                    n[6] = 0,
                    n[7] = 0,
                    n[8] = 0,
                    n[9] = 0,
                    n[11] = -1,
                    n[12] = 0,
                    n[13] = 0,
                    n[15] = 0,
                    u != null && u !== 1 / 0 ? (n[10] = (u + a) * (p = 1 / (a - u)),
                    n[14] = 2 * u * a * p) : (n[10] = -1,
                    n[14] = -2 * a),
                    n
                }
                ,
                C.b4 = function(n) {
                    var t = new rt(16);
                    return t[0] = n[0],
                    t[1] = n[1],
                    t[2] = n[2],
                    t[3] = n[3],
                    t[4] = n[4],
                    t[5] = n[5],
                    t[6] = n[6],
                    t[7] = n[7],
                    t[8] = n[8],
                    t[9] = n[9],
                    t[10] = n[10],
                    t[11] = n[11],
                    t[12] = n[12],
                    t[13] = n[13],
                    t[14] = n[14],
                    t[15] = n[15],
                    t
                }
                ,
                C.b5 = function(n, t, i) {
                    var a = Math.sin(i)
                      , u = Math.cos(i)
                      , p = t[0]
                      , f = t[1]
                      , g = t[2]
                      , y = t[3]
                      , S = t[4]
                      , I = t[5]
                      , A = t[6]
                      , R = t[7];
                    return t !== n && (n[8] = t[8],
                    n[9] = t[9],
                    n[10] = t[10],
                    n[11] = t[11],
                    n[12] = t[12],
                    n[13] = t[13],
                    n[14] = t[14],
                    n[15] = t[15]),
                    n[0] = p * u + S * a,
                    n[1] = f * u + I * a,
                    n[2] = g * u + A * a,
                    n[3] = y * u + R * a,
                    n[4] = S * u - p * a,
                    n[5] = I * u - f * a,
                    n[6] = A * u - g * a,
                    n[7] = R * u - y * a,
                    n
                }
                ,
                C.b6 = function(n, t, i) {
                    var a = Math.sin(i)
                      , u = Math.cos(i)
                      , p = t[4]
                      , f = t[5]
                      , g = t[6]
                      , y = t[7]
                      , S = t[8]
                      , I = t[9]
                      , A = t[10]
                      , R = t[11];
                    return t !== n && (n[0] = t[0],
                    n[1] = t[1],
                    n[2] = t[2],
                    n[3] = t[3],
                    n[12] = t[12],
                    n[13] = t[13],
                    n[14] = t[14],
                    n[15] = t[15]),
                    n[4] = p * u + S * a,
                    n[5] = f * u + I * a,
                    n[6] = g * u + A * a,
                    n[7] = y * u + R * a,
                    n[8] = S * u - p * a,
                    n[9] = I * u - f * a,
                    n[10] = A * u - g * a,
                    n[11] = R * u - y * a,
                    n
                }
                ,
                C.b7 = function() {
                    const n = new Float32Array(16);
                    return lt(n),
                    n
                }
                ,
                C.b8 = function() {
                    const n = new Float64Array(16);
                    return lt(n),
                    n
                }
                ,
                C.b9 = function() {
                    return new Float64Array(16)
                }
                ,
                C.bA = function(n) {
                    return n[0] = 0,
                    n[1] = 0,
                    n[2] = 0,
                    n
                }
                ,
                C.bB = function(n, t, i, a) {
                    const u = Math.sqrt(n * n + t * t)
                      , p = Math.sqrt(i * i + a * a);
                    n /= u,
                    t /= u,
                    i /= p,
                    a /= p;
                    const f = Math.acos(n * i + t * a);
                    return -t * i + n * a > 0 ? f : -f
                }
                ,
                C.bC = function(n, t) {
                    const i = at(n, 2 * Math.PI)
                      , a = at(t, 2 * Math.PI);
                    return Math.min(Math.abs(i - a), Math.abs(i - a + 2 * Math.PI), Math.abs(i - a - 2 * Math.PI))
                }
                ,
                C.bD = function() {
                    const n = {}
                      , t = ye.$version;
                    for (const i in ye.$root) {
                        const a = ye.$root[i];
                        if (a.required) {
                            let u = null;
                            u = i === "version" ? t : a.type === "array" ? [] : {},
                            u != null && (n[i] = u)
                        }
                    }
                    return n
                }
                ,
                C.bE = Zc,
                C.bF = we,
                C.bG = function n(t, i) {
                    if (Array.isArray(t)) {
                        if (!Array.isArray(i) || t.length !== i.length)
                            return !1;
                        for (let a = 0; a < t.length; a++)
                            if (!n(t[a], i[a]))
                                return !1;
                        return !0
                    }
                    if (typeof t == "object" && t !== null && i !== null) {
                        if (typeof i != "object" || Object.keys(t).length !== Object.keys(i).length)
                            return !1;
                        for (const a in t)
                            if (!n(t[a], i[a]))
                                return !1;
                        return !0
                    }
                    return t === i
                }
                ,
                C.bH = function(n) {
                    n = n.slice();
                    const t = Object.create(null);
                    for (let i = 0; i < n.length; i++)
                        t[n[i].id] = n[i];
                    for (let i = 0; i < n.length; i++)
                        "ref"in n[i] && (n[i] = Kt(n[i], t[n[i].ref]));
                    return n
                }
                ,
                C.bI = function(n) {
                    if (n.type === "custom")
                        return new sy(n);
                    switch (n.type) {
                    case "background":
                        return new iy(n);
                    case "circle":
                        return new Yv(n);
                    case "color-relief":
                        return new i0(n);
                    case "fill":
                        return new v0(n);
                    case "fill-extrusion":
                        return new P0(n);
                    case "heatmap":
                        return new Qv(n);
                    case "hillshade":
                        return new t0(n);
                    case "line":
                        return new D0(n);
                    case "raster":
                        return new ay(n);
                    case "symbol":
                        return new pd(n)
                    }
                }
                ,
                C.bJ = xr,
                C.bK = function(n, t) {
                    if (!n)
                        return [{
                            command: "setStyle",
                            args: [t]
                        }];
                    let i = [];
                    try {
                        if (!Bt(n.version, t.version))
                            return [{
                                command: "setStyle",
                                args: [t]
                            }];
                        Bt(n.center, t.center) || i.push({
                            command: "setCenter",
                            args: [t.center]
                        }),
                        Bt(n.state, t.state) || i.push({
                            command: "setGlobalState",
                            args: [t.state]
                        }),
                        Bt(n.centerAltitude, t.centerAltitude) || i.push({
                            command: "setCenterAltitude",
                            args: [t.centerAltitude]
                        }),
                        Bt(n.zoom, t.zoom) || i.push({
                            command: "setZoom",
                            args: [t.zoom]
                        }),
                        Bt(n.bearing, t.bearing) || i.push({
                            command: "setBearing",
                            args: [t.bearing]
                        }),
                        Bt(n.pitch, t.pitch) || i.push({
                            command: "setPitch",
                            args: [t.pitch]
                        }),
                        Bt(n.roll, t.roll) || i.push({
                            command: "setRoll",
                            args: [t.roll]
                        }),
                        Bt(n.sprite, t.sprite) || i.push({
                            command: "setSprite",
                            args: [t.sprite]
                        }),
                        Bt(n.glyphs, t.glyphs) || i.push({
                            command: "setGlyphs",
                            args: [t.glyphs]
                        }),
                        Bt(n.transition, t.transition) || i.push({
                            command: "setTransition",
                            args: [t.transition]
                        }),
                        Bt(n.light, t.light) || i.push({
                            command: "setLight",
                            args: [t.light]
                        }),
                        Bt(n.terrain, t.terrain) || i.push({
                            command: "setTerrain",
                            args: [t.terrain]
                        }),
                        Bt(n.sky, t.sky) || i.push({
                            command: "setSky",
                            args: [t.sky]
                        }),
                        Bt(n.projection, t.projection) || i.push({
                            command: "setProjection",
                            args: [t.projection]
                        });
                        const a = {}
                          , u = [];
                        (function(f, g, y, S) {
                            let I;
                            for (I in g = g || {},
                            f = f || {})
                                Object.prototype.hasOwnProperty.call(f, I) && (Object.prototype.hasOwnProperty.call(g, I) || ci(I, y, S));
                            for (I in g)
                                Object.prototype.hasOwnProperty.call(g, I) && (Object.prototype.hasOwnProperty.call(f, I) ? Bt(f[I], g[I]) || (f[I].type === "geojson" && g[I].type === "geojson" && yt(f, g, I) ? Ut(y, {
                                    command: "setGeoJSONSourceData",
                                    args: [I, g[I].data]
                                }) : Yr(I, g, y, S)) : wr(I, g, y))
                        }
                        )(n.sources, t.sources, u, a);
                        const p = [];
                        n.layers && n.layers.forEach(f => {
                            "source"in f && a[f.source] ? i.push({
                                command: "removeLayer",
                                args: [f.id]
                            }) : p.push(f)
                        }
                        ),
                        i = i.concat(u),
                        function(f, g, y) {
                            g = g || [];
                            const S = (f = f || []).map(Gt)
                              , I = g.map(Gt)
                              , A = f.reduce(Fr, {})
                              , R = g.reduce(Fr, {})
                              , N = S.slice()
                              , j = Object.create(null);
                            let $, J, se, Ae, _e;
                            for (let O = 0, Y = 0; O < S.length; O++)
                                $ = S[O],
                                Object.prototype.hasOwnProperty.call(R, $) ? Y++ : (Ut(y, {
                                    command: "removeLayer",
                                    args: [$]
                                }),
                                N.splice(N.indexOf($, Y), 1));
                            for (let O = 0, Y = 0; O < I.length; O++)
                                $ = I[I.length - 1 - O],
                                N[N.length - 1 - O] !== $ && (Object.prototype.hasOwnProperty.call(A, $) ? (Ut(y, {
                                    command: "removeLayer",
                                    args: [$]
                                }),
                                N.splice(N.lastIndexOf($, N.length - Y), 1)) : Y++,
                                Ae = N[N.length - O],
                                Ut(y, {
                                    command: "addLayer",
                                    args: [R[$], Ae]
                                }),
                                N.splice(N.length - O, 0, $),
                                j[$] = !0);
                            for (let O = 0; O < I.length; O++)
                                if ($ = I[O],
                                J = A[$],
                                se = R[$],
                                !j[$] && !Bt(J, se))
                                    if (Bt(J.source, se.source) && Bt(J["source-layer"], se["source-layer"]) && Bt(J.type, se.type)) {
                                        for (_e in Mt(J.layout, se.layout, y, $, null, "setLayoutProperty"),
                                        Mt(J.paint, se.paint, y, $, null, "setPaintProperty"),
                                        Bt(J.filter, se.filter) || Ut(y, {
                                            command: "setFilter",
                                            args: [$, se.filter]
                                        }),
                                        Bt(J.minzoom, se.minzoom) && Bt(J.maxzoom, se.maxzoom) || Ut(y, {
                                            command: "setLayerZoomRange",
                                            args: [$, se.minzoom, se.maxzoom]
                                        }),
                                        J)
                                            Object.prototype.hasOwnProperty.call(J, _e) && _e !== "layout" && _e !== "paint" && _e !== "filter" && _e !== "metadata" && _e !== "minzoom" && _e !== "maxzoom" && (_e.indexOf("paint.") === 0 ? Mt(J[_e], se[_e], y, $, _e.slice(6), "setPaintProperty") : Bt(J[_e], se[_e]) || Ut(y, {
                                                command: "setLayerProperty",
                                                args: [$, _e, se[_e]]
                                            }));
                                        for (_e in se)
                                            Object.prototype.hasOwnProperty.call(se, _e) && !Object.prototype.hasOwnProperty.call(J, _e) && _e !== "layout" && _e !== "paint" && _e !== "filter" && _e !== "metadata" && _e !== "minzoom" && _e !== "maxzoom" && (_e.indexOf("paint.") === 0 ? Mt(J[_e], se[_e], y, $, _e.slice(6), "setPaintProperty") : Bt(J[_e], se[_e]) || Ut(y, {
                                                command: "setLayerProperty",
                                                args: [$, _e, se[_e]]
                                            }))
                                    } else
                                        Ut(y, {
                                            command: "removeLayer",
                                            args: [$]
                                        }),
                                        Ae = N[N.lastIndexOf($) + 1],
                                        Ut(y, {
                                            command: "addLayer",
                                            args: [se, Ae]
                                        })
                        }(p, t.layers, i)
                    } catch (a) {
                        console.warn("Unable to compute style diff:", a),
                        i = [{
                            command: "setStyle",
                            args: [t]
                        }]
                    }
                    return i
                }
                ,
                C.bL = function(n) {
                    const t = []
                      , i = n.id;
                    return i === void 0 && t.push({
                        message: `layers.${i}: missing required property "id"`
                    }),
                    n.render === void 0 && t.push({
                        message: `layers.${i}: missing required method "render"`
                    }),
                    n.renderingMode && n.renderingMode !== "2d" && n.renderingMode !== "3d" && t.push({
                        message: `layers.${i}: property "renderingMode" must be either "2d" or "3d"`
                    }),
                    t
                }
                ,
                C.bM = Lt,
                C.bN = nr,
                C.bO = class extends Mi {
                    constructor(n, t) {
                        super(n, t),
                        this.current = 0
                    }
                    set(n) {
                        this.current !== n && (this.current = n,
                        this.gl.uniform1i(this.location, n))
                    }
                }
                ,
                C.bP = rd,
                C.bQ = class extends Mi {
                    constructor(n, t) {
                        super(n, t),
                        this.current = yp
                    }
                    set(n) {
                        if (n[12] !== this.current[12] || n[0] !== this.current[0])
                            return this.current = n,
                            void this.gl.uniformMatrix4fv(this.location, !1, n);
                        for (let t = 1; t < 16; t++)
                            if (n[t] !== this.current[t]) {
                                this.current = n,
                                this.gl.uniformMatrix4fv(this.location, !1, n);
                                break
                            }
                    }
                }
                ,
                C.bR = tn,
                C.bS = class extends Mi {
                    constructor(n, t) {
                        super(n, t),
                        this.current = [0, 0, 0]
                    }
                    set(n) {
                        n[0] === this.current[0] && n[1] === this.current[1] && n[2] === this.current[2] || (this.current = n,
                        this.gl.uniform3f(this.location, n[0], n[1], n[2]))
                    }
                }
                ,
                C.bT = class extends Mi {
                    constructor(n, t) {
                        super(n, t),
                        this.current = [0, 0]
                    }
                    set(n) {
                        n[0] === this.current[0] && n[1] === this.current[1] || (this.current = n,
                        this.gl.uniform2f(this.location, n[0], n[1]))
                    }
                }
                ,
                C.bU = Ue,
                C.bV = function(n, t) {
                    var i = Math.sin(t)
                      , a = Math.cos(t);
                    return n[0] = a,
                    n[1] = i,
                    n[2] = 0,
                    n[3] = -i,
                    n[4] = a,
                    n[5] = 0,
                    n[6] = 0,
                    n[7] = 0,
                    n[8] = 1,
                    n
                }
                ,
                C.bW = function(n, t, i) {
                    var a = t[0]
                      , u = t[1]
                      , p = t[2];
                    return n[0] = a * i[0] + u * i[3] + p * i[6],
                    n[1] = a * i[1] + u * i[4] + p * i[7],
                    n[2] = a * i[2] + u * i[5] + p * i[8],
                    n
                }
                ,
                C.bX = function(n, t, i, a, u, p, f) {
                    var g = 1 / (t - i)
                      , y = 1 / (a - u)
                      , S = 1 / (p - f);
                    return n[0] = -2 * g,
                    n[1] = 0,
                    n[2] = 0,
                    n[3] = 0,
                    n[4] = 0,
                    n[5] = -2 * y,
                    n[6] = 0,
                    n[7] = 0,
                    n[8] = 0,
                    n[9] = 0,
                    n[10] = 2 * S,
                    n[11] = 0,
                    n[12] = (t + i) * g,
                    n[13] = (u + a) * y,
                    n[14] = (f + p) * S,
                    n[15] = 1,
                    n
                }
                ,
                C.bY = class extends Mi {
                    constructor(n, t) {
                        super(n, t),
                        this.current = new Array
                    }
                    set(n) {
                        if (n != this.current) {
                            this.current = n;
                            const t = new Float32Array(4 * n.length);
                            for (let i = 0; i < n.length; i++)
                                t[4 * i] = n[i].r,
                                t[4 * i + 1] = n[i].g,
                                t[4 * i + 2] = n[i].b,
                                t[4 * i + 3] = n[i].a;
                            this.gl.uniform4fv(this.location, t)
                        }
                    }
                }
                ,
                C.bZ = class extends Mi {
                    constructor(n, t) {
                        super(n, t),
                        this.current = new Array
                    }
                    set(n) {
                        if (n != this.current) {
                            this.current = n;
                            const t = new Float32Array(n);
                            this.gl.uniform1fv(this.location, t)
                        }
                    }
                }
                ,
                C.b_ = class extends s {
                }
                ,
                C.ba = function(n, t, i) {
                    const a = new Float64Array(4);
                    return ue(a, n, t - 90, i),
                    a
                }
                ,
                C.bb = function(n, t, i, a) {
                    var u, p, f, g, y, S = t[0], I = t[1], A = t[2], R = t[3], N = i[0], j = i[1], $ = i[2], J = i[3];
                    return (p = S * N + I * j + A * $ + R * J) < 0 && (p = -p,
                    N = -N,
                    j = -j,
                    $ = -$,
                    J = -J),
                    1 - p > ut ? (u = Math.acos(p),
                    f = Math.sin(u),
                    g = Math.sin((1 - a) * u) / f,
                    y = Math.sin(a * u) / f) : (g = 1 - a,
                    y = a),
                    n[0] = g * S + y * N,
                    n[1] = g * I + y * j,
                    n[2] = g * A + y * $,
                    n[3] = g * R + y * J,
                    n
                }
                ,
                C.bc = function(n) {
                    const t = new Float64Array(9);
                    var i, a, u, p, f, g, y, S, I, A, R, N, j, $, J, se, Ae, _e;
                    A = (u = (a = n)[0]) * (y = u + u),
                    R = (p = a[1]) * y,
                    j = (f = a[2]) * y,
                    $ = f * (S = p + p),
                    se = (g = a[3]) * y,
                    Ae = g * S,
                    _e = g * (I = f + f),
                    (i = t)[0] = 1 - (N = p * S) - (J = f * I),
                    i[3] = R - _e,
                    i[6] = j + Ae,
                    i[1] = R + _e,
                    i[4] = 1 - A - J,
                    i[7] = $ - se,
                    i[2] = j - Ae,
                    i[5] = $ + se,
                    i[8] = 1 - A - N;
                    const O = br(-Math.asin(kt(t[2], -1, 1)));
                    let Y, ve;
                    return Math.hypot(t[5], t[8]) < .001 ? (Y = 0,
                    ve = -br(Math.atan2(t[3], t[4]))) : (Y = br(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])),
                    ve = br(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))),
                    {
                        roll: Y,
                        pitch: O + 90,
                        bearing: ve
                    }
                }
                ,
                C.bd = function(n, t) {
                    return n.roll == t.roll && n.pitch == t.pitch && n.bearing == t.bearing
                }
                ,
                C.be = Jr,
                C.bf = Dn,
                C.bg = Bl,
                C.bh = cu,
                C.bi = Rl,
                C.bj = ht,
                C.bk = Ft,
                C.bl = Hr,
                C.bm = function(n, t, i, a, u) {
                    return ht(a, u, kt((n - t) / (i - t), 0, 1))
                }
                ,
                C.bn = at,
                C.bo = function() {
                    return new Float64Array(3)
                }
                ,
                C.bp = function(n, t, i, a) {
                    return n[0] = t[0] + i[0] * a,
                    n[1] = t[1] + i[1] * a,
                    n[2] = t[2] + i[2] * a,
                    n
                }
                ,
                C.bq = ue,
                C.br = function(n, t, i) {
                    var a = i[0]
                      , u = i[1]
                      , p = i[2]
                      , f = t[0]
                      , g = t[1]
                      , y = t[2]
                      , S = u * y - p * g
                      , I = p * f - a * y
                      , A = a * g - u * f
                      , R = u * A - p * I
                      , N = p * S - a * A
                      , j = a * I - u * S
                      , $ = 2 * i[3];
                    return I *= $,
                    A *= $,
                    N *= 2,
                    j *= 2,
                    n[0] = f + (S *= $) + (R *= 2),
                    n[1] = g + I + N,
                    n[2] = y + A + j,
                    n
                }
                ,
                C.bs = function(n, t, i) {
                    const a = (u = [n[0], n[1], n[2], t[0], t[1], t[2], i[0], i[1], i[2]])[0] * ((I = u[8]) * (f = u[4]) - (g = u[5]) * (S = u[7])) + u[1] * (-I * (p = u[3]) + g * (y = u[6])) + u[2] * (S * p - f * y);
                    var u, p, f, g, y, S, I;
                    if (a === 0)
                        return null;
                    const A = ze([], [t[0], t[1], t[2]], [i[0], i[1], i[2]])
                      , R = ze([], [i[0], i[1], i[2]], [n[0], n[1], n[2]])
                      , N = ze([], [n[0], n[1], n[2]], [t[0], t[1], t[2]])
                      , j = ct([], A, -n[3]);
                    return dt(j, j, ct([], R, -t[3])),
                    dt(j, j, ct([], N, -i[3])),
                    ct(j, j, 1 / a),
                    j
                }
                ,
                C.bt = Xp,
                C.bu = function() {
                    return new Float64Array(4)
                }
                ,
                C.bv = function(n, t, i, a) {
                    var u = []
                      , p = [];
                    return u[0] = t[0] - i[0],
                    u[1] = t[1] - i[1],
                    u[2] = t[2] - i[2],
                    p[0] = u[0] * Math.cos(a) - u[1] * Math.sin(a),
                    p[1] = u[0] * Math.sin(a) + u[1] * Math.cos(a),
                    p[2] = u[2],
                    n[0] = p[0] + i[0],
                    n[1] = p[1] + i[1],
                    n[2] = p[2] + i[2],
                    n
                }
                ,
                C.bw = function(n, t, i, a) {
                    var u = []
                      , p = [];
                    return u[0] = t[0] - i[0],
                    u[1] = t[1] - i[1],
                    u[2] = t[2] - i[2],
                    p[0] = u[0],
                    p[1] = u[1] * Math.cos(a) - u[2] * Math.sin(a),
                    p[2] = u[1] * Math.sin(a) + u[2] * Math.cos(a),
                    n[0] = p[0] + i[0],
                    n[1] = p[1] + i[1],
                    n[2] = p[2] + i[2],
                    n
                }
                ,
                C.bx = function(n, t, i, a) {
                    var u = []
                      , p = [];
                    return u[0] = t[0] - i[0],
                    u[1] = t[1] - i[1],
                    u[2] = t[2] - i[2],
                    p[0] = u[2] * Math.sin(a) + u[0] * Math.cos(a),
                    p[1] = u[1],
                    p[2] = u[2] * Math.cos(a) - u[0] * Math.sin(a),
                    n[0] = p[0] + i[0],
                    n[1] = p[1] + i[1],
                    n[2] = p[2] + i[2],
                    n
                }
                ,
                C.by = function(n, t, i) {
                    var a = Math.sin(i)
                      , u = Math.cos(i)
                      , p = t[0]
                      , f = t[1]
                      , g = t[2]
                      , y = t[3]
                      , S = t[8]
                      , I = t[9]
                      , A = t[10]
                      , R = t[11];
                    return t !== n && (n[4] = t[4],
                    n[5] = t[5],
                    n[6] = t[6],
                    n[7] = t[7],
                    n[12] = t[12],
                    n[13] = t[13],
                    n[14] = t[14],
                    n[15] = t[15]),
                    n[0] = p * u - S * a,
                    n[1] = f * u - I * a,
                    n[2] = g * u - A * a,
                    n[3] = y * u - R * a,
                    n[8] = p * a + S * u,
                    n[9] = f * a + I * u,
                    n[10] = g * a + A * u,
                    n[11] = y * a + R * u,
                    n
                }
                ,
                C.bz = function(n, t) {
                    const i = at(n, 360)
                      , a = at(t, 360)
                      , u = a - i
                      , p = a > i ? u - 360 : u + 360;
                    return Math.abs(u) < Math.abs(p) ? u : p
                }
                ,
                C.c = be,
                C.c0 = class extends d {
                }
                ,
                C.c1 = Sp,
                C.c2 = function(n) {
                    return n <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
                }
                ,
                C.c3 = Vm,
                C.c4 = function(n, t, i) {
                    var a = t[0]
                      , u = t[1]
                      , p = t[2]
                      , f = i[3] * a + i[7] * u + i[11] * p + i[15];
                    return n[0] = (i[0] * a + i[4] * u + i[8] * p + i[12]) / (f = f || 1),
                    n[1] = (i[1] * a + i[5] * u + i[9] * p + i[13]) / f,
                    n[2] = (i[2] * a + i[6] * u + i[10] * p + i[14]) / f,
                    n
                }
                ,
                C.c5 = class extends Kc {
                }
                ,
                C.c6 = class extends L {
                }
                ,
                C.c7 = function(n, t) {
                    return n[0] === t[0] && n[1] === t[1] && n[2] === t[2] && n[3] === t[3] && n[4] === t[4] && n[5] === t[5] && n[6] === t[6] && n[7] === t[7] && n[8] === t[8] && n[9] === t[9] && n[10] === t[10] && n[11] === t[11] && n[12] === t[12] && n[13] === t[13] && n[14] === t[14] && n[15] === t[15]
                }
                ,
                C.c8 = function(n, t) {
                    var i = n[0]
                      , a = n[1]
                      , u = n[2]
                      , p = n[3]
                      , f = n[4]
                      , g = n[5]
                      , y = n[6]
                      , S = n[7]
                      , I = n[8]
                      , A = n[9]
                      , R = n[10]
                      , N = n[11]
                      , j = n[12]
                      , $ = n[13]
                      , J = n[14]
                      , se = n[15]
                      , Ae = t[0]
                      , _e = t[1]
                      , O = t[2]
                      , Y = t[3]
                      , ve = t[4]
                      , Xe = t[5]
                      , bt = t[6]
                      , Qe = t[7]
                      , ot = t[8]
                      , Et = t[9]
                      , Ct = t[10]
                      , Dt = t[11]
                      , pt = t[12]
                      , ir = t[13]
                      , Er = t[14]
                      , Cr = t[15];
                    return Math.abs(i - Ae) <= ut * Math.max(1, Math.abs(i), Math.abs(Ae)) && Math.abs(a - _e) <= ut * Math.max(1, Math.abs(a), Math.abs(_e)) && Math.abs(u - O) <= ut * Math.max(1, Math.abs(u), Math.abs(O)) && Math.abs(p - Y) <= ut * Math.max(1, Math.abs(p), Math.abs(Y)) && Math.abs(f - ve) <= ut * Math.max(1, Math.abs(f), Math.abs(ve)) && Math.abs(g - Xe) <= ut * Math.max(1, Math.abs(g), Math.abs(Xe)) && Math.abs(y - bt) <= ut * Math.max(1, Math.abs(y), Math.abs(bt)) && Math.abs(S - Qe) <= ut * Math.max(1, Math.abs(S), Math.abs(Qe)) && Math.abs(I - ot) <= ut * Math.max(1, Math.abs(I), Math.abs(ot)) && Math.abs(A - Et) <= ut * Math.max(1, Math.abs(A), Math.abs(Et)) && Math.abs(R - Ct) <= ut * Math.max(1, Math.abs(R), Math.abs(Ct)) && Math.abs(N - Dt) <= ut * Math.max(1, Math.abs(N), Math.abs(Dt)) && Math.abs(j - pt) <= ut * Math.max(1, Math.abs(j), Math.abs(pt)) && Math.abs($ - ir) <= ut * Math.max(1, Math.abs($), Math.abs(ir)) && Math.abs(J - Er) <= ut * Math.max(1, Math.abs(J), Math.abs(Er)) && Math.abs(se - Cr) <= ut * Math.max(1, Math.abs(se), Math.abs(Cr))
                }
                ,
                C.c9 = function(n, t) {
                    return n[0] = t[0],
                    n[1] = t[1],
                    n[2] = t[2],
                    n[3] = t[3],
                    n[4] = t[4],
                    n[5] = t[5],
                    n[6] = t[6],
                    n[7] = t[7],
                    n[8] = t[8],
                    n[9] = t[9],
                    n[10] = t[10],
                    n[11] = t[11],
                    n[12] = t[12],
                    n[13] = t[13],
                    n[14] = t[14],
                    n[15] = t[15],
                    n
                }
                ,
                C.cA = function(n) {
                    delete q.REGISTERED_PROTOCOLS[n]
                }
                ,
                C.cB = function(n, t) {
                    const i = {};
                    for (let u = 0; u < n.length; u++) {
                        const p = t && t[n[u].id] || xl(n[u]);
                        t && (t[n[u].id] = p);
                        let f = i[p];
                        f || (f = i[p] = []),
                        f.push(n[u])
                    }
                    const a = [];
                    for (const u in i)
                        a.push(i[u]);
                    return a
                }
                ,
                C.cC = Wt,
                C.cD = $_,
                C.cE = G_,
                C.cF = w_,
                C.cG = function(n) {
                    n.bucket.createArrays(),
                    n.bucket.tilePixelRatio = We / (512 * n.bucket.overscaling),
                    n.bucket.compareText = {},
                    n.bucket.iconsNeedLinear = !1;
                    const t = n.bucket.layers[0]
                      , i = t.layout
                      , a = t._unevaluatedLayout._values
                      , u = {
                        layoutIconSize: a["icon-size"].possiblyEvaluate(new Ei(n.bucket.zoom + 1), n.canonical),
                        layoutTextSize: a["text-size"].possiblyEvaluate(new Ei(n.bucket.zoom + 1), n.canonical),
                        textMaxSize: a["text-size"].possiblyEvaluate(new Ei(18))
                    };
                    if (n.bucket.textSizeData.kind === "composite") {
                        const {minZoom: S, maxZoom: I} = n.bucket.textSizeData;
                        u.compositeTextSizes = [a["text-size"].possiblyEvaluate(new Ei(S), n.canonical), a["text-size"].possiblyEvaluate(new Ei(I), n.canonical)]
                    }
                    if (n.bucket.iconSizeData.kind === "composite") {
                        const {minZoom: S, maxZoom: I} = n.bucket.iconSizeData;
                        u.compositeIconSizes = [a["icon-size"].possiblyEvaluate(new Ei(S), n.canonical), a["icon-size"].possiblyEvaluate(new Ei(I), n.canonical)]
                    }
                    const p = i.get("text-line-height") * un
                      , f = i.get("text-rotation-alignment") !== "viewport" && i.get("symbol-placement") !== "point"
                      , g = i.get("text-keep-upright")
                      , y = i.get("text-size");
                    for (const S of n.bucket.features) {
                        const I = i.get("text-font").evaluate(S, {}, n.canonical).join(",")
                          , A = y.evaluate(S, {}, n.canonical)
                          , R = u.layoutTextSize.evaluate(S, {}, n.canonical)
                          , N = u.layoutIconSize.evaluate(S, {}, n.canonical)
                          , j = {
                            horizontal: {},
                            vertical: void 0
                        }
                          , $ = S.text;
                        let J, se = [0, 0];
                        if ($) {
                            const O = $.toString()
                              , Y = i.get("text-letter-spacing").evaluate(S, {}, n.canonical) * un
                              , ve = Xh(O) ? Y : 0
                              , Xe = i.get("text-anchor").evaluate(S, {}, n.canonical)
                              , bt = ig(t, S, n.canonical);
                            if (!bt) {
                                const Ct = i.get("text-radial-offset").evaluate(S, {}, n.canonical);
                                se = Ct ? rg(Xe, [Ct * un, Jp]) : i.get("text-offset").evaluate(S, {}, n.canonical).map(Dt => Dt * un)
                            }
                            let Qe = f ? "center" : i.get("text-justify").evaluate(S, {}, n.canonical);
                            const ot = i.get("symbol-placement") === "point" ? i.get("text-max-width").evaluate(S, {}, n.canonical) * un : 1 / 0
                              , Et = () => {
                                n.bucket.allowVerticalPlacement && $c(O) && (j.vertical = ud($, n.glyphMap, n.glyphPositions, n.imagePositions, I, ot, p, Xe, "left", ve, se, C.an.vertical, !0, R, A))
                            }
                            ;
                            if (!f && bt) {
                                const Ct = new Set;
                                if (Qe === "auto")
                                    for (let pt = 0; pt < bt.values.length; pt += 2)
                                        Ct.add(Qp(bt.values[pt]));
                                else
                                    Ct.add(Qe);
                                let Dt = !1;
                                for (const pt of Ct)
                                    if (!j.horizontal[pt])
                                        if (Dt)
                                            j.horizontal[pt] = j.horizontal[0];
                                        else {
                                            const ir = ud($, n.glyphMap, n.glyphPositions, n.imagePositions, I, ot, p, "center", pt, ve, se, C.an.horizontal, !1, R, A);
                                            ir && (j.horizontal[pt] = ir,
                                            Dt = ir.positionedLines.length === 1)
                                        }
                                Et()
                            } else {
                                Qe === "auto" && (Qe = Qp(Xe));
                                const Ct = ud($, n.glyphMap, n.glyphPositions, n.imagePositions, I, ot, p, Xe, Qe, ve, se, C.an.horizontal, !1, R, A);
                                Ct && (j.horizontal[Qe] = Ct),
                                Et(),
                                $c(O) && f && g && (j.vertical = ud($, n.glyphMap, n.glyphPositions, n.imagePositions, I, ot, p, Xe, Qe, ve, se, C.an.vertical, !1, R, A))
                            }
                        }
                        let Ae = !1;
                        if (S.icon && S.icon.name) {
                            const O = n.imageMap[S.icon.name];
                            O && (J = J0(n.imagePositions[S.icon.name], i.get("icon-offset").evaluate(S, {}, n.canonical), i.get("icon-anchor").evaluate(S, {}, n.canonical)),
                            Ae = !!O.sdf,
                            n.bucket.sdfIcons === void 0 ? n.bucket.sdfIcons = Ae : n.bucket.sdfIcons !== Ae && Qt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),
                            (O.pixelRatio !== n.bucket.pixelRatio || i.get("icon-rotate").constantOr(1) !== 0) && (n.bucket.iconsNeedLinear = !0))
                        }
                        const _e = ag(j.horizontal) || j.vertical;
                        n.bucket.iconsInText = !!_e && _e.iconsInText,
                        (_e || J) && my(n.bucket, S, j, J, n.imageMap, u, R, N, se, Ae, n.canonical, n.subdivisionGranularity)
                    }
                    n.showCollisionBoxes && n.bucket.generateCollisionDebugBuffers()
                }
                ,
                C.cH = Fp,
                C.cI = Ep,
                C.cJ = Bp,
                C.cK = hu,
                C.cL = jp,
                C.cM = class {
                    constructor(n) {
                        this._marks = {
                            start: [n.url, "start"].join("#"),
                            end: [n.url, "end"].join("#"),
                            measure: n.url.toString()
                        },
                        performance.mark(this._marks.start)
                    }
                    finish() {
                        performance.mark(this._marks.end);
                        let n = performance.getEntriesByName(this._marks.measure);
                        return n.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end),
                        n = performance.getEntriesByName(this._marks.measure),
                        performance.clearMarks(this._marks.start),
                        performance.clearMarks(this._marks.end),
                        performance.clearMeasures(this._marks.measure)),
                        n
                    }
                }
                ,
                C.cN = function(n, t, i, a, u) {
                    return o(this, void 0, void 0, function*() {
                        if (Ze())
                            try {
                                return yield sr(n, t, i, a, u)
                            } catch {}
                        return function(p, f, g, y, S) {
                            const I = p.width
                              , A = p.height;
                            Xt && Ir || (Xt = new OffscreenCanvas(I,A),
                            Ir = Xt.getContext("2d", {
                                willReadFrequently: !0
                            })),
                            Xt.width = I,
                            Xt.height = A,
                            Ir.drawImage(p, 0, 0, I, A);
                            const R = Ir.getImageData(f, g, y, S);
                            return Ir.clearRect(0, 0, I, A),
                            R.data
                        }(n, t, i, a, u)
                    })
                }
                ,
                C.cO = Um,
                C.cP = W,
                C.cQ = de,
                C.cR = l_,
                C.cS = x_,
                C.cT = _l,
                C.cU = Xa,
                C.ca = n => n.type === "symbol",
                C.cb = n => n.type === "circle",
                C.cc = n => n.type === "heatmap",
                C.cd = n => n.type === "line",
                C.ce = n => n.type === "fill",
                C.cf = n => n.type === "fill-extrusion",
                C.cg = n => n.type === "hillshade",
                C.ch = n => n.type === "color-relief",
                C.ci = n => n.type === "raster",
                C.cj = n => n.type === "background",
                C.ck = n => n.type === "custom",
                C.cl = zt,
                C.cm = function(n, t, i) {
                    const a = Re(t.x - i.x, t.y - i.y)
                      , u = Re(n.x - i.x, n.y - i.y);
                    var p, f;
                    return br(Math.atan2(a[0] * u[1] - a[1] * u[0], (p = a)[0] * (f = u)[0] + p[1] * f[1]))
                }
                ,
                C.cn = lr,
                C.co = function(n, t) {
                    return Ar[t] && (n instanceof MouseEvent || n instanceof WheelEvent)
                }
                ,
                C.cp = function(n, t) {
                    return _r[t] && "touches"in n
                }
                ,
                C.cq = function(n) {
                    return _r[n] || Ar[n]
                }
                ,
                C.cr = function(n, t, i) {
                    var a = t[0]
                      , u = t[1];
                    return n[0] = i[0] * a + i[4] * u + i[12],
                    n[1] = i[1] * a + i[5] * u + i[13],
                    n
                }
                ,
                C.cs = function(n, t) {
                    const {x: i, y: a} = _u.fromLngLat(t);
                    return !(n < 0 || n > 25 || a < 0 || a >= 1 || i < 0 || i >= 1)
                }
                ,
                C.ct = function(n, t) {
                    return n[0] = t[0],
                    n[1] = 0,
                    n[2] = 0,
                    n[3] = 0,
                    n[4] = 0,
                    n[5] = t[1],
                    n[6] = 0,
                    n[7] = 0,
                    n[8] = 0,
                    n[9] = 0,
                    n[10] = t[2],
                    n[11] = 0,
                    n[12] = 0,
                    n[13] = 0,
                    n[14] = 0,
                    n[15] = 1,
                    n
                }
                ,
                C.cu = class extends Ya {
                }
                ,
                C.cv = gy,
                C.cx = function(n) {
                    return n.message === Tr
                }
                ,
                C.cy = ae,
                C.cz = function(n, t) {
                    q.REGISTERED_PROTOCOLS[n] = t
                }
                ,
                C.d = ke,
                C.e = Pt,
                C.f = n => o(void 0, void 0, void 0, function*() {
                    if (n.byteLength === 0)
                        return createImageBitmap(new ImageData(1,1));
                    const t = new Blob([new Uint8Array(n)],{
                        type: "image/png"
                    });
                    try {
                        return createImageBitmap(t)
                    } catch (i) {
                        throw new Error(`Could not load image because of ${i.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)
                    }
                }),
                C.g = V,
                C.h = n => new Promise( (t, i) => {
                    const a = new Image;
                    a.onload = () => {
                        t(a),
                        URL.revokeObjectURL(a.src),
                        a.onload = null,
                        window.requestAnimationFrame( () => {
                            a.src = Mr
                        }
                        )
                    }
                    ,
                    a.onerror = () => i(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                    const u = new Blob([new Uint8Array(n)],{
                        type: "image/png"
                    });
                    a.src = n.byteLength ? URL.createObjectURL(u) : Mr
                }
                ),
                C.i = tr,
                C.j = (n, t) => Me(Pt(n, {
                    type: "json"
                }), t),
                C.k = Ee,
                C.l = Oe,
                C.m = Me,
                C.n = (n, t) => Me(Pt(n, {
                    type: "arrayBuffer"
                }), t),
                C.o = function(n) {
                    return new jp(n).readFields(q0, [])
                }
                ,
                C.p = b_,
                C.q = nu,
                C.r = Ln,
                C.s = mr,
                C.t = Wc,
                C.u = ti,
                C.v = ye,
                C.w = Qt,
                C.x = pp,
                C.y = ko,
                C.z = Ws
            }),
            E("worker", ["./shared"], function(C) {
                class o {
                    constructor(q) {
                        this.keyCache = {},
                        q && this.replace(q)
                    }
                    replace(q) {
                        this._layerConfigs = {},
                        this._layers = {},
                        this.update(q, [])
                    }
                    update(q, V) {
                        for (const ae of q) {
                            this._layerConfigs[ae.id] = ae;
                            const we = this._layers[ae.id] = C.bI(ae);
                            we._featureFilter = C.a9(we.filter),
                            this.keyCache[ae.id] && delete this.keyCache[ae.id]
                        }
                        for (const ae of V)
                            delete this.keyCache[ae],
                            delete this._layerConfigs[ae],
                            delete this._layers[ae];
                        this.familiesBySource = {};
                        const K = C.cB(Object.values(this._layerConfigs), this.keyCache);
                        for (const ae of K) {
                            const we = ae.map(Ee => this._layers[Ee.id])
                              , Me = we[0];
                            if (Me.visibility === "none")
                                continue;
                            const ke = Me.source || "";
                            let ge = this.familiesBySource[ke];
                            ge || (ge = this.familiesBySource[ke] = {});
                            const je = Me.sourceLayer || "_geojsonTileLayer";
                            let Oe = ge[je];
                            Oe || (Oe = ge[je] = []),
                            Oe.push(we)
                        }
                    }
                }
                class W {
                    constructor(q) {
                        const V = {}
                          , K = [];
                        for (const ke in q) {
                            const ge = q[ke]
                              , je = V[ke] = {};
                            for (const Oe in ge) {
                                const Ee = ge[+Oe];
                                if (!Ee || Ee.bitmap.width === 0 || Ee.bitmap.height === 0)
                                    continue;
                                const Ke = {
                                    x: 0,
                                    y: 0,
                                    w: Ee.bitmap.width + 2,
                                    h: Ee.bitmap.height + 2
                                };
                                K.push(Ke),
                                je[Oe] = {
                                    rect: Ke,
                                    metrics: Ee.metrics
                                }
                            }
                        }
                        const {w: ae, h: we} = C.p(K)
                          , Me = new C.q({
                            width: ae || 1,
                            height: we || 1
                        });
                        for (const ke in q) {
                            const ge = q[ke];
                            for (const je in ge) {
                                const Oe = ge[+je];
                                if (!Oe || Oe.bitmap.width === 0 || Oe.bitmap.height === 0)
                                    continue;
                                const Ee = V[ke][je].rect;
                                C.q.copy(Oe.bitmap, Me, {
                                    x: 0,
                                    y: 0
                                }, {
                                    x: Ee.x + 1,
                                    y: Ee.y + 1
                                }, Oe.bitmap)
                            }
                        }
                        this.image = Me,
                        this.positions = V
                    }
                }
                C.cC("GlyphAtlas", W);
                class G {
                    constructor(q) {
                        this.tileID = new C.Z(q.tileID.overscaledZ,q.tileID.wrap,q.tileID.canonical.z,q.tileID.canonical.x,q.tileID.canonical.y),
                        this.uid = q.uid,
                        this.zoom = q.zoom,
                        this.pixelRatio = q.pixelRatio,
                        this.tileSize = q.tileSize,
                        this.source = q.source,
                        this.overscaling = this.tileID.overscaleFactor(),
                        this.showCollisionBoxes = q.showCollisionBoxes,
                        this.collectResourceTiming = !!q.collectResourceTiming,
                        this.returnDependencies = !!q.returnDependencies,
                        this.promoteId = q.promoteId,
                        this.inFlightDependencies = [],
                        this.globalState = q.globalState
                    }
                    parse(q, V, K, ae, we) {
                        return C._(this, void 0, void 0, function*() {
                            this.status = "parsing",
                            this.data = q,
                            this.collisionBoxArray = new C.a7;
                            const Me = new C.cD(Object.keys(q.layers).sort())
                              , ke = new C.cE(this.tileID,this.promoteId);
                            ke.bucketLayerIDs = [];
                            const ge = {}
                              , je = {
                                featureIndex: ke,
                                iconDependencies: {},
                                patternDependencies: {},
                                glyphDependencies: {},
                                availableImages: K,
                                subdivisionGranularity: we
                            }
                              , Oe = V.familiesBySource[this.source];
                            for (const Mt in Oe) {
                                const Gt = q.layers[Mt];
                                if (!Gt)
                                    continue;
                                Gt.version === 1 && C.w(`Vector tile source "${this.source}" layer "${Mt}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                                const Fr = Me.encode(Mt)
                                  , ft = [];
                                for (let Br = 0; Br < Gt.length; Br++) {
                                    const Ur = Gt.feature(Br)
                                      , Si = ke.getId(Ur, Mt);
                                    ft.push({
                                        feature: Ur,
                                        id: Si,
                                        index: Br,
                                        sourceLayerIndex: Fr
                                    })
                                }
                                for (const Br of Oe[Mt]) {
                                    const Ur = Br[0];
                                    Ur.source !== this.source && C.w(`layer.source = ${Ur.source} does not equal this.source = ${this.source}`),
                                    Ur.minzoom && this.zoom < Math.floor(Ur.minzoom) || Ur.maxzoom && this.zoom >= Ur.maxzoom || Ur.visibility !== "none" && (re(Br, this.zoom, K),
                                    (ge[Ur.id] = Ur.createBucket({
                                        index: ke.bucketLayerIDs.length,
                                        layers: Br,
                                        zoom: this.zoom,
                                        pixelRatio: this.pixelRatio,
                                        overscaling: this.overscaling,
                                        collisionBoxArray: this.collisionBoxArray,
                                        sourceLayerIndex: Fr,
                                        sourceID: this.source,
                                        globalState: this.globalState
                                    })).populate(ft, je, this.tileID.canonical),
                                    ke.bucketLayerIDs.push(Br.map(Si => Si.id)))
                                }
                            }
                            const Ee = C.bM(je.glyphDependencies, Mt => Object.keys(Mt).map(Number));
                            this.inFlightDependencies.forEach(Mt => Mt == null ? void 0 : Mt.abort()),
                            this.inFlightDependencies = [];
                            let Ke = Promise.resolve({});
                            if (Object.keys(Ee).length) {
                                const Mt = new AbortController;
                                this.inFlightDependencies.push(Mt),
                                Ke = ae.sendAsync({
                                    type: "GG",
                                    data: {
                                        stacks: Ee,
                                        source: this.source,
                                        tileID: this.tileID,
                                        type: "glyphs"
                                    }
                                }, Mt)
                            }
                            const ye = Object.keys(je.iconDependencies);
                            let It = Promise.resolve({});
                            if (ye.length) {
                                const Mt = new AbortController;
                                this.inFlightDependencies.push(Mt),
                                It = ae.sendAsync({
                                    type: "GI",
                                    data: {
                                        icons: ye,
                                        source: this.source,
                                        tileID: this.tileID,
                                        type: "icons"
                                    }
                                }, Mt)
                            }
                            const Kt = Object.keys(je.patternDependencies);
                            let Bt = Promise.resolve({});
                            if (Kt.length) {
                                const Mt = new AbortController;
                                this.inFlightDependencies.push(Mt),
                                Bt = ae.sendAsync({
                                    type: "GI",
                                    data: {
                                        icons: Kt,
                                        source: this.source,
                                        tileID: this.tileID,
                                        type: "patterns"
                                    }
                                }, Mt)
                            }
                            const [Ut,wr,ci] = yield Promise.all([Ke, It, Bt])
                              , Yr = new W(Ut)
                              , yt = new C.cF(wr,ci);
                            for (const Mt in ge) {
                                const Gt = ge[Mt];
                                Gt instanceof C.a8 ? (re(Gt.layers, this.zoom, K),
                                C.cG({
                                    bucket: Gt,
                                    glyphMap: Ut,
                                    glyphPositions: Yr.positions,
                                    imageMap: wr,
                                    imagePositions: yt.iconPositions,
                                    showCollisionBoxes: this.showCollisionBoxes,
                                    canonical: this.tileID.canonical,
                                    subdivisionGranularity: je.subdivisionGranularity
                                })) : Gt.hasPattern && (Gt instanceof C.cH || Gt instanceof C.cI || Gt instanceof C.cJ) && (re(Gt.layers, this.zoom, K),
                                Gt.addFeatures(je, this.tileID.canonical, yt.patternPositions))
                            }
                            return this.status = "done",
                            {
                                buckets: Object.values(ge).filter(Mt => !Mt.isEmpty()),
                                featureIndex: ke,
                                collisionBoxArray: this.collisionBoxArray,
                                glyphAtlasImage: Yr.image,
                                imageAtlas: yt,
                                glyphMap: this.returnDependencies ? Ut : null,
                                iconMap: this.returnDependencies ? wr : null,
                                glyphPositions: this.returnDependencies ? Yr.positions : null
                            }
                        })
                    }
                }
                function re(be, q, V) {
                    const K = new C.F(q);
                    for (const ae of be)
                        ae.recalculate(K, V)
                }
                class de {
                    constructor(q, V, K) {
                        this.actor = q,
                        this.layerIndex = V,
                        this.availableImages = K,
                        this.fetching = {},
                        this.loading = {},
                        this.loaded = {}
                    }
                    loadVectorTile(q, V) {
                        return C._(this, void 0, void 0, function*() {
                            const K = yield C.n(q.request, V);
                            try {
                                return {
                                    vectorTile: new C.cK.VectorTile(new C.cL(K.data)),
                                    rawData: K.data,
                                    cacheControl: K.cacheControl,
                                    expires: K.expires
                                }
                            } catch (ae) {
                                const we = new Uint8Array(K.data);
                                let Me = `Unable to parse the tile at ${q.request.url}, `;
                                throw Me += we[0] === 31 && we[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${ae.message}`,
                                new Error(Me)
                            }
                        })
                    }
                    loadTile(q) {
                        return C._(this, void 0, void 0, function*() {
                            const V = q.uid
                              , K = !!(q && q.request && q.request.collectResourceTiming) && new C.cM(q.request)
                              , ae = new G(q);
                            this.loading[V] = ae;
                            const we = new AbortController;
                            ae.abort = we;
                            try {
                                const Me = yield this.loadVectorTile(q, we);
                                if (delete this.loading[V],
                                !Me)
                                    return null;
                                const ke = Me.rawData
                                  , ge = {};
                                Me.expires && (ge.expires = Me.expires),
                                Me.cacheControl && (ge.cacheControl = Me.cacheControl);
                                const je = {};
                                if (K) {
                                    const Ee = K.finish();
                                    Ee && (je.resourceTiming = JSON.parse(JSON.stringify(Ee)))
                                }
                                ae.vectorTile = Me.vectorTile;
                                const Oe = ae.parse(Me.vectorTile, this.layerIndex, this.availableImages, this.actor, q.subdivisionGranularity);
                                this.loaded[V] = ae,
                                this.fetching[V] = {
                                    rawTileData: ke,
                                    cacheControl: ge,
                                    resourceTiming: je
                                };
                                try {
                                    const Ee = yield Oe;
                                    return C.e({
                                        rawTileData: ke.slice(0)
                                    }, Ee, ge, je)
                                } finally {
                                    delete this.fetching[V]
                                }
                            } catch (Me) {
                                throw delete this.loading[V],
                                ae.status = "done",
                                this.loaded[V] = ae,
                                Me
                            }
                        })
                    }
                    reloadTile(q) {
                        return C._(this, void 0, void 0, function*() {
                            const V = q.uid;
                            if (!this.loaded || !this.loaded[V])
                                throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
                            const K = this.loaded[V];
                            if (K.showCollisionBoxes = q.showCollisionBoxes,
                            K.globalState = q.globalState,
                            K.status === "parsing") {
                                const ae = yield K.parse(K.vectorTile, this.layerIndex, this.availableImages, this.actor, q.subdivisionGranularity);
                                let we;
                                if (this.fetching[V]) {
                                    const {rawTileData: Me, cacheControl: ke, resourceTiming: ge} = this.fetching[V];
                                    delete this.fetching[V],
                                    we = C.e({
                                        rawTileData: Me.slice(0)
                                    }, ae, ke, ge)
                                } else
                                    we = ae;
                                return we
                            }
                            if (K.status === "done" && K.vectorTile)
                                return K.parse(K.vectorTile, this.layerIndex, this.availableImages, this.actor, q.subdivisionGranularity)
                        })
                    }
                    abortTile(q) {
                        return C._(this, void 0, void 0, function*() {
                            const V = this.loading
                              , K = q.uid;
                            V && V[K] && V[K].abort && (V[K].abort.abort(),
                            delete V[K])
                        })
                    }
                    removeTile(q) {
                        return C._(this, void 0, void 0, function*() {
                            this.loaded && this.loaded[q.uid] && delete this.loaded[q.uid]
                        })
                    }
                }
                class he {
                    constructor() {
                        this.loaded = {}
                    }
                    loadTile(q) {
                        return C._(this, void 0, void 0, function*() {
                            const {uid: V, encoding: K, rawImageData: ae, redFactor: we, greenFactor: Me, blueFactor: ke, baseShift: ge} = q
                              , je = ae.width + 2
                              , Oe = ae.height + 2
                              , Ee = C.b(ae) ? new C.R({
                                width: je,
                                height: Oe
                            },yield C.cN(ae, -1, -1, je, Oe)) : ae
                              , Ke = new C.cO(V,Ee,K,we,Me,ke,ge);
                            return this.loaded = this.loaded || {},
                            this.loaded[V] = Ke,
                            Ke
                        })
                    }
                    removeTile(q) {
                        const V = this.loaded
                          , K = q.uid;
                        V && V[K] && delete V[K]
                    }
                }
                var X, le, Se = function() {
                    if (le)
                        return X;
                    function be(V, K) {
                        if (V.length !== 0) {
                            q(V[0], K);
                            for (var ae = 1; ae < V.length; ae++)
                                q(V[ae], !K)
                        }
                    }
                    function q(V, K) {
                        for (var ae = 0, we = 0, Me = 0, ke = V.length, ge = ke - 1; Me < ke; ge = Me++) {
                            var je = (V[Me][0] - V[ge][0]) * (V[ge][1] + V[Me][1])
                              , Oe = ae + je;
                            we += Math.abs(ae) >= Math.abs(je) ? ae - Oe + je : je - Oe + ae,
                            ae = Oe
                        }
                        ae + we >= 0 != !!K && V.reverse()
                    }
                    return le = 1,
                    X = function V(K, ae) {
                        var we, Me = K && K.type;
                        if (Me === "FeatureCollection")
                            for (we = 0; we < K.features.length; we++)
                                V(K.features[we], ae);
                        else if (Me === "GeometryCollection")
                            for (we = 0; we < K.geometries.length; we++)
                                V(K.geometries[we], ae);
                        else if (Me === "Feature")
                            V(K.geometry, ae);
                        else if (Me === "Polygon")
                            be(K.coordinates, ae);
                        else if (Me === "MultiPolygon")
                            for (we = 0; we < K.coordinates.length; we++)
                                be(K.coordinates[we], ae);
                        return K
                    }
                }(), Ie = C.cP(Se);
                const De = C.cK.VectorTileFeature.prototype.toGeoJSON;
                class qe {
                    constructor(q) {
                        this._feature = q,
                        this.extent = C.$,
                        this.type = q.type,
                        this.properties = q.tags,
                        "id"in q && !isNaN(q.id) && (this.id = parseInt(q.id, 10))
                    }
                    loadGeometry() {
                        if (this._feature.type === 1) {
                            const q = [];
                            for (const V of this._feature.geometry)
                                q.push([new C.P(V[0],V[1])]);
                            return q
                        }
                        {
                            const q = [];
                            for (const V of this._feature.geometry) {
                                const K = [];
                                for (const ae of V)
                                    K.push(new C.P(ae[0],ae[1]));
                                q.push(K)
                            }
                            return q
                        }
                    }
                    toGeoJSON(q, V, K) {
                        return De.call(this, q, V, K)
                    }
                }
                class Ne {
                    constructor(q) {
                        this.layers = {
                            _geojsonTileLayer: this
                        },
                        this.name = "_geojsonTileLayer",
                        this.extent = C.$,
                        this.length = q.length,
                        this._features = q
                    }
                    feature(q) {
                        return new qe(this._features[q])
                    }
                }
                var Ze, ut, rt, Ue = {
                    exports: {}
                }, lt = function() {
                    if (rt)
                        return Ue.exports;
                    rt = 1;
                    var be = C.cS()
                      , q = function() {
                        if (ut)
                            return Ze;
                        ut = 1;
                        var Oe = C.cQ()
                          , Ee = C.cR().VectorTileFeature;
                        function Ke(It, Kt) {
                            this.options = Kt || {},
                            this.features = It,
                            this.length = It.length
                        }
                        function ye(It, Kt) {
                            this.id = typeof It.id == "number" ? It.id : void 0,
                            this.type = It.type,
                            this.rawGeometry = It.type === 1 ? [It.geometry] : It.geometry,
                            this.properties = It.tags,
                            this.extent = Kt || 4096
                        }
                        return Ze = Ke,
                        Ke.prototype.feature = function(It) {
                            return new ye(this.features[It],this.options.extent)
                        }
                        ,
                        ye.prototype.loadGeometry = function() {
                            var It = this.rawGeometry;
                            this.geometry = [];
                            for (var Kt = 0; Kt < It.length; Kt++) {
                                for (var Bt = It[Kt], Ut = [], wr = 0; wr < Bt.length; wr++)
                                    Ut.push(new Oe(Bt[wr][0],Bt[wr][1]));
                                this.geometry.push(Ut)
                            }
                            return this.geometry
                        }
                        ,
                        ye.prototype.bbox = function() {
                            this.geometry || this.loadGeometry();
                            for (var It = this.geometry, Kt = 1 / 0, Bt = -1 / 0, Ut = 1 / 0, wr = -1 / 0, ci = 0; ci < It.length; ci++)
                                for (var Yr = It[ci], yt = 0; yt < Yr.length; yt++) {
                                    var Mt = Yr[yt];
                                    Kt = Math.min(Kt, Mt.x),
                                    Bt = Math.max(Bt, Mt.x),
                                    Ut = Math.min(Ut, Mt.y),
                                    wr = Math.max(wr, Mt.y)
                                }
                            return [Kt, Ut, Bt, wr]
                        }
                        ,
                        ye.prototype.toGeoJSON = Ee.prototype.toGeoJSON,
                        Ze
                    }();
                    function V(Oe) {
                        var Ee = new be;
                        return function(Ke, ye) {
                            for (var It in Ke.layers)
                                ye.writeMessage(3, K, Ke.layers[It])
                        }(Oe, Ee),
                        Ee.finish()
                    }
                    function K(Oe, Ee) {
                        var Ke;
                        Ee.writeVarintField(15, Oe.version || 1),
                        Ee.writeStringField(1, Oe.name || ""),
                        Ee.writeVarintField(5, Oe.extent || 4096);
                        var ye = {
                            keys: [],
                            values: [],
                            keycache: {},
                            valuecache: {}
                        };
                        for (Ke = 0; Ke < Oe.length; Ke++)
                            ye.feature = Oe.feature(Ke),
                            Ee.writeMessage(2, ae, ye);
                        var It = ye.keys;
                        for (Ke = 0; Ke < It.length; Ke++)
                            Ee.writeStringField(3, It[Ke]);
                        var Kt = ye.values;
                        for (Ke = 0; Ke < Kt.length; Ke++)
                            Ee.writeMessage(4, je, Kt[Ke])
                    }
                    function ae(Oe, Ee) {
                        var Ke = Oe.feature;
                        Ke.id !== void 0 && Ee.writeVarintField(1, Ke.id),
                        Ee.writeMessage(2, we, Oe),
                        Ee.writeVarintField(3, Ke.type),
                        Ee.writeMessage(4, ge, Ke)
                    }
                    function we(Oe, Ee) {
                        var Ke = Oe.feature
                          , ye = Oe.keys
                          , It = Oe.values
                          , Kt = Oe.keycache
                          , Bt = Oe.valuecache;
                        for (var Ut in Ke.properties) {
                            var wr = Ke.properties[Ut]
                              , ci = Kt[Ut];
                            if (wr !== null) {
                                ci === void 0 && (ye.push(Ut),
                                Kt[Ut] = ci = ye.length - 1),
                                Ee.writeVarint(ci);
                                var Yr = typeof wr;
                                Yr !== "string" && Yr !== "boolean" && Yr !== "number" && (wr = JSON.stringify(wr));
                                var yt = Yr + ":" + wr
                                  , Mt = Bt[yt];
                                Mt === void 0 && (It.push(wr),
                                Bt[yt] = Mt = It.length - 1),
                                Ee.writeVarint(Mt)
                            }
                        }
                    }
                    function Me(Oe, Ee) {
                        return (Ee << 3) + (7 & Oe)
                    }
                    function ke(Oe) {
                        return Oe << 1 ^ Oe >> 31
                    }
                    function ge(Oe, Ee) {
                        for (var Ke = Oe.loadGeometry(), ye = Oe.type, It = 0, Kt = 0, Bt = Ke.length, Ut = 0; Ut < Bt; Ut++) {
                            var wr = Ke[Ut]
                              , ci = 1;
                            ye === 1 && (ci = wr.length),
                            Ee.writeVarint(Me(1, ci));
                            for (var Yr = ye === 3 ? wr.length - 1 : wr.length, yt = 0; yt < Yr; yt++) {
                                yt === 1 && ye !== 1 && Ee.writeVarint(Me(2, Yr - 1));
                                var Mt = wr[yt].x - It
                                  , Gt = wr[yt].y - Kt;
                                Ee.writeVarint(ke(Mt)),
                                Ee.writeVarint(ke(Gt)),
                                It += Mt,
                                Kt += Gt
                            }
                            ye === 3 && Ee.writeVarint(Me(7, 1))
                        }
                    }
                    function je(Oe, Ee) {
                        var Ke = typeof Oe;
                        Ke === "string" ? Ee.writeStringField(1, Oe) : Ke === "boolean" ? Ee.writeBooleanField(7, Oe) : Ke === "number" && (Oe % 1 != 0 ? Ee.writeDoubleField(3, Oe) : Oe < 0 ? Ee.writeSVarintField(6, Oe) : Ee.writeVarintField(5, Oe))
                    }
                    return Ue.exports = V,
                    Ue.exports.fromVectorTileJs = V,
                    Ue.exports.fromGeojsonVt = function(Oe, Ee) {
                        Ee = Ee || {};
                        var Ke = {};
                        for (var ye in Oe)
                            Ke[ye] = new q(Oe[ye].features,Ee),
                            Ke[ye].name = ye,
                            Ke[ye].version = Ee.version,
                            Ke[ye].extent = Ee.extent;
                        return V({
                            layers: Ke
                        })
                    }
                    ,
                    Ue.exports.GeoJSONWrapper = q,
                    Ue.exports
                }(), et = C.cP(lt);
                const Ve = {
                    minZoom: 0,
                    maxZoom: 16,
                    minPoints: 2,
                    radius: 40,
                    extent: 512,
                    nodeSize: 64,
                    log: !1,
                    generateId: !1,
                    reduce: null,
                    map: be => be
                }
                  , gt = Math.fround || (dt = new Float32Array(1),
                be => (dt[0] = +be,
                dt[0]));
                var dt;
                class ct {
                    constructor(q) {
                        this.options = Object.assign(Object.create(Ve), q),
                        this.trees = new Array(this.options.maxZoom + 1),
                        this.stride = this.options.reduce ? 7 : 6,
                        this.clusterProps = []
                    }
                    load(q) {
                        const {log: V, minZoom: K, maxZoom: ae} = this.options;
                        V && console.time("total time");
                        const we = `prepare ${q.length} points`;
                        V && console.time(we),
                        this.points = q;
                        const Me = [];
                        for (let ge = 0; ge < q.length; ge++) {
                            const je = q[ge];
                            if (!je.geometry)
                                continue;
                            const [Oe,Ee] = je.geometry.coordinates
                              , Ke = gt(Q(Oe))
                              , ye = gt(ie(Ee));
                            Me.push(Ke, ye, 1 / 0, ge, -1, 1),
                            this.options.reduce && Me.push(0)
                        }
                        let ke = this.trees[ae + 1] = this._createTree(Me);
                        V && console.timeEnd(we);
                        for (let ge = ae; ge >= K; ge--) {
                            const je = +Date.now();
                            ke = this.trees[ge] = this._createTree(this._cluster(ke, ge)),
                            V && console.log("z%d: %d clusters in %dms", ge, ke.numItems, +Date.now() - je)
                        }
                        return V && console.timeEnd("total time"),
                        this
                    }
                    getClusters(q, V) {
                        let K = ((q[0] + 180) % 360 + 360) % 360 - 180;
                        const ae = Math.max(-90, Math.min(90, q[1]));
                        let we = q[2] === 180 ? 180 : ((q[2] + 180) % 360 + 360) % 360 - 180;
                        const Me = Math.max(-90, Math.min(90, q[3]));
                        if (q[2] - q[0] >= 360)
                            K = -180,
                            we = 180;
                        else if (K > we) {
                            const Ee = this.getClusters([K, ae, 180, Me], V)
                              , Ke = this.getClusters([-180, ae, we, Me], V);
                            return Ee.concat(Ke)
                        }
                        const ke = this.trees[this._limitZoom(V)]
                          , ge = ke.range(Q(K), ie(Me), Q(we), ie(ae))
                          , je = ke.data
                          , Oe = [];
                        for (const Ee of ge) {
                            const Ke = this.stride * Ee;
                            Oe.push(je[Ke + 5] > 1 ? ze(je, Ke, this.clusterProps) : this.points[je[Ke + 3]])
                        }
                        return Oe
                    }
                    getChildren(q) {
                        const V = this._getOriginId(q)
                          , K = this._getOriginZoom(q)
                          , ae = "No cluster with the specified id."
                          , we = this.trees[K];
                        if (!we)
                            throw new Error(ae);
                        const Me = we.data;
                        if (V * this.stride >= Me.length)
                            throw new Error(ae);
                        const ke = this.options.radius / (this.options.extent * Math.pow(2, K - 1))
                          , ge = we.within(Me[V * this.stride], Me[V * this.stride + 1], ke)
                          , je = [];
                        for (const Oe of ge) {
                            const Ee = Oe * this.stride;
                            Me[Ee + 4] === q && je.push(Me[Ee + 5] > 1 ? ze(Me, Ee, this.clusterProps) : this.points[Me[Ee + 3]])
                        }
                        if (je.length === 0)
                            throw new Error(ae);
                        return je
                    }
                    getLeaves(q, V, K) {
                        const ae = [];
                        return this._appendLeaves(ae, q, V = V || 10, K = K || 0, 0),
                        ae
                    }
                    getTile(q, V, K) {
                        const ae = this.trees[this._limitZoom(q)]
                          , we = Math.pow(2, q)
                          , {extent: Me, radius: ke} = this.options
                          , ge = ke / Me
                          , je = (K - ge) / we
                          , Oe = (K + 1 + ge) / we
                          , Ee = {
                            features: []
                        };
                        return this._addTileFeatures(ae.range((V - ge) / we, je, (V + 1 + ge) / we, Oe), ae.data, V, K, we, Ee),
                        V === 0 && this._addTileFeatures(ae.range(1 - ge / we, je, 1, Oe), ae.data, we, K, we, Ee),
                        V === we - 1 && this._addTileFeatures(ae.range(0, je, ge / we, Oe), ae.data, -1, K, we, Ee),
                        Ee.features.length ? Ee : null
                    }
                    getClusterExpansionZoom(q) {
                        let V = this._getOriginZoom(q) - 1;
                        for (; V <= this.options.maxZoom; ) {
                            const K = this.getChildren(q);
                            if (V++,
                            K.length !== 1)
                                break;
                            q = K[0].properties.cluster_id
                        }
                        return V
                    }
                    _appendLeaves(q, V, K, ae, we) {
                        const Me = this.getChildren(V);
                        for (const ke of Me) {
                            const ge = ke.properties;
                            if (ge && ge.cluster ? we + ge.point_count <= ae ? we += ge.point_count : we = this._appendLeaves(q, ge.cluster_id, K, ae, we) : we < ae ? we++ : q.push(ke),
                            q.length === K)
                                break
                        }
                        return we
                    }
                    _createTree(q) {
                        const V = new C.aH(q.length / this.stride | 0,this.options.nodeSize,Float32Array);
                        for (let K = 0; K < q.length; K += this.stride)
                            V.add(q[K], q[K + 1]);
                        return V.finish(),
                        V.data = q,
                        V
                    }
                    _addTileFeatures(q, V, K, ae, we, Me) {
                        for (const ke of q) {
                            const ge = ke * this.stride
                              , je = V[ge + 5] > 1;
                            let Oe, Ee, Ke;
                            if (je)
                                Oe = vt(V, ge, this.clusterProps),
                                Ee = V[ge],
                                Ke = V[ge + 1];
                            else {
                                const Kt = this.points[V[ge + 3]];
                                Oe = Kt.properties;
                                const [Bt,Ut] = Kt.geometry.coordinates;
                                Ee = Q(Bt),
                                Ke = ie(Ut)
                            }
                            const ye = {
                                type: 1,
                                geometry: [[Math.round(this.options.extent * (Ee * we - K)), Math.round(this.options.extent * (Ke * we - ae))]],
                                tags: Oe
                            };
                            let It;
                            It = je || this.options.generateId ? V[ge + 3] : this.points[V[ge + 3]].id,
                            It !== void 0 && (ye.id = It),
                            Me.features.push(ye)
                        }
                    }
                    _limitZoom(q) {
                        return Math.max(this.options.minZoom, Math.min(Math.floor(+q), this.options.maxZoom + 1))
                    }
                    _cluster(q, V) {
                        const {radius: K, extent: ae, reduce: we, minPoints: Me} = this.options
                          , ke = K / (ae * Math.pow(2, V))
                          , ge = q.data
                          , je = []
                          , Oe = this.stride;
                        for (let Ee = 0; Ee < ge.length; Ee += Oe) {
                            if (ge[Ee + 2] <= V)
                                continue;
                            ge[Ee + 2] = V;
                            const Ke = ge[Ee]
                              , ye = ge[Ee + 1]
                              , It = q.within(ge[Ee], ge[Ee + 1], ke)
                              , Kt = ge[Ee + 5];
                            let Bt = Kt;
                            for (const Ut of It) {
                                const wr = Ut * Oe;
                                ge[wr + 2] > V && (Bt += ge[wr + 5])
                            }
                            if (Bt > Kt && Bt >= Me) {
                                let Ut, wr = Ke * Kt, ci = ye * Kt, Yr = -1;
                                const yt = (Ee / Oe << 5) + (V + 1) + this.points.length;
                                for (const Mt of It) {
                                    const Gt = Mt * Oe;
                                    if (ge[Gt + 2] <= V)
                                        continue;
                                    ge[Gt + 2] = V;
                                    const Fr = ge[Gt + 5];
                                    wr += ge[Gt] * Fr,
                                    ci += ge[Gt + 1] * Fr,
                                    ge[Gt + 4] = yt,
                                    we && (Ut || (Ut = this._map(ge, Ee, !0),
                                    Yr = this.clusterProps.length,
                                    this.clusterProps.push(Ut)),
                                    we(Ut, this._map(ge, Gt)))
                                }
                                ge[Ee + 4] = yt,
                                je.push(wr / Bt, ci / Bt, 1 / 0, yt, -1, Bt),
                                we && je.push(Yr)
                            } else {
                                for (let Ut = 0; Ut < Oe; Ut++)
                                    je.push(ge[Ee + Ut]);
                                if (Bt > 1)
                                    for (const Ut of It) {
                                        const wr = Ut * Oe;
                                        if (!(ge[wr + 2] <= V)) {
                                            ge[wr + 2] = V;
                                            for (let ci = 0; ci < Oe; ci++)
                                                je.push(ge[wr + ci])
                                        }
                                    }
                            }
                        }
                        return je
                    }
                    _getOriginId(q) {
                        return q - this.points.length >> 5
                    }
                    _getOriginZoom(q) {
                        return (q - this.points.length) % 32
                    }
                    _map(q, V, K) {
                        if (q[V + 5] > 1) {
                            const Me = this.clusterProps[q[V + 6]];
                            return K ? Object.assign({}, Me) : Me
                        }
                        const ae = this.points[q[V + 3]].properties
                          , we = this.options.map(ae);
                        return K && we === ae ? Object.assign({}, we) : we
                    }
                }
                function ze(be, q, V) {
                    return {
                        type: "Feature",
                        id: be[q + 3],
                        properties: vt(be, q, V),
                        geometry: {
                            type: "Point",
                            coordinates: [(K = be[q],
                            360 * (K - .5)), xe(be[q + 1])]
                        }
                    };
                    var K
                }
                function vt(be, q, V) {
                    const K = be[q + 5]
                      , ae = K >= 1e4 ? `${Math.round(K / 1e3)}k` : K >= 1e3 ? Math.round(K / 100) / 10 + "k" : K
                      , we = be[q + 6]
                      , Me = we === -1 ? {} : Object.assign({}, V[we]);
                    return Object.assign(Me, {
                        cluster: !0,
                        cluster_id: be[q + 3],
                        point_count: K,
                        point_count_abbreviated: ae
                    })
                }
                function Q(be) {
                    return be / 360 + .5
                }
                function ie(be) {
                    const q = Math.sin(be * Math.PI / 180)
                      , V = .5 - .25 * Math.log((1 + q) / (1 - q)) / Math.PI;
                    return V < 0 ? 0 : V > 1 ? 1 : V
                }
                function xe(be) {
                    const q = (180 - 360 * be) * Math.PI / 180;
                    return 360 * Math.atan(Math.exp(q)) / Math.PI - 90
                }
                function ue(be, q, V, K) {
                    let ae = K;
                    const we = q + (V - q >> 1);
                    let Me, ke = V - q;
                    const ge = be[q]
                      , je = be[q + 1]
                      , Oe = be[V]
                      , Ee = be[V + 1];
                    for (let Ke = q + 3; Ke < V; Ke += 3) {
                        const ye = Le(be[Ke], be[Ke + 1], ge, je, Oe, Ee);
                        if (ye > ae)
                            Me = Ke,
                            ae = ye;
                        else if (ye === ae) {
                            const It = Math.abs(Ke - we);
                            It < ke && (Me = Ke,
                            ke = It)
                        }
                    }
                    ae > K && (Me - q > 3 && ue(be, q, Me, K),
                    be[Me + 2] = ae,
                    V - Me > 3 && ue(be, Me, V, K))
                }
                function Le(be, q, V, K, ae, we) {
                    let Me = ae - V
                      , ke = we - K;
                    if (Me !== 0 || ke !== 0) {
                        const ge = ((be - V) * Me + (q - K) * ke) / (Me * Me + ke * ke);
                        ge > 1 ? (V = ae,
                        K = we) : ge > 0 && (V += Me * ge,
                        K += ke * ge)
                    }
                    return Me = be - V,
                    ke = q - K,
                    Me * Me + ke * ke
                }
                function Re(be, q, V, K) {
                    const ae = {
                        id: be ?? null,
                        type: q,
                        geometry: V,
                        tags: K,
                        minX: 1 / 0,
                        minY: 1 / 0,
                        maxX: -1 / 0,
                        maxY: -1 / 0
                    };
                    if (q === "Point" || q === "MultiPoint" || q === "LineString")
                        We(ae, V);
                    else if (q === "Polygon")
                        We(ae, V[0]);
                    else if (q === "MultiLineString")
                        for (const we of V)
                            We(ae, we);
                    else if (q === "MultiPolygon")
                        for (const we of V)
                            We(ae, we[0]);
                    return ae
                }
                function We(be, q) {
                    for (let V = 0; V < q.length; V += 3)
                        be.minX = Math.min(be.minX, q[V]),
                        be.minY = Math.min(be.minY, q[V + 1]),
                        be.maxX = Math.max(be.maxX, q[V]),
                        be.maxY = Math.max(be.maxY, q[V + 1])
                }
                function it(be, q, V, K) {
                    if (!q.geometry)
                        return;
                    const ae = q.geometry.coordinates;
                    if (ae && ae.length === 0)
                        return;
                    const we = q.geometry.type
                      , Me = Math.pow(V.tolerance / ((1 << V.maxZoom) * V.extent), 2);
                    let ke = []
                      , ge = q.id;
                    if (V.promoteId ? ge = q.properties[V.promoteId] : V.generateId && (ge = K || 0),
                    we === "Point")
                        at(ae, ke);
                    else if (we === "MultiPoint")
                        for (const je of ae)
                            at(je, ke);
                    else if (we === "LineString")
                        ht(ae, ke, Me, !1);
                    else if (we === "MultiLineString") {
                        if (V.lineMetrics) {
                            for (const je of ae)
                                ke = [],
                                ht(je, ke, Me, !1),
                                be.push(Re(ge, "LineString", ke, q.properties));
                            return
                        }
                        Ft(ae, ke, Me, !1)
                    } else if (we === "Polygon")
                        Ft(ae, ke, Me, !0);
                    else {
                        if (we !== "MultiPolygon") {
                            if (we === "GeometryCollection") {
                                for (const je of q.geometry.geometries)
                                    it(be, {
                                        id: ge,
                                        geometry: je,
                                        properties: q.properties
                                    }, V, K);
                                return
                            }
                            throw new Error("Input data is not a valid GeoJSON object.")
                        }
                        for (const je of ae) {
                            const Oe = [];
                            Ft(je, Oe, Me, !0),
                            ke.push(Oe)
                        }
                    }
                    be.push(Re(ge, we, ke, q.properties))
                }
                function at(be, q) {
                    q.push(zt(be[0]), lr(be[1]), 0)
                }
                function ht(be, q, V, K) {
                    let ae, we, Me = 0;
                    for (let ge = 0; ge < be.length; ge++) {
                        const je = zt(be[ge][0])
                          , Oe = lr(be[ge][1]);
                        q.push(je, Oe, 0),
                        ge > 0 && (Me += K ? (ae * Oe - je * we) / 2 : Math.sqrt(Math.pow(je - ae, 2) + Math.pow(Oe - we, 2))),
                        ae = je,
                        we = Oe
                    }
                    const ke = q.length - 3;
                    q[2] = 1,
                    ue(q, 0, ke, V),
                    q[ke + 2] = 1,
                    q.size = Math.abs(Me),
                    q.start = 0,
                    q.end = q.size
                }
                function Ft(be, q, V, K) {
                    for (let ae = 0; ae < be.length; ae++) {
                        const we = [];
                        ht(be[ae], we, V, K),
                        q.push(we)
                    }
                }
                function zt(be) {
                    return be / 360 + .5
                }
                function lr(be) {
                    const q = Math.sin(be * Math.PI / 180)
                      , V = .5 - .25 * Math.log((1 + q) / (1 - q)) / Math.PI;
                    return V < 0 ? 0 : V > 1 ? 1 : V
                }
                function kt(be, q, V, K, ae, we, Me, ke) {
                    if (K /= q,
                    we >= (V /= q) && Me < K)
                        return be;
                    if (Me < V || we >= K)
                        return null;
                    const ge = [];
                    for (const je of be) {
                        const Oe = je.geometry;
                        let Ee = je.type;
                        const Ke = ae === 0 ? je.minX : je.minY
                          , ye = ae === 0 ? je.maxX : je.maxY;
                        if (Ke >= V && ye < K) {
                            ge.push(je);
                            continue
                        }
                        if (ye < V || Ke >= K)
                            continue;
                        let It = [];
                        if (Ee === "Point" || Ee === "MultiPoint")
                            xt(Oe, It, V, K, ae);
                        else if (Ee === "LineString")
                            Pt(Oe, It, V, K, ae, !1, ke.lineMetrics);
                        else if (Ee === "MultiLineString")
                            Lt(Oe, It, V, K, ae, !1);
                        else if (Ee === "Polygon")
                            Lt(Oe, It, V, K, ae, !0);
                        else if (Ee === "MultiPolygon")
                            for (const Kt of Oe) {
                                const Bt = [];
                                Lt(Kt, Bt, V, K, ae, !0),
                                Bt.length && It.push(Bt)
                            }
                        if (It.length) {
                            if (ke.lineMetrics && Ee === "LineString") {
                                for (const Kt of It)
                                    ge.push(Re(je.id, Ee, Kt, je.tags));
                                continue
                            }
                            Ee !== "LineString" && Ee !== "MultiLineString" || (It.length === 1 ? (Ee = "LineString",
                            It = It[0]) : Ee = "MultiLineString"),
                            Ee !== "Point" && Ee !== "MultiPoint" || (Ee = It.length === 3 ? "Point" : "MultiPoint"),
                            ge.push(Re(je.id, Ee, It, je.tags))
                        }
                    }
                    return ge.length ? ge : null
                }
                function xt(be, q, V, K, ae) {
                    for (let we = 0; we < be.length; we += 3) {
                        const Me = be[we + ae];
                        Me >= V && Me <= K && nr(q, be[we], be[we + 1], be[we + 2])
                    }
                }
                function Pt(be, q, V, K, ae, we, Me) {
                    let ke = jt(be);
                    const ge = ae === 0 ? xr : er;
                    let je, Oe, Ee = be.start;
                    for (let Bt = 0; Bt < be.length - 3; Bt += 3) {
                        const Ut = be[Bt]
                          , wr = be[Bt + 1]
                          , ci = be[Bt + 2]
                          , Yr = be[Bt + 3]
                          , yt = be[Bt + 4]
                          , Mt = ae === 0 ? Ut : wr
                          , Gt = ae === 0 ? Yr : yt;
                        let Fr = !1;
                        Me && (je = Math.sqrt(Math.pow(Ut - Yr, 2) + Math.pow(wr - yt, 2))),
                        Mt < V ? Gt > V && (Oe = ge(ke, Ut, wr, Yr, yt, V),
                        Me && (ke.start = Ee + je * Oe)) : Mt > K ? Gt < K && (Oe = ge(ke, Ut, wr, Yr, yt, K),
                        Me && (ke.start = Ee + je * Oe)) : nr(ke, Ut, wr, ci),
                        Gt < V && Mt >= V && (Oe = ge(ke, Ut, wr, Yr, yt, V),
                        Fr = !0),
                        Gt > K && Mt <= K && (Oe = ge(ke, Ut, wr, Yr, yt, K),
                        Fr = !0),
                        !we && Fr && (Me && (ke.end = Ee + je * Oe),
                        q.push(ke),
                        ke = jt(be)),
                        Me && (Ee += je)
                    }
                    let Ke = be.length - 3;
                    const ye = be[Ke]
                      , It = be[Ke + 1]
                      , Kt = ae === 0 ? ye : It;
                    Kt >= V && Kt <= K && nr(ke, ye, It, be[Ke + 2]),
                    Ke = ke.length - 3,
                    we && Ke >= 3 && (ke[Ke] !== ke[0] || ke[Ke + 1] !== ke[1]) && nr(ke, ke[0], ke[1], ke[2]),
                    ke.length && q.push(ke)
                }
                function jt(be) {
                    const q = [];
                    return q.size = be.size,
                    q.start = be.start,
                    q.end = be.end,
                    q
                }
                function Lt(be, q, V, K, ae, we) {
                    for (const Me of be)
                        Pt(Me, q, V, K, ae, we, !1)
                }
                function nr(be, q, V, K) {
                    be.push(q, V, K)
                }
                function xr(be, q, V, K, ae, we) {
                    const Me = (we - q) / (K - q);
                    return nr(be, we, V + (ae - V) * Me, 1),
                    Me
                }
                function er(be, q, V, K, ae, we) {
                    const Me = (we - V) / (ae - V);
                    return nr(be, q + (K - q) * Me, we, 1),
                    Me
                }
                function Qt(be, q) {
                    const V = [];
                    for (let K = 0; K < be.length; K++) {
                        const ae = be[K]
                          , we = ae.type;
                        let Me;
                        if (we === "Point" || we === "MultiPoint" || we === "LineString")
                            Me = $t(ae.geometry, q);
                        else if (we === "MultiLineString" || we === "Polygon") {
                            Me = [];
                            for (const ke of ae.geometry)
                                Me.push($t(ke, q))
                        } else if (we === "MultiPolygon") {
                            Me = [];
                            for (const ke of ae.geometry) {
                                const ge = [];
                                for (const je of ke)
                                    ge.push($t(je, q));
                                Me.push(ge)
                            }
                        }
                        V.push(Re(ae.id, we, Me, ae.tags))
                    }
                    return V
                }
                function $t(be, q) {
                    const V = [];
                    V.size = be.size,
                    be.start !== void 0 && (V.start = be.start,
                    V.end = be.end);
                    for (let K = 0; K < be.length; K += 3)
                        V.push(be[K] + q, be[K + 1], be[K + 2]);
                    return V
                }
                function tr(be, q) {
                    if (be.transformed)
                        return be;
                    const V = 1 << be.z
                      , K = be.x
                      , ae = be.y;
                    for (const we of be.features) {
                        const Me = we.geometry
                          , ke = we.type;
                        if (we.geometry = [],
                        ke === 1)
                            for (let ge = 0; ge < Me.length; ge += 2)
                                we.geometry.push($r(Me[ge], Me[ge + 1], q, V, K, ae));
                        else
                            for (let ge = 0; ge < Me.length; ge++) {
                                const je = [];
                                for (let Oe = 0; Oe < Me[ge].length; Oe += 2)
                                    je.push($r(Me[ge][Oe], Me[ge][Oe + 1], q, V, K, ae));
                                we.geometry.push(je)
                            }
                    }
                    return be.transformed = !0,
                    be
                }
                function $r(be, q, V, K, ae, we) {
                    return [Math.round(V * (be * K - ae)), Math.round(V * (q * K - we))]
                }
                function zr(be, q, V, K, ae) {
                    const we = q === ae.maxZoom ? 0 : ae.tolerance / ((1 << q) * ae.extent)
                      , Me = {
                        features: [],
                        numPoints: 0,
                        numSimplified: 0,
                        numFeatures: be.length,
                        source: null,
                        x: V,
                        y: K,
                        z: q,
                        transformed: !1,
                        minX: 2,
                        minY: 1,
                        maxX: -1,
                        maxY: 0
                    };
                    for (const ke of be)
                        Mr(Me, ke, we, ae);
                    return Me
                }
                function Mr(be, q, V, K) {
                    const ae = q.geometry
                      , we = q.type
                      , Me = [];
                    if (be.minX = Math.min(be.minX, q.minX),
                    be.minY = Math.min(be.minY, q.minY),
                    be.maxX = Math.max(be.maxX, q.maxX),
                    be.maxY = Math.max(be.maxY, q.maxY),
                    we === "Point" || we === "MultiPoint")
                        for (let ke = 0; ke < ae.length; ke += 3)
                            Me.push(ae[ke], ae[ke + 1]),
                            be.numPoints++,
                            be.numSimplified++;
                    else if (we === "LineString")
                        sr(Me, ae, be, V, !1, !1);
                    else if (we === "MultiLineString" || we === "Polygon")
                        for (let ke = 0; ke < ae.length; ke++)
                            sr(Me, ae[ke], be, V, we === "Polygon", ke === 0);
                    else if (we === "MultiPolygon")
                        for (let ke = 0; ke < ae.length; ke++) {
                            const ge = ae[ke];
                            for (let je = 0; je < ge.length; je++)
                                sr(Me, ge[je], be, V, !0, je === 0)
                        }
                    if (Me.length) {
                        let ke = q.tags || null;
                        if (we === "LineString" && K.lineMetrics) {
                            ke = {};
                            for (const je in q.tags)
                                ke[je] = q.tags[je];
                            ke.mapbox_clip_start = ae.start / ae.size,
                            ke.mapbox_clip_end = ae.end / ae.size
                        }
                        const ge = {
                            geometry: Me,
                            type: we === "Polygon" || we === "MultiPolygon" ? 3 : we === "LineString" || we === "MultiLineString" ? 2 : 1,
                            tags: ke
                        };
                        q.id !== null && (ge.id = q.id),
                        be.features.push(ge)
                    }
                }
                function sr(be, q, V, K, ae, we) {
                    const Me = K * K;
                    if (K > 0 && q.size < (ae ? Me : K))
                        return void (V.numPoints += q.length / 3);
                    const ke = [];
                    for (let ge = 0; ge < q.length; ge += 3)
                        (K === 0 || q[ge + 2] > Me) && (V.numSimplified++,
                        ke.push(q[ge], q[ge + 1])),
                        V.numPoints++;
                    ae && function(ge, je) {
                        let Oe = 0;
                        for (let Ee = 0, Ke = ge.length, ye = Ke - 2; Ee < Ke; ye = Ee,
                        Ee += 2)
                            Oe += (ge[Ee] - ge[ye]) * (ge[Ee + 1] + ge[ye + 1]);
                        if (Oe > 0 === je)
                            for (let Ee = 0, Ke = ge.length; Ee < Ke / 2; Ee += 2) {
                                const ye = ge[Ee]
                                  , It = ge[Ee + 1];
                                ge[Ee] = ge[Ke - 2 - Ee],
                                ge[Ee + 1] = ge[Ke - 1 - Ee],
                                ge[Ke - 2 - Ee] = ye,
                                ge[Ke - 1 - Ee] = It
                            }
                    }(ke, we),
                    be.push(ke)
                }
                const Xt = {
                    maxZoom: 14,
                    indexMaxZoom: 5,
                    indexMaxPoints: 1e5,
                    tolerance: 3,
                    extent: 4096,
                    buffer: 64,
                    lineMetrics: !1,
                    promoteId: null,
                    generateId: !1,
                    debug: 0
                };
                class Ir {
                    constructor(q, V) {
                        const K = (V = this.options = function(we, Me) {
                            for (const ke in Me)
                                we[ke] = Me[ke];
                            return we
                        }(Object.create(Xt), V)).debug;
                        if (K && console.time("preprocess data"),
                        V.maxZoom < 0 || V.maxZoom > 24)
                            throw new Error("maxZoom should be in the 0-24 range");
                        if (V.promoteId && V.generateId)
                            throw new Error("promoteId and generateId cannot be used together.");
                        let ae = function(we, Me) {
                            const ke = [];
                            if (we.type === "FeatureCollection")
                                for (let ge = 0; ge < we.features.length; ge++)
                                    it(ke, we.features[ge], Me, ge);
                            else
                                it(ke, we.type === "Feature" ? we : {
                                    geometry: we
                                }, Me);
                            return ke
                        }(q, V);
                        this.tiles = {},
                        this.tileCoords = [],
                        K && (console.timeEnd("preprocess data"),
                        console.log("index: maxZoom: %d, maxPoints: %d", V.indexMaxZoom, V.indexMaxPoints),
                        console.time("generate tiles"),
                        this.stats = {},
                        this.total = 0),
                        ae = function(we, Me) {
                            const ke = Me.buffer / Me.extent;
                            let ge = we;
                            const je = kt(we, 1, -1 - ke, ke, 0, -1, 2, Me)
                              , Oe = kt(we, 1, 1 - ke, 2 + ke, 0, -1, 2, Me);
                            return (je || Oe) && (ge = kt(we, 1, -ke, 1 + ke, 0, -1, 2, Me) || [],
                            je && (ge = Qt(je, 1).concat(ge)),
                            Oe && (ge = ge.concat(Qt(Oe, -1)))),
                            ge
                        }(ae, V),
                        ae.length && this.splitTile(ae, 0, 0, 0),
                        K && (ae.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints),
                        console.timeEnd("generate tiles"),
                        console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
                    }
                    splitTile(q, V, K, ae, we, Me, ke) {
                        const ge = [q, V, K, ae]
                          , je = this.options
                          , Oe = je.debug;
                        for (; ge.length; ) {
                            ae = ge.pop(),
                            K = ge.pop(),
                            V = ge.pop(),
                            q = ge.pop();
                            const Ee = 1 << V
                              , Ke = mr(V, K, ae);
                            let ye = this.tiles[Ke];
                            if (!ye && (Oe > 1 && console.time("creation"),
                            ye = this.tiles[Ke] = zr(q, V, K, ae, je),
                            this.tileCoords.push({
                                z: V,
                                x: K,
                                y: ae
                            }),
                            Oe)) {
                                Oe > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", V, K, ae, ye.numFeatures, ye.numPoints, ye.numSimplified),
                                console.timeEnd("creation"));
                                const Fr = `z${V}`;
                                this.stats[Fr] = (this.stats[Fr] || 0) + 1,
                                this.total++
                            }
                            if (ye.source = q,
                            we == null) {
                                if (V === je.indexMaxZoom || ye.numPoints <= je.indexMaxPoints)
                                    continue
                            } else {
                                if (V === je.maxZoom || V === we)
                                    continue;
                                if (we != null) {
                                    const Fr = we - V;
                                    if (K !== Me >> Fr || ae !== ke >> Fr)
                                        continue
                                }
                            }
                            if (ye.source = null,
                            q.length === 0)
                                continue;
                            Oe > 1 && console.time("clipping");
                            const It = .5 * je.buffer / je.extent
                              , Kt = .5 - It
                              , Bt = .5 + It
                              , Ut = 1 + It;
                            let wr = null
                              , ci = null
                              , Yr = null
                              , yt = null
                              , Mt = kt(q, Ee, K - It, K + Bt, 0, ye.minX, ye.maxX, je)
                              , Gt = kt(q, Ee, K + Kt, K + Ut, 0, ye.minX, ye.maxX, je);
                            q = null,
                            Mt && (wr = kt(Mt, Ee, ae - It, ae + Bt, 1, ye.minY, ye.maxY, je),
                            ci = kt(Mt, Ee, ae + Kt, ae + Ut, 1, ye.minY, ye.maxY, je),
                            Mt = null),
                            Gt && (Yr = kt(Gt, Ee, ae - It, ae + Bt, 1, ye.minY, ye.maxY, je),
                            yt = kt(Gt, Ee, ae + Kt, ae + Ut, 1, ye.minY, ye.maxY, je),
                            Gt = null),
                            Oe > 1 && console.timeEnd("clipping"),
                            ge.push(wr || [], V + 1, 2 * K, 2 * ae),
                            ge.push(ci || [], V + 1, 2 * K, 2 * ae + 1),
                            ge.push(Yr || [], V + 1, 2 * K + 1, 2 * ae),
                            ge.push(yt || [], V + 1, 2 * K + 1, 2 * ae + 1)
                        }
                    }
                    getTile(q, V, K) {
                        q = +q,
                        V = +V,
                        K = +K;
                        const ae = this.options
                          , {extent: we, debug: Me} = ae;
                        if (q < 0 || q > 24)
                            return null;
                        const ke = 1 << q
                          , ge = mr(q, V = V + ke & ke - 1, K);
                        if (this.tiles[ge])
                            return tr(this.tiles[ge], we);
                        Me > 1 && console.log("drilling down to z%d-%d-%d", q, V, K);
                        let je, Oe = q, Ee = V, Ke = K;
                        for (; !je && Oe > 0; )
                            Oe--,
                            Ee >>= 1,
                            Ke >>= 1,
                            je = this.tiles[mr(Oe, Ee, Ke)];
                        return je && je.source ? (Me > 1 && (console.log("found parent tile z%d-%d-%d", Oe, Ee, Ke),
                        console.time("drilling down")),
                        this.splitTile(je.source, Oe, Ee, Ke, q, V, K),
                        Me > 1 && console.timeEnd("drilling down"),
                        this.tiles[ge] ? tr(this.tiles[ge], we) : null) : null
                    }
                }
                function mr(be, q, V) {
                    return 32 * ((1 << be) * V + q) + be
                }
                function vr(be, q) {
                    return q ? be.properties[q] : be.id
                }
                function br(be, q) {
                    if (be == null)
                        return !0;
                    if (be.type === "Feature")
                        return vr(be, q) != null;
                    if (be.type === "FeatureCollection") {
                        const V = new Set;
                        for (const K of be.features) {
                            const ae = vr(K, q);
                            if (ae == null || V.has(ae))
                                return !1;
                            V.add(ae)
                        }
                        return !0
                    }
                    return !1
                }
                function _r(be, q) {
                    const V = new Map;
                    if (be != null)
                        if (be.type === "Feature")
                            V.set(vr(be, q), be);
                        else
                            for (const K of be.features)
                                V.set(vr(K, q), K);
                    return V
                }
                class Ar extends de {
                    constructor() {
                        super(...arguments),
                        this._dataUpdateable = new Map
                    }
                    loadVectorTile(q, V) {
                        return C._(this, void 0, void 0, function*() {
                            const K = q.tileID.canonical;
                            if (!this._geoJSONIndex)
                                throw new Error("Unable to parse the data into a cluster or geojson");
                            const ae = this._geoJSONIndex.getTile(K.z, K.x, K.y);
                            if (!ae)
                                return null;
                            const we = new Ne(ae.features);
                            let Me = et(we);
                            return Me.byteOffset === 0 && Me.byteLength === Me.buffer.byteLength || (Me = new Uint8Array(Me)),
                            {
                                vectorTile: we,
                                rawData: Me.buffer
                            }
                        })
                    }
                    loadData(q) {
                        return C._(this, void 0, void 0, function*() {
                            var V;
                            (V = this._pendingRequest) === null || V === void 0 || V.abort();
                            const K = !!(q && q.request && q.request.collectResourceTiming) && new C.cM(q.request);
                            this._pendingRequest = new AbortController;
                            try {
                                this._pendingData = this.loadAndProcessGeoJSON(q, this._pendingRequest),
                                this._geoJSONIndex = q.cluster ? new ct(function({superclusterOptions: Me, clusterProperties: ke}) {
                                    if (!ke || !Me)
                                        return Me;
                                    const ge = {}
                                      , je = {}
                                      , Oe = {
                                        accumulated: null,
                                        zoom: 0
                                    }
                                      , Ee = {
                                        properties: null
                                    }
                                      , Ke = Object.keys(ke);
                                    for (const ye of Ke) {
                                        const [It,Kt] = ke[ye]
                                          , Bt = C.cT(Kt)
                                          , Ut = C.cT(typeof It == "string" ? [It, ["accumulated"], ["get", ye]] : It);
                                        ge[ye] = Bt.value,
                                        je[ye] = Ut.value
                                    }
                                    return Me.map = ye => {
                                        Ee.properties = ye;
                                        const It = {};
                                        for (const Kt of Ke)
                                            It[Kt] = ge[Kt].evaluate(Oe, Ee);
                                        return It
                                    }
                                    ,
                                    Me.reduce = (ye, It) => {
                                        Ee.properties = It;
                                        for (const Kt of Ke)
                                            Oe.accumulated = ye[Kt],
                                            ye[Kt] = je[Kt].evaluate(Oe, Ee)
                                    }
                                    ,
                                    Me
                                }(q)).load((yield this._pendingData).features) : (ae = yield this._pendingData,
                                new Ir(ae,q.geojsonVtOptions)),
                                this.loaded = {};
                                const we = {};
                                if (K) {
                                    const Me = K.finish();
                                    Me && (we.resourceTiming = {},
                                    we.resourceTiming[q.source] = JSON.parse(JSON.stringify(Me)))
                                }
                                return we
                            } catch (we) {
                                if (delete this._pendingRequest,
                                C.cx(we))
                                    return {
                                        abandoned: !0
                                    };
                                throw we
                            }
                            var ae
                        })
                    }
                    getData() {
                        return C._(this, void 0, void 0, function*() {
                            return this._pendingData
                        })
                    }
                    reloadTile(q) {
                        const V = this.loaded;
                        return V && V[q.uid] ? super.reloadTile(q) : this.loadTile(q)
                    }
                    loadAndProcessGeoJSON(q, V) {
                        return C._(this, void 0, void 0, function*() {
                            let K = yield this.loadGeoJSON(q, V);
                            if (delete this._pendingRequest,
                            typeof K != "object")
                                throw new Error(`Input data given to '${q.source}' is not a valid GeoJSON object.`);
                            if (Ie(K, !0),
                            q.filter) {
                                const ae = C.cT(q.filter, {
                                    type: "boolean",
                                    "property-type": "data-driven",
                                    overridable: !1,
                                    transition: !1
                                });
                                if (ae.result === "error")
                                    throw new Error(ae.value.map(Me => `${Me.key}: ${Me.message}`).join(", "));
                                K = {
                                    type: "FeatureCollection",
                                    features: K.features.filter(Me => ae.value.evaluate({
                                        zoom: 0
                                    }, Me))
                                }
                            }
                            return K
                        })
                    }
                    loadGeoJSON(q, V) {
                        return C._(this, void 0, void 0, function*() {
                            const {promoteId: K} = q;
                            if (q.request) {
                                const ae = yield C.j(q.request, V);
                                return this._dataUpdateable = br(ae.data, K) ? _r(ae.data, K) : void 0,
                                ae.data
                            }
                            if (typeof q.data == "string")
                                try {
                                    const ae = JSON.parse(q.data);
                                    return this._dataUpdateable = br(ae, K) ? _r(ae, K) : void 0,
                                    ae
                                } catch {
                                    throw new Error(`Input data given to '${q.source}' is not a valid GeoJSON object.`)
                                }
                            if (!q.dataDiff)
                                throw new Error(`Input data given to '${q.source}' is not a valid GeoJSON object.`);
                            if (!this._dataUpdateable)
                                throw new Error(`Cannot update existing geojson data in ${q.source}`);
                            return function(ae, we, Me) {
                                var ke, ge, je, Oe;
                                if (we.removeAll && ae.clear(),
                                we.remove)
                                    for (const Ee of we.remove)
                                        ae.delete(Ee);
                                if (we.add)
                                    for (const Ee of we.add) {
                                        const Ke = vr(Ee, Me);
                                        Ke != null && ae.set(Ke, Ee)
                                    }
                                if (we.update)
                                    for (const Ee of we.update) {
                                        let Ke = ae.get(Ee.id);
                                        if (Ke == null)
                                            continue;
                                        const ye = !Ee.removeAllProperties && (((ke = Ee.removeProperties) === null || ke === void 0 ? void 0 : ke.length) > 0 || ((ge = Ee.addOrUpdateProperties) === null || ge === void 0 ? void 0 : ge.length) > 0);
                                        if ((Ee.newGeometry || Ee.removeAllProperties || ye) && (Ke = Object.assign({}, Ke),
                                        ae.set(Ee.id, Ke),
                                        ye && (Ke.properties = Object.assign({}, Ke.properties))),
                                        Ee.newGeometry && (Ke.geometry = Ee.newGeometry),
                                        Ee.removeAllProperties)
                                            Ke.properties = {};
                                        else if (((je = Ee.removeProperties) === null || je === void 0 ? void 0 : je.length) > 0)
                                            for (const It of Ee.removeProperties)
                                                Object.prototype.hasOwnProperty.call(Ke.properties, It) && delete Ke.properties[It];
                                        if (((Oe = Ee.addOrUpdateProperties) === null || Oe === void 0 ? void 0 : Oe.length) > 0)
                                            for (const {key: It, value: Kt} of Ee.addOrUpdateProperties)
                                                Ke.properties[It] = Kt
                                    }
                            }(this._dataUpdateable, q.dataDiff, K),
                            {
                                type: "FeatureCollection",
                                features: Array.from(this._dataUpdateable.values())
                            }
                        })
                    }
                    removeSource(q) {
                        return C._(this, void 0, void 0, function*() {
                            this._pendingRequest && this._pendingRequest.abort()
                        })
                    }
                    getClusterExpansionZoom(q) {
                        return this._geoJSONIndex.getClusterExpansionZoom(q.clusterId)
                    }
                    getClusterChildren(q) {
                        return this._geoJSONIndex.getChildren(q.clusterId)
                    }
                    getClusterLeaves(q) {
                        return this._geoJSONIndex.getLeaves(q.clusterId, q.limit, q.offset)
                    }
                }
                class Tr {
                    constructor(q) {
                        this.self = q,
                        this.actor = new C.J(q),
                        this.layerIndexes = {},
                        this.availableImages = {},
                        this.workerSources = {},
                        this.demWorkerSources = {},
                        this.externalWorkerSourceTypes = {},
                        this.self.registerWorkerSource = (V, K) => {
                            if (this.externalWorkerSourceTypes[V])
                                throw new Error(`Worker source with name "${V}" already registered.`);
                            this.externalWorkerSourceTypes[V] = K
                        }
                        ,
                        this.self.addProtocol = C.cz,
                        this.self.removeProtocol = C.cA,
                        this.self.registerRTLTextPlugin = V => {
                            C.cU.setMethods(V)
                        }
                        ,
                        this.actor.registerMessageHandler("LDT", (V, K) => this._getDEMWorkerSource(V, K.source).loadTile(K)),
                        this.actor.registerMessageHandler("RDT", (V, K) => C._(this, void 0, void 0, function*() {
                            this._getDEMWorkerSource(V, K.source).removeTile(K)
                        })),
                        this.actor.registerMessageHandler("GCEZ", (V, K) => C._(this, void 0, void 0, function*() {
                            return this._getWorkerSource(V, K.type, K.source).getClusterExpansionZoom(K)
                        })),
                        this.actor.registerMessageHandler("GCC", (V, K) => C._(this, void 0, void 0, function*() {
                            return this._getWorkerSource(V, K.type, K.source).getClusterChildren(K)
                        })),
                        this.actor.registerMessageHandler("GCL", (V, K) => C._(this, void 0, void 0, function*() {
                            return this._getWorkerSource(V, K.type, K.source).getClusterLeaves(K)
                        })),
                        this.actor.registerMessageHandler("LD", (V, K) => this._getWorkerSource(V, K.type, K.source).loadData(K)),
                        this.actor.registerMessageHandler("GD", (V, K) => this._getWorkerSource(V, K.type, K.source).getData()),
                        this.actor.registerMessageHandler("LT", (V, K) => this._getWorkerSource(V, K.type, K.source).loadTile(K)),
                        this.actor.registerMessageHandler("RT", (V, K) => this._getWorkerSource(V, K.type, K.source).reloadTile(K)),
                        this.actor.registerMessageHandler("AT", (V, K) => this._getWorkerSource(V, K.type, K.source).abortTile(K)),
                        this.actor.registerMessageHandler("RMT", (V, K) => this._getWorkerSource(V, K.type, K.source).removeTile(K)),
                        this.actor.registerMessageHandler("RS", (V, K) => C._(this, void 0, void 0, function*() {
                            if (!this.workerSources[V] || !this.workerSources[V][K.type] || !this.workerSources[V][K.type][K.source])
                                return;
                            const ae = this.workerSources[V][K.type][K.source];
                            delete this.workerSources[V][K.type][K.source],
                            ae.removeSource !== void 0 && ae.removeSource(K)
                        })),
                        this.actor.registerMessageHandler("RM", V => C._(this, void 0, void 0, function*() {
                            delete this.layerIndexes[V],
                            delete this.availableImages[V],
                            delete this.workerSources[V],
                            delete this.demWorkerSources[V]
                        })),
                        this.actor.registerMessageHandler("SR", (V, K) => C._(this, void 0, void 0, function*() {
                            this.referrer = K
                        })),
                        this.actor.registerMessageHandler("SRPS", (V, K) => this._syncRTLPluginState(V, K)),
                        this.actor.registerMessageHandler("IS", (V, K) => C._(this, void 0, void 0, function*() {
                            this.self.importScripts(K)
                        })),
                        this.actor.registerMessageHandler("SI", (V, K) => this._setImages(V, K)),
                        this.actor.registerMessageHandler("UL", (V, K) => C._(this, void 0, void 0, function*() {
                            this._getLayerIndex(V).update(K.layers, K.removedIds)
                        })),
                        this.actor.registerMessageHandler("SL", (V, K) => C._(this, void 0, void 0, function*() {
                            this._getLayerIndex(V).replace(K)
                        }))
                    }
                    _setImages(q, V) {
                        return C._(this, void 0, void 0, function*() {
                            this.availableImages[q] = V;
                            for (const K in this.workerSources[q]) {
                                const ae = this.workerSources[q][K];
                                for (const we in ae)
                                    ae[we].availableImages = V
                            }
                        })
                    }
                    _syncRTLPluginState(q, V) {
                        return C._(this, void 0, void 0, function*() {
                            return yield C.cU.syncState(V, this.self.importScripts)
                        })
                    }
                    _getAvailableImages(q) {
                        let V = this.availableImages[q];
                        return V || (V = []),
                        V
                    }
                    _getLayerIndex(q) {
                        let V = this.layerIndexes[q];
                        return V || (V = this.layerIndexes[q] = new o),
                        V
                    }
                    _getWorkerSource(q, V, K) {
                        if (this.workerSources[q] || (this.workerSources[q] = {}),
                        this.workerSources[q][V] || (this.workerSources[q][V] = {}),
                        !this.workerSources[q][V][K]) {
                            const ae = {
                                sendAsync: (we, Me) => (we.targetMapId = q,
                                this.actor.sendAsync(we, Me))
                            };
                            switch (V) {
                            case "vector":
                                this.workerSources[q][V][K] = new de(ae,this._getLayerIndex(q),this._getAvailableImages(q));
                                break;
                            case "geojson":
                                this.workerSources[q][V][K] = new Ar(ae,this._getLayerIndex(q),this._getAvailableImages(q));
                                break;
                            default:
                                this.workerSources[q][V][K] = new this.externalWorkerSourceTypes[V](ae,this._getLayerIndex(q),this._getAvailableImages(q))
                            }
                        }
                        return this.workerSources[q][V][K]
                    }
                    _getDEMWorkerSource(q, V) {
                        return this.demWorkerSources[q] || (this.demWorkerSources[q] = {}),
                        this.demWorkerSources[q][V] || (this.demWorkerSources[q][V] = new he),
                        this.demWorkerSources[q][V]
                    }
                }
                return C.i(self) && (self.worker = new Tr(self)),
                Tr
            }),
            E("index", ["exports", "./shared"], function(C, o) {
                var W = "5.6.1";
                function G() {
                    var h = new o.A(4);
                    return o.A != Float32Array && (h[1] = 0,
                    h[2] = 0),
                    h[0] = 1,
                    h[3] = 1,
                    h
                }
                let re, de;
                const he = {
                    now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date),
                    frame(h, e, r) {
                        const s = requestAnimationFrame(d => {
                            c(),
                            e(d)
                        }
                        )
                          , {unsubscribe: c} = o.s(h.signal, "abort", () => {
                            c(),
                            cancelAnimationFrame(s),
                            r(o.c())
                        }
                        , !1)
                    },
                    frameAsync(h) {
                        return new Promise( (e, r) => {
                            this.frame(h, e, r)
                        }
                        )
                    },
                    getImageData(h, e=0) {
                        return this.getImageCanvasContext(h).getImageData(-e, -e, h.width + 2 * e, h.height + 2 * e)
                    },
                    getImageCanvasContext(h) {
                        const e = window.document.createElement("canvas")
                          , r = e.getContext("2d", {
                            willReadFrequently: !0
                        });
                        if (!r)
                            throw new Error("failed to create canvas 2d context");
                        return e.width = h.width,
                        e.height = h.height,
                        r.drawImage(h, 0, 0, h.width, h.height),
                        r
                    },
                    resolveURL: h => (re || (re = document.createElement("a")),
                    re.href = h,
                    re.href),
                    hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
                    get prefersReducedMotion() {
                        return !!matchMedia && (de == null && (de = matchMedia("(prefers-reduced-motion: reduce)")),
                        de.matches)
                    }
                };
                class X {
                    static testProp(e) {
                        if (!X.docStyle)
                            return e[0];
                        for (let r = 0; r < e.length; r++)
                            if (e[r]in X.docStyle)
                                return e[r];
                        return e[0]
                    }
                    static create(e, r, s) {
                        const c = window.document.createElement(e);
                        return r !== void 0 && (c.className = r),
                        s && s.appendChild(c),
                        c
                    }
                    static createNS(e, r) {
                        return window.document.createElementNS(e, r)
                    }
                    static disableDrag() {
                        X.docStyle && X.selectProp && (X.userSelect = X.docStyle[X.selectProp],
                        X.docStyle[X.selectProp] = "none")
                    }
                    static enableDrag() {
                        X.docStyle && X.selectProp && (X.docStyle[X.selectProp] = X.userSelect)
                    }
                    static setTransform(e, r) {
                        e.style[X.transformProp] = r
                    }
                    static addEventListener(e, r, s, c={}) {
                        e.addEventListener(r, s, "passive"in c ? c : c.capture)
                    }
                    static removeEventListener(e, r, s, c={}) {
                        e.removeEventListener(r, s, "passive"in c ? c : c.capture)
                    }
                    static suppressClickInternal(e) {
                        e.preventDefault(),
                        e.stopPropagation(),
                        window.removeEventListener("click", X.suppressClickInternal, !0)
                    }
                    static suppressClick() {
                        window.addEventListener("click", X.suppressClickInternal, !0),
                        window.setTimeout( () => {
                            window.removeEventListener("click", X.suppressClickInternal, !0)
                        }
                        , 0)
                    }
                    static getScale(e) {
                        const r = e.getBoundingClientRect();
                        return {
                            x: r.width / e.offsetWidth || 1,
                            y: r.height / e.offsetHeight || 1,
                            boundingClientRect: r
                        }
                    }
                    static getPoint(e, r, s) {
                        const c = r.boundingClientRect;
                        return new o.P((s.clientX - c.left) / r.x - e.clientLeft,(s.clientY - c.top) / r.y - e.clientTop)
                    }
                    static mousePos(e, r) {
                        const s = X.getScale(e);
                        return X.getPoint(e, s, r)
                    }
                    static touchPos(e, r) {
                        const s = []
                          , c = X.getScale(e);
                        for (let d = 0; d < r.length; d++)
                            s.push(X.getPoint(e, c, r[d]));
                        return s
                    }
                    static mouseButton(e) {
                        return e.button
                    }
                    static remove(e) {
                        e.parentNode && e.parentNode.removeChild(e)
                    }
                    static sanitize(e) {
                        const r = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body")
                          , s = r.querySelectorAll("script");
                        for (const c of s)
                            c.remove();
                        return X.clean(r),
                        r.innerHTML
                    }
                    static isPossiblyDangerous(e, r) {
                        const s = r.replace(/\s+/g, "").toLowerCase();
                        return !(!["src", "href", "xlink:href"].includes(e) || !s.includes("javascript:") && !s.includes("data:")) || !!e.startsWith("on") || void 0
                    }
                    static clean(e) {
                        const r = e.children;
                        for (const s of r)
                            X.removeAttributes(s),
                            X.clean(s)
                    }
                    static removeAttributes(e) {
                        for (const {name: r, value: s} of e.attributes)
                            X.isPossiblyDangerous(r, s) && e.removeAttribute(r)
                    }
                }
                X.docStyle = typeof window < "u" && window.document && window.document.documentElement.style,
                X.selectProp = X.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]),
                X.transformProp = X.testProp(["transform", "WebkitTransform"]);
                const le = {
                    supported: !1,
                    testSupport: function(h) {
                        !De && Ie && (qe ? Ne(h) : Se = h)
                    }
                };
                let Se, Ie, De = !1, qe = !1;
                function Ne(h) {
                    const e = h.createTexture();
                    h.bindTexture(h.TEXTURE_2D, e);
                    try {
                        if (h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, h.RGBA, h.UNSIGNED_BYTE, Ie),
                        h.isContextLost())
                            return;
                        le.supported = !0
                    } catch {}
                    h.deleteTexture(e),
                    De = !0
                }
                var Ze;
                typeof document < "u" && (Ie = document.createElement("img"),
                Ie.onload = () => {
                    Se && Ne(Se),
                    Se = null,
                    qe = !0
                }
                ,
                Ie.onerror = () => {
                    De = !0,
                    Se = null
                }
                ,
                Ie.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="),
                function(h) {
                    let e, r, s, c;
                    h.resetRequestQueue = () => {
                        e = [],
                        r = 0,
                        s = 0,
                        c = {}
                    }
                    ,
                    h.addThrottleControl = b => {
                        const P = s++;
                        return c[P] = b,
                        P
                    }
                    ,
                    h.removeThrottleControl = b => {
                        delete c[b],
                        m()
                    }
                    ,
                    h.getImage = (b, P, M=!0) => new Promise( (D, L) => {
                        le.supported && (b.headers || (b.headers = {}),
                        b.headers.accept = "image/webp,*/*"),
                        o.e(b, {
                            type: "image"
                        }),
                        e.push({
                            abortController: P,
                            requestParameters: b,
                            supportImageRefresh: M,
                            state: "queued",
                            onError: B => {
                                L(B)
                            }
                            ,
                            onSuccess: B => {
                                D(B)
                            }
                        }),
                        m()
                    }
                    );
                    const d = b => o._(this, void 0, void 0, function*() {
                        b.state = "running";
                        const {requestParameters: P, supportImageRefresh: M, onError: D, onSuccess: L, abortController: B} = b
                          , Z = M === !1 && !o.i(self) && !o.g(P.url) && (!P.headers || Object.keys(P.headers).reduce( (ne, oe) => ne && oe === "accept", !0));
                        r++;
                        const te = Z ? v(P, B) : o.m(P, B);
                        try {
                            const ne = yield te;
                            delete b.abortController,
                            b.state = "completed",
                            ne.data instanceof HTMLImageElement || o.b(ne.data) ? L(ne) : ne.data && L({
                                data: yield(ee = ne.data,
                                typeof createImageBitmap == "function" ? o.f(ee) : o.h(ee)),
                                cacheControl: ne.cacheControl,
                                expires: ne.expires
                            })
                        } catch (ne) {
                            delete b.abortController,
                            D(ne)
                        } finally {
                            r--,
                            m()
                        }
                        var ee
                    })
                      , m = () => {
                        const b = ( () => {
                            for (const P of Object.keys(c))
                                if (c[P]())
                                    return !0;
                            return !1
                        }
                        )() ? o.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : o.a.MAX_PARALLEL_IMAGE_REQUESTS;
                        for (let P = r; P < b && e.length > 0; P++) {
                            const M = e.shift();
                            M.abortController.signal.aborted ? P-- : d(M)
                        }
                    }
                      , v = (b, P) => new Promise( (M, D) => {
                        const L = new Image
                          , B = b.url
                          , Z = b.credentials;
                        Z && Z === "include" ? L.crossOrigin = "use-credentials" : (Z && Z === "same-origin" || !o.d(B)) && (L.crossOrigin = "anonymous"),
                        P.signal.addEventListener("abort", () => {
                            L.src = "",
                            D(o.c())
                        }
                        ),
                        L.fetchPriority = "high",
                        L.onload = () => {
                            L.onerror = L.onload = null,
                            M({
                                data: L
                            })
                        }
                        ,
                        L.onerror = () => {
                            L.onerror = L.onload = null,
                            P.signal.aborted || D(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))
                        }
                        ,
                        L.src = B
                    }
                    )
                }(Ze || (Ze = {})),
                Ze.resetRequestQueue();
                class ut {
                    constructor(e) {
                        this._transformRequestFn = e
                    }
                    transformRequest(e, r) {
                        return this._transformRequestFn && this._transformRequestFn(e, r) || {
                            url: e
                        }
                    }
                    setTransformRequest(e) {
                        this._transformRequestFn = e
                    }
                }
                function rt(h) {
                    const e = [];
                    if (typeof h == "string")
                        e.push({
                            id: "default",
                            url: h
                        });
                    else if (h && h.length > 0) {
                        const r = [];
                        for (const {id: s, url: c} of h) {
                            const d = `${s}${c}`;
                            r.indexOf(d) === -1 && (r.push(d),
                            e.push({
                                id: s,
                                url: c
                            }))
                        }
                    }
                    return e
                }
                function Ue(h, e, r) {
                    try {
                        const s = new URL(h);
                        return s.pathname += `${e}${r}`,
                        s.toString()
                    } catch {
                        throw new Error(`Invalid sprite URL "${h}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`)
                    }
                }
                function lt(h) {
                    const {userImage: e} = h;
                    return !!(e && e.render && e.render()) && (h.data.replace(new Uint8Array(e.data.buffer)),
                    !0)
                }
                class et extends o.E {
                    constructor() {
                        super(),
                        this.images = {},
                        this.updatedImages = {},
                        this.callbackDispatchedThisFrame = {},
                        this.loaded = !1,
                        this.requestors = [],
                        this.patterns = {},
                        this.atlasImage = new o.R({
                            width: 1,
                            height: 1
                        }),
                        this.dirty = !0
                    }
                    isLoaded() {
                        return this.loaded
                    }
                    setLoaded(e) {
                        if (this.loaded !== e && (this.loaded = e,
                        e)) {
                            for (const {ids: r, promiseResolve: s} of this.requestors)
                                s(this._getImagesForIds(r));
                            this.requestors = []
                        }
                    }
                    getImage(e) {
                        const r = this.images[e];
                        if (r && !r.data && r.spriteData) {
                            const s = r.spriteData;
                            r.data = new o.R({
                                width: s.width,
                                height: s.height
                            },s.context.getImageData(s.x, s.y, s.width, s.height).data),
                            r.spriteData = null
                        }
                        return r
                    }
                    addImage(e, r) {
                        if (this.images[e])
                            throw new Error(`Image id ${e} already exist, use updateImage instead`);
                        this._validate(e, r) && (this.images[e] = r)
                    }
                    _validate(e, r) {
                        let s = !0;
                        const c = r.data || r.spriteData;
                        return this._validateStretch(r.stretchX, c && c.width) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "stretchX" value`))),
                        s = !1),
                        this._validateStretch(r.stretchY, c && c.height) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "stretchY" value`))),
                        s = !1),
                        this._validateContent(r.content, r) || (this.fire(new o.k(new Error(`Image "${e}" has invalid "content" value`))),
                        s = !1),
                        s
                    }
                    _validateStretch(e, r) {
                        if (!e)
                            return !0;
                        let s = 0;
                        for (const c of e) {
                            if (c[0] < s || c[1] < c[0] || r < c[1])
                                return !1;
                            s = c[1]
                        }
                        return !0
                    }
                    _validateContent(e, r) {
                        if (!e)
                            return !0;
                        if (e.length !== 4)
                            return !1;
                        const s = r.spriteData
                          , c = s && s.width || r.data.width
                          , d = s && s.height || r.data.height;
                        return !(e[0] < 0 || c < e[0] || e[1] < 0 || d < e[1] || e[2] < 0 || c < e[2] || e[3] < 0 || d < e[3] || e[2] < e[0] || e[3] < e[1])
                    }
                    updateImage(e, r, s=!0) {
                        const c = this.getImage(e);
                        if (s && (c.data.width !== r.data.width || c.data.height !== r.data.height))
                            throw new Error(`size mismatch between old image (${c.data.width}x${c.data.height}) and new image (${r.data.width}x${r.data.height}).`);
                        r.version = c.version + 1,
                        this.images[e] = r,
                        this.updatedImages[e] = !0
                    }
                    removeImage(e) {
                        const r = this.images[e];
                        delete this.images[e],
                        delete this.patterns[e],
                        r.userImage && r.userImage.onRemove && r.userImage.onRemove()
                    }
                    listImages() {
                        return Object.keys(this.images)
                    }
                    getImages(e) {
                        return new Promise( (r, s) => {
                            let c = !0;
                            if (!this.isLoaded())
                                for (const d of e)
                                    this.images[d] || (c = !1);
                            this.isLoaded() || c ? r(this._getImagesForIds(e)) : this.requestors.push({
                                ids: e,
                                promiseResolve: r
                            })
                        }
                        )
                    }
                    _getImagesForIds(e) {
                        const r = {};
                        for (const s of e) {
                            let c = this.getImage(s);
                            c || (this.fire(new o.l("styleimagemissing",{
                                id: s
                            })),
                            c = this.getImage(s)),
                            c ? r[s] = {
                                data: c.data.clone(),
                                pixelRatio: c.pixelRatio,
                                sdf: c.sdf,
                                version: c.version,
                                stretchX: c.stretchX,
                                stretchY: c.stretchY,
                                content: c.content,
                                textFitWidth: c.textFitWidth,
                                textFitHeight: c.textFitHeight,
                                hasRenderCallback: !!(c.userImage && c.userImage.render)
                            } : o.w(`Image "${s}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
                        }
                        return r
                    }
                    getPixelSize() {
                        const {width: e, height: r} = this.atlasImage;
                        return {
                            width: e,
                            height: r
                        }
                    }
                    getPattern(e) {
                        const r = this.patterns[e]
                          , s = this.getImage(e);
                        if (!s)
                            return null;
                        if (r && r.position.version === s.version)
                            return r.position;
                        if (r)
                            r.position.version = s.version;
                        else {
                            const c = {
                                w: s.data.width + 2,
                                h: s.data.height + 2,
                                x: 0,
                                y: 0
                            }
                              , d = new o.I(c,s);
                            this.patterns[e] = {
                                bin: c,
                                position: d
                            }
                        }
                        return this._updatePatternAtlas(),
                        this.patterns[e].position
                    }
                    bind(e) {
                        const r = e.gl;
                        this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage),
                        this.dirty = !1) : this.atlasTexture = new o.T(e,this.atlasImage,r.RGBA),
                        this.atlasTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE)
                    }
                    _updatePatternAtlas() {
                        const e = [];
                        for (const d in this.patterns)
                            e.push(this.patterns[d].bin);
                        const {w: r, h: s} = o.p(e)
                          , c = this.atlasImage;
                        c.resize({
                            width: r || 1,
                            height: s || 1
                        });
                        for (const d in this.patterns) {
                            const {bin: m} = this.patterns[d]
                              , v = m.x + 1
                              , b = m.y + 1
                              , P = this.getImage(d).data
                              , M = P.width
                              , D = P.height;
                            o.R.copy(P, c, {
                                x: 0,
                                y: 0
                            }, {
                                x: v,
                                y: b
                            }, {
                                width: M,
                                height: D
                            }),
                            o.R.copy(P, c, {
                                x: 0,
                                y: D - 1
                            }, {
                                x: v,
                                y: b - 1
                            }, {
                                width: M,
                                height: 1
                            }),
                            o.R.copy(P, c, {
                                x: 0,
                                y: 0
                            }, {
                                x: v,
                                y: b + D
                            }, {
                                width: M,
                                height: 1
                            }),
                            o.R.copy(P, c, {
                                x: M - 1,
                                y: 0
                            }, {
                                x: v - 1,
                                y: b
                            }, {
                                width: 1,
                                height: D
                            }),
                            o.R.copy(P, c, {
                                x: 0,
                                y: 0
                            }, {
                                x: v + M,
                                y: b
                            }, {
                                width: 1,
                                height: D
                            })
                        }
                        this.dirty = !0
                    }
                    beginFrame() {
                        this.callbackDispatchedThisFrame = {}
                    }
                    dispatchRenderCallbacks(e) {
                        for (const r of e) {
                            if (this.callbackDispatchedThisFrame[r])
                                continue;
                            this.callbackDispatchedThisFrame[r] = !0;
                            const s = this.getImage(r);
                            s || o.w(`Image with ID: "${r}" was not found`),
                            lt(s) && this.updateImage(r, s)
                        }
                    }
                }
                const Ve = 1e20;
                function gt(h, e, r, s, c, d, m, v, b) {
                    for (let P = e; P < e + s; P++)
                        dt(h, r * d + P, d, c, m, v, b);
                    for (let P = r; P < r + c; P++)
                        dt(h, P * d + e, 1, s, m, v, b)
                }
                function dt(h, e, r, s, c, d, m) {
                    d[0] = 0,
                    m[0] = -Ve,
                    m[1] = Ve,
                    c[0] = h[e];
                    for (let v = 1, b = 0, P = 0; v < s; v++) {
                        c[v] = h[e + v * r];
                        const M = v * v;
                        do {
                            const D = d[b];
                            P = (c[v] - c[D] + M - D * D) / (v - D) / 2
                        } while (P <= m[b] && --b > -1);
                        b++,
                        d[b] = v,
                        m[b] = P,
                        m[b + 1] = Ve
                    }
                    for (let v = 0, b = 0; v < s; v++) {
                        for (; m[b + 1] < v; )
                            b++;
                        const P = d[b]
                          , M = v - P;
                        h[e + v * r] = c[P] + M * M
                    }
                }
                class ct {
                    constructor(e, r) {
                        this.requestManager = e,
                        this.localIdeographFontFamily = r,
                        this.entries = {}
                    }
                    setURL(e) {
                        this.url = e
                    }
                    getGlyphs(e) {
                        return o._(this, void 0, void 0, function*() {
                            const r = [];
                            for (const d in e)
                                for (const m of e[d])
                                    r.push(this._getAndCacheGlyphsPromise(d, m));
                            const s = yield Promise.all(r)
                              , c = {};
                            for (const {stack: d, id: m, glyph: v} of s)
                                c[d] || (c[d] = {}),
                                c[d][m] = v && {
                                    id: v.id,
                                    bitmap: v.bitmap.clone(),
                                    metrics: v.metrics
                                };
                            return c
                        })
                    }
                    _getAndCacheGlyphsPromise(e, r) {
                        return o._(this, void 0, void 0, function*() {
                            let s = this.entries[e];
                            s || (s = this.entries[e] = {
                                glyphs: {},
                                requests: {},
                                ranges: {}
                            });
                            let c = s.glyphs[r];
                            if (c !== void 0)
                                return {
                                    stack: e,
                                    id: r,
                                    glyph: c
                                };
                            if (c = this._tinySDF(s, e, r),
                            c)
                                return s.glyphs[r] = c,
                                {
                                    stack: e,
                                    id: r,
                                    glyph: c
                                };
                            const d = Math.floor(r / 256);
                            if (256 * d > 65535)
                                throw new Error("glyphs > 65535 not supported");
                            if (s.ranges[d])
                                return {
                                    stack: e,
                                    id: r,
                                    glyph: c
                                };
                            if (!this.url)
                                throw new Error("glyphsUrl is not set");
                            if (!s.requests[d]) {
                                const v = ct.loadGlyphRange(e, d, this.url, this.requestManager);
                                s.requests[d] = v
                            }
                            const m = yield s.requests[d];
                            for (const v in m)
                                this._doesCharSupportLocalGlyph(+v) || (s.glyphs[+v] = m[+v]);
                            return s.ranges[d] = !0,
                            {
                                stack: e,
                                id: r,
                                glyph: m[r] || null
                            }
                        })
                    }
                    _doesCharSupportLocalGlyph(e) {
                        return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}","u").test(String.fromCodePoint(e)) || o.u["CJK Unified Ideographs"](e) || o.u["Hangul Syllables"](e) || o.u.Hiragana(e) || o.u.Katakana(e) || o.u["CJK Symbols and Punctuation"](e) || o.u["Halfwidth and Fullwidth Forms"](e))
                    }
                    _tinySDF(e, r, s) {
                        const c = this.localIdeographFontFamily;
                        if (!c || !this._doesCharSupportLocalGlyph(s))
                            return;
                        let d = e.tinySDF;
                        if (!d) {
                            let v = "400";
                            /bold/i.test(r) ? v = "900" : /medium/i.test(r) ? v = "500" : /light/i.test(r) && (v = "200"),
                            d = e.tinySDF = new ct.TinySDF({
                                fontSize: 48,
                                buffer: 6,
                                radius: 16,
                                cutoff: .25,
                                fontFamily: c,
                                fontWeight: v
                            })
                        }
                        const m = d.draw(String.fromCharCode(s));
                        return {
                            id: s,
                            bitmap: new o.q({
                                width: m.width || 60,
                                height: m.height || 60
                            },m.data),
                            metrics: {
                                width: m.glyphWidth / 2 || 24,
                                height: m.glyphHeight / 2 || 24,
                                left: m.glyphLeft / 2 + .5 || 0,
                                top: m.glyphTop / 2 - 27.5 || -8,
                                advance: m.glyphAdvance / 2 || 24,
                                isDoubleResolution: !0
                            }
                        }
                    }
                }
                ct.loadGlyphRange = function(h, e, r, s) {
                    return o._(this, void 0, void 0, function*() {
                        const c = 256 * e
                          , d = c + 255
                          , m = s.transformRequest(r.replace("{fontstack}", h).replace("{range}", `${c}-${d}`), "Glyphs")
                          , v = yield o.n(m, new AbortController);
                        if (!v || !v.data)
                            throw new Error(`Could not load glyph range. range: ${e}, ${c}-${d}`);
                        const b = {};
                        for (const P of o.o(v.data))
                            b[P.id] = P;
                        return b
                    })
                }
                ,
                ct.TinySDF = class {
                    constructor({fontSize: h=24, buffer: e=3, radius: r=8, cutoff: s=.25, fontFamily: c="sans-serif", fontWeight: d="normal", fontStyle: m="normal"}={}) {
                        this.buffer = e,
                        this.cutoff = s,
                        this.radius = r;
                        const v = this.size = h + 4 * e
                          , b = this._createCanvas(v)
                          , P = this.ctx = b.getContext("2d", {
                            willReadFrequently: !0
                        });
                        P.font = `${m} ${d} ${h}px ${c}`,
                        P.textBaseline = "alphabetic",
                        P.textAlign = "left",
                        P.fillStyle = "black",
                        this.gridOuter = new Float64Array(v * v),
                        this.gridInner = new Float64Array(v * v),
                        this.f = new Float64Array(v),
                        this.z = new Float64Array(v + 1),
                        this.v = new Uint16Array(v)
                    }
                    _createCanvas(h) {
                        const e = document.createElement("canvas");
                        return e.width = e.height = h,
                        e
                    }
                    draw(h) {
                        const {width: e, actualBoundingBoxAscent: r, actualBoundingBoxDescent: s, actualBoundingBoxLeft: c, actualBoundingBoxRight: d} = this.ctx.measureText(h)
                          , m = Math.ceil(r)
                          , v = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(d - c)))
                          , b = Math.min(this.size - this.buffer, m + Math.ceil(s))
                          , P = v + 2 * this.buffer
                          , M = b + 2 * this.buffer
                          , D = Math.max(P * M, 0)
                          , L = new Uint8ClampedArray(D)
                          , B = {
                            data: L,
                            width: P,
                            height: M,
                            glyphWidth: v,
                            glyphHeight: b,
                            glyphTop: m,
                            glyphLeft: 0,
                            glyphAdvance: e
                        };
                        if (v === 0 || b === 0)
                            return B;
                        const {ctx: Z, buffer: te, gridInner: ee, gridOuter: ne} = this;
                        Z.clearRect(te, te, v, b),
                        Z.fillText(h, te, te + m);
                        const oe = Z.getImageData(te, te, v, b);
                        ne.fill(Ve, 0, D),
                        ee.fill(0, 0, D);
                        for (let me = 0; me < b; me++)
                            for (let ce = 0; ce < v; ce++) {
                                const Te = oe.data[4 * (me * v + ce) + 3] / 255;
                                if (Te === 0)
                                    continue;
                                const Pe = (me + te) * P + ce + te;
                                if (Te === 1)
                                    ne[Pe] = 0,
                                    ee[Pe] = Ve;
                                else {
                                    const pe = .5 - Te;
                                    ne[Pe] = pe > 0 ? pe * pe : 0,
                                    ee[Pe] = pe < 0 ? pe * pe : 0
                                }
                            }
                        gt(ne, 0, 0, P, M, P, this.f, this.v, this.z),
                        gt(ee, te, te, v, b, P, this.f, this.v, this.z);
                        for (let me = 0; me < D; me++) {
                            const ce = Math.sqrt(ne[me]) - Math.sqrt(ee[me]);
                            L[me] = Math.round(255 - 255 * (ce / this.radius + this.cutoff))
                        }
                        return B
                    }
                }
                ;
                class ze {
                    constructor() {
                        this.specification = o.v.light.position
                    }
                    possiblyEvaluate(e, r) {
                        return o.B(e.expression.evaluate(r))
                    }
                    interpolate(e, r, s) {
                        return {
                            x: o.C.number(e.x, r.x, s),
                            y: o.C.number(e.y, r.y, s),
                            z: o.C.number(e.z, r.z, s)
                        }
                    }
                }
                let vt;
                class Q extends o.E {
                    constructor(e) {
                        super(),
                        vt = vt || new o.r({
                            anchor: new o.D(o.v.light.anchor),
                            position: new ze,
                            color: new o.D(o.v.light.color),
                            intensity: new o.D(o.v.light.intensity)
                        }),
                        this._transitionable = new o.t(vt),
                        this.setLight(e),
                        this._transitioning = this._transitionable.untransitioned()
                    }
                    getLight() {
                        return this._transitionable.serialize()
                    }
                    setLight(e, r={}) {
                        if (!this._validate(o.x, e, r))
                            for (const s in e) {
                                const c = e[s];
                                s.endsWith("-transition") ? this._transitionable.setTransition(s.slice(0, -11), c) : this._transitionable.setValue(s, c)
                            }
                    }
                    updateTransitions(e) {
                        this._transitioning = this._transitionable.transitioned(e, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition()
                    }
                    recalculate(e) {
                        this.properties = this._transitioning.possiblyEvaluate(e)
                    }
                    _validate(e, r, s) {
                        return (!s || s.validate !== !1) && o.y(this, e.call(o.z, {
                            value: r,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            },
                            styleSpec: o.v
                        }))
                    }
                }
                const ie = new o.r({
                    "sky-color": new o.D(o.v.sky["sky-color"]),
                    "horizon-color": new o.D(o.v.sky["horizon-color"]),
                    "fog-color": new o.D(o.v.sky["fog-color"]),
                    "fog-ground-blend": new o.D(o.v.sky["fog-ground-blend"]),
                    "horizon-fog-blend": new o.D(o.v.sky["horizon-fog-blend"]),
                    "sky-horizon-blend": new o.D(o.v.sky["sky-horizon-blend"]),
                    "atmosphere-blend": new o.D(o.v.sky["atmosphere-blend"])
                });
                class xe extends o.E {
                    constructor(e) {
                        super(),
                        this._transitionable = new o.t(ie),
                        this.setSky(e),
                        this._transitioning = this._transitionable.untransitioned(),
                        this.recalculate(new o.F(0))
                    }
                    setSky(e, r={}) {
                        if (!this._validate(o.G, e, r)) {
                            e || (e = {
                                "sky-color": "transparent",
                                "horizon-color": "transparent",
                                "fog-color": "transparent",
                                "fog-ground-blend": 1,
                                "atmosphere-blend": 0
                            });
                            for (const s in e) {
                                const c = e[s];
                                s.endsWith("-transition") ? this._transitionable.setTransition(s.slice(0, -11), c) : this._transitionable.setValue(s, c)
                            }
                        }
                    }
                    getSky() {
                        return this._transitionable.serialize()
                    }
                    updateTransitions(e) {
                        this._transitioning = this._transitionable.transitioned(e, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition()
                    }
                    recalculate(e) {
                        this.properties = this._transitioning.possiblyEvaluate(e)
                    }
                    _validate(e, r, s={}) {
                        return (s == null ? void 0 : s.validate) !== !1 && o.y(this, e.call(o.z, o.e({
                            value: r,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            },
                            styleSpec: o.v
                        })))
                    }
                    calculateFogBlendOpacity(e) {
                        return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1
                    }
                }
                class ue {
                    constructor(e, r) {
                        this.width = e,
                        this.height = r,
                        this.nextRow = 0,
                        this.data = new Uint8Array(this.width * this.height),
                        this.dashEntry = {}
                    }
                    getDash(e, r) {
                        const s = e.join(",") + String(r);
                        return this.dashEntry[s] || (this.dashEntry[s] = this.addDash(e, r)),
                        this.dashEntry[s]
                    }
                    getDashRanges(e, r, s) {
                        const c = [];
                        let d = e.length % 2 == 1 ? -e[e.length - 1] * s : 0
                          , m = e[0] * s
                          , v = !0;
                        c.push({
                            left: d,
                            right: m,
                            isDash: v,
                            zeroLength: e[0] === 0
                        });
                        let b = e[0];
                        for (let P = 1; P < e.length; P++) {
                            v = !v;
                            const M = e[P];
                            d = b * s,
                            b += M,
                            m = b * s,
                            c.push({
                                left: d,
                                right: m,
                                isDash: v,
                                zeroLength: M === 0
                            })
                        }
                        return c
                    }
                    addRoundDash(e, r, s) {
                        const c = r / 2;
                        for (let d = -s; d <= s; d++) {
                            const m = this.width * (this.nextRow + s + d);
                            let v = 0
                              , b = e[v];
                            for (let P = 0; P < this.width; P++) {
                                P / b.right > 1 && (b = e[++v]);
                                const M = Math.abs(P - b.left)
                                  , D = Math.abs(P - b.right)
                                  , L = Math.min(M, D);
                                let B;
                                const Z = d / s * (c + 1);
                                if (b.isDash) {
                                    const te = c - Math.abs(Z);
                                    B = Math.sqrt(L * L + te * te)
                                } else
                                    B = c - Math.sqrt(L * L + Z * Z);
                                this.data[m + P] = Math.max(0, Math.min(255, B + 128))
                            }
                        }
                    }
                    addRegularDash(e) {
                        for (let v = e.length - 1; v >= 0; --v) {
                            const b = e[v]
                              , P = e[v + 1];
                            b.zeroLength ? e.splice(v, 1) : P && P.isDash === b.isDash && (P.left = b.left,
                            e.splice(v, 1))
                        }
                        const r = e[0]
                          , s = e[e.length - 1];
                        r.isDash === s.isDash && (r.left = s.left - this.width,
                        s.right = r.right + this.width);
                        const c = this.width * this.nextRow;
                        let d = 0
                          , m = e[d];
                        for (let v = 0; v < this.width; v++) {
                            v / m.right > 1 && (m = e[++d]);
                            const b = Math.abs(v - m.left)
                              , P = Math.abs(v - m.right)
                              , M = Math.min(b, P);
                            this.data[c + v] = Math.max(0, Math.min(255, (m.isDash ? M : -M) + 128))
                        }
                    }
                    addDash(e, r) {
                        const s = r ? 7 : 0
                          , c = 2 * s + 1;
                        if (this.nextRow + c > this.height)
                            return o.w("LineAtlas out of space"),
                            null;
                        let d = 0;
                        for (let v = 0; v < e.length; v++)
                            d += e[v];
                        if (d !== 0) {
                            const v = this.width / d
                              , b = this.getDashRanges(e, this.width, v);
                            r ? this.addRoundDash(b, v, s) : this.addRegularDash(b)
                        }
                        const m = {
                            y: (this.nextRow + s + .5) / this.height,
                            height: 2 * s / this.height,
                            width: d
                        };
                        return this.nextRow += c,
                        this.dirty = !0,
                        m
                    }
                    bind(e) {
                        const r = e.gl;
                        this.texture ? (r.bindTexture(r.TEXTURE_2D, this.texture),
                        this.dirty && (this.dirty = !1,
                        r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, this.width, this.height, r.ALPHA, r.UNSIGNED_BYTE, this.data))) : (this.texture = r.createTexture(),
                        r.bindTexture(r.TEXTURE_2D, this.texture),
                        r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.REPEAT),
                        r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.REPEAT),
                        r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR),
                        r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR),
                        r.texImage2D(r.TEXTURE_2D, 0, r.ALPHA, this.width, this.height, 0, r.ALPHA, r.UNSIGNED_BYTE, this.data))
                    }
                }
                const Le = "maplibre_preloaded_worker_pool";
                class Re {
                    constructor() {
                        this.active = {}
                    }
                    acquire(e) {
                        if (!this.workers)
                            for (this.workers = []; this.workers.length < Re.workerCount; )
                                this.workers.push(new Worker(o.a.WORKER_URL));
                        return this.active[e] = !0,
                        this.workers.slice()
                    }
                    release(e) {
                        delete this.active[e],
                        this.numActive() === 0 && (this.workers.forEach(r => {
                            r.terminate()
                        }
                        ),
                        this.workers = null)
                    }
                    isPreloaded() {
                        return !!this.active[Le]
                    }
                    numActive() {
                        return Object.keys(this.active).length
                    }
                }
                const We = Math.floor(he.hardwareConcurrency / 2);
                let it, at;
                function ht() {
                    return it || (it = new Re),
                    it
                }
                Re.workerCount = o.H(globalThis) ? Math.max(Math.min(We, 3), 1) : 1;
                class Ft {
                    constructor(e, r) {
                        this.workerPool = e,
                        this.actors = [],
                        this.currentActor = 0,
                        this.id = r;
                        const s = this.workerPool.acquire(r);
                        for (let c = 0; c < s.length; c++) {
                            const d = new o.J(s[c],r);
                            d.name = `Worker ${c}`,
                            this.actors.push(d)
                        }
                        if (!this.actors.length)
                            throw new Error("No actors found")
                    }
                    broadcast(e, r) {
                        const s = [];
                        for (const c of this.actors)
                            s.push(c.sendAsync({
                                type: e,
                                data: r
                            }));
                        return Promise.all(s)
                    }
                    getActor() {
                        return this.currentActor = (this.currentActor + 1) % this.actors.length,
                        this.actors[this.currentActor]
                    }
                    remove(e=!0) {
                        this.actors.forEach(r => {
                            r.remove()
                        }
                        ),
                        this.actors = [],
                        e && this.workerPool.release(this.id)
                    }
                    registerMessageHandler(e, r) {
                        for (const s of this.actors)
                            s.registerMessageHandler(e, r)
                    }
                }
                function zt() {
                    return at || (at = new Ft(ht(),o.K),
                    at.registerMessageHandler("GR", (h, e, r) => o.m(e, r))),
                    at
                }
                function lr(h, e) {
                    const r = o.L();
                    return o.M(r, r, [1, 1, 0]),
                    o.N(r, r, [.5 * h.width, .5 * h.height, 1]),
                    h.calculatePosMatrix ? o.O(r, r, h.calculatePosMatrix(e.toUnwrapped())) : r
                }
                function kt(h, e, r, s, c, d, m) {
                    var v;
                    const b = function(L, B, Z) {
                        if (L)
                            for (const te of L) {
                                const ee = B[te];
                                if (ee && ee.source === Z && ee.type === "fill-extrusion")
                                    return !0
                            }
                        else
                            for (const te in B) {
                                const ee = B[te];
                                if (ee.source === Z && ee.type === "fill-extrusion")
                                    return !0
                            }
                        return !1
                    }((v = c == null ? void 0 : c.layers) !== null && v !== void 0 ? v : null, e, h.id)
                      , P = d.maxPitchScaleFactor()
                      , M = h.tilesIn(s, P, b);
                    M.sort(xt);
                    const D = [];
                    for (const L of M)
                        D.push({
                            wrappedTileID: L.tileID.wrapped().key,
                            queryResults: L.tile.queryRenderedFeatures(e, r, h._state, L.queryGeometry, L.cameraQueryGeometry, L.scale, c, d, P, lr(h.transform, L.tileID), m ? (B, Z) => m(L.tileID, B, Z) : void 0)
                        });
                    return function(L, B) {
                        for (const Z in L)
                            for (const te of L[Z])
                                Pt(te, B);
                        return L
                    }(function(L) {
                        const B = {}
                          , Z = {};
                        for (const te of L) {
                            const ee = te.queryResults
                              , ne = te.wrappedTileID
                              , oe = Z[ne] = Z[ne] || {};
                            for (const me in ee) {
                                const ce = ee[me]
                                  , Te = oe[me] = oe[me] || {}
                                  , Pe = B[me] = B[me] || [];
                                for (const pe of ce)
                                    Te[pe.featureIndex] || (Te[pe.featureIndex] = !0,
                                    Pe.push(pe))
                            }
                        }
                        return B
                    }(D), h)
                }
                function xt(h, e) {
                    const r = h.tileID
                      , s = e.tileID;
                    return r.overscaledZ - s.overscaledZ || r.canonical.y - s.canonical.y || r.wrap - s.wrap || r.canonical.x - s.canonical.x
                }
                function Pt(h, e) {
                    const r = h.feature
                      , s = e.getFeatureState(r.layer["source-layer"], r.id);
                    r.source = r.layer.source,
                    r.layer["source-layer"] && (r.sourceLayer = r.layer["source-layer"]),
                    r.state = s
                }
                function jt(h, e, r) {
                    return o._(this, void 0, void 0, function*() {
                        let s = h;
                        if (h.url ? s = (yield o.j(e.transformRequest(h.url, "Source"), r)).data : yield he.frameAsync(r),
                        !s)
                            return null;
                        const c = o.Q(o.e(s, h), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
                        return "vector_layers"in s && s.vector_layers && (c.vectorLayerIds = s.vector_layers.map(d => d.id)),
                        c
                    })
                }
                class Lt {
                    constructor(e, r) {
                        e && (r ? this.setSouthWest(e).setNorthEast(r) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])))
                    }
                    setNorthEast(e) {
                        return this._ne = e instanceof o.S ? new o.S(e.lng,e.lat) : o.S.convert(e),
                        this
                    }
                    setSouthWest(e) {
                        return this._sw = e instanceof o.S ? new o.S(e.lng,e.lat) : o.S.convert(e),
                        this
                    }
                    extend(e) {
                        const r = this._sw
                          , s = this._ne;
                        let c, d;
                        if (e instanceof o.S)
                            c = e,
                            d = e;
                        else {
                            if (!(e instanceof Lt))
                                return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(Lt.convert(e)) : this.extend(o.S.convert(e)) : e && ("lng"in e || "lon"in e) && "lat"in e ? this.extend(o.S.convert(e)) : this;
                            if (c = e._sw,
                            d = e._ne,
                            !c || !d)
                                return this
                        }
                        return r || s ? (r.lng = Math.min(c.lng, r.lng),
                        r.lat = Math.min(c.lat, r.lat),
                        s.lng = Math.max(d.lng, s.lng),
                        s.lat = Math.max(d.lat, s.lat)) : (this._sw = new o.S(c.lng,c.lat),
                        this._ne = new o.S(d.lng,d.lat)),
                        this
                    }
                    getCenter() {
                        return new o.S((this._sw.lng + this._ne.lng) / 2,(this._sw.lat + this._ne.lat) / 2)
                    }
                    getSouthWest() {
                        return this._sw
                    }
                    getNorthEast() {
                        return this._ne
                    }
                    getNorthWest() {
                        return new o.S(this.getWest(),this.getNorth())
                    }
                    getSouthEast() {
                        return new o.S(this.getEast(),this.getSouth())
                    }
                    getWest() {
                        return this._sw.lng
                    }
                    getSouth() {
                        return this._sw.lat
                    }
                    getEast() {
                        return this._ne.lng
                    }
                    getNorth() {
                        return this._ne.lat
                    }
                    toArray() {
                        return [this._sw.toArray(), this._ne.toArray()]
                    }
                    toString() {
                        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
                    }
                    isEmpty() {
                        return !(this._sw && this._ne)
                    }
                    contains(e) {
                        const {lng: r, lat: s} = o.S.convert(e);
                        let c = this._sw.lng <= r && r <= this._ne.lng;
                        return this._sw.lng > this._ne.lng && (c = this._sw.lng >= r && r >= this._ne.lng),
                        this._sw.lat <= s && s <= this._ne.lat && c
                    }
                    static convert(e) {
                        return e instanceof Lt ? e : e && new Lt(e)
                    }
                    static fromLngLat(e, r=0) {
                        const s = 360 * r / 40075017
                          , c = s / Math.cos(Math.PI / 180 * e.lat);
                        return new Lt(new o.S(e.lng - c,e.lat - s),new o.S(e.lng + c,e.lat + s))
                    }
                    adjustAntiMeridian() {
                        const e = new o.S(this._sw.lng,this._sw.lat)
                          , r = new o.S(this._ne.lng,this._ne.lat);
                        return new Lt(e,e.lng > r.lng ? new o.S(r.lng + 360,r.lat) : r)
                    }
                }
                class nr {
                    constructor(e, r, s) {
                        this.bounds = Lt.convert(this.validateBounds(e)),
                        this.minzoom = r || 0,
                        this.maxzoom = s || 24
                    }
                    validateBounds(e) {
                        return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90]
                    }
                    contains(e) {
                        const r = Math.pow(2, e.z)
                          , s = Math.floor(o.V(this.bounds.getWest()) * r)
                          , c = Math.floor(o.U(this.bounds.getNorth()) * r)
                          , d = Math.ceil(o.V(this.bounds.getEast()) * r)
                          , m = Math.ceil(o.U(this.bounds.getSouth()) * r);
                        return e.x >= s && e.x < d && e.y >= c && e.y < m
                    }
                }
                class xr extends o.E {
                    constructor(e, r, s, c) {
                        if (super(),
                        this.id = e,
                        this.dispatcher = s,
                        this.type = "vector",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.scheme = "xyz",
                        this.tileSize = 512,
                        this.reparseOverscaled = !0,
                        this.isTileClipped = !0,
                        this._loaded = !1,
                        o.e(this, o.Q(r, ["url", "scheme", "tileSize", "promoteId"])),
                        this._options = o.e({
                            type: "vector"
                        }, r),
                        this._collectResourceTiming = r.collectResourceTiming,
                        this.tileSize !== 512)
                            throw new Error("vector tile sources must have a tileSize of 512");
                        this.setEventedParent(c)
                    }
                    load() {
                        return o._(this, void 0, void 0, function*() {
                            this._loaded = !1,
                            this.fire(new o.l("dataloading",{
                                dataType: "source"
                            })),
                            this._tileJSONRequest = new AbortController;
                            try {
                                const e = yield jt(this._options, this.map._requestManager, this._tileJSONRequest);
                                this._tileJSONRequest = null,
                                this._loaded = !0,
                                this.map.style.sourceCaches[this.id].clearTiles(),
                                e && (o.e(this, e),
                                e.bounds && (this.tileBounds = new nr(e.bounds,this.minzoom,this.maxzoom)),
                                this.fire(new o.l("data",{
                                    dataType: "source",
                                    sourceDataType: "metadata"
                                })),
                                this.fire(new o.l("data",{
                                    dataType: "source",
                                    sourceDataType: "content"
                                })))
                            } catch (e) {
                                this._tileJSONRequest = null,
                                this.fire(new o.k(e))
                            }
                        })
                    }
                    loaded() {
                        return this._loaded
                    }
                    hasTile(e) {
                        return !this.tileBounds || this.tileBounds.contains(e.canonical)
                    }
                    onAdd(e) {
                        this.map = e,
                        this.load()
                    }
                    setSourceProperty(e) {
                        this._tileJSONRequest && this._tileJSONRequest.abort(),
                        e(),
                        this.load()
                    }
                    setTiles(e) {
                        return this.setSourceProperty( () => {
                            this._options.tiles = e
                        }
                        ),
                        this
                    }
                    setUrl(e) {
                        return this.setSourceProperty( () => {
                            this.url = e,
                            this._options.url = e
                        }
                        ),
                        this
                    }
                    onRemove() {
                        this._tileJSONRequest && (this._tileJSONRequest.abort(),
                        this._tileJSONRequest = null)
                    }
                    serialize() {
                        return o.e({}, this._options)
                    }
                    loadTile(e) {
                        return o._(this, void 0, void 0, function*() {
                            const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme)
                              , s = {
                                request: this.map._requestManager.transformRequest(r, "Tile"),
                                uid: e.uid,
                                tileID: e.tileID,
                                zoom: e.tileID.overscaledZ,
                                tileSize: this.tileSize * e.tileID.overscaleFactor(),
                                type: this.type,
                                source: this.id,
                                pixelRatio: this.map.getPixelRatio(),
                                showCollisionBoxes: this.map.showCollisionBoxes,
                                promoteId: this.promoteId,
                                subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
                                globalState: this.map.getGlobalState()
                            };
                            s.request.collectResourceTiming = this._collectResourceTiming;
                            let c = "RT";
                            if (e.actor && e.state !== "expired") {
                                if (e.state === "loading")
                                    return new Promise( (d, m) => {
                                        e.reloadPromise = {
                                            resolve: d,
                                            reject: m
                                        }
                                    }
                                    )
                            } else
                                e.actor = this.dispatcher.getActor(),
                                c = "LT";
                            e.abortController = new AbortController;
                            try {
                                const d = yield e.actor.sendAsync({
                                    type: c,
                                    data: s
                                }, e.abortController);
                                if (delete e.abortController,
                                e.aborted)
                                    return;
                                this._afterTileLoadWorkerResponse(e, d)
                            } catch (d) {
                                if (delete e.abortController,
                                e.aborted)
                                    return;
                                if (d && d.status !== 404)
                                    throw d;
                                this._afterTileLoadWorkerResponse(e, null)
                            }
                        })
                    }
                    _afterTileLoadWorkerResponse(e, r) {
                        if (r && r.resourceTiming && (e.resourceTiming = r.resourceTiming),
                        r && this.map._refreshExpiredTiles && e.setExpiryData(r),
                        e.loadVectorData(r, this.map.painter),
                        e.reloadPromise) {
                            const s = e.reloadPromise;
                            e.reloadPromise = null,
                            this.loadTile(e).then(s.resolve).catch(s.reject)
                        }
                    }
                    abortTile(e) {
                        return o._(this, void 0, void 0, function*() {
                            e.abortController && (e.abortController.abort(),
                            delete e.abortController),
                            e.actor && (yield e.actor.sendAsync({
                                type: "AT",
                                data: {
                                    uid: e.uid,
                                    type: this.type,
                                    source: this.id
                                }
                            }))
                        })
                    }
                    unloadTile(e) {
                        return o._(this, void 0, void 0, function*() {
                            e.unloadVectorData(),
                            e.actor && (yield e.actor.sendAsync({
                                type: "RMT",
                                data: {
                                    uid: e.uid,
                                    type: this.type,
                                    source: this.id
                                }
                            }))
                        })
                    }
                    hasTransition() {
                        return !1
                    }
                }
                class er extends o.E {
                    constructor(e, r, s, c) {
                        super(),
                        this.id = e,
                        this.dispatcher = s,
                        this.setEventedParent(c),
                        this.type = "raster",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.roundZoom = !0,
                        this.scheme = "xyz",
                        this.tileSize = 512,
                        this._loaded = !1,
                        this._options = o.e({
                            type: "raster"
                        }, r),
                        o.e(this, o.Q(r, ["url", "scheme", "tileSize"]))
                    }
                    load() {
                        return o._(this, arguments, void 0, function*(e=!1) {
                            this._loaded = !1,
                            this.fire(new o.l("dataloading",{
                                dataType: "source"
                            })),
                            this._tileJSONRequest = new AbortController;
                            try {
                                const r = yield jt(this._options, this.map._requestManager, this._tileJSONRequest);
                                this._tileJSONRequest = null,
                                this._loaded = !0,
                                r && (o.e(this, r),
                                r.bounds && (this.tileBounds = new nr(r.bounds,this.minzoom,this.maxzoom)),
                                this.fire(new o.l("data",{
                                    dataType: "source",
                                    sourceDataType: "metadata"
                                })),
                                this.fire(new o.l("data",{
                                    dataType: "source",
                                    sourceDataType: "content",
                                    sourceDataChanged: e
                                })))
                            } catch (r) {
                                this._tileJSONRequest = null,
                                this.fire(new o.k(r))
                            }
                        })
                    }
                    loaded() {
                        return this._loaded
                    }
                    onAdd(e) {
                        this.map = e,
                        this.load()
                    }
                    onRemove() {
                        this._tileJSONRequest && (this._tileJSONRequest.abort(),
                        this._tileJSONRequest = null)
                    }
                    setSourceProperty(e) {
                        this._tileJSONRequest && (this._tileJSONRequest.abort(),
                        this._tileJSONRequest = null),
                        e(),
                        this.load(!0)
                    }
                    setTiles(e) {
                        return this.setSourceProperty( () => {
                            this._options.tiles = e
                        }
                        ),
                        this
                    }
                    setUrl(e) {
                        return this.setSourceProperty( () => {
                            this.url = e,
                            this._options.url = e
                        }
                        ),
                        this
                    }
                    serialize() {
                        return o.e({}, this._options)
                    }
                    hasTile(e) {
                        return !this.tileBounds || this.tileBounds.contains(e.canonical)
                    }
                    loadTile(e) {
                        return o._(this, void 0, void 0, function*() {
                            const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
                            e.abortController = new AbortController;
                            try {
                                const s = yield Ze.getImage(this.map._requestManager.transformRequest(r, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                                if (delete e.abortController,
                                e.aborted)
                                    return void (e.state = "unloaded");
                                if (s && s.data) {
                                    this.map._refreshExpiredTiles && (s.cacheControl || s.expires) && e.setExpiryData({
                                        cacheControl: s.cacheControl,
                                        expires: s.expires
                                    });
                                    const c = this.map.painter.context
                                      , d = c.gl
                                      , m = s.data;
                                    e.texture = this.map.painter.getTileTexture(m.width),
                                    e.texture ? e.texture.update(m, {
                                        useMipmap: !0
                                    }) : (e.texture = new o.T(c,m,d.RGBA,{
                                        useMipmap: !0
                                    }),
                                    e.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE, d.LINEAR_MIPMAP_NEAREST)),
                                    e.state = "loaded"
                                }
                            } catch (s) {
                                if (delete e.abortController,
                                e.aborted)
                                    e.state = "unloaded";
                                else if (s)
                                    throw e.state = "errored",
                                    s
                            }
                        })
                    }
                    abortTile(e) {
                        return o._(this, void 0, void 0, function*() {
                            e.abortController && (e.abortController.abort(),
                            delete e.abortController)
                        })
                    }
                    unloadTile(e) {
                        return o._(this, void 0, void 0, function*() {
                            e.texture && this.map.painter.saveTileTexture(e.texture)
                        })
                    }
                    hasTransition() {
                        return !1
                    }
                }
                class Qt extends er {
                    constructor(e, r, s, c) {
                        super(e, r, s, c),
                        this.type = "raster-dem",
                        this.maxzoom = 22,
                        this._options = o.e({
                            type: "raster-dem"
                        }, r),
                        this.encoding = r.encoding || "mapbox",
                        this.redFactor = r.redFactor,
                        this.greenFactor = r.greenFactor,
                        this.blueFactor = r.blueFactor,
                        this.baseShift = r.baseShift
                    }
                    loadTile(e) {
                        return o._(this, void 0, void 0, function*() {
                            const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme)
                              , s = this.map._requestManager.transformRequest(r, "Tile");
                            e.neighboringTiles = this._getNeighboringTiles(e.tileID),
                            e.abortController = new AbortController;
                            try {
                                const c = yield Ze.getImage(s, e.abortController, this.map._refreshExpiredTiles);
                                if (delete e.abortController,
                                e.aborted)
                                    return void (e.state = "unloaded");
                                if (c && c.data) {
                                    const d = c.data;
                                    this.map._refreshExpiredTiles && (c.cacheControl || c.expires) && e.setExpiryData({
                                        cacheControl: c.cacheControl,
                                        expires: c.expires
                                    });
                                    const m = o.b(d) && o.W() ? d : yield this.readImageNow(d)
                                      , v = {
                                        type: this.type,
                                        uid: e.uid,
                                        source: this.id,
                                        rawImageData: m,
                                        encoding: this.encoding,
                                        redFactor: this.redFactor,
                                        greenFactor: this.greenFactor,
                                        blueFactor: this.blueFactor,
                                        baseShift: this.baseShift
                                    };
                                    if (!e.actor || e.state === "expired") {
                                        e.actor = this.dispatcher.getActor();
                                        const b = yield e.actor.sendAsync({
                                            type: "LDT",
                                            data: v
                                        });
                                        e.dem = b,
                                        e.needsHillshadePrepare = !0,
                                        e.needsTerrainPrepare = !0,
                                        e.state = "loaded"
                                    }
                                }
                            } catch (c) {
                                if (delete e.abortController,
                                e.aborted)
                                    e.state = "unloaded";
                                else if (c)
                                    throw e.state = "errored",
                                    c
                            }
                        })
                    }
                    readImageNow(e) {
                        return o._(this, void 0, void 0, function*() {
                            if (typeof VideoFrame < "u" && o.X()) {
                                const r = e.width + 2
                                  , s = e.height + 2;
                                try {
                                    return new o.R({
                                        width: r,
                                        height: s
                                    },yield o.Y(e, -1, -1, r, s))
                                } catch {}
                            }
                            return he.getImageData(e, 1)
                        })
                    }
                    _getNeighboringTiles(e) {
                        const r = e.canonical
                          , s = Math.pow(2, r.z)
                          , c = (r.x - 1 + s) % s
                          , d = r.x === 0 ? e.wrap - 1 : e.wrap
                          , m = (r.x + 1 + s) % s
                          , v = r.x + 1 === s ? e.wrap + 1 : e.wrap
                          , b = {};
                        return b[new o.Z(e.overscaledZ,d,r.z,c,r.y).key] = {
                            backfilled: !1
                        },
                        b[new o.Z(e.overscaledZ,v,r.z,m,r.y).key] = {
                            backfilled: !1
                        },
                        r.y > 0 && (b[new o.Z(e.overscaledZ,d,r.z,c,r.y - 1).key] = {
                            backfilled: !1
                        },
                        b[new o.Z(e.overscaledZ,e.wrap,r.z,r.x,r.y - 1).key] = {
                            backfilled: !1
                        },
                        b[new o.Z(e.overscaledZ,v,r.z,m,r.y - 1).key] = {
                            backfilled: !1
                        }),
                        r.y + 1 < s && (b[new o.Z(e.overscaledZ,d,r.z,c,r.y + 1).key] = {
                            backfilled: !1
                        },
                        b[new o.Z(e.overscaledZ,e.wrap,r.z,r.x,r.y + 1).key] = {
                            backfilled: !1
                        },
                        b[new o.Z(e.overscaledZ,v,r.z,m,r.y + 1).key] = {
                            backfilled: !1
                        }),
                        b
                    }
                    unloadTile(e) {
                        return o._(this, void 0, void 0, function*() {
                            e.demTexture && this.map.painter.saveTileTexture(e.demTexture),
                            e.fbo && (e.fbo.destroy(),
                            delete e.fbo),
                            e.dem && delete e.dem,
                            delete e.neighboringTiles,
                            e.state = "unloaded",
                            e.actor && (yield e.actor.sendAsync({
                                type: "RDT",
                                data: {
                                    type: this.type,
                                    uid: e.uid,
                                    source: this.id
                                }
                            }))
                        })
                    }
                }
                class $t extends o.E {
                    constructor(e, r, s, c) {
                        super(),
                        this.id = e,
                        this.type = "geojson",
                        this.minzoom = 0,
                        this.maxzoom = 18,
                        this.tileSize = 512,
                        this.isTileClipped = !0,
                        this.reparseOverscaled = !0,
                        this._removed = !1,
                        this._pendingLoads = 0,
                        this.actor = s.getActor(),
                        this.setEventedParent(c),
                        this._data = r.data,
                        this._options = o.e({}, r),
                        this._collectResourceTiming = r.collectResourceTiming,
                        r.maxzoom !== void 0 && (this.maxzoom = r.maxzoom),
                        r.type && (this.type = r.type),
                        r.attribution && (this.attribution = r.attribution),
                        this.promoteId = r.promoteId,
                        r.clusterMaxZoom !== void 0 && this.maxzoom <= r.clusterMaxZoom && o.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${r.clusterMaxZoom}".`),
                        this.workerOptions = o.e({
                            source: this.id,
                            cluster: r.cluster || !1,
                            geojsonVtOptions: {
                                buffer: this._pixelsToTileUnits(r.buffer !== void 0 ? r.buffer : 128),
                                tolerance: this._pixelsToTileUnits(r.tolerance !== void 0 ? r.tolerance : .375),
                                extent: o.$,
                                maxZoom: this.maxzoom,
                                lineMetrics: r.lineMetrics || !1,
                                generateId: r.generateId || !1
                            },
                            superclusterOptions: {
                                maxZoom: this._getClusterMaxZoom(r.clusterMaxZoom),
                                minPoints: Math.max(2, r.clusterMinPoints || 2),
                                extent: o.$,
                                radius: this._pixelsToTileUnits(r.clusterRadius || 50),
                                log: !1,
                                generateId: r.generateId || !1
                            },
                            clusterProperties: r.clusterProperties,
                            filter: r.filter
                        }, r.workerOptions),
                        typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId)
                    }
                    _pixelsToTileUnits(e) {
                        return e * (o.$ / this.tileSize)
                    }
                    _getClusterMaxZoom(e) {
                        const r = e ? Math.round(e) : this.maxzoom - 1;
                        return Number.isInteger(e) || e === void 0 || o.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${r}"`),
                        r
                    }
                    load() {
                        return o._(this, void 0, void 0, function*() {
                            yield this._updateWorkerData()
                        })
                    }
                    onAdd(e) {
                        this.map = e,
                        this.load()
                    }
                    setData(e) {
                        return this._data = e,
                        this._updateWorkerData(),
                        this
                    }
                    updateData(e) {
                        return this._updateWorkerData(e),
                        this
                    }
                    getData() {
                        return o._(this, void 0, void 0, function*() {
                            const e = o.e({
                                type: this.type
                            }, this.workerOptions);
                            return this.actor.sendAsync({
                                type: "GD",
                                data: e
                            })
                        })
                    }
                    getCoordinatesFromGeometry(e) {
                        return e.type === "GeometryCollection" ? e.geometries.map(r => r.coordinates).flat(1 / 0) : e.coordinates.flat(1 / 0)
                    }
                    getBounds() {
                        return o._(this, void 0, void 0, function*() {
                            const e = new Lt
                              , r = yield this.getData();
                            let s;
                            switch (r.type) {
                            case "FeatureCollection":
                                s = r.features.map(c => this.getCoordinatesFromGeometry(c.geometry)).flat(1 / 0);
                                break;
                            case "Feature":
                                s = this.getCoordinatesFromGeometry(r.geometry);
                                break;
                            default:
                                s = this.getCoordinatesFromGeometry(r)
                            }
                            if (s.length == 0)
                                return e;
                            for (let c = 0; c < s.length - 1; c += 2)
                                e.extend([s[c], s[c + 1]]);
                            return e
                        })
                    }
                    setClusterOptions(e) {
                        return this.workerOptions.cluster = e.cluster,
                        e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)),
                        e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom))),
                        this._updateWorkerData(),
                        this
                    }
                    getClusterExpansionZoom(e) {
                        return this.actor.sendAsync({
                            type: "GCEZ",
                            data: {
                                type: this.type,
                                clusterId: e,
                                source: this.id
                            }
                        })
                    }
                    getClusterChildren(e) {
                        return this.actor.sendAsync({
                            type: "GCC",
                            data: {
                                type: this.type,
                                clusterId: e,
                                source: this.id
                            }
                        })
                    }
                    getClusterLeaves(e, r, s) {
                        return this.actor.sendAsync({
                            type: "GCL",
                            data: {
                                type: this.type,
                                source: this.id,
                                clusterId: e,
                                limit: r,
                                offset: s
                            }
                        })
                    }
                    _updateWorkerData(e) {
                        return o._(this, void 0, void 0, function*() {
                            const r = o.e({
                                type: this.type
                            }, this.workerOptions);
                            e ? r.dataDiff = e : typeof this._data == "string" ? (r.request = this.map._requestManager.transformRequest(he.resolveURL(this._data), "Source"),
                            r.request.collectResourceTiming = this._collectResourceTiming) : r.data = JSON.stringify(this._data),
                            this._pendingLoads++,
                            this.fire(new o.l("dataloading",{
                                dataType: "source"
                            }));
                            try {
                                const s = yield this.actor.sendAsync({
                                    type: "LD",
                                    data: r
                                });
                                if (this._pendingLoads--,
                                this._removed || s.abandoned)
                                    return void this.fire(new o.l("dataabort",{
                                        dataType: "source"
                                    }));
                                let c = null;
                                s.resourceTiming && s.resourceTiming[this.id] && (c = s.resourceTiming[this.id].slice(0));
                                const d = {
                                    dataType: "source"
                                };
                                this._collectResourceTiming && c && c.length > 0 && o.e(d, {
                                    resourceTiming: c
                                }),
                                this.fire(new o.l("data",Object.assign(Object.assign({}, d), {
                                    sourceDataType: "metadata"
                                }))),
                                this.fire(new o.l("data",Object.assign(Object.assign({}, d), {
                                    sourceDataType: "content"
                                })))
                            } catch (s) {
                                if (this._pendingLoads--,
                                this._removed)
                                    return void this.fire(new o.l("dataabort",{
                                        dataType: "source"
                                    }));
                                this.fire(new o.k(s))
                            }
                        })
                    }
                    loaded() {
                        return this._pendingLoads === 0
                    }
                    loadTile(e) {
                        return o._(this, void 0, void 0, function*() {
                            const r = e.actor ? "RT" : "LT";
                            e.actor = this.actor;
                            const s = {
                                type: this.type,
                                uid: e.uid,
                                tileID: e.tileID,
                                zoom: e.tileID.overscaledZ,
                                maxZoom: this.maxzoom,
                                tileSize: this.tileSize,
                                source: this.id,
                                pixelRatio: this.map.getPixelRatio(),
                                showCollisionBoxes: this.map.showCollisionBoxes,
                                promoteId: this.promoteId,
                                subdivisionGranularity: this.map.style.projection.subdivisionGranularity,
                                globalState: this.map.getGlobalState()
                            };
                            e.abortController = new AbortController;
                            const c = yield this.actor.sendAsync({
                                type: r,
                                data: s
                            }, e.abortController);
                            delete e.abortController,
                            e.unloadVectorData(),
                            e.aborted || e.loadVectorData(c, this.map.painter, r === "RT")
                        })
                    }
                    abortTile(e) {
                        return o._(this, void 0, void 0, function*() {
                            e.abortController && (e.abortController.abort(),
                            delete e.abortController),
                            e.aborted = !0
                        })
                    }
                    unloadTile(e) {
                        return o._(this, void 0, void 0, function*() {
                            e.unloadVectorData(),
                            yield this.actor.sendAsync({
                                type: "RMT",
                                data: {
                                    uid: e.uid,
                                    type: this.type,
                                    source: this.id
                                }
                            })
                        })
                    }
                    onRemove() {
                        this._removed = !0,
                        this.actor.sendAsync({
                            type: "RS",
                            data: {
                                type: this.type,
                                source: this.id
                            }
                        })
                    }
                    serialize() {
                        return o.e({}, this._options, {
                            type: this.type,
                            data: this._data
                        })
                    }
                    hasTransition() {
                        return !1
                    }
                }
                class tr extends o.E {
                    constructor(e, r, s, c) {
                        super(),
                        this.flippedWindingOrder = !1,
                        this.id = e,
                        this.dispatcher = s,
                        this.coordinates = r.coordinates,
                        this.type = "image",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.tileSize = 512,
                        this.tiles = {},
                        this._loaded = !1,
                        this.setEventedParent(c),
                        this.options = r
                    }
                    load(e) {
                        return o._(this, void 0, void 0, function*() {
                            this._loaded = !1,
                            this.fire(new o.l("dataloading",{
                                dataType: "source"
                            })),
                            this.url = this.options.url,
                            this._request = new AbortController;
                            try {
                                const r = yield Ze.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                                this._request = null,
                                this._loaded = !0,
                                r && r.data && (this.image = r.data,
                                e && (this.coordinates = e),
                                this._finishLoading())
                            } catch (r) {
                                this._request = null,
                                this._loaded = !0,
                                this.fire(new o.k(r))
                            }
                        })
                    }
                    loaded() {
                        return this._loaded
                    }
                    updateImage(e) {
                        return e.url ? (this._request && (this._request.abort(),
                        this._request = null),
                        this.options.url = e.url,
                        this.load(e.coordinates).finally( () => {
                            this.texture = null
                        }
                        ),
                        this) : this
                    }
                    _finishLoading() {
                        this.map && (this.setCoordinates(this.coordinates),
                        this.fire(new o.l("data",{
                            dataType: "source",
                            sourceDataType: "metadata"
                        })))
                    }
                    onAdd(e) {
                        this.map = e,
                        this.load()
                    }
                    onRemove() {
                        this._request && (this._request.abort(),
                        this._request = null)
                    }
                    setCoordinates(e) {
                        this.coordinates = e;
                        const r = e.map(o.a0.fromLngLat);
                        var s;
                        return this.tileID = function(c) {
                            const d = o.a1.fromPoints(c)
                              , m = d.width()
                              , v = d.height()
                              , b = Math.max(m, v)
                              , P = Math.max(0, Math.floor(-Math.log(b) / Math.LN2))
                              , M = Math.pow(2, P);
                            return new o.a3(P,Math.floor((d.minX + d.maxX) / 2 * M),Math.floor((d.minY + d.maxY) / 2 * M))
                        }(r),
                        this.terrainTileRanges = this._getOverlappingTileRanges(r),
                        this.minzoom = this.maxzoom = this.tileID.z,
                        this.tileCoords = r.map(c => this.tileID.getTilePoint(c)._round()),
                        this.flippedWindingOrder = ((s = this.tileCoords)[1].x - s[0].x) * (s[2].y - s[0].y) - (s[1].y - s[0].y) * (s[2].x - s[0].x) < 0,
                        this.fire(new o.l("data",{
                            dataType: "source",
                            sourceDataType: "content"
                        })),
                        this
                    }
                    prepare() {
                        if (Object.keys(this.tiles).length === 0 || !this.image)
                            return;
                        const e = this.map.painter.context
                          , r = e.gl;
                        this.texture || (this.texture = new o.T(e,this.image,r.RGBA),
                        this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
                        let s = !1;
                        for (const c in this.tiles) {
                            const d = this.tiles[c];
                            d.state !== "loaded" && (d.state = "loaded",
                            d.texture = this.texture,
                            s = !0)
                        }
                        s && this.fire(new o.l("data",{
                            dataType: "source",
                            sourceDataType: "idle",
                            sourceId: this.id
                        }))
                    }
                    loadTile(e) {
                        return o._(this, void 0, void 0, function*() {
                            this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e,
                            e.buckets = {}) : e.state = "errored"
                        })
                    }
                    serialize() {
                        return {
                            type: "image",
                            url: this.options.url,
                            coordinates: this.coordinates
                        }
                    }
                    hasTransition() {
                        return !1
                    }
                    _getOverlappingTileRanges(e) {
                        const {minX: r, minY: s, maxX: c, maxY: d} = o.a1.fromPoints(e)
                          , m = {};
                        for (let v = 0; v <= o.a2; v++) {
                            const b = Math.pow(2, v)
                              , P = Math.floor(r * b)
                              , M = Math.floor(s * b)
                              , D = Math.floor(c * b)
                              , L = Math.floor(d * b);
                            m[v] = {
                                minTileX: P,
                                minTileY: M,
                                maxTileX: D,
                                maxTileY: L
                            }
                        }
                        return m
                    }
                }
                class $r extends tr {
                    constructor(e, r, s, c) {
                        super(e, r, s, c),
                        this.roundZoom = !0,
                        this.type = "video",
                        this.options = r
                    }
                    load() {
                        return o._(this, void 0, void 0, function*() {
                            this._loaded = !1;
                            const e = this.options;
                            this.urls = [];
                            for (const r of e.urls)
                                this.urls.push(this.map._requestManager.transformRequest(r, "Source").url);
                            try {
                                const r = yield o.a4(this.urls);
                                if (this._loaded = !0,
                                !r)
                                    return;
                                this.video = r,
                                this.video.loop = !0,
                                this.video.addEventListener("playing", () => {
                                    this.map.triggerRepaint()
                                }
                                ),
                                this.map && this.video.play(),
                                this._finishLoading()
                            } catch (r) {
                                this.fire(new o.k(r))
                            }
                        })
                    }
                    pause() {
                        this.video && this.video.pause()
                    }
                    play() {
                        this.video && this.video.play()
                    }
                    seek(e) {
                        if (this.video) {
                            const r = this.video.seekable;
                            e < r.start(0) || e > r.end(0) ? this.fire(new o.k(new o.a5(`sources.${this.id}`,null,`Playback for this video can be set only between the ${r.start(0)} and ${r.end(0)}-second mark.`))) : this.video.currentTime = e
                        }
                    }
                    getVideo() {
                        return this.video
                    }
                    onAdd(e) {
                        this.map || (this.map = e,
                        this.load(),
                        this.video && (this.video.play(),
                        this.setCoordinates(this.coordinates)))
                    }
                    prepare() {
                        if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
                            return;
                        const e = this.map.painter.context
                          , r = e.gl;
                        this.texture ? this.video.paused || (this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE),
                        r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, r.RGBA, r.UNSIGNED_BYTE, this.video)) : (this.texture = new o.T(e,this.video,r.RGBA),
                        this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
                        let s = !1;
                        for (const c in this.tiles) {
                            const d = this.tiles[c];
                            d.state !== "loaded" && (d.state = "loaded",
                            d.texture = this.texture,
                            s = !0)
                        }
                        s && this.fire(new o.l("data",{
                            dataType: "source",
                            sourceDataType: "idle",
                            sourceId: this.id
                        }))
                    }
                    serialize() {
                        return {
                            type: "video",
                            urls: this.urls,
                            coordinates: this.coordinates
                        }
                    }
                    hasTransition() {
                        return this.video && !this.video.paused
                    }
                }
                class zr extends tr {
                    constructor(e, r, s, c) {
                        super(e, r, s, c),
                        r.coordinates ? Array.isArray(r.coordinates) && r.coordinates.length === 4 && !r.coordinates.some(d => !Array.isArray(d) || d.length !== 2 || d.some(m => typeof m != "number")) || this.fire(new o.k(new o.a5(`sources.${e}`,null,'"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new o.k(new o.a5(`sources.${e}`,null,'missing required property "coordinates"'))),
                        r.animate && typeof r.animate != "boolean" && this.fire(new o.k(new o.a5(`sources.${e}`,null,'optional "animate" property must be a boolean value'))),
                        r.canvas ? typeof r.canvas == "string" || r.canvas instanceof HTMLCanvasElement || this.fire(new o.k(new o.a5(`sources.${e}`,null,'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new o.k(new o.a5(`sources.${e}`,null,'missing required property "canvas"'))),
                        this.options = r,
                        this.animate = r.animate === void 0 || r.animate
                    }
                    load() {
                        return o._(this, void 0, void 0, function*() {
                            this._loaded = !0,
                            this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)),
                            this.width = this.canvas.width,
                            this.height = this.canvas.height,
                            this._hasInvalidDimensions() ? this.fire(new o.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                                this._playing = !0,
                                this.map.triggerRepaint()
                            }
                            ,
                            this.pause = function() {
                                this._playing && (this.prepare(),
                                this._playing = !1)
                            }
                            ,
                            this._finishLoading())
                        })
                    }
                    getCanvas() {
                        return this.canvas
                    }
                    onAdd(e) {
                        this.map = e,
                        this.load(),
                        this.canvas && this.animate && this.play()
                    }
                    onRemove() {
                        this.pause()
                    }
                    prepare() {
                        let e = !1;
                        if (this.canvas.width !== this.width && (this.width = this.canvas.width,
                        e = !0),
                        this.canvas.height !== this.height && (this.height = this.canvas.height,
                        e = !0),
                        this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0)
                            return;
                        const r = this.map.painter.context
                          , s = r.gl;
                        this.texture ? (e || this._playing) && this.texture.update(this.canvas, {
                            premultiply: !0
                        }) : this.texture = new o.T(r,this.canvas,s.RGBA,{
                            premultiply: !0
                        });
                        let c = !1;
                        for (const d in this.tiles) {
                            const m = this.tiles[d];
                            m.state !== "loaded" && (m.state = "loaded",
                            m.texture = this.texture,
                            c = !0)
                        }
                        c && this.fire(new o.l("data",{
                            dataType: "source",
                            sourceDataType: "idle",
                            sourceId: this.id
                        }))
                    }
                    serialize() {
                        return {
                            type: "canvas",
                            coordinates: this.coordinates
                        }
                    }
                    hasTransition() {
                        return this._playing
                    }
                    _hasInvalidDimensions() {
                        for (const e of [this.canvas.width, this.canvas.height])
                            if (isNaN(e) || e <= 0)
                                return !0;
                        return !1
                    }
                }
                const Mr = {}
                  , sr = h => {
                    switch (h) {
                    case "geojson":
                        return $t;
                    case "image":
                        return tr;
                    case "raster":
                        return er;
                    case "raster-dem":
                        return Qt;
                    case "vector":
                        return xr;
                    case "video":
                        return $r;
                    case "canvas":
                        return zr
                    }
                    return Mr[h]
                }
                  , Xt = "RTLPluginLoaded";
                class Ir extends o.E {
                    constructor() {
                        super(...arguments),
                        this.status = "unavailable",
                        this.url = null,
                        this.dispatcher = zt()
                    }
                    _syncState(e) {
                        return this.status = e,
                        this.dispatcher.broadcast("SRPS", {
                            pluginStatus: e,
                            pluginURL: this.url
                        }).catch(r => {
                            throw this.status = "error",
                            r
                        }
                        )
                    }
                    getRTLTextPluginStatus() {
                        return this.status
                    }
                    clearRTLTextPlugin() {
                        this.status = "unavailable",
                        this.url = null
                    }
                    setRTLTextPlugin(e) {
                        return o._(this, arguments, void 0, function*(r, s=!1) {
                            if (this.url)
                                throw new Error("setRTLTextPlugin cannot be called multiple times.");
                            if (this.url = he.resolveURL(r),
                            !this.url)
                                throw new Error(`requested url ${r} is invalid`);
                            if (this.status === "unavailable") {
                                if (!s)
                                    return this._requestImport();
                                this.status = "deferred",
                                this._syncState(this.status)
                            } else if (this.status === "requested")
                                return this._requestImport()
                        })
                    }
                    _requestImport() {
                        return o._(this, void 0, void 0, function*() {
                            yield this._syncState("loading"),
                            this.status = "loaded",
                            this.fire(new o.l(Xt))
                        })
                    }
                    lazyLoad() {
                        this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport()
                    }
                }
                let mr = null;
                function vr() {
                    return mr || (mr = new Ir),
                    mr
                }
                class br {
                    constructor(e, r) {
                        this.timeAdded = 0,
                        this.fadeEndTime = 0,
                        this.tileID = e,
                        this.uid = o.a6(),
                        this.uses = 0,
                        this.tileSize = r,
                        this.buckets = {},
                        this.expirationTime = null,
                        this.queryPadding = 0,
                        this.hasSymbolBuckets = !1,
                        this.hasRTLText = !1,
                        this.dependencies = {},
                        this.rtt = [],
                        this.rttCoords = {},
                        this.expiredRequestCount = 0,
                        this.state = "loading"
                    }
                    registerFadeDuration(e) {
                        const r = e + this.timeAdded;
                        r < this.fadeEndTime || (this.fadeEndTime = r)
                    }
                    wasRequested() {
                        return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
                    }
                    clearTextures(e) {
                        this.demTexture && e.saveTileTexture(this.demTexture),
                        this.demTexture = null
                    }
                    loadVectorData(e, r, s) {
                        if (this.hasData() && this.unloadVectorData(),
                        this.state = "loaded",
                        e) {
                            e.featureIndex && (this.latestFeatureIndex = e.featureIndex,
                            e.rawTileData ? (this.latestRawTileData = e.rawTileData,
                            this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)),
                            this.collisionBoxArray = e.collisionBoxArray,
                            this.buckets = function(c, d) {
                                const m = {};
                                if (!d)
                                    return m;
                                for (const v of c) {
                                    const b = v.layerIds.map(P => d.getLayer(P)).filter(Boolean);
                                    if (b.length !== 0) {
                                        v.layers = b,
                                        v.stateDependentLayerIds && (v.stateDependentLayers = v.stateDependentLayerIds.map(P => b.filter(M => M.id === P)[0]));
                                        for (const P of b)
                                            m[P.id] = v
                                    }
                                }
                                return m
                            }(e.buckets, r == null ? void 0 : r.style),
                            this.hasSymbolBuckets = !1;
                            for (const c in this.buckets) {
                                const d = this.buckets[c];
                                if (d instanceof o.a8) {
                                    if (this.hasSymbolBuckets = !0,
                                    !s)
                                        break;
                                    d.justReloaded = !0
                                }
                            }
                            if (this.hasRTLText = !1,
                            this.hasSymbolBuckets)
                                for (const c in this.buckets) {
                                    const d = this.buckets[c];
                                    if (d instanceof o.a8 && d.hasRTLText) {
                                        this.hasRTLText = !0,
                                        vr().lazyLoad();
                                        break
                                    }
                                }
                            this.queryPadding = 0;
                            for (const c in this.buckets) {
                                const d = this.buckets[c];
                                this.queryPadding = Math.max(this.queryPadding, r.style.getLayer(c).queryRadius(d))
                            }
                            e.imageAtlas && (this.imageAtlas = e.imageAtlas),
                            e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage)
                        } else
                            this.collisionBoxArray = new o.a7
                    }
                    unloadVectorData() {
                        for (const e in this.buckets)
                            this.buckets[e].destroy();
                        this.buckets = {},
                        this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
                        this.imageAtlas && (this.imageAtlas = null),
                        this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
                        this.latestFeatureIndex = null,
                        this.state = "unloaded"
                    }
                    getBucket(e) {
                        return this.buckets[e.id]
                    }
                    upload(e) {
                        for (const s in this.buckets) {
                            const c = this.buckets[s];
                            c.uploadPending() && c.upload(e)
                        }
                        const r = e.gl;
                        this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new o.T(e,this.imageAtlas.image,r.RGBA),
                        this.imageAtlas.uploaded = !0),
                        this.glyphAtlasImage && (this.glyphAtlasTexture = new o.T(e,this.glyphAtlasImage,r.ALPHA),
                        this.glyphAtlasImage = null)
                    }
                    prepare(e) {
                        this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture)
                    }
                    queryRenderedFeatures(e, r, s, c, d, m, v, b, P, M, D) {
                        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
                            queryGeometry: c,
                            cameraQueryGeometry: d,
                            scale: m,
                            tileSize: this.tileSize,
                            pixelPosMatrix: M,
                            transform: b,
                            params: v,
                            queryPadding: this.queryPadding * P,
                            getElevation: D
                        }, e, r, s) : {}
                    }
                    querySourceFeatures(e, r) {
                        const s = this.latestFeatureIndex;
                        if (!s || !s.rawTileData)
                            return;
                        const c = s.loadVTLayers()
                          , d = r && r.sourceLayer ? r.sourceLayer : ""
                          , m = c._geojsonTileLayer || c[d];
                        if (!m)
                            return;
                        const v = o.a9(r && r.filter)
                          , {z: b, x: P, y: M} = this.tileID.canonical
                          , D = {
                            z: b,
                            x: P,
                            y: M
                        };
                        for (let L = 0; L < m.length; L++) {
                            const B = m.feature(L);
                            if (v.needGeometry) {
                                const ee = o.aa(B, !0);
                                if (!v.filter(new o.F(this.tileID.overscaledZ), ee, this.tileID.canonical))
                                    continue
                            } else if (!v.filter(new o.F(this.tileID.overscaledZ), B))
                                continue;
                            const Z = s.getId(B, d)
                              , te = new o.ab(B,b,P,M,Z);
                            te.tile = D,
                            e.push(te)
                        }
                    }
                    hasData() {
                        return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
                    }
                    patternsLoaded() {
                        return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
                    }
                    setExpiryData(e) {
                        const r = this.expirationTime;
                        if (e.cacheControl) {
                            const s = o.ac(e.cacheControl);
                            s["max-age"] && (this.expirationTime = Date.now() + 1e3 * s["max-age"])
                        } else
                            e.expires && (this.expirationTime = new Date(e.expires).getTime());
                        if (this.expirationTime) {
                            const s = Date.now();
                            let c = !1;
                            if (this.expirationTime > s)
                                c = !1;
                            else if (r)
                                if (this.expirationTime < r)
                                    c = !0;
                                else {
                                    const d = this.expirationTime - r;
                                    d ? this.expirationTime = s + Math.max(d, 3e4) : c = !0
                                }
                            else
                                c = !0;
                            c ? (this.expiredRequestCount++,
                            this.state = "expired") : this.expiredRequestCount = 0
                        }
                    }
                    getExpiryTimeout() {
                        if (this.expirationTime)
                            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
                    }
                    setFeatureState(e, r) {
                        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0)
                            return;
                        const s = this.latestFeatureIndex.loadVTLayers();
                        for (const c in this.buckets) {
                            if (!r.style.hasLayer(c))
                                continue;
                            const d = this.buckets[c]
                              , m = d.layers[0].sourceLayer || "_geojsonTileLayer"
                              , v = s[m]
                              , b = e[m];
                            if (!v || !b || Object.keys(b).length === 0)
                                continue;
                            d.update(b, v, this.imageAtlas && this.imageAtlas.patternPositions || {});
                            const P = r && r.style && r.style.getLayer(c);
                            P && (this.queryPadding = Math.max(this.queryPadding, P.queryRadius(d)))
                        }
                    }
                    holdingForFade() {
                        return this.symbolFadeHoldUntil !== void 0
                    }
                    symbolFadeFinished() {
                        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < he.now()
                    }
                    clearFadeHold() {
                        this.symbolFadeHoldUntil = void 0
                    }
                    setHoldDuration(e) {
                        this.symbolFadeHoldUntil = he.now() + e
                    }
                    setDependencies(e, r) {
                        const s = {};
                        for (const c of r)
                            s[c] = !0;
                        this.dependencies[e] = s
                    }
                    hasDependency(e, r) {
                        for (const s of e) {
                            const c = this.dependencies[s];
                            if (c) {
                                for (const d of r)
                                    if (c[d])
                                        return !0
                            }
                        }
                        return !1
                    }
                }
                class _r {
                    constructor(e, r) {
                        this.max = e,
                        this.onRemove = r,
                        this.reset()
                    }
                    reset() {
                        for (const e in this.data)
                            for (const r of this.data[e])
                                r.timeout && clearTimeout(r.timeout),
                                this.onRemove(r.value);
                        return this.data = {},
                        this.order = [],
                        this
                    }
                    add(e, r, s) {
                        const c = e.wrapped().key;
                        this.data[c] === void 0 && (this.data[c] = []);
                        const d = {
                            value: r,
                            timeout: void 0
                        };
                        if (s !== void 0 && (d.timeout = setTimeout( () => {
                            this.remove(e, d)
                        }
                        , s)),
                        this.data[c].push(d),
                        this.order.push(c),
                        this.order.length > this.max) {
                            const m = this._getAndRemoveByKey(this.order[0]);
                            m && this.onRemove(m)
                        }
                        return this
                    }
                    has(e) {
                        return e.wrapped().key in this.data
                    }
                    getAndRemove(e) {
                        return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null
                    }
                    _getAndRemoveByKey(e) {
                        const r = this.data[e].shift();
                        return r.timeout && clearTimeout(r.timeout),
                        this.data[e].length === 0 && delete this.data[e],
                        this.order.splice(this.order.indexOf(e), 1),
                        r.value
                    }
                    getByKey(e) {
                        const r = this.data[e];
                        return r ? r[0].value : null
                    }
                    get(e) {
                        return this.has(e) ? this.data[e.wrapped().key][0].value : null
                    }
                    remove(e, r) {
                        if (!this.has(e))
                            return this;
                        const s = e.wrapped().key
                          , c = r === void 0 ? 0 : this.data[s].indexOf(r)
                          , d = this.data[s][c];
                        return this.data[s].splice(c, 1),
                        d.timeout && clearTimeout(d.timeout),
                        this.data[s].length === 0 && delete this.data[s],
                        this.onRemove(d.value),
                        this.order.splice(this.order.indexOf(s), 1),
                        this
                    }
                    setMaxSize(e) {
                        for (this.max = e; this.order.length > this.max; ) {
                            const r = this._getAndRemoveByKey(this.order[0]);
                            r && this.onRemove(r)
                        }
                        return this
                    }
                    filter(e) {
                        const r = [];
                        for (const s in this.data)
                            for (const c of this.data[s])
                                e(c.value) || r.push(c);
                        for (const s of r)
                            this.remove(s.value.tileID, s)
                    }
                }
                class Ar {
                    constructor() {
                        this.state = {},
                        this.stateChanges = {},
                        this.deletedStates = {}
                    }
                    updateState(e, r, s) {
                        const c = String(r);
                        if (this.stateChanges[e] = this.stateChanges[e] || {},
                        this.stateChanges[e][c] = this.stateChanges[e][c] || {},
                        o.e(this.stateChanges[e][c], s),
                        this.deletedStates[e] === null) {
                            this.deletedStates[e] = {};
                            for (const d in this.state[e])
                                d !== c && (this.deletedStates[e][d] = null)
                        } else if (this.deletedStates[e] && this.deletedStates[e][c] === null) {
                            this.deletedStates[e][c] = {};
                            for (const d in this.state[e][c])
                                s[d] || (this.deletedStates[e][c][d] = null)
                        } else
                            for (const d in s)
                                this.deletedStates[e] && this.deletedStates[e][c] && this.deletedStates[e][c][d] === null && delete this.deletedStates[e][c][d]
                    }
                    removeFeatureState(e, r, s) {
                        if (this.deletedStates[e] === null)
                            return;
                        const c = String(r);
                        if (this.deletedStates[e] = this.deletedStates[e] || {},
                        s && r !== void 0)
                            this.deletedStates[e][c] !== null && (this.deletedStates[e][c] = this.deletedStates[e][c] || {},
                            this.deletedStates[e][c][s] = null);
                        else if (r !== void 0)
                            if (this.stateChanges[e] && this.stateChanges[e][c])
                                for (s in this.deletedStates[e][c] = {},
                                this.stateChanges[e][c])
                                    this.deletedStates[e][c][s] = null;
                            else
                                this.deletedStates[e][c] = null;
                        else
                            this.deletedStates[e] = null
                    }
                    getState(e, r) {
                        const s = String(r)
                          , c = o.e({}, (this.state[e] || {})[s], (this.stateChanges[e] || {})[s]);
                        if (this.deletedStates[e] === null)
                            return {};
                        if (this.deletedStates[e]) {
                            const d = this.deletedStates[e][r];
                            if (d === null)
                                return {};
                            for (const m in d)
                                delete c[m]
                        }
                        return c
                    }
                    initializeTileState(e, r) {
                        e.setFeatureState(this.state, r)
                    }
                    coalesceChanges(e, r) {
                        const s = {};
                        for (const c in this.stateChanges) {
                            this.state[c] = this.state[c] || {};
                            const d = {};
                            for (const m in this.stateChanges[c])
                                this.state[c][m] || (this.state[c][m] = {}),
                                o.e(this.state[c][m], this.stateChanges[c][m]),
                                d[m] = this.state[c][m];
                            s[c] = d
                        }
                        for (const c in this.deletedStates) {
                            this.state[c] = this.state[c] || {};
                            const d = {};
                            if (this.deletedStates[c] === null)
                                for (const m in this.state[c])
                                    d[m] = {},
                                    this.state[c][m] = {};
                            else
                                for (const m in this.deletedStates[c]) {
                                    if (this.deletedStates[c][m] === null)
                                        this.state[c][m] = {};
                                    else
                                        for (const v of Object.keys(this.deletedStates[c][m]))
                                            delete this.state[c][m][v];
                                    d[m] = this.state[c][m]
                                }
                            s[c] = s[c] || {},
                            o.e(s[c], d)
                        }
                        if (this.stateChanges = {},
                        this.deletedStates = {},
                        Object.keys(s).length !== 0)
                            for (const c in e)
                                e[c].setFeatureState(s, r)
                    }
                }
                const Tr = 89.25;
                function be(h, e) {
                    const r = o.ag(e.lat, -o.ah, o.ah);
                    return new o.P(o.V(e.lng) * h,o.U(r) * h)
                }
                function q(h, e) {
                    return new o.a0(e.x / h,e.y / h).toLngLat()
                }
                function V(h) {
                    return h.cameraToCenterDistance * Math.min(.85 * Math.tan(o.ad(90 - h.pitch)), Math.tan(o.ad(Tr - h.pitch)))
                }
                function K(h, e) {
                    const r = h.canonical
                      , s = e / o.ae(r.z)
                      , c = r.x + Math.pow(2, r.z) * h.wrap
                      , d = o.af(new Float64Array(16));
                    return o.M(d, d, [c * s, r.y * s, 0]),
                    o.N(d, d, [s / o.$, s / o.$, 1]),
                    d
                }
                function ae(h, e, r, s, c) {
                    const d = o.a0.fromLngLat(h, e)
                      , m = c * o.ai(1, h.lat)
                      , v = m * Math.cos(o.ad(r))
                      , b = Math.sqrt(m * m - v * v)
                      , P = b * Math.sin(o.ad(-s))
                      , M = b * Math.cos(o.ad(-s));
                    return new o.a0(d.x + P,d.y + M,d.z + v)
                }
                function we(h, e, r) {
                    const s = e.intersectsFrustum(h);
                    if (!r || s === 0)
                        return s;
                    const c = e.intersectsPlane(r);
                    return c === 0 ? 0 : s === 2 && c === 2 ? 2 : 1
                }
                function Me(h, e, r) {
                    let s = 0;
                    const c = (r - e) / 10;
                    for (let d = 0; d < 10; d++)
                        s += c * Math.pow(Math.cos(e + (d + .5) / 10 * (r - e)), h);
                    return s
                }
                function ke(h, e) {
                    return function(r, s, c, d, m) {
                        const v = 2 * ((h - 1) / o.aj(Math.cos(o.ad(Tr - m)) / Math.cos(o.ad(Tr))) - 1)
                          , b = Math.acos(c / d)
                          , P = 2 * Me(v - 1, 0, o.ad(m / 2))
                          , M = Math.min(o.ad(Tr), b + o.ad(m / 2))
                          , D = Me(v - 1, Math.min(M, b - o.ad(m / 2)), M)
                          , L = Math.atan(s / c)
                          , B = Math.hypot(s, c);
                        let Z = r;
                        return Z += o.aj(d / B / Math.max(.5, Math.cos(o.ad(m / 2)))),
                        Z += v * o.aj(Math.cos(L)) / 2,
                        Z -= o.aj(Math.max(1, D / P / e)) / 2,
                        Z
                    }
                }
                const ge = ke(9.314, 3);
                function je(h, e) {
                    const r = (e.roundZoom ? Math.round : Math.floor)(h.zoom + o.aj(h.tileSize / e.tileSize));
                    return Math.max(0, r)
                }
                function Oe(h, e) {
                    const r = h.getCameraFrustum()
                      , s = h.getClippingPlane()
                      , c = h.screenPointToMercatorCoordinate(h.getCameraPoint())
                      , d = o.a0.fromLngLat(h.center, h.elevation);
                    c.z = d.z + Math.cos(h.pitchInRadians) * h.cameraToCenterDistance / h.worldSize;
                    const m = h.getCoveringTilesDetailsProvider()
                      , v = m.allowVariableZoom(h, e)
                      , b = je(h, e)
                      , P = e.minzoom || 0
                      , M = e.maxzoom !== void 0 ? e.maxzoom : h.maxZoom
                      , D = Math.min(Math.max(0, b), M)
                      , L = Math.pow(2, D)
                      , B = [L * c.x, L * c.y, 0]
                      , Z = [L * d.x, L * d.y, 0]
                      , te = Math.hypot(d.x - c.x, d.y - c.y)
                      , ee = Math.abs(d.z - c.z)
                      , ne = Math.hypot(te, ee)
                      , oe = Te => ({
                        zoom: 0,
                        x: 0,
                        y: 0,
                        wrap: Te,
                        fullyVisible: !1
                    })
                      , me = []
                      , ce = [];
                    if (h.renderWorldCopies && m.allowWorldCopies())
                        for (let Te = 1; Te <= 3; Te++)
                            me.push(oe(-Te)),
                            me.push(oe(Te));
                    for (me.push(oe(0)); me.length > 0; ) {
                        const Te = me.pop()
                          , Pe = Te.x
                          , pe = Te.y;
                        let Fe = Te.fullyVisible;
                        const Ye = {
                            x: Pe,
                            y: pe,
                            z: Te.zoom
                        }
                          , $e = m.getTileBoundingVolume(Ye, Te.wrap, h.elevation, e);
                        if (!Fe) {
                            const Nt = we(r, $e, s);
                            if (Nt === 0)
                                continue;
                            Fe = Nt === 2
                        }
                        const He = m.distanceToTile2d(c.x, c.y, Ye, $e);
                        let Je = b;
                        v && (Je = (e.calculateTileZoom || ge)(h.zoom + o.aj(h.tileSize / e.tileSize), He, ee, ne, h.fov)),
                        Je = (e.roundZoom ? Math.round : Math.floor)(Je),
                        Je = Math.max(0, Je);
                        const qt = Math.min(Je, M);
                        if (Te.wrap = m.getWrap(d, Ye, Te.wrap),
                        Te.zoom >= qt) {
                            if (Te.zoom < P)
                                continue;
                            const Nt = D - Te.zoom
                              , wt = B[0] - .5 - (Pe << Nt)
                              , rr = B[1] - .5 - (pe << Nt)
                              , Kr = e.reparseOverscaled ? Math.max(Te.zoom, Je) : Te.zoom;
                            ce.push({
                                tileID: new o.Z(Te.zoom === M ? Kr : Te.zoom,Te.wrap,Te.zoom,Pe,pe),
                                distanceSq: o.ak([Z[0] - .5 - Pe, Z[1] - .5 - pe]),
                                tileDistanceToCamera: Math.sqrt(wt * wt + rr * rr)
                            })
                        } else
                            for (let Nt = 0; Nt < 4; Nt++)
                                me.push({
                                    zoom: Te.zoom + 1,
                                    x: (Pe << 1) + Nt % 2,
                                    y: (pe << 1) + (Nt >> 1),
                                    wrap: Te.wrap,
                                    fullyVisible: Fe
                                })
                    }
                    return ce.sort( (Te, Pe) => Te.distanceSq - Pe.distanceSq).map(Te => Te.tileID)
                }
                const Ee = o.a1.fromPoints([new o.P(0,0), new o.P(o.$,o.$)]);
                class Ke extends o.E {
                    constructor(e, r, s) {
                        super(),
                        this.id = e,
                        this.dispatcher = s,
                        this.on("data", c => this._dataHandler(c)),
                        this.on("dataloading", () => {
                            this._sourceErrored = !1
                        }
                        ),
                        this.on("error", () => {
                            this._sourceErrored = this._source.loaded()
                        }
                        ),
                        this._source = ( (c, d, m, v) => {
                            const b = new (sr(d.type))(c,d,m,v);
                            if (b.id !== c)
                                throw new Error(`Expected Source id to be ${c} instead of ${b.id}`);
                            return b
                        }
                        )(e, r, s, this),
                        this._tiles = {},
                        this._cache = new _r(0,c => this._unloadTile(c)),
                        this._timers = {},
                        this._cacheTimers = {},
                        this._maxTileCacheSize = null,
                        this._maxTileCacheZoomLevels = null,
                        this._loadedParentTiles = {},
                        this._coveredTiles = {},
                        this._state = new Ar,
                        this._didEmitContent = !1,
                        this._updated = !1
                    }
                    onAdd(e) {
                        this.map = e,
                        this._maxTileCacheSize = e ? e._maxTileCacheSize : null,
                        this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null,
                        this._source && this._source.onAdd && this._source.onAdd(e)
                    }
                    onRemove(e) {
                        this.clearTiles(),
                        this._source && this._source.onRemove && this._source.onRemove(e)
                    }
                    loaded() {
                        if (this._sourceErrored)
                            return !0;
                        if (!this._sourceLoaded || !this._source.loaded())
                            return !1;
                        if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain))
                            return !0;
                        if (!this._updated)
                            return !1;
                        for (const e in this._tiles) {
                            const r = this._tiles[e];
                            if (r.state !== "loaded" && r.state !== "errored")
                                return !1
                        }
                        return !0
                    }
                    getSource() {
                        return this._source
                    }
                    pause() {
                        this._paused = !0
                    }
                    resume() {
                        if (!this._paused)
                            return;
                        const e = this._shouldReloadOnResume;
                        this._paused = !1,
                        this._shouldReloadOnResume = !1,
                        e && this.reload(),
                        this.transform && this.update(this.transform, this.terrain)
                    }
                    _loadTile(e, r, s) {
                        return o._(this, void 0, void 0, function*() {
                            try {
                                yield this._source.loadTile(e),
                                this._tileLoaded(e, r, s)
                            } catch (c) {
                                e.state = "errored",
                                c.status !== 404 ? this._source.fire(new o.k(c,{
                                    tile: e
                                })) : this.update(this.transform, this.terrain)
                            }
                        })
                    }
                    _unloadTile(e) {
                        this._source.unloadTile && this._source.unloadTile(e)
                    }
                    _abortTile(e) {
                        this._source.abortTile && this._source.abortTile(e),
                        this._source.fire(new o.l("dataabort",{
                            tile: e,
                            coord: e.tileID,
                            dataType: "source"
                        }))
                    }
                    serialize() {
                        return this._source.serialize()
                    }
                    prepare(e) {
                        this._source.prepare && this._source.prepare(),
                        this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                        for (const r in this._tiles) {
                            const s = this._tiles[r];
                            s.upload(e),
                            s.prepare(this.map.style.imageManager)
                        }
                    }
                    getIds() {
                        return Object.values(this._tiles).map(e => e.tileID).sort(ye).map(e => e.key)
                    }
                    getRenderableIds(e) {
                        const r = [];
                        for (const s in this._tiles)
                            this._isIdRenderable(s, e) && r.push(this._tiles[s]);
                        return e ? r.sort( (s, c) => {
                            const d = s.tileID
                              , m = c.tileID
                              , v = new o.P(d.canonical.x,d.canonical.y)._rotate(-this.transform.bearingInRadians)
                              , b = new o.P(m.canonical.x,m.canonical.y)._rotate(-this.transform.bearingInRadians);
                            return d.overscaledZ - m.overscaledZ || b.y - v.y || b.x - v.x
                        }
                        ).map(s => s.tileID.key) : r.map(s => s.tileID).sort(ye).map(s => s.key)
                    }
                    hasRenderableParent(e) {
                        const r = this.findLoadedParent(e, 0);
                        return !!r && this._isIdRenderable(r.tileID.key)
                    }
                    _isIdRenderable(e, r) {
                        return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (r || !this._tiles[e].holdingForFade())
                    }
                    reload(e) {
                        if (this._paused)
                            this._shouldReloadOnResume = !0;
                        else {
                            this._cache.reset();
                            for (const r in this._tiles)
                                e ? this._reloadTile(r, "expired") : this._tiles[r].state !== "errored" && this._reloadTile(r, "reloading")
                        }
                    }
                    _reloadTile(e, r) {
                        return o._(this, void 0, void 0, function*() {
                            const s = this._tiles[e];
                            s && (s.state !== "loading" && (s.state = r),
                            yield this._loadTile(s, e, r))
                        })
                    }
                    _tileLoaded(e, r, s) {
                        e.timeAdded = he.now(),
                        s === "expired" && (e.refreshedUponExpiration = !0),
                        this._setTileReloadTimer(r, e),
                        this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e),
                        this._state.initializeTileState(e, this.map ? this.map.painter : null),
                        e.aborted || this._source.fire(new o.l("data",{
                            dataType: "source",
                            tile: e,
                            coord: e.tileID
                        }))
                    }
                    _backfillDEM(e) {
                        const r = this.getRenderableIds();
                        for (let c = 0; c < r.length; c++) {
                            const d = r[c];
                            if (e.neighboringTiles && e.neighboringTiles[d]) {
                                const m = this.getTileByID(d);
                                s(e, m),
                                s(m, e)
                            }
                        }
                        function s(c, d) {
                            c.needsHillshadePrepare = !0,
                            c.needsTerrainPrepare = !0;
                            let m = d.tileID.canonical.x - c.tileID.canonical.x;
                            const v = d.tileID.canonical.y - c.tileID.canonical.y
                              , b = Math.pow(2, c.tileID.canonical.z)
                              , P = d.tileID.key;
                            m === 0 && v === 0 || Math.abs(v) > 1 || (Math.abs(m) > 1 && (Math.abs(m + b) === 1 ? m += b : Math.abs(m - b) === 1 && (m -= b)),
                            d.dem && c.dem && (c.dem.backfillBorder(d.dem, m, v),
                            c.neighboringTiles && c.neighboringTiles[P] && (c.neighboringTiles[P].backfilled = !0)))
                        }
                    }
                    getTile(e) {
                        return this.getTileByID(e.key)
                    }
                    getTileByID(e) {
                        return this._tiles[e]
                    }
                    _retainLoadedChildren(e, r, s, c) {
                        for (const d in this._tiles) {
                            let m = this._tiles[d];
                            if (c[d] || !m.hasData() || m.tileID.overscaledZ <= r || m.tileID.overscaledZ > s)
                                continue;
                            let v = m.tileID;
                            for (; m && m.tileID.overscaledZ > r + 1; ) {
                                const P = m.tileID.scaledTo(m.tileID.overscaledZ - 1);
                                m = this._tiles[P.key],
                                m && m.hasData() && (v = P)
                            }
                            let b = v;
                            for (; b.overscaledZ > r; )
                                if (b = b.scaledTo(b.overscaledZ - 1),
                                e[b.key] || e[b.canonical.key]) {
                                    c[v.key] = v;
                                    break
                                }
                        }
                    }
                    findLoadedParent(e, r) {
                        if (e.key in this._loadedParentTiles) {
                            const s = this._loadedParentTiles[e.key];
                            return s && s.tileID.overscaledZ >= r ? s : null
                        }
                        for (let s = e.overscaledZ - 1; s >= r; s--) {
                            const c = e.scaledTo(s)
                              , d = this._getLoadedTile(c);
                            if (d)
                                return d
                        }
                    }
                    findLoadedSibling(e) {
                        return this._getLoadedTile(e)
                    }
                    _getLoadedTile(e) {
                        const r = this._tiles[e.key];
                        return r && r.hasData() ? r : this._cache.getByKey(e.wrapped().key)
                    }
                    updateCacheSize(e) {
                        const r = Math.ceil(e.width / this._source.tileSize) + 1
                          , s = Math.ceil(e.height / this._source.tileSize) + 1
                          , c = Math.floor(r * s * (this._maxTileCacheZoomLevels === null ? o.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels))
                          , d = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, c) : c;
                        this._cache.setMaxSize(d)
                    }
                    handleWrapJump(e) {
                        const r = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
                        if (this._prevLng = e,
                        r) {
                            const s = {};
                            for (const c in this._tiles) {
                                const d = this._tiles[c];
                                d.tileID = d.tileID.unwrapTo(d.tileID.wrap + r),
                                s[d.tileID.key] = d
                            }
                            this._tiles = s;
                            for (const c in this._timers)
                                clearTimeout(this._timers[c]),
                                delete this._timers[c];
                            for (const c in this._tiles)
                                this._setTileReloadTimer(c, this._tiles[c])
                        }
                    }
                    _updateCoveredAndRetainedTiles(e, r, s, c, d, m) {
                        const v = {}
                          , b = {}
                          , P = Object.keys(e)
                          , M = he.now();
                        for (const D of P) {
                            const L = e[D]
                              , B = this._tiles[D];
                            if (!B || B.fadeEndTime !== 0 && B.fadeEndTime <= M)
                                continue;
                            const Z = this.findLoadedParent(L, r)
                              , te = this.findLoadedSibling(L)
                              , ee = Z || te || null;
                            ee && (this._addTile(ee.tileID),
                            v[ee.tileID.key] = ee.tileID),
                            b[D] = L
                        }
                        this._retainLoadedChildren(b, c, s, e);
                        for (const D in v)
                            e[D] || (this._coveredTiles[D] = !0,
                            e[D] = v[D]);
                        if (m) {
                            const D = {}
                              , L = {};
                            for (const B of d)
                                this._tiles[B.key].hasData() ? D[B.key] = B : L[B.key] = B;
                            for (const B in L) {
                                const Z = L[B].children(this._source.maxzoom);
                                this._tiles[Z[0].key] && this._tiles[Z[1].key] && this._tiles[Z[2].key] && this._tiles[Z[3].key] && (D[Z[0].key] = e[Z[0].key] = Z[0],
                                D[Z[1].key] = e[Z[1].key] = Z[1],
                                D[Z[2].key] = e[Z[2].key] = Z[2],
                                D[Z[3].key] = e[Z[3].key] = Z[3],
                                delete L[B])
                            }
                            for (const B in L) {
                                const Z = L[B]
                                  , te = this.findLoadedParent(Z, this._source.minzoom)
                                  , ee = this.findLoadedSibling(Z)
                                  , ne = te || ee || null;
                                if (ne) {
                                    D[ne.tileID.key] = e[ne.tileID.key] = ne.tileID;
                                    for (const oe in D)
                                        D[oe].isChildOf(ne.tileID) && delete D[oe]
                                }
                            }
                            for (const B in this._tiles)
                                D[B] || (this._coveredTiles[B] = !0)
                        }
                    }
                    update(e, r) {
                        if (!this._sourceLoaded || this._paused)
                            return;
                        let s;
                        this.transform = e,
                        this.terrain = r,
                        this.updateCacheSize(e),
                        this.handleWrapJump(this.transform.center.lng),
                        this._coveredTiles = {},
                        this.used || this.usedForTerrain ? this._source.tileID ? s = e.getVisibleUnwrappedCoordinates(this._source.tileID).map(M => new o.Z(M.canonical.z,M.wrap,M.canonical.z,M.canonical.x,M.canonical.y)) : (s = Oe(e, {
                            tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
                            minzoom: this._source.minzoom,
                            maxzoom: this._source.maxzoom,
                            roundZoom: !this.usedForTerrain && this._source.roundZoom,
                            reparseOverscaled: this._source.reparseOverscaled,
                            terrain: r,
                            calculateTileZoom: this._source.calculateTileZoom
                        }),
                        this._source.hasTile && (s = s.filter(M => this._source.hasTile(M)))) : s = [];
                        const c = je(e, this._source)
                          , d = Math.max(c - Ke.maxOverzooming, this._source.minzoom)
                          , m = Math.max(c + Ke.maxUnderzooming, this._source.minzoom);
                        if (this.usedForTerrain) {
                            const M = {};
                            for (const D of s)
                                if (D.canonical.z > this._source.minzoom) {
                                    const L = D.scaledTo(D.canonical.z - 1);
                                    M[L.key] = L;
                                    const B = D.scaledTo(Math.max(this._source.minzoom, Math.min(D.canonical.z, 5)));
                                    M[B.key] = B
                                }
                            s = s.concat(Object.values(M))
                        }
                        const v = s.length === 0 && !this._updated && this._didEmitContent;
                        this._updated = !0,
                        v && this.fire(new o.l("data",{
                            sourceDataType: "idle",
                            dataType: "source",
                            sourceId: this.id
                        }));
                        const b = this._updateRetainedTiles(s, c);
                        It(this._source.type) && this._updateCoveredAndRetainedTiles(b, d, m, c, s, r);
                        for (const M in b)
                            this._tiles[M].clearFadeHold();
                        const P = o.al(this._tiles, b);
                        for (const M of P) {
                            const D = this._tiles[M];
                            D.hasSymbolBuckets && !D.holdingForFade() ? D.setHoldDuration(this.map._fadeDuration) : D.hasSymbolBuckets && !D.symbolFadeFinished() || this._removeTile(M)
                        }
                        this._updateLoadedParentTileCache(),
                        this._updateLoadedSiblingTileCache()
                    }
                    releaseSymbolFadeTiles() {
                        for (const e in this._tiles)
                            this._tiles[e].holdingForFade() && this._removeTile(e)
                    }
                    _updateRetainedTiles(e, r) {
                        var s;
                        const c = {}
                          , d = {}
                          , m = Math.max(r - Ke.maxOverzooming, this._source.minzoom)
                          , v = Math.max(r + Ke.maxUnderzooming, this._source.minzoom)
                          , b = {};
                        for (const P of e) {
                            const M = this._addTile(P);
                            c[P.key] = P,
                            M.hasData() || r < this._source.maxzoom && (b[P.key] = P)
                        }
                        this._retainLoadedChildren(b, r, v, c);
                        for (const P of e) {
                            let M = this._tiles[P.key];
                            if (M.hasData())
                                continue;
                            if (r + 1 > this._source.maxzoom) {
                                const L = P.children(this._source.maxzoom)[0]
                                  , B = this.getTile(L);
                                if (B && B.hasData()) {
                                    c[L.key] = L;
                                    continue
                                }
                            } else {
                                const L = P.children(this._source.maxzoom);
                                if (c[L[0].key] && c[L[1].key] && c[L[2].key] && c[L[3].key])
                                    continue
                            }
                            let D = M.wasRequested();
                            for (let L = P.overscaledZ - 1; L >= m; --L) {
                                const B = P.scaledTo(L);
                                if (d[B.key])
                                    break;
                                if (d[B.key] = !0,
                                M = this.getTile(B),
                                !M && D && (M = this._addTile(B)),
                                M) {
                                    const Z = M.hasData();
                                    if ((Z || !(!((s = this.map) === null || s === void 0) && s.cancelPendingTileRequestsWhileZooming) || D) && (c[B.key] = B),
                                    D = M.wasRequested(),
                                    Z)
                                        break
                                }
                            }
                        }
                        return c
                    }
                    _updateLoadedParentTileCache() {
                        this._loadedParentTiles = {};
                        for (const e in this._tiles) {
                            const r = [];
                            let s, c = this._tiles[e].tileID;
                            for (; c.overscaledZ > 0; ) {
                                if (c.key in this._loadedParentTiles) {
                                    s = this._loadedParentTiles[c.key];
                                    break
                                }
                                r.push(c.key);
                                const d = c.scaledTo(c.overscaledZ - 1);
                                if (s = this._getLoadedTile(d),
                                s)
                                    break;
                                c = d
                            }
                            for (const d of r)
                                this._loadedParentTiles[d] = s
                        }
                    }
                    _updateLoadedSiblingTileCache() {
                        this._loadedSiblingTiles = {};
                        for (const e in this._tiles) {
                            const r = this._tiles[e].tileID
                              , s = this._getLoadedTile(r);
                            this._loadedSiblingTiles[r.key] = s
                        }
                    }
                    _addTile(e) {
                        let r = this._tiles[e.key];
                        if (r)
                            return r;
                        r = this._cache.getAndRemove(e),
                        r && (this._setTileReloadTimer(e.key, r),
                        r.tileID = e,
                        this._state.initializeTileState(r, this.map ? this.map.painter : null),
                        this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]),
                        delete this._cacheTimers[e.key],
                        this._setTileReloadTimer(e.key, r)));
                        const s = r;
                        return r || (r = new br(e,this._source.tileSize * e.overscaleFactor()),
                        this._loadTile(r, e.key, r.state)),
                        r.uses++,
                        this._tiles[e.key] = r,
                        s || this._source.fire(new o.l("dataloading",{
                            tile: r,
                            coord: r.tileID,
                            dataType: "source"
                        })),
                        r
                    }
                    _setTileReloadTimer(e, r) {
                        e in this._timers && (clearTimeout(this._timers[e]),
                        delete this._timers[e]);
                        const s = r.getExpiryTimeout();
                        s && (this._timers[e] = setTimeout( () => {
                            this._reloadTile(e, "expired"),
                            delete this._timers[e]
                        }
                        , s))
                    }
                    refreshTiles(e) {
                        for (const r in this._tiles)
                            (this._isIdRenderable(r) || this._tiles[r].state == "errored") && e.some(s => s.equals(this._tiles[r].tileID.canonical)) && this._reloadTile(r, "expired")
                    }
                    _removeTile(e) {
                        const r = this._tiles[e];
                        r && (r.uses--,
                        delete this._tiles[e],
                        this._timers[e] && (clearTimeout(this._timers[e]),
                        delete this._timers[e]),
                        r.uses > 0 || (r.hasData() && r.state !== "reloading" ? this._cache.add(r.tileID, r, r.getExpiryTimeout()) : (r.aborted = !0,
                        this._abortTile(r),
                        this._unloadTile(r))))
                    }
                    _dataHandler(e) {
                        const r = e.sourceDataType;
                        e.dataType === "source" && r === "metadata" && (this._sourceLoaded = !0),
                        this._sourceLoaded && !this._paused && e.dataType === "source" && r === "content" && (this.reload(e.sourceDataChanged),
                        this.transform && this.update(this.transform, this.terrain),
                        this._didEmitContent = !0)
                    }
                    clearTiles() {
                        this._shouldReloadOnResume = !1,
                        this._paused = !1;
                        for (const e in this._tiles)
                            this._removeTile(e);
                        this._cache.reset()
                    }
                    tilesIn(e, r, s) {
                        const c = []
                          , d = this.transform;
                        if (!d)
                            return c;
                        const m = d.getCoveringTilesDetailsProvider().allowWorldCopies()
                          , v = s ? d.getCameraQueryGeometry(e) : e
                          , b = B => d.screenPointToMercatorCoordinate(B, this.terrain)
                          , P = this.transformBbox(e, b, !m)
                          , M = this.transformBbox(v, b, !m)
                          , D = this.getIds()
                          , L = o.a1.fromPoints(M);
                        for (let B = 0; B < D.length; B++) {
                            const Z = this._tiles[D[B]];
                            if (Z.holdingForFade())
                                continue;
                            const te = m ? [Z.tileID] : [Z.tileID.unwrapTo(-1), Z.tileID.unwrapTo(0)]
                              , ee = Math.pow(2, d.zoom - Z.tileID.overscaledZ)
                              , ne = r * Z.queryPadding * o.$ / Z.tileSize / ee;
                            for (const oe of te) {
                                const me = L.map(ce => oe.getTilePoint(new o.a0(ce.x,ce.y)));
                                if (me.expandBy(ne),
                                me.intersects(Ee)) {
                                    const ce = P.map(Pe => oe.getTilePoint(Pe))
                                      , Te = M.map(Pe => oe.getTilePoint(Pe));
                                    c.push({
                                        tile: Z,
                                        tileID: m ? oe : oe.unwrapTo(0),
                                        queryGeometry: ce,
                                        cameraQueryGeometry: Te,
                                        scale: ee
                                    })
                                }
                            }
                        }
                        return c
                    }
                    transformBbox(e, r, s) {
                        let c = e.map(r);
                        if (s) {
                            const d = o.a1.fromPoints(e);
                            d.shrinkBy(.001 * Math.min(d.width(), d.height()));
                            const m = d.map(r);
                            o.a1.fromPoints(c).covers(m) || (c = c.map(v => v.x > .5 ? new o.a0(v.x - 1,v.y,v.z) : v))
                        }
                        return c
                    }
                    getVisibleCoordinates(e) {
                        const r = this.getRenderableIds(e).map(s => this._tiles[s].tileID);
                        return this.transform && this.transform.populateCache(r),
                        r
                    }
                    hasTransition() {
                        if (this._source.hasTransition())
                            return !0;
                        if (It(this._source.type)) {
                            const e = he.now();
                            for (const r in this._tiles)
                                if (this._tiles[r].fadeEndTime >= e)
                                    return !0
                        }
                        return !1
                    }
                    setFeatureState(e, r, s) {
                        this._state.updateState(e = e || "_geojsonTileLayer", r, s)
                    }
                    removeFeatureState(e, r, s) {
                        this._state.removeFeatureState(e = e || "_geojsonTileLayer", r, s)
                    }
                    getFeatureState(e, r) {
                        return this._state.getState(e = e || "_geojsonTileLayer", r)
                    }
                    setDependencies(e, r, s) {
                        const c = this._tiles[e];
                        c && c.setDependencies(r, s)
                    }
                    reloadTilesForDependencies(e, r) {
                        for (const s in this._tiles)
                            this._tiles[s].hasDependency(e, r) && this._reloadTile(s, "reloading");
                        this._cache.filter(s => !s.hasDependency(e, r))
                    }
                }
                function ye(h, e) {
                    const r = Math.abs(2 * h.wrap) - +(h.wrap < 0)
                      , s = Math.abs(2 * e.wrap) - +(e.wrap < 0);
                    return h.overscaledZ - e.overscaledZ || s - r || e.canonical.y - h.canonical.y || e.canonical.x - h.canonical.x
                }
                function It(h) {
                    return h === "raster" || h === "image" || h === "video"
                }
                Ke.maxOverzooming = 10,
                Ke.maxUnderzooming = 3;
                class Kt {
                    constructor(e, r) {
                        this.reset(e, r)
                    }
                    reset(e, r) {
                        this.points = e || [],
                        this._distances = [0];
                        for (let s = 1; s < this.points.length; s++)
                            this._distances[s] = this._distances[s - 1] + this.points[s].dist(this.points[s - 1]);
                        this.length = this._distances[this._distances.length - 1],
                        this.padding = Math.min(r || 0, .5 * this.length),
                        this.paddedLength = this.length - 2 * this.padding
                    }
                    lerp(e) {
                        if (this.points.length === 1)
                            return this.points[0];
                        e = o.ag(e, 0, 1);
                        let r = 1
                          , s = this._distances[r];
                        const c = e * this.paddedLength + this.padding;
                        for (; s < c && r < this._distances.length; )
                            s = this._distances[++r];
                        const d = r - 1
                          , m = this._distances[d]
                          , v = s - m
                          , b = v > 0 ? (c - m) / v : 0;
                        return this.points[d].mult(1 - b).add(this.points[r].mult(b))
                    }
                }
                function Bt(h, e) {
                    let r = !0;
                    return h === "always" || h !== "never" && e !== "never" || (r = !1),
                    r
                }
                class Ut {
                    constructor(e, r, s) {
                        const c = this.boxCells = []
                          , d = this.circleCells = [];
                        this.xCellCount = Math.ceil(e / s),
                        this.yCellCount = Math.ceil(r / s);
                        for (let m = 0; m < this.xCellCount * this.yCellCount; m++)
                            c.push([]),
                            d.push([]);
                        this.circleKeys = [],
                        this.boxKeys = [],
                        this.bboxes = [],
                        this.circles = [],
                        this.width = e,
                        this.height = r,
                        this.xScale = this.xCellCount / e,
                        this.yScale = this.yCellCount / r,
                        this.boxUid = 0,
                        this.circleUid = 0
                    }
                    keysLength() {
                        return this.boxKeys.length + this.circleKeys.length
                    }
                    insert(e, r, s, c, d) {
                        this._forEachCell(r, s, c, d, this._insertBoxCell, this.boxUid++),
                        this.boxKeys.push(e),
                        this.bboxes.push(r),
                        this.bboxes.push(s),
                        this.bboxes.push(c),
                        this.bboxes.push(d)
                    }
                    insertCircle(e, r, s, c) {
                        this._forEachCell(r - c, s - c, r + c, s + c, this._insertCircleCell, this.circleUid++),
                        this.circleKeys.push(e),
                        this.circles.push(r),
                        this.circles.push(s),
                        this.circles.push(c)
                    }
                    _insertBoxCell(e, r, s, c, d, m) {
                        this.boxCells[d].push(m)
                    }
                    _insertCircleCell(e, r, s, c, d, m) {
                        this.circleCells[d].push(m)
                    }
                    _query(e, r, s, c, d, m, v) {
                        if (s < 0 || e > this.width || c < 0 || r > this.height)
                            return [];
                        const b = [];
                        if (e <= 0 && r <= 0 && this.width <= s && this.height <= c) {
                            if (d)
                                return [{
                                    key: null,
                                    x1: e,
                                    y1: r,
                                    x2: s,
                                    y2: c
                                }];
                            for (let P = 0; P < this.boxKeys.length; P++)
                                b.push({
                                    key: this.boxKeys[P],
                                    x1: this.bboxes[4 * P],
                                    y1: this.bboxes[4 * P + 1],
                                    x2: this.bboxes[4 * P + 2],
                                    y2: this.bboxes[4 * P + 3]
                                });
                            for (let P = 0; P < this.circleKeys.length; P++) {
                                const M = this.circles[3 * P]
                                  , D = this.circles[3 * P + 1]
                                  , L = this.circles[3 * P + 2];
                                b.push({
                                    key: this.circleKeys[P],
                                    x1: M - L,
                                    y1: D - L,
                                    x2: M + L,
                                    y2: D + L
                                })
                            }
                        } else
                            this._forEachCell(e, r, s, c, this._queryCell, b, {
                                hitTest: d,
                                overlapMode: m,
                                seenUids: {
                                    box: {},
                                    circle: {}
                                }
                            }, v);
                        return b
                    }
                    query(e, r, s, c) {
                        return this._query(e, r, s, c, !1, null)
                    }
                    hitTest(e, r, s, c, d, m) {
                        return this._query(e, r, s, c, !0, d, m).length > 0
                    }
                    hitTestCircle(e, r, s, c, d) {
                        const m = e - s
                          , v = e + s
                          , b = r - s
                          , P = r + s;
                        if (v < 0 || m > this.width || P < 0 || b > this.height)
                            return !1;
                        const M = [];
                        return this._forEachCell(m, b, v, P, this._queryCellCircle, M, {
                            hitTest: !0,
                            overlapMode: c,
                            circle: {
                                x: e,
                                y: r,
                                radius: s
                            },
                            seenUids: {
                                box: {},
                                circle: {}
                            }
                        }, d),
                        M.length > 0
                    }
                    _queryCell(e, r, s, c, d, m, v, b) {
                        const {seenUids: P, hitTest: M, overlapMode: D} = v
                          , L = this.boxCells[d];
                        if (L !== null) {
                            const Z = this.bboxes;
                            for (const te of L)
                                if (!P.box[te]) {
                                    P.box[te] = !0;
                                    const ee = 4 * te
                                      , ne = this.boxKeys[te];
                                    if (e <= Z[ee + 2] && r <= Z[ee + 3] && s >= Z[ee + 0] && c >= Z[ee + 1] && (!b || b(ne)) && (!M || !Bt(D, ne.overlapMode)) && (m.push({
                                        key: ne,
                                        x1: Z[ee],
                                        y1: Z[ee + 1],
                                        x2: Z[ee + 2],
                                        y2: Z[ee + 3]
                                    }),
                                    M))
                                        return !0
                                }
                        }
                        const B = this.circleCells[d];
                        if (B !== null) {
                            const Z = this.circles;
                            for (const te of B)
                                if (!P.circle[te]) {
                                    P.circle[te] = !0;
                                    const ee = 3 * te
                                      , ne = this.circleKeys[te];
                                    if (this._circleAndRectCollide(Z[ee], Z[ee + 1], Z[ee + 2], e, r, s, c) && (!b || b(ne)) && (!M || !Bt(D, ne.overlapMode))) {
                                        const oe = Z[ee]
                                          , me = Z[ee + 1]
                                          , ce = Z[ee + 2];
                                        if (m.push({
                                            key: ne,
                                            x1: oe - ce,
                                            y1: me - ce,
                                            x2: oe + ce,
                                            y2: me + ce
                                        }),
                                        M)
                                            return !0
                                    }
                                }
                        }
                        return !1
                    }
                    _queryCellCircle(e, r, s, c, d, m, v, b) {
                        const {circle: P, seenUids: M, overlapMode: D} = v
                          , L = this.boxCells[d];
                        if (L !== null) {
                            const Z = this.bboxes;
                            for (const te of L)
                                if (!M.box[te]) {
                                    M.box[te] = !0;
                                    const ee = 4 * te
                                      , ne = this.boxKeys[te];
                                    if (this._circleAndRectCollide(P.x, P.y, P.radius, Z[ee + 0], Z[ee + 1], Z[ee + 2], Z[ee + 3]) && (!b || b(ne)) && !Bt(D, ne.overlapMode))
                                        return m.push(!0),
                                        !0
                                }
                        }
                        const B = this.circleCells[d];
                        if (B !== null) {
                            const Z = this.circles;
                            for (const te of B)
                                if (!M.circle[te]) {
                                    M.circle[te] = !0;
                                    const ee = 3 * te
                                      , ne = this.circleKeys[te];
                                    if (this._circlesCollide(Z[ee], Z[ee + 1], Z[ee + 2], P.x, P.y, P.radius) && (!b || b(ne)) && !Bt(D, ne.overlapMode))
                                        return m.push(!0),
                                        !0
                                }
                        }
                    }
                    _forEachCell(e, r, s, c, d, m, v, b) {
                        const P = this._convertToXCellCoord(e)
                          , M = this._convertToYCellCoord(r)
                          , D = this._convertToXCellCoord(s)
                          , L = this._convertToYCellCoord(c);
                        for (let B = P; B <= D; B++)
                            for (let Z = M; Z <= L; Z++)
                                if (d.call(this, e, r, s, c, this.xCellCount * Z + B, m, v, b))
                                    return
                    }
                    _convertToXCellCoord(e) {
                        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)))
                    }
                    _convertToYCellCoord(e) {
                        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)))
                    }
                    _circlesCollide(e, r, s, c, d, m) {
                        const v = c - e
                          , b = d - r
                          , P = s + m;
                        return P * P > v * v + b * b
                    }
                    _circleAndRectCollide(e, r, s, c, d, m, v) {
                        const b = (m - c) / 2
                          , P = Math.abs(e - (c + b));
                        if (P > b + s)
                            return !1;
                        const M = (v - d) / 2
                          , D = Math.abs(r - (d + M));
                        if (D > M + s)
                            return !1;
                        if (P <= b || D <= M)
                            return !0;
                        const L = P - b
                          , B = D - M;
                        return L * L + B * B <= s * s
                    }
                }
                function wr(h, e, r) {
                    const s = o.L();
                    if (!h) {
                        const {vecSouth: D, vecEast: L} = Yr(e)
                          , B = G();
                        B[0] = L[0],
                        B[1] = L[1],
                        B[2] = D[0],
                        B[3] = D[1],
                        c = B,
                        (M = (m = (d = B)[0]) * (P = d[3]) - (b = d[2]) * (v = d[1])) && (c[0] = P * (M = 1 / M),
                        c[1] = -v * M,
                        c[2] = -b * M,
                        c[3] = m * M),
                        s[0] = B[0],
                        s[1] = B[1],
                        s[4] = B[2],
                        s[5] = B[3]
                    }
                    var c, d, m, v, b, P, M;
                    return o.N(s, s, [1 / r, 1 / r, 1]),
                    s
                }
                function ci(h, e, r, s) {
                    if (h) {
                        const c = o.L();
                        if (!e) {
                            const {vecSouth: d, vecEast: m} = Yr(r);
                            c[0] = m[0],
                            c[1] = m[1],
                            c[4] = d[0],
                            c[5] = d[1]
                        }
                        return o.N(c, c, [s, s, 1]),
                        c
                    }
                    return r.pixelsToClipSpaceMatrix
                }
                function Yr(h) {
                    const e = Math.cos(h.rollInRadians)
                      , r = Math.sin(h.rollInRadians)
                      , s = Math.cos(h.pitchInRadians)
                      , c = Math.cos(h.bearingInRadians)
                      , d = Math.sin(h.bearingInRadians)
                      , m = o.aq();
                    m[0] = -c * s * r - d * e,
                    m[1] = -d * s * r + c * e;
                    const v = o.ar(m);
                    v < 1e-9 ? o.as(m) : o.at(m, m, 1 / v);
                    const b = o.aq();
                    b[0] = c * s * e - d * r,
                    b[1] = d * s * e + c * r;
                    const P = o.ar(b);
                    return P < 1e-9 ? o.as(b) : o.at(b, b, 1 / P),
                    {
                        vecEast: b,
                        vecSouth: m
                    }
                }
                function yt(h, e, r, s) {
                    let c;
                    s ? (c = [h, e, s(h, e), 1],
                    o.av(c, c, r)) : (c = [h, e, 0, 1],
                    On(c, c, r));
                    const d = c[3];
                    return {
                        point: new o.P(c[0] / d,c[1] / d),
                        signedDistanceFromCamera: d,
                        isOccluded: !1
                    }
                }
                function Mt(h, e) {
                    return .5 + h / e * .5
                }
                function Gt(h, e) {
                    return h.x >= -e[0] && h.x <= e[0] && h.y >= -e[1] && h.y <= e[1]
                }
                function Fr(h, e, r, s, c, d, m, v, b, P, M, D, L) {
                    const B = r ? h.textSizeData : h.iconSizeData
                      , Z = o.am(B, e.transform.zoom)
                      , te = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1]
                      , ee = r ? h.text.dynamicLayoutVertexArray : h.icon.dynamicLayoutVertexArray;
                    ee.clear();
                    const ne = h.lineVertexArray
                      , oe = r ? h.text.placedSymbolArray : h.icon.placedSymbolArray
                      , me = e.transform.width / e.transform.height;
                    let ce = !1;
                    for (let Te = 0; Te < oe.length; Te++) {
                        const Pe = oe.get(Te);
                        if (Pe.hidden || Pe.writingMode === o.an.vertical && !ce) {
                            $i(Pe.numGlyphs, ee);
                            continue
                        }
                        ce = !1;
                        const pe = new o.P(Pe.anchorX,Pe.anchorY)
                          , Fe = {
                            getElevation: L,
                            pitchedLabelPlaneMatrix: s,
                            lineVertexArray: ne,
                            pitchWithMap: d,
                            projectionCache: {
                                projections: {},
                                offsets: {},
                                cachedAnchorPoint: void 0,
                                anyProjectionOccluded: !1
                            },
                            transform: e.transform,
                            tileAnchorPoint: pe,
                            unwrappedTileID: b,
                            width: P,
                            height: M,
                            translation: D
                        }
                          , Ye = pr(Pe.anchorX, Pe.anchorY, Fe);
                        if (!Gt(Ye.point, te)) {
                            $i(Pe.numGlyphs, ee);
                            continue
                        }
                        const $e = Mt(e.transform.cameraToCenterDistance, Ye.signedDistanceFromCamera)
                          , He = o.ao(B, Z, Pe)
                          , Je = d ? He * e.transform.getPitchedTextCorrection(Pe.anchorX, Pe.anchorY, b) / $e : He * $e
                          , qt = Ur({
                            projectionContext: Fe,
                            pitchedLabelPlaneMatrixInverse: c,
                            symbol: Pe,
                            fontSize: Je,
                            flip: !1,
                            keepUpright: m,
                            glyphOffsetArray: h.glyphOffsetArray,
                            dynamicLayoutVertexArray: ee,
                            aspectRatio: me,
                            rotateToLine: v
                        });
                        ce = qt.useVertical,
                        (qt.notEnoughRoom || ce || qt.needsFlipping && Ur({
                            projectionContext: Fe,
                            pitchedLabelPlaneMatrixInverse: c,
                            symbol: Pe,
                            fontSize: Je,
                            flip: !0,
                            keepUpright: m,
                            glyphOffsetArray: h.glyphOffsetArray,
                            dynamicLayoutVertexArray: ee,
                            aspectRatio: me,
                            rotateToLine: v
                        }).notEnoughRoom) && $i(Pe.numGlyphs, ee)
                    }
                    r ? h.text.dynamicLayoutVertexBuffer.updateData(ee) : h.icon.dynamicLayoutVertexBuffer.updateData(ee)
                }
                function ft(h, e, r, s, c, d, m, v) {
                    const b = d.glyphStartIndex + d.numGlyphs
                      , P = d.lineStartIndex
                      , M = d.lineStartIndex + d.lineLength
                      , D = e.getoffsetX(d.glyphStartIndex)
                      , L = e.getoffsetX(b - 1)
                      , B = si(h * D, r, s, c, d.segment, P, M, v, m);
                    if (!B)
                        return null;
                    const Z = si(h * L, r, s, c, d.segment, P, M, v, m);
                    return Z ? v.projectionCache.anyProjectionOccluded ? null : {
                        first: B,
                        last: Z
                    } : null
                }
                function Br(h, e, r, s) {
                    return h === o.an.horizontal && Math.abs(r.y - e.y) > Math.abs(r.x - e.x) * s ? {
                        useVertical: !0
                    } : (h === o.an.vertical ? e.y < r.y : e.x > r.x) ? {
                        needsFlipping: !0
                    } : null
                }
                function Ur(h) {
                    const {projectionContext: e, pitchedLabelPlaneMatrixInverse: r, symbol: s, fontSize: c, flip: d, keepUpright: m, glyphOffsetArray: v, dynamicLayoutVertexArray: b, aspectRatio: P, rotateToLine: M} = h
                      , D = c / 24
                      , L = s.lineOffsetX * D
                      , B = s.lineOffsetY * D;
                    let Z;
                    if (s.numGlyphs > 1) {
                        const te = s.glyphStartIndex + s.numGlyphs
                          , ee = s.lineStartIndex
                          , ne = s.lineStartIndex + s.lineLength
                          , oe = ft(D, v, L, B, d, s, M, e);
                        if (!oe)
                            return {
                                notEnoughRoom: !0
                            };
                        const me = yr(oe.first.point.x, oe.first.point.y, e, r)
                          , ce = yr(oe.last.point.x, oe.last.point.y, e, r);
                        if (m && !d) {
                            const Te = Br(s.writingMode, me, ce, P);
                            if (Te)
                                return Te
                        }
                        Z = [oe.first];
                        for (let Te = s.glyphStartIndex + 1; Te < te - 1; Te++) {
                            const Pe = si(D * v.getoffsetX(Te), L, B, d, s.segment, ee, ne, e, M);
                            if (!Pe)
                                return {
                                    notEnoughRoom: !0
                                };
                            Z.push(Pe)
                        }
                        Z.push(oe.last)
                    } else {
                        if (m && !d) {
                            const ee = St(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point
                              , ne = s.lineStartIndex + s.segment + 1
                              , oe = new o.P(e.lineVertexArray.getx(ne),e.lineVertexArray.gety(ne))
                              , me = St(oe.x, oe.y, e)
                              , ce = me.signedDistanceFromCamera > 0 ? me.point : Si(e.tileAnchorPoint, oe, ee, 1, e)
                              , Te = yr(ee.x, ee.y, e, r)
                              , Pe = yr(ce.x, ce.y, e, r)
                              , pe = Br(s.writingMode, Te, Pe, P);
                            if (pe)
                                return pe
                        }
                        const te = si(D * v.getoffsetX(s.glyphStartIndex), L, B, d, s.segment, s.lineStartIndex, s.lineStartIndex + s.lineLength, e, M);
                        if (!te || e.projectionCache.anyProjectionOccluded)
                            return {
                                notEnoughRoom: !0
                            };
                        Z = [te]
                    }
                    for (const te of Z)
                        o.au(b, te.point, te.angle);
                    return {}
                }
                function Si(h, e, r, s, c) {
                    const d = h.add(h.sub(e)._unit())
                      , m = St(d.x, d.y, c).point
                      , v = r.sub(m);
                    return r.add(v._mult(s / v.mag()))
                }
                function ui(h, e, r) {
                    const s = e.projectionCache;
                    if (s.projections[h])
                        return s.projections[h];
                    const c = new o.P(e.lineVertexArray.getx(h),e.lineVertexArray.gety(h))
                      , d = St(c.x, c.y, e);
                    if (d.signedDistanceFromCamera > 0)
                        return s.projections[h] = d.point,
                        s.anyProjectionOccluded = s.anyProjectionOccluded || d.isOccluded,
                        d.point;
                    const m = h - r.direction;
                    return Si(r.distanceFromAnchor === 0 ? e.tileAnchorPoint : new o.P(e.lineVertexArray.getx(m),e.lineVertexArray.gety(m)), c, r.previousVertex, r.absOffsetX - r.distanceFromAnchor + 1, e)
                }
                function St(h, e, r) {
                    const s = h + r.translation[0]
                      , c = e + r.translation[1];
                    let d;
                    return r.pitchWithMap ? (d = yt(s, c, r.pitchedLabelPlaneMatrix, r.getElevation),
                    d.isOccluded = !1) : (d = r.transform.projectTileCoordinates(s, c, r.unwrappedTileID, r.getElevation),
                    d.point.x = (.5 * d.point.x + .5) * r.width,
                    d.point.y = (.5 * -d.point.y + .5) * r.height),
                    d
                }
                function yr(h, e, r, s) {
                    if (r.pitchWithMap) {
                        const c = [h, e, 0, 1];
                        return o.av(c, c, s),
                        r.transform.projectTileCoordinates(c[0] / c[3], c[1] / c[3], r.unwrappedTileID, r.getElevation).point
                    }
                    return {
                        x: h / r.width * 2 - 1,
                        y: 1 - e / r.height * 2
                    }
                }
                function pr(h, e, r) {
                    return r.transform.projectTileCoordinates(h, e, r.unwrappedTileID, r.getElevation)
                }
                function hi(h, e, r) {
                    return h._unit()._perp()._mult(e * r)
                }
                function Or(h, e, r, s, c, d, m, v, b) {
                    if (v.projectionCache.offsets[h])
                        return v.projectionCache.offsets[h];
                    const P = r.add(e);
                    if (h + b.direction < s || h + b.direction >= c)
                        return v.projectionCache.offsets[h] = P,
                        P;
                    const M = ui(h + b.direction, v, b)
                      , D = hi(M.sub(r), m, b.direction)
                      , L = r.add(D)
                      , B = M.add(D);
                    return v.projectionCache.offsets[h] = o.aw(d, P, L, B) || P,
                    v.projectionCache.offsets[h]
                }
                function si(h, e, r, s, c, d, m, v, b) {
                    const P = s ? h - e : h + e;
                    let M = P > 0 ? 1 : -1
                      , D = 0;
                    s && (M *= -1,
                    D = Math.PI),
                    M < 0 && (D += Math.PI);
                    let L, B = M > 0 ? d + c : d + c + 1;
                    v.projectionCache.cachedAnchorPoint ? L = v.projectionCache.cachedAnchorPoint : (L = St(v.tileAnchorPoint.x, v.tileAnchorPoint.y, v).point,
                    v.projectionCache.cachedAnchorPoint = L);
                    let Z, te, ee = L, ne = L, oe = 0, me = 0;
                    const ce = Math.abs(P)
                      , Te = [];
                    let Pe;
                    for (; oe + me <= ce; ) {
                        if (B += M,
                        B < d || B >= m)
                            return null;
                        oe += me,
                        ne = ee,
                        te = Z;
                        const Ye = {
                            absOffsetX: ce,
                            direction: M,
                            distanceFromAnchor: oe,
                            previousVertex: ne
                        };
                        if (ee = ui(B, v, Ye),
                        r === 0)
                            Te.push(ne),
                            Pe = ee.sub(ne);
                        else {
                            let $e;
                            const He = ee.sub(ne);
                            $e = He.mag() === 0 ? hi(ui(B + M, v, Ye).sub(ee), r, M) : hi(He, r, M),
                            te || (te = ne.add($e)),
                            Z = Or(B, $e, ee, d, m, te, r, v, Ye),
                            Te.push(te),
                            Pe = Z.sub(te)
                        }
                        me = Pe.mag()
                    }
                    const pe = Pe._mult((ce - oe) / me)._add(te || ne)
                      , Fe = D + Math.atan2(ee.y - ne.y, ee.x - ne.x);
                    return Te.push(pe),
                    {
                        point: pe,
                        angle: b ? Fe : 0,
                        path: Te
                    }
                }
                const fr = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
                function $i(h, e) {
                    for (let r = 0; r < h; r++) {
                        const s = e.length;
                        e.resize(s + 4),
                        e.float32.set(fr, 3 * s)
                    }
                }
                function On(h, e, r) {
                    const s = e[0]
                      , c = e[1];
                    return h[0] = r[0] * s + r[4] * c + r[12],
                    h[1] = r[1] * s + r[5] * c + r[13],
                    h[3] = r[3] * s + r[7] * c + r[15],
                    h
                }
                const _i = 100;
                class An {
                    constructor(e, r=new Ut(e.width + 200,e.height + 200,25), s=new Ut(e.width + 200,e.height + 200,25)) {
                        this.transform = e,
                        this.grid = r,
                        this.ignoredGrid = s,
                        this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance,
                        this.screenRightBoundary = e.width + _i,
                        this.screenBottomBoundary = e.height + _i,
                        this.gridRightBoundary = e.width + 200,
                        this.gridBottomBoundary = e.height + 200,
                        this.perspectiveRatioCutoff = .6
                    }
                    placeCollisionBox(e, r, s, c, d, m, v, b, P, M, D, L) {
                        const B = this.projectAndGetPerspectiveRatio(e.anchorPointX + b[0], e.anchorPointY + b[1], d, M, L)
                          , Z = s * B.perspectiveRatio;
                        let te;
                        if (m || v)
                            te = this._projectCollisionBox(e, Z, c, d, m, v, b, B, M, D, L);
                        else {
                            const Pe = B.x + (D ? D.x * Z : 0)
                              , pe = B.y + (D ? D.y * Z : 0);
                            te = {
                                allPointsOccluded: !1,
                                box: [Pe + e.x1 * Z, pe + e.y1 * Z, Pe + e.x2 * Z, pe + e.y2 * Z]
                            }
                        }
                        const [ee,ne,oe,me] = te.box
                          , ce = m ? te.allPointsOccluded : B.isOccluded;
                        let Te = ce;
                        return Te || (Te = B.perspectiveRatio < this.perspectiveRatioCutoff),
                        Te || (Te = !this.isInsideGrid(ee, ne, oe, me)),
                        Te || r !== "always" && this.grid.hitTest(ee, ne, oe, me, r, P) ? {
                            box: [ee, ne, oe, me],
                            placeable: !1,
                            offscreen: !1,
                            occluded: ce
                        } : {
                            box: [ee, ne, oe, me],
                            placeable: !0,
                            offscreen: this.isOffscreen(ee, ne, oe, me),
                            occluded: ce
                        }
                    }
                    placeCollisionCircles(e, r, s, c, d, m, v, b, P, M, D, L, B, Z) {
                        const te = []
                          , ee = new o.P(r.anchorX,r.anchorY)
                          , ne = this.getPerspectiveRatio(ee.x, ee.y, m, Z)
                          , oe = (P ? d * this.transform.getPitchedTextCorrection(r.anchorX, r.anchorY, m) / ne : d * ne) / o.aA
                          , me = {
                            getElevation: Z,
                            pitchedLabelPlaneMatrix: v,
                            lineVertexArray: s,
                            pitchWithMap: P,
                            projectionCache: {
                                projections: {},
                                offsets: {},
                                cachedAnchorPoint: void 0,
                                anyProjectionOccluded: !1
                            },
                            transform: this.transform,
                            tileAnchorPoint: ee,
                            unwrappedTileID: m,
                            width: this.transform.width,
                            height: this.transform.height,
                            translation: B
                        }
                          , ce = ft(oe, c, r.lineOffsetX * oe, r.lineOffsetY * oe, !1, r, !1, me);
                        let Te = !1
                          , Pe = !1
                          , pe = !0;
                        if (ce) {
                            const Fe = .5 * D * ne + L
                              , Ye = new o.P(-100,-100)
                              , $e = new o.P(this.screenRightBoundary,this.screenBottomBoundary)
                              , He = new Kt
                              , Je = ce.first
                              , qt = ce.last;
                            let Nt = [];
                            for (let Kr = Je.path.length - 1; Kr >= 1; Kr--)
                                Nt.push(Je.path[Kr]);
                            for (let Kr = 1; Kr < qt.path.length; Kr++)
                                Nt.push(qt.path[Kr]);
                            const wt = 2.5 * Fe;
                            if (P) {
                                const Kr = this.projectPathToScreenSpace(Nt, me);
                                Nt = Kr.some(fi => fi.signedDistanceFromCamera <= 0) ? [] : Kr.map(fi => fi.point)
                            }
                            let rr = [];
                            if (Nt.length > 0) {
                                const Kr = Nt[0].clone()
                                  , fi = Nt[0].clone();
                                for (let Bi = 1; Bi < Nt.length; Bi++)
                                    Kr.x = Math.min(Kr.x, Nt[Bi].x),
                                    Kr.y = Math.min(Kr.y, Nt[Bi].y),
                                    fi.x = Math.max(fi.x, Nt[Bi].x),
                                    fi.y = Math.max(fi.y, Nt[Bi].y);
                                rr = Kr.x >= Ye.x && fi.x <= $e.x && Kr.y >= Ye.y && fi.y <= $e.y ? [Nt] : fi.x < Ye.x || Kr.x > $e.x || fi.y < Ye.y || Kr.y > $e.y ? [] : o.ax([Nt], Ye.x, Ye.y, $e.x, $e.y)
                            }
                            for (const Kr of rr) {
                                He.reset(Kr, .25 * Fe);
                                let fi = 0;
                                fi = He.length <= .5 * Fe ? 1 : Math.ceil(He.paddedLength / wt) + 1;
                                for (let Bi = 0; Bi < fi; Bi++) {
                                    const xi = Bi / Math.max(fi - 1, 1)
                                      , Fi = He.lerp(xi)
                                      , Ti = Fi.x + _i
                                      , bi = Fi.y + _i;
                                    te.push(Ti, bi, Fe, 0);
                                    const Ci = Ti - Fe
                                      , vn = bi - Fe
                                      , li = Ti + Fe
                                      , cn = bi + Fe;
                                    if (pe = pe && this.isOffscreen(Ci, vn, li, cn),
                                    Pe = Pe || this.isInsideGrid(Ci, vn, li, cn),
                                    e !== "always" && this.grid.hitTestCircle(Ti, bi, Fe, e, M) && (Te = !0,
                                    !b))
                                        return {
                                            circles: [],
                                            offscreen: !1,
                                            collisionDetected: Te
                                        }
                                }
                            }
                        }
                        return {
                            circles: !b && Te || !Pe || ne < this.perspectiveRatioCutoff ? [] : te,
                            offscreen: pe,
                            collisionDetected: Te
                        }
                    }
                    projectPathToScreenSpace(e, r) {
                        const s = function(c, d) {
                            const m = o.L();
                            return o.ap(m, d.pitchedLabelPlaneMatrix),
                            c.map(v => {
                                const b = yt(v.x, v.y, m, d.getElevation)
                                  , P = d.transform.projectTileCoordinates(b.point.x, b.point.y, d.unwrappedTileID, d.getElevation);
                                return P.point.x = (.5 * P.point.x + .5) * d.width,
                                P.point.y = (.5 * -P.point.y + .5) * d.height,
                                P
                            }
                            )
                        }(e, r);
                        return function(c) {
                            let d = 0
                              , m = 0
                              , v = 0
                              , b = 0;
                            for (let P = 0; P < c.length; P++)
                                c[P].isOccluded ? (v = P + 1,
                                b = 0) : (b++,
                                b > m && (m = b,
                                d = v));
                            return c.slice(d, d + m)
                        }(s)
                    }
                    queryRenderedSymbols(e) {
                        if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
                            return {};
                        const r = []
                          , s = new o.a1;
                        for (const D of e) {
                            const L = new o.P(D.x + _i,D.y + _i);
                            s.extend(L),
                            r.push(L)
                        }
                        const {minX: c, minY: d, maxX: m, maxY: v} = s
                          , b = this.grid.query(c, d, m, v).concat(this.ignoredGrid.query(c, d, m, v))
                          , P = {}
                          , M = {};
                        for (const D of b) {
                            const L = D.key;
                            if (P[L.bucketInstanceId] === void 0 && (P[L.bucketInstanceId] = {}),
                            P[L.bucketInstanceId][L.featureIndex])
                                continue;
                            const B = [new o.P(D.x1,D.y1), new o.P(D.x2,D.y1), new o.P(D.x2,D.y2), new o.P(D.x1,D.y2)];
                            o.ay(r, B) && (P[L.bucketInstanceId][L.featureIndex] = !0,
                            M[L.bucketInstanceId] === void 0 && (M[L.bucketInstanceId] = []),
                            M[L.bucketInstanceId].push(L.featureIndex))
                        }
                        return M
                    }
                    insertCollisionBox(e, r, s, c, d, m) {
                        (s ? this.ignoredGrid : this.grid).insert({
                            bucketInstanceId: c,
                            featureIndex: d,
                            collisionGroupID: m,
                            overlapMode: r
                        }, e[0], e[1], e[2], e[3])
                    }
                    insertCollisionCircles(e, r, s, c, d, m) {
                        const v = s ? this.ignoredGrid : this.grid
                          , b = {
                            bucketInstanceId: c,
                            featureIndex: d,
                            collisionGroupID: m,
                            overlapMode: r
                        };
                        for (let P = 0; P < e.length; P += 4)
                            v.insertCircle(b, e[P], e[P + 1], e[P + 2])
                    }
                    projectAndGetPerspectiveRatio(e, r, s, c, d) {
                        if (d) {
                            let m;
                            c ? (m = [e, r, c(e, r), 1],
                            o.av(m, m, d)) : (m = [e, r, 0, 1],
                            On(m, m, d));
                            const v = m[3];
                            return {
                                x: (m[0] / v + 1) / 2 * this.transform.width + _i,
                                y: (-m[1] / v + 1) / 2 * this.transform.height + _i,
                                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / v * .5,
                                isOccluded: !1,
                                signedDistanceFromCamera: v
                            }
                        }
                        {
                            const m = this.transform.projectTileCoordinates(e, r, s, c);
                            return {
                                x: (m.point.x + 1) / 2 * this.transform.width + _i,
                                y: (1 - m.point.y) / 2 * this.transform.height + _i,
                                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / m.signedDistanceFromCamera * .5,
                                isOccluded: m.isOccluded,
                                signedDistanceFromCamera: m.signedDistanceFromCamera
                            }
                        }
                    }
                    getPerspectiveRatio(e, r, s, c) {
                        const d = this.transform.projectTileCoordinates(e, r, s, c);
                        return .5 + this.transform.cameraToCenterDistance / d.signedDistanceFromCamera * .5
                    }
                    isOffscreen(e, r, s, c) {
                        return s < _i || e >= this.screenRightBoundary || c < _i || r > this.screenBottomBoundary
                    }
                    isInsideGrid(e, r, s, c) {
                        return s >= 0 && e < this.gridRightBoundary && c >= 0 && r < this.gridBottomBoundary
                    }
                    getViewportMatrix() {
                        const e = o.af([]);
                        return o.M(e, e, [-100, -100, 0]),
                        e
                    }
                    _projectCollisionBox(e, r, s, c, d, m, v, b, P, M, D) {
                        let L = 1
                          , B = 0
                          , Z = 0
                          , te = 1;
                        const ee = e.anchorPointX + v[0]
                          , ne = e.anchorPointY + v[1];
                        if (m && !d) {
                            const Nt = this.projectAndGetPerspectiveRatio(ee + 1, ne, c, P, D)
                              , wt = Nt.x - b.x
                              , rr = Math.atan((Nt.y - b.y) / wt) + (wt < 0 ? Math.PI : 0)
                              , Kr = Math.sin(rr)
                              , fi = Math.cos(rr);
                            L = fi,
                            B = Kr,
                            Z = -Kr,
                            te = fi
                        } else if (!m && d) {
                            const Nt = Yr(this.transform);
                            L = Nt.vecEast[0],
                            B = Nt.vecEast[1],
                            Z = Nt.vecSouth[0],
                            te = Nt.vecSouth[1]
                        }
                        let oe = b.x
                          , me = b.y
                          , ce = r;
                        d && (oe = ee,
                        me = ne,
                        ce = Math.pow(2, -(this.transform.zoom - s.overscaledZ)),
                        ce *= this.transform.getPitchedTextCorrection(ee, ne, c),
                        M || (ce *= o.ag(.5 + b.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))),
                        M && (oe += L * M.x * ce + Z * M.y * ce,
                        me += B * M.x * ce + te * M.y * ce);
                        const Te = e.x1 * ce
                          , Pe = e.x2 * ce
                          , pe = (Te + Pe) / 2
                          , Fe = e.y1 * ce
                          , Ye = e.y2 * ce
                          , $e = (Fe + Ye) / 2
                          , He = [{
                            offsetX: Te,
                            offsetY: Fe
                        }, {
                            offsetX: pe,
                            offsetY: Fe
                        }, {
                            offsetX: Pe,
                            offsetY: Fe
                        }, {
                            offsetX: Pe,
                            offsetY: $e
                        }, {
                            offsetX: Pe,
                            offsetY: Ye
                        }, {
                            offsetX: pe,
                            offsetY: Ye
                        }, {
                            offsetX: Te,
                            offsetY: Ye
                        }, {
                            offsetX: Te,
                            offsetY: $e
                        }];
                        let Je = [];
                        for (const {offsetX: Nt, offsetY: wt} of He)
                            Je.push(new o.P(oe + L * Nt + Z * wt,me + B * Nt + te * wt));
                        let qt = !1;
                        if (d) {
                            const Nt = Je.map(wt => this.projectAndGetPerspectiveRatio(wt.x, wt.y, c, P, D));
                            qt = Nt.some(wt => !wt.isOccluded),
                            Je = Nt.map(wt => new o.P(wt.x,wt.y))
                        } else
                            qt = !0;
                        return {
                            box: o.az(Je),
                            allPointsOccluded: !qt
                        }
                    }
                }
                class Kn {
                    constructor(e, r, s, c) {
                        this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? r : -r))) : c && s ? 1 : 0,
                        this.placed = s
                    }
                    isHidden() {
                        return this.opacity === 0 && !this.placed
                    }
                }
                class Nn {
                    constructor(e, r, s, c, d) {
                        this.text = new Kn(e ? e.text : null,r,s,d),
                        this.icon = new Kn(e ? e.icon : null,r,c,d)
                    }
                    isHidden() {
                        return this.text.isHidden() && this.icon.isHidden()
                    }
                }
                class Tt {
                    constructor(e, r, s) {
                        this.text = e,
                        this.icon = r,
                        this.skipFade = s
                    }
                }
                class Ot {
                    constructor(e, r, s, c, d) {
                        this.bucketInstanceId = e,
                        this.featureIndex = r,
                        this.sourceLayerIndex = s,
                        this.bucketIndex = c,
                        this.tileID = d
                    }
                }
                class Ht {
                    constructor(e) {
                        this.crossSourceCollisions = e,
                        this.maxGroupID = 0,
                        this.collisionGroups = {}
                    }
                    get(e) {
                        if (this.crossSourceCollisions)
                            return {
                                ID: 0,
                                predicate: null
                            };
                        if (!this.collisionGroups[e]) {
                            const r = ++this.maxGroupID;
                            this.collisionGroups[e] = {
                                ID: r,
                                predicate: s => s.collisionGroupID === r
                            }
                        }
                        return this.collisionGroups[e]
                    }
                }
                function mi(h, e, r, s, c) {
                    const {horizontalAlign: d, verticalAlign: m} = o.aG(h);
                    return new o.P(-(d - .5) * e + s[0] * c,-(m - .5) * r + s[1] * c)
                }
                class Ii {
                    constructor(e, r, s, c, d) {
                        this.transform = e.clone(),
                        this.terrain = r,
                        this.collisionIndex = new An(this.transform),
                        this.placements = {},
                        this.opacities = {},
                        this.variableOffsets = {},
                        this.stale = !1,
                        this.commitTime = 0,
                        this.fadeDuration = s,
                        this.retainedQueryData = {},
                        this.collisionGroups = new Ht(c),
                        this.collisionCircleArrays = {},
                        this.collisionBoxArrays = new Map,
                        this.prevPlacement = d,
                        d && (d.prevPlacement = void 0),
                        this.placedOrientations = {}
                    }
                    _getTerrainElevationFunc(e) {
                        const r = this.terrain;
                        return r ? (s, c) => r.getElevation(e, s, c) : null
                    }
                    getBucketParts(e, r, s, c) {
                        const d = s.getBucket(r)
                          , m = s.latestFeatureIndex;
                        if (!d || !m || r.id !== d.layerIds[0])
                            return;
                        const v = s.collisionBoxArray
                          , b = d.layers[0].layout
                          , P = d.layers[0].paint
                          , M = Math.pow(2, this.transform.zoom - s.tileID.overscaledZ)
                          , D = s.tileSize / o.$
                          , L = s.tileID.toUnwrapped()
                          , B = b.get("text-rotation-alignment") === "map"
                          , Z = o.aB(s, 1, this.transform.zoom)
                          , te = o.aC(this.collisionIndex.transform, s, P.get("text-translate"), P.get("text-translate-anchor"))
                          , ee = o.aC(this.collisionIndex.transform, s, P.get("icon-translate"), P.get("icon-translate-anchor"))
                          , ne = wr(B, this.transform, Z);
                        this.retainedQueryData[d.bucketInstanceId] = new Ot(d.bucketInstanceId,m,d.sourceLayerIndex,d.index,s.tileID);
                        const oe = {
                            bucket: d,
                            layout: b,
                            translationText: te,
                            translationIcon: ee,
                            unwrappedTileID: L,
                            pitchedLabelPlaneMatrix: ne,
                            scale: M,
                            textPixelRatio: D,
                            holdingForFade: s.holdingForFade(),
                            collisionBoxArray: v,
                            partiallyEvaluatedTextSize: o.am(d.textSizeData, this.transform.zoom),
                            collisionGroup: this.collisionGroups.get(d.sourceID)
                        };
                        if (c)
                            for (const me of d.sortKeyRanges) {
                                const {sortKey: ce, symbolInstanceStart: Te, symbolInstanceEnd: Pe} = me;
                                e.push({
                                    sortKey: ce,
                                    symbolInstanceStart: Te,
                                    symbolInstanceEnd: Pe,
                                    parameters: oe
                                })
                            }
                        else
                            e.push({
                                symbolInstanceStart: 0,
                                symbolInstanceEnd: d.symbolInstances.length,
                                parameters: oe
                            })
                    }
                    attemptAnchorPlacement(e, r, s, c, d, m, v, b, P, M, D, L, B, Z, te, ee, ne, oe, me, ce) {
                        const Te = o.aD[e.textAnchor]
                          , Pe = [e.textOffset0, e.textOffset1]
                          , pe = mi(Te, s, c, Pe, d)
                          , Fe = this.collisionIndex.placeCollisionBox(r, L, b, P, M, v, m, ee, D.predicate, me, pe, ce);
                        if ((!oe || this.collisionIndex.placeCollisionBox(oe, L, b, P, M, v, m, ne, D.predicate, me, pe, ce).placeable) && Fe.placeable) {
                            let Ye;
                            if (this.prevPlacement && this.prevPlacement.variableOffsets[B.crossTileID] && this.prevPlacement.placements[B.crossTileID] && this.prevPlacement.placements[B.crossTileID].text && (Ye = this.prevPlacement.variableOffsets[B.crossTileID].anchor),
                            B.crossTileID === 0)
                                throw new Error("symbolInstance.crossTileID can't be 0");
                            return this.variableOffsets[B.crossTileID] = {
                                textOffset: Pe,
                                width: s,
                                height: c,
                                anchor: Te,
                                textBoxScale: d,
                                prevAnchor: Ye
                            },
                            this.markUsedJustification(Z, Te, B, te),
                            Z.allowVerticalPlacement && (this.markUsedOrientation(Z, te, B),
                            this.placedOrientations[B.crossTileID] = te),
                            {
                                shift: pe,
                                placedGlyphBoxes: Fe
                            }
                        }
                    }
                    placeLayerBucketPart(e, r, s) {
                        const {bucket: c, layout: d, translationText: m, translationIcon: v, unwrappedTileID: b, pitchedLabelPlaneMatrix: P, textPixelRatio: M, holdingForFade: D, collisionBoxArray: L, partiallyEvaluatedTextSize: B, collisionGroup: Z} = e.parameters
                          , te = d.get("text-optional")
                          , ee = d.get("icon-optional")
                          , ne = o.aE(d, "text-overlap", "text-allow-overlap")
                          , oe = ne === "always"
                          , me = o.aE(d, "icon-overlap", "icon-allow-overlap")
                          , ce = me === "always"
                          , Te = d.get("text-rotation-alignment") === "map"
                          , Pe = d.get("text-pitch-alignment") === "map"
                          , pe = d.get("icon-text-fit") !== "none"
                          , Fe = d.get("symbol-z-order") === "viewport-y"
                          , Ye = oe && (ce || !c.hasIconData() || ee)
                          , $e = ce && (oe || !c.hasTextData() || te);
                        !c.collisionArrays && L && c.deserializeCollisionBoxes(L);
                        const He = this.retainedQueryData[c.bucketInstanceId].tileID
                          , Je = this._getTerrainElevationFunc(He)
                          , qt = this.transform.getFastPathSimpleProjectionMatrix(He)
                          , Nt = (wt, rr, Kr) => {
                            var fi, Bi;
                            if (r[wt.crossTileID])
                                return;
                            if (D)
                                return void (this.placements[wt.crossTileID] = new Tt(!1,!1,!1));
                            let xi = !1
                              , Fi = !1
                              , Ti = !0
                              , bi = null
                              , Ci = {
                                box: null,
                                placeable: !1,
                                offscreen: null,
                                occluded: !1
                            }
                              , vn = {
                                placeable: !1
                            }
                              , li = null
                              , cn = null
                              , yn = null
                              , Ja = 0
                              , Qa = 0
                              , es = 0;
                            rr.textFeatureIndex ? Ja = rr.textFeatureIndex : wt.useRuntimeCollisionCircles && (Ja = wt.featureIndex),
                            rr.verticalTextFeatureIndex && (Qa = rr.verticalTextFeatureIndex);
                            const Ma = rr.textBox;
                            if (Ma) {
                                const Un = Zi => {
                                    let Mi = o.an.horizontal;
                                    if (c.allowVerticalPlacement && !Zi && this.prevPlacement) {
                                        const Dn = this.prevPlacement.placedOrientations[wt.crossTileID];
                                        Dn && (this.placedOrientations[wt.crossTileID] = Dn,
                                        Mi = Dn,
                                        this.markUsedOrientation(c, Mi, wt))
                                    }
                                    return Mi
                                }
                                  , _a = (Zi, Mi) => {
                                    if (c.allowVerticalPlacement && wt.numVerticalGlyphVertices > 0 && rr.verticalTextBox) {
                                        for (const Dn of c.writingModes)
                                            if (Dn === o.an.vertical ? (Ci = Mi(),
                                            vn = Ci) : Ci = Zi(),
                                            Ci && Ci.placeable)
                                                break
                                    } else
                                        Ci = Zi()
                                }
                                  , ts = wt.textAnchorOffsetStartIndex
                                  , gs = wt.textAnchorOffsetEndIndex;
                                if (gs === ts) {
                                    const Zi = (Mi, Dn) => {
                                        const tn = this.collisionIndex.placeCollisionBox(Mi, ne, M, He, b, Pe, Te, m, Z.predicate, Je, void 0, qt);
                                        return tn && tn.placeable && (this.markUsedOrientation(c, Dn, wt),
                                        this.placedOrientations[wt.crossTileID] = Dn),
                                        tn
                                    }
                                    ;
                                    _a( () => Zi(Ma, o.an.horizontal), () => {
                                        const Mi = rr.verticalTextBox;
                                        return c.allowVerticalPlacement && wt.numVerticalGlyphVertices > 0 && Mi ? Zi(Mi, o.an.vertical) : {
                                            box: null,
                                            offscreen: null
                                        }
                                    }
                                    ),
                                    Un(Ci && Ci.placeable)
                                } else {
                                    let Zi = o.aD[(Bi = (fi = this.prevPlacement) === null || fi === void 0 ? void 0 : fi.variableOffsets[wt.crossTileID]) === null || Bi === void 0 ? void 0 : Bi.anchor];
                                    const Mi = (tn, rd, yp) => {
                                        const Qc = tn.x2 - tn.x1
                                          , No = tn.y2 - tn.y1
                                          , Js = wt.textBoxScale
                                          , Ba = pe && me === "never" ? rd : null;
                                        let xn = null
                                          , Fa = ne === "never" ? 1 : 2
                                          , eu = "never";
                                        Zi && Fa++;
                                        for (let rs = 0; rs < Fa; rs++) {
                                            for (let tu = ts; tu < gs; tu++) {
                                                const ru = c.textAnchorOffsets.get(tu);
                                                if (Zi && ru.textAnchor !== Zi)
                                                    continue;
                                                const jo = this.attemptAnchorPlacement(ru, tn, Qc, No, Js, Te, Pe, M, He, b, Z, eu, wt, c, yp, m, v, Ba, Je);
                                                if (jo && (xn = jo.placedGlyphBoxes,
                                                xn && xn.placeable))
                                                    return xi = !0,
                                                    bi = jo.shift,
                                                    xn
                                            }
                                            Zi ? Zi = null : eu = ne
                                        }
                                        return s && !xn && (xn = {
                                            box: this.collisionIndex.placeCollisionBox(Ma, "always", M, He, b, Pe, Te, m, Z.predicate, Je, void 0, qt).box,
                                            offscreen: !1,
                                            placeable: !1,
                                            occluded: !1
                                        }),
                                        xn
                                    }
                                    ;
                                    _a( () => Mi(Ma, rr.iconBox, o.an.horizontal), () => {
                                        const tn = rr.verticalTextBox;
                                        return c.allowVerticalPlacement && (!Ci || !Ci.placeable) && wt.numVerticalGlyphVertices > 0 && tn ? Mi(tn, rr.verticalIconBox, o.an.vertical) : {
                                            box: null,
                                            occluded: !0,
                                            offscreen: null
                                        }
                                    }
                                    ),
                                    Ci && (xi = Ci.placeable,
                                    Ti = Ci.offscreen);
                                    const Dn = Un(Ci && Ci.placeable);
                                    if (!xi && this.prevPlacement) {
                                        const tn = this.prevPlacement.variableOffsets[wt.crossTileID];
                                        tn && (this.variableOffsets[wt.crossTileID] = tn,
                                        this.markUsedJustification(c, tn.anchor, wt, Dn))
                                    }
                                }
                            }
                            if (li = Ci,
                            xi = li && li.placeable,
                            Ti = li && li.offscreen,
                            wt.useRuntimeCollisionCircles) {
                                const Un = c.text.placedSymbolArray.get(wt.centerJustifiedTextSymbolIndex)
                                  , _a = o.ao(c.textSizeData, B, Un)
                                  , ts = d.get("text-padding");
                                cn = this.collisionIndex.placeCollisionCircles(ne, Un, c.lineVertexArray, c.glyphOffsetArray, _a, b, P, s, Pe, Z.predicate, wt.collisionCircleDiameter, ts, m, Je),
                                cn.circles.length && cn.collisionDetected && !s && o.w("Collisions detected, but collision boxes are not shown"),
                                xi = oe || cn.circles.length > 0 && !cn.collisionDetected,
                                Ti = Ti && cn.offscreen
                            }
                            if (rr.iconFeatureIndex && (es = rr.iconFeatureIndex),
                            rr.iconBox) {
                                const Un = _a => this.collisionIndex.placeCollisionBox(_a, me, M, He, b, Pe, Te, v, Z.predicate, Je, pe && bi ? bi : void 0, qt);
                                vn && vn.placeable && rr.verticalIconBox ? (yn = Un(rr.verticalIconBox),
                                Fi = yn.placeable) : (yn = Un(rr.iconBox),
                                Fi = yn.placeable),
                                Ti = Ti && yn.offscreen
                            }
                            const Fo = te || wt.numHorizontalGlyphVertices === 0 && wt.numVerticalGlyphVertices === 0
                              , Oo = ee || wt.numIconVertices === 0;
                            Fo || Oo ? Oo ? Fo || (Fi = Fi && xi) : xi = Fi && xi : Fi = xi = Fi && xi;
                            const Ys = Fi && yn.placeable;
                            if (xi && li.placeable && this.collisionIndex.insertCollisionBox(li.box, ne, d.get("text-ignore-placement"), c.bucketInstanceId, vn && vn.placeable && Qa ? Qa : Ja, Z.ID),
                            Ys && this.collisionIndex.insertCollisionBox(yn.box, me, d.get("icon-ignore-placement"), c.bucketInstanceId, es, Z.ID),
                            cn && xi && this.collisionIndex.insertCollisionCircles(cn.circles, ne, d.get("text-ignore-placement"), c.bucketInstanceId, Ja, Z.ID),
                            s && this.storeCollisionData(c.bucketInstanceId, Kr, rr, li, yn, cn),
                            wt.crossTileID === 0)
                                throw new Error("symbolInstance.crossTileID can't be 0");
                            if (c.bucketInstanceId === 0)
                                throw new Error("bucket.bucketInstanceId can't be 0");
                            this.placements[wt.crossTileID] = new Tt((xi || Ye) && !(li != null && li.occluded),(Fi || $e) && !(yn != null && yn.occluded),Ti || c.justReloaded),
                            r[wt.crossTileID] = !0
                        }
                        ;
                        if (Fe) {
                            if (e.symbolInstanceStart !== 0)
                                throw new Error("bucket.bucketInstanceId should be 0");
                            const wt = c.getSortedSymbolIndexes(-this.transform.bearingInRadians);
                            for (let rr = wt.length - 1; rr >= 0; --rr) {
                                const Kr = wt[rr];
                                Nt(c.symbolInstances.get(Kr), c.collisionArrays[Kr], Kr)
                            }
                        } else
                            for (let wt = e.symbolInstanceStart; wt < e.symbolInstanceEnd; wt++)
                                Nt(c.symbolInstances.get(wt), c.collisionArrays[wt], wt);
                        c.justReloaded = !1
                    }
                    storeCollisionData(e, r, s, c, d, m) {
                        if (s.textBox || s.iconBox) {
                            let v, b;
                            this.collisionBoxArrays.has(e) ? v = this.collisionBoxArrays.get(e) : (v = new Map,
                            this.collisionBoxArrays.set(e, v)),
                            v.has(r) ? b = v.get(r) : (b = {
                                text: null,
                                icon: null
                            },
                            v.set(r, b)),
                            s.textBox && (b.text = c.box),
                            s.iconBox && (b.icon = d.box)
                        }
                        if (m) {
                            let v = this.collisionCircleArrays[e];
                            v === void 0 && (v = this.collisionCircleArrays[e] = []);
                            for (let b = 0; b < m.circles.length; b += 4)
                                v.push(m.circles[b + 0] - _i),
                                v.push(m.circles[b + 1] - _i),
                                v.push(m.circles[b + 2]),
                                v.push(m.collisionDetected ? 1 : 0)
                        }
                    }
                    markUsedJustification(e, r, s, c) {
                        let d;
                        d = c === o.an.vertical ? s.verticalPlacedTextSymbolIndex : {
                            left: s.leftJustifiedTextSymbolIndex,
                            center: s.centerJustifiedTextSymbolIndex,
                            right: s.rightJustifiedTextSymbolIndex
                        }[o.aF(r)];
                        const m = [s.leftJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.rightJustifiedTextSymbolIndex, s.verticalPlacedTextSymbolIndex];
                        for (const v of m)
                            v >= 0 && (e.text.placedSymbolArray.get(v).crossTileID = d >= 0 && v !== d ? 0 : s.crossTileID)
                    }
                    markUsedOrientation(e, r, s) {
                        const c = r === o.an.horizontal || r === o.an.horizontalOnly ? r : 0
                          , d = r === o.an.vertical ? r : 0
                          , m = [s.leftJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.rightJustifiedTextSymbolIndex];
                        for (const v of m)
                            e.text.placedSymbolArray.get(v).placedOrientation = c;
                        s.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(s.verticalPlacedTextSymbolIndex).placedOrientation = d)
                    }
                    commit(e) {
                        this.commitTime = e,
                        this.zoomAtLastRecencyCheck = this.transform.zoom;
                        const r = this.prevPlacement;
                        let s = !1;
                        this.prevZoomAdjustment = r ? r.zoomAdjustment(this.transform.zoom) : 0;
                        const c = r ? r.symbolFadeChange(e) : 1
                          , d = r ? r.opacities : {}
                          , m = r ? r.variableOffsets : {}
                          , v = r ? r.placedOrientations : {};
                        for (const b in this.placements) {
                            const P = this.placements[b]
                              , M = d[b];
                            M ? (this.opacities[b] = new Nn(M,c,P.text,P.icon),
                            s = s || P.text !== M.text.placed || P.icon !== M.icon.placed) : (this.opacities[b] = new Nn(null,c,P.text,P.icon,P.skipFade),
                            s = s || P.text || P.icon)
                        }
                        for (const b in d) {
                            const P = d[b];
                            if (!this.opacities[b]) {
                                const M = new Nn(P,c,!1,!1);
                                M.isHidden() || (this.opacities[b] = M,
                                s = s || P.text.placed || P.icon.placed)
                            }
                        }
                        for (const b in m)
                            this.variableOffsets[b] || !this.opacities[b] || this.opacities[b].isHidden() || (this.variableOffsets[b] = m[b]);
                        for (const b in v)
                            this.placedOrientations[b] || !this.opacities[b] || this.opacities[b].isHidden() || (this.placedOrientations[b] = v[b]);
                        if (r && r.lastPlacementChangeTime === void 0)
                            throw new Error("Last placement time for previous placement is not defined");
                        s ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = r ? r.lastPlacementChangeTime : e)
                    }
                    updateLayerOpacities(e, r) {
                        const s = {};
                        for (const c of r) {
                            const d = c.getBucket(e);
                            d && c.latestFeatureIndex && e.id === d.layerIds[0] && this.updateBucketOpacities(d, c.tileID, s, c.collisionBoxArray)
                        }
                    }
                    updateBucketOpacities(e, r, s, c) {
                        e.hasTextData() && (e.text.opacityVertexArray.clear(),
                        e.text.hasVisibleVertices = !1),
                        e.hasIconData() && (e.icon.opacityVertexArray.clear(),
                        e.icon.hasVisibleVertices = !1),
                        e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(),
                        e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
                        const d = e.layers[0]
                          , m = d.layout
                          , v = new Nn(null,0,!1,!1,!0)
                          , b = m.get("text-allow-overlap")
                          , P = m.get("icon-allow-overlap")
                          , M = d._unevaluatedLayout.hasValue("text-variable-anchor") || d._unevaluatedLayout.hasValue("text-variable-anchor-offset")
                          , D = m.get("text-rotation-alignment") === "map"
                          , L = m.get("text-pitch-alignment") === "map"
                          , B = m.get("icon-text-fit") !== "none"
                          , Z = new Nn(null,0,b && (P || !e.hasIconData() || m.get("icon-optional")),P && (b || !e.hasTextData() || m.get("text-optional")),!0);
                        !e.collisionArrays && c && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(c);
                        const te = (ne, oe, me) => {
                            for (let ce = 0; ce < oe / 4; ce++)
                                ne.opacityVertexArray.emplaceBack(me);
                            ne.hasVisibleVertices = ne.hasVisibleVertices || me !== oi
                        }
                          , ee = this.collisionBoxArrays.get(e.bucketInstanceId);
                        for (let ne = 0; ne < e.symbolInstances.length; ne++) {
                            const oe = e.symbolInstances.get(ne)
                              , {numHorizontalGlyphVertices: me, numVerticalGlyphVertices: ce, crossTileID: Te} = oe;
                            let Pe = this.opacities[Te];
                            s[Te] ? Pe = v : Pe || (Pe = Z,
                            this.opacities[Te] = Pe),
                            s[Te] = !0;
                            const pe = oe.numIconVertices > 0
                              , Fe = this.placedOrientations[oe.crossTileID]
                              , Ye = Fe === o.an.vertical
                              , $e = Fe === o.an.horizontal || Fe === o.an.horizontalOnly;
                            if (me > 0 || ce > 0) {
                                const Je = yi(Pe.text);
                                te(e.text, me, Ye ? oi : Je),
                                te(e.text, ce, $e ? oi : Je);
                                const qt = Pe.text.isHidden();
                                [oe.rightJustifiedTextSymbolIndex, oe.centerJustifiedTextSymbolIndex, oe.leftJustifiedTextSymbolIndex].forEach(rr => {
                                    rr >= 0 && (e.text.placedSymbolArray.get(rr).hidden = qt || Ye ? 1 : 0)
                                }
                                ),
                                oe.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(oe.verticalPlacedTextSymbolIndex).hidden = qt || $e ? 1 : 0);
                                const Nt = this.variableOffsets[oe.crossTileID];
                                Nt && this.markUsedJustification(e, Nt.anchor, oe, Fe);
                                const wt = this.placedOrientations[oe.crossTileID];
                                wt && (this.markUsedJustification(e, "left", oe, wt),
                                this.markUsedOrientation(e, wt, oe))
                            }
                            if (pe) {
                                const Je = yi(Pe.icon)
                                  , qt = !(B && oe.verticalPlacedIconSymbolIndex && Ye);
                                oe.placedIconSymbolIndex >= 0 && (te(e.icon, oe.numIconVertices, qt ? Je : oi),
                                e.icon.placedSymbolArray.get(oe.placedIconSymbolIndex).hidden = Pe.icon.isHidden()),
                                oe.verticalPlacedIconSymbolIndex >= 0 && (te(e.icon, oe.numVerticalIconVertices, qt ? oi : Je),
                                e.icon.placedSymbolArray.get(oe.verticalPlacedIconSymbolIndex).hidden = Pe.icon.isHidden())
                            }
                            const He = ee && ee.has(ne) ? ee.get(ne) : {
                                text: null,
                                icon: null
                            };
                            if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                                const Je = e.collisionArrays[ne];
                                if (Je) {
                                    let qt = new o.P(0,0);
                                    if (Je.textBox || Je.verticalTextBox) {
                                        let Nt = !0;
                                        if (M) {
                                            const wt = this.variableOffsets[Te];
                                            wt ? (qt = mi(wt.anchor, wt.width, wt.height, wt.textOffset, wt.textBoxScale),
                                            D && qt._rotate(L ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : Nt = !1
                                        }
                                        if (Je.textBox || Je.verticalTextBox) {
                                            let wt;
                                            Je.textBox && (wt = Ye),
                                            Je.verticalTextBox && (wt = $e),
                                            Qi(e.textCollisionBox.collisionVertexArray, Pe.text.placed, !Nt || wt, He.text, qt.x, qt.y)
                                        }
                                    }
                                    if (Je.iconBox || Je.verticalIconBox) {
                                        const Nt = !!(!$e && Je.verticalIconBox);
                                        let wt;
                                        Je.iconBox && (wt = Nt),
                                        Je.verticalIconBox && (wt = !Nt),
                                        Qi(e.iconCollisionBox.collisionVertexArray, Pe.icon.placed, wt, He.icon, B ? qt.x : 0, B ? qt.y : 0)
                                    }
                                }
                            }
                        }
                        if (e.sortFeatures(-this.transform.bearingInRadians),
                        this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder),
                        e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray),
                        e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray),
                        e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray),
                        e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray),
                        e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4)
                            throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
                        if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4)
                            throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
                        e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId],
                        delete this.collisionCircleArrays[e.bucketInstanceId])
                    }
                    symbolFadeChange(e) {
                        return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
                    }
                    zoomAdjustment(e) {
                        return Math.max(0, (this.transform.zoom - e) / 1.5)
                    }
                    hasTransitions(e) {
                        return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration
                    }
                    stillRecent(e, r) {
                        const s = this.zoomAtLastRecencyCheck === r ? 1 - this.zoomAdjustment(r) : 1;
                        return this.zoomAtLastRecencyCheck = r,
                        this.commitTime + this.fadeDuration * s > e
                    }
                    setStale() {
                        this.stale = !0
                    }
                }
                function Qi(h, e, r, s, c, d) {
                    s && s.length !== 0 || (s = [0, 0, 0, 0]);
                    const m = s[0] - _i
                      , v = s[1] - _i
                      , b = s[2] - _i
                      , P = s[3] - _i;
                    h.emplaceBack(e ? 1 : 0, r ? 1 : 0, c || 0, d || 0, m, v),
                    h.emplaceBack(e ? 1 : 0, r ? 1 : 0, c || 0, d || 0, b, v),
                    h.emplaceBack(e ? 1 : 0, r ? 1 : 0, c || 0, d || 0, b, P),
                    h.emplaceBack(e ? 1 : 0, r ? 1 : 0, c || 0, d || 0, m, P)
                }
                const vi = Math.pow(2, 25)
                  , kr = Math.pow(2, 24)
                  , Yn = Math.pow(2, 17)
                  , gr = Math.pow(2, 16)
                  , Zt = Math.pow(2, 9)
                  , Qr = Math.pow(2, 8)
                  , ni = Math.pow(2, 1);
                function yi(h) {
                    if (h.opacity === 0 && !h.placed)
                        return 0;
                    if (h.opacity === 1 && h.placed)
                        return 4294967295;
                    const e = h.placed ? 1 : 0
                      , r = Math.floor(127 * h.opacity);
                    return r * vi + e * kr + r * Yn + e * gr + r * Zt + e * Qr + r * ni + e
                }
                const oi = 0;
                class ki {
                    constructor(e) {
                        this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(),
                        this._currentTileIndex = 0,
                        this._currentPartIndex = 0,
                        this._seenCrossTileIDs = {},
                        this._bucketParts = []
                    }
                    continuePlacement(e, r, s, c, d) {
                        const m = this._bucketParts;
                        for (; this._currentTileIndex < e.length; )
                            if (r.getBucketParts(m, c, e[this._currentTileIndex], this._sortAcrossTiles),
                            this._currentTileIndex++,
                            d())
                                return !0;
                        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1,
                        m.sort( (v, b) => v.sortKey - b.sortKey)); this._currentPartIndex < m.length; )
                            if (r.placeLayerBucketPart(m[this._currentPartIndex], this._seenCrossTileIDs, s),
                            this._currentPartIndex++,
                            d())
                                return !0;
                        return !1
                    }
                }
                class Ki {
                    constructor(e, r, s, c, d, m, v, b) {
                        this.placement = new Ii(e,r,m,v,b),
                        this._currentPlacementIndex = s.length - 1,
                        this._forceFullPlacement = c,
                        this._showCollisionBoxes = d,
                        this._done = !1
                    }
                    isDone() {
                        return this._done
                    }
                    continuePlacement(e, r, s) {
                        const c = he.now()
                          , d = () => !this._forceFullPlacement && he.now() - c > 2;
                        for (; this._currentPlacementIndex >= 0; ) {
                            const m = r[e[this._currentPlacementIndex]]
                              , v = this.placement.collisionIndex.transform.zoom;
                            if (m.type === "symbol" && (!m.minzoom || m.minzoom <= v) && (!m.maxzoom || m.maxzoom > v)) {
                                if (this._inProgressLayer || (this._inProgressLayer = new ki(m)),
                                this._inProgressLayer.continuePlacement(s[m.source], this.placement, this._showCollisionBoxes, m, d))
                                    return;
                                delete this._inProgressLayer
                            }
                            this._currentPlacementIndex--
                        }
                        this._done = !0
                    }
                    commit(e) {
                        return this.placement.commit(e),
                        this.placement
                    }
                }
                const Pi = 512 / o.$ / 2;
                class Ni {
                    constructor(e, r, s) {
                        this.tileID = e,
                        this.bucketInstanceId = s,
                        this._symbolsByKey = {};
                        const c = new Map;
                        for (let d = 0; d < r.length; d++) {
                            const m = r.get(d)
                              , v = m.key
                              , b = c.get(v);
                            b ? b.push(m) : c.set(v, [m])
                        }
                        for (const [d,m] of c) {
                            const v = {
                                positions: m.map(b => ({
                                    x: Math.floor(b.anchorX * Pi),
                                    y: Math.floor(b.anchorY * Pi)
                                })),
                                crossTileIDs: m.map(b => b.crossTileID)
                            };
                            if (v.positions.length > 128) {
                                const b = new o.aH(v.positions.length,16,Uint16Array);
                                for (const {x: P, y: M} of v.positions)
                                    b.add(P, M);
                                b.finish(),
                                delete v.positions,
                                v.index = b
                            }
                            this._symbolsByKey[d] = v
                        }
                    }
                    getScaledCoordinates(e, r) {
                        const {x: s, y: c, z: d} = this.tileID.canonical
                          , {x: m, y: v, z: b} = r.canonical
                          , P = Pi / Math.pow(2, b - d)
                          , M = (v * o.$ + e.anchorY) * P
                          , D = c * o.$ * Pi;
                        return {
                            x: Math.floor((m * o.$ + e.anchorX) * P - s * o.$ * Pi),
                            y: Math.floor(M - D)
                        }
                    }
                    findMatches(e, r, s) {
                        const c = this.tileID.canonical.z < r.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - r.canonical.z);
                        for (let d = 0; d < e.length; d++) {
                            const m = e.get(d);
                            if (m.crossTileID)
                                continue;
                            const v = this._symbolsByKey[m.key];
                            if (!v)
                                continue;
                            const b = this.getScaledCoordinates(m, r);
                            if (v.index) {
                                const P = v.index.range(b.x - c, b.y - c, b.x + c, b.y + c).sort();
                                for (const M of P) {
                                    const D = v.crossTileIDs[M];
                                    if (!s[D]) {
                                        s[D] = !0,
                                        m.crossTileID = D;
                                        break
                                    }
                                }
                            } else if (v.positions)
                                for (let P = 0; P < v.positions.length; P++) {
                                    const M = v.positions[P]
                                      , D = v.crossTileIDs[P];
                                    if (Math.abs(M.x - b.x) <= c && Math.abs(M.y - b.y) <= c && !s[D]) {
                                        s[D] = !0,
                                        m.crossTileID = D;
                                        break
                                    }
                                }
                        }
                    }
                    getCrossTileIDsLists() {
                        return Object.values(this._symbolsByKey).map( ({crossTileIDs: e}) => e)
                    }
                }
                class zi {
                    constructor() {
                        this.maxCrossTileID = 0
                    }
                    generate() {
                        return ++this.maxCrossTileID
                    }
                }
                class gi {
                    constructor() {
                        this.indexes = {},
                        this.usedCrossTileIDs = {},
                        this.lng = 0
                    }
                    handleWrapJump(e) {
                        const r = Math.round((e - this.lng) / 360);
                        if (r !== 0)
                            for (const s in this.indexes) {
                                const c = this.indexes[s]
                                  , d = {};
                                for (const m in c) {
                                    const v = c[m];
                                    v.tileID = v.tileID.unwrapTo(v.tileID.wrap + r),
                                    d[v.tileID.key] = v
                                }
                                this.indexes[s] = d
                            }
                        this.lng = e
                    }
                    addBucket(e, r, s) {
                        if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
                            if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === r.bucketInstanceId)
                                return !1;
                            this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key])
                        }
                        for (let d = 0; d < r.symbolInstances.length; d++)
                            r.symbolInstances.get(d).crossTileID = 0;
                        this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
                        const c = this.usedCrossTileIDs[e.overscaledZ];
                        for (const d in this.indexes) {
                            const m = this.indexes[d];
                            if (Number(d) > e.overscaledZ)
                                for (const v in m) {
                                    const b = m[v];
                                    b.tileID.isChildOf(e) && b.findMatches(r.symbolInstances, e, c)
                                }
                            else {
                                const v = m[e.scaledTo(Number(d)).key];
                                v && v.findMatches(r.symbolInstances, e, c)
                            }
                        }
                        for (let d = 0; d < r.symbolInstances.length; d++) {
                            const m = r.symbolInstances.get(d);
                            m.crossTileID || (m.crossTileID = s.generate(),
                            c[m.crossTileID] = !0)
                        }
                        return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}),
                        this.indexes[e.overscaledZ][e.key] = new Ni(e,r.symbolInstances,r.bucketInstanceId),
                        !0
                    }
                    removeBucketCrossTileIDs(e, r) {
                        for (const s of r.getCrossTileIDsLists())
                            for (const c of s)
                                delete this.usedCrossTileIDs[e][c]
                    }
                    removeStaleBuckets(e) {
                        let r = !1;
                        for (const s in this.indexes) {
                            const c = this.indexes[s];
                            for (const d in c)
                                e[c[d].bucketInstanceId] || (this.removeBucketCrossTileIDs(s, c[d]),
                                delete c[d],
                                r = !0)
                        }
                        return r
                    }
                }
                class en {
                    constructor() {
                        this.layerIndexes = {},
                        this.crossTileIDs = new zi,
                        this.maxBucketInstanceId = 0,
                        this.bucketsInCurrentPlacement = {}
                    }
                    addLayer(e, r, s) {
                        let c = this.layerIndexes[e.id];
                        c === void 0 && (c = this.layerIndexes[e.id] = new gi);
                        let d = !1;
                        const m = {};
                        c.handleWrapJump(s);
                        for (const v of r) {
                            const b = v.getBucket(e);
                            b && e.id === b.layerIds[0] && (b.bucketInstanceId || (b.bucketInstanceId = ++this.maxBucketInstanceId),
                            c.addBucket(v.tileID, b, this.crossTileIDs) && (d = !0),
                            m[b.bucketInstanceId] = !0)
                        }
                        return c.removeStaleBuckets(m) && (d = !0),
                        d
                    }
                    pruneUnusedLayers(e) {
                        const r = {};
                        e.forEach(s => {
                            r[s] = !0
                        }
                        );
                        for (const s in this.layerIndexes)
                            r[s] || delete this.layerIndexes[s]
                    }
                }
                var Jn = "void main() {fragColor=vec4(1.0);}";
                const Ui = {
                    prelude: Wr(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`),
                    projectionMercator: Wr("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
                    projectionGlobe: Wr("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`),
                    background: Wr(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
                    backgroundPattern: Wr(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
                    circle: Wr(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`),
                    clippingMask: Wr(Jn, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
                    heatmap: Wr(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`),
                    heatmapTexture: Wr(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
                    collisionBox: Wr("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
                    collisionCircle: Wr("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
                    colorRelief: Wr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
                    debug: Wr("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
                    depth: Wr(Jn, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`),
                    fill: Wr(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`),
                    fillOutline: Wr(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
                    fillOutlinePattern: Wr(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
                    fillPattern: Wr(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`),
                    fillExtrusion: Wr(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`),
                    fillExtrusionPattern: Wr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`),
                    hillshadePrepare: Wr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
                    hillshade: Wr(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
                    line: Wr(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
                    lineGradient: Wr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
                    linePattern: Wr(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`),
                    lineSDF: Wr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`),
                    raster: Wr(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`),
                    symbolIcon: Wr(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`),
                    symbolSDF: Wr(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`),
                    symbolTextAndIcon: Wr(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`),
                    terrain: Wr("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
                    terrainDepth: Wr("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
                    terrainCoords: Wr("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
                    projectionErrorMeasurement: Wr("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
                    atmosphere: Wr(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
                    sky: Wr("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
                };
                function Wr(h, e) {
                    const r = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g
                      , s = e.match(/in ([\w]+) ([\w]+)/g)
                      , c = h.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g)
                      , d = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g)
                      , m = d ? d.concat(c) : c
                      , v = {};
                    return {
                        fragmentSource: h = h.replace(r, (b, P, M, D, L) => (v[L] = !0,
                        P === "define" ? `
#ifndef HAS_UNIFORM_u_${L}
in ${M} ${D} ${L};
#else
uniform ${M} ${D} u_${L};
#endif
` : `
#ifdef HAS_UNIFORM_u_${L}
    ${M} ${D} ${L} = u_${L};
#endif
`)),
                        vertexSource: e = e.replace(r, (b, P, M, D, L) => {
                            const B = D === "float" ? "vec2" : "vec4"
                              , Z = L.match(/color/) ? "color" : B;
                            return v[L] ? P === "define" ? `
#ifndef HAS_UNIFORM_u_${L}
uniform lowp float u_${L}_t;
in ${M} ${B} a_${L};
out ${M} ${D} ${L};
#else
uniform ${M} ${D} u_${L};
#endif
` : Z === "vec4" ? `
#ifndef HAS_UNIFORM_u_${L}
    ${L} = a_${L};
#else
    ${M} ${D} ${L} = u_${L};
#endif
` : `
#ifndef HAS_UNIFORM_u_${L}
    ${L} = unpack_mix_${Z}(a_${L}, u_${L}_t);
#else
    ${M} ${D} ${L} = u_${L};
#endif
` : P === "define" ? `
#ifndef HAS_UNIFORM_u_${L}
uniform lowp float u_${L}_t;
in ${M} ${B} a_${L};
#else
uniform ${M} ${D} u_${L};
#endif
` : Z === "vec4" ? `
#ifndef HAS_UNIFORM_u_${L}
    ${M} ${D} ${L} = a_${L};
#else
    ${M} ${D} ${L} = u_${L};
#endif
` : `
#ifndef HAS_UNIFORM_u_${L}
    ${M} ${D} ${L} = unpack_mix_${Z}(a_${L}, u_${L}_t);
#else
    ${M} ${D} ${L} = u_${L};
#endif
`
                        }
                        ),
                        staticAttributes: s,
                        staticUniforms: m
                    }
                }
                class Qn {
                    constructor(e, r, s) {
                        this.vertexBuffer = e,
                        this.indexBuffer = r,
                        this.segments = s
                    }
                    destroy() {
                        this.vertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.segments.destroy(),
                        this.vertexBuffer = null,
                        this.indexBuffer = null,
                        this.segments = null
                    }
                }
                var sa = o.aI([{
                    name: "a_pos",
                    type: "Int16",
                    components: 2
                }]);
                const da = "#define PROJECTION_MERCATOR"
                  , os = "mercator";
                class Ps {
                    constructor() {
                        this._cachedMesh = null
                    }
                    get name() {
                        return "mercator"
                    }
                    get useSubdivision() {
                        return !1
                    }
                    get shaderVariantName() {
                        return os
                    }
                    get shaderDefine() {
                        return da
                    }
                    get shaderPreludeCode() {
                        return Ui.projectionMercator
                    }
                    get vertexShaderPreludeCode() {
                        return Ui.projectionMercator.vertexSource
                    }
                    get subdivisionGranularity() {
                        return o.aJ.noSubdivision
                    }
                    get useGlobeControls() {
                        return !1
                    }
                    get transitionState() {
                        return 0
                    }
                    get latitudeErrorCorrectionRadians() {
                        return 0
                    }
                    destroy() {}
                    updateGPUdependent(e) {}
                    getMeshFromTileID(e, r, s, c, d) {
                        if (this._cachedMesh)
                            return this._cachedMesh;
                        const m = new o.aK;
                        m.emplaceBack(0, 0),
                        m.emplaceBack(o.$, 0),
                        m.emplaceBack(0, o.$),
                        m.emplaceBack(o.$, o.$);
                        const v = e.createVertexBuffer(m, sa.members)
                          , b = o.aL.simpleSegment(0, 0, 4, 2)
                          , P = new o.aM;
                        P.emplaceBack(1, 0, 2),
                        P.emplaceBack(1, 2, 3);
                        const M = e.createIndexBuffer(P);
                        return this._cachedMesh = new Qn(v,M,b),
                        this._cachedMesh
                    }
                    recalculate() {}
                    hasTransition() {
                        return !1
                    }
                    setErrorQueryLatitudeDegrees(e) {}
                }
                class jn {
                    constructor(e=0, r=0, s=0, c=0) {
                        if (isNaN(e) || e < 0 || isNaN(r) || r < 0 || isNaN(s) || s < 0 || isNaN(c) || c < 0)
                            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                        this.top = e,
                        this.bottom = r,
                        this.left = s,
                        this.right = c
                    }
                    interpolate(e, r, s) {
                        return r.top != null && e.top != null && (this.top = o.C.number(e.top, r.top, s)),
                        r.bottom != null && e.bottom != null && (this.bottom = o.C.number(e.bottom, r.bottom, s)),
                        r.left != null && e.left != null && (this.left = o.C.number(e.left, r.left, s)),
                        r.right != null && e.right != null && (this.right = o.C.number(e.right, r.right, s)),
                        this
                    }
                    getCenter(e, r) {
                        const s = o.ag((this.left + e - this.right) / 2, 0, e)
                          , c = o.ag((this.top + r - this.bottom) / 2, 0, r);
                        return new o.P(s,c)
                    }
                    equals(e) {
                        return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right
                    }
                    clone() {
                        return new jn(this.top,this.bottom,this.left,this.right)
                    }
                    toJSON() {
                        return {
                            top: this.top,
                            bottom: this.bottom,
                            left: this.left,
                            right: this.right
                        }
                    }
                }
                function ea(h, e) {
                    if (!h.renderWorldCopies || h.lngRange)
                        return;
                    const r = e.lng - h.center.lng;
                    e.lng += r > 180 ? -360 : r < -180 ? 360 : 0
                }
                function Jr(h) {
                    return Math.max(0, Math.floor(h))
                }
                class Ua {
                    constructor(e, r, s, c, d, m) {
                        this._callbacks = e,
                        this._tileSize = 512,
                        this._renderWorldCopies = m === void 0 || !!m,
                        this._minZoom = r || 0,
                        this._maxZoom = s || 22,
                        this._minPitch = c ?? 0,
                        this._maxPitch = d ?? 60,
                        this.setMaxBounds(),
                        this._width = 0,
                        this._height = 0,
                        this._center = new o.S(0,0),
                        this._elevation = 0,
                        this._zoom = 0,
                        this._tileZoom = Jr(this._zoom),
                        this._scale = o.ae(this._zoom),
                        this._bearingInRadians = 0,
                        this._fovInRadians = .6435011087932844,
                        this._pitchInRadians = 0,
                        this._rollInRadians = 0,
                        this._unmodified = !0,
                        this._edgeInsets = new jn,
                        this._minElevationForCurrentTile = 0,
                        this._autoCalculateNearFarZ = !0
                    }
                    apply(e, r, s) {
                        this._latRange = e.latRange,
                        this._lngRange = e.lngRange,
                        this._width = e.width,
                        this._height = e.height,
                        this._center = e.center,
                        this._elevation = e.elevation,
                        this._minElevationForCurrentTile = e.minElevationForCurrentTile,
                        this._zoom = e.zoom,
                        this._tileZoom = Jr(this._zoom),
                        this._scale = o.ae(this._zoom),
                        this._bearingInRadians = e.bearingInRadians,
                        this._fovInRadians = e.fovInRadians,
                        this._pitchInRadians = e.pitchInRadians,
                        this._rollInRadians = e.rollInRadians,
                        this._unmodified = e.unmodified,
                        this._edgeInsets = new jn(e.padding.top,e.padding.bottom,e.padding.left,e.padding.right),
                        this._minZoom = e.minZoom,
                        this._maxZoom = e.maxZoom,
                        this._minPitch = e.minPitch,
                        this._maxPitch = e.maxPitch,
                        this._renderWorldCopies = e.renderWorldCopies,
                        this._cameraToCenterDistance = e.cameraToCenterDistance,
                        this._nearZ = e.nearZ,
                        this._farZ = e.farZ,
                        this._autoCalculateNearFarZ = !s && e.autoCalculateNearFarZ,
                        r && this._constrain(),
                        this._calcMatrices()
                    }
                    get pixelsToClipSpaceMatrix() {
                        return this._pixelsToClipSpaceMatrix
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._clipSpaceToPixelsMatrix
                    }
                    get minElevationForCurrentTile() {
                        return this._minElevationForCurrentTile
                    }
                    setMinElevationForCurrentTile(e) {
                        this._minElevationForCurrentTile = e
                    }
                    get tileSize() {
                        return this._tileSize
                    }
                    get tileZoom() {
                        return this._tileZoom
                    }
                    get scale() {
                        return this._scale
                    }
                    get width() {
                        return this._width
                    }
                    get height() {
                        return this._height
                    }
                    get bearingInRadians() {
                        return this._bearingInRadians
                    }
                    get lngRange() {
                        return this._lngRange
                    }
                    get latRange() {
                        return this._latRange
                    }
                    get pixelsToGLUnits() {
                        return this._pixelsToGLUnits
                    }
                    get minZoom() {
                        return this._minZoom
                    }
                    setMinZoom(e) {
                        this._minZoom !== e && (this._minZoom = e,
                        this.setZoom(this.getConstrained(this._center, this.zoom).zoom))
                    }
                    get maxZoom() {
                        return this._maxZoom
                    }
                    setMaxZoom(e) {
                        this._maxZoom !== e && (this._maxZoom = e,
                        this.setZoom(this.getConstrained(this._center, this.zoom).zoom))
                    }
                    get minPitch() {
                        return this._minPitch
                    }
                    setMinPitch(e) {
                        this._minPitch !== e && (this._minPitch = e,
                        this.setPitch(Math.max(this.pitch, e)))
                    }
                    get maxPitch() {
                        return this._maxPitch
                    }
                    setMaxPitch(e) {
                        this._maxPitch !== e && (this._maxPitch = e,
                        this.setPitch(Math.min(this.pitch, e)))
                    }
                    get renderWorldCopies() {
                        return this._renderWorldCopies
                    }
                    setRenderWorldCopies(e) {
                        e === void 0 ? e = !0 : e === null && (e = !1),
                        this._renderWorldCopies = e
                    }
                    get worldSize() {
                        return this._tileSize * this._scale
                    }
                    get centerOffset() {
                        return this.centerPoint._sub(this.size._div(2))
                    }
                    get size() {
                        return new o.P(this._width,this._height)
                    }
                    get bearing() {
                        return this._bearingInRadians / Math.PI * 180
                    }
                    setBearing(e) {
                        const r = o.aN(e, -180, 180) * Math.PI / 180;
                        var s, c, d, m, v, b, P, M, D;
                        this._bearingInRadians !== r && (this._unmodified = !1,
                        this._bearingInRadians = r,
                        this._calcMatrices(),
                        this._rotationMatrix = G(),
                        s = this._rotationMatrix,
                        d = -this._bearingInRadians,
                        m = (c = this._rotationMatrix)[0],
                        v = c[1],
                        b = c[2],
                        P = c[3],
                        M = Math.sin(d),
                        D = Math.cos(d),
                        s[0] = m * D + b * M,
                        s[1] = v * D + P * M,
                        s[2] = m * -M + b * D,
                        s[3] = v * -M + P * D)
                    }
                    get rotationMatrix() {
                        return this._rotationMatrix
                    }
                    get pitchInRadians() {
                        return this._pitchInRadians
                    }
                    get pitch() {
                        return this._pitchInRadians / Math.PI * 180
                    }
                    setPitch(e) {
                        const r = o.ag(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
                        this._pitchInRadians !== r && (this._unmodified = !1,
                        this._pitchInRadians = r,
                        this._calcMatrices())
                    }
                    get rollInRadians() {
                        return this._rollInRadians
                    }
                    get roll() {
                        return this._rollInRadians / Math.PI * 180
                    }
                    setRoll(e) {
                        const r = e / 180 * Math.PI;
                        this._rollInRadians !== r && (this._unmodified = !1,
                        this._rollInRadians = r,
                        this._calcMatrices())
                    }
                    get fovInRadians() {
                        return this._fovInRadians
                    }
                    get fov() {
                        return o.aO(this._fovInRadians)
                    }
                    setFov(e) {
                        e = o.ag(e, .1, 150),
                        this.fov !== e && (this._unmodified = !1,
                        this._fovInRadians = o.ad(e),
                        this._calcMatrices())
                    }
                    get zoom() {
                        return this._zoom
                    }
                    setZoom(e) {
                        const r = this.getConstrained(this._center, e).zoom;
                        this._zoom !== r && (this._unmodified = !1,
                        this._zoom = r,
                        this._tileZoom = Math.max(0, Math.floor(r)),
                        this._scale = o.ae(r),
                        this._constrain(),
                        this._calcMatrices())
                    }
                    get center() {
                        return this._center
                    }
                    setCenter(e) {
                        e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1,
                        this._center = e,
                        this._constrain(),
                        this._calcMatrices())
                    }
                    get elevation() {
                        return this._elevation
                    }
                    setElevation(e) {
                        e !== this._elevation && (this._elevation = e,
                        this._constrain(),
                        this._calcMatrices())
                    }
                    get padding() {
                        return this._edgeInsets.toJSON()
                    }
                    setPadding(e) {
                        this._edgeInsets.equals(e) || (this._unmodified = !1,
                        this._edgeInsets.interpolate(this._edgeInsets, e, 1),
                        this._calcMatrices())
                    }
                    get centerPoint() {
                        return this._edgeInsets.getCenter(this._width, this._height)
                    }
                    get pixelsPerMeter() {
                        return this._pixelPerMeter
                    }
                    get unmodified() {
                        return this._unmodified
                    }
                    get cameraToCenterDistance() {
                        return this._cameraToCenterDistance
                    }
                    get nearZ() {
                        return this._nearZ
                    }
                    get farZ() {
                        return this._farZ
                    }
                    get autoCalculateNearFarZ() {
                        return this._autoCalculateNearFarZ
                    }
                    overrideNearFarZ(e, r) {
                        this._autoCalculateNearFarZ = !1,
                        this._nearZ = e,
                        this._farZ = r,
                        this._calcMatrices()
                    }
                    clearNearFarZOverride() {
                        this._autoCalculateNearFarZ = !0,
                        this._calcMatrices()
                    }
                    isPaddingEqual(e) {
                        return this._edgeInsets.equals(e)
                    }
                    interpolatePadding(e, r, s) {
                        this._unmodified = !1,
                        this._edgeInsets.interpolate(e, r, s),
                        this._constrain(),
                        this._calcMatrices()
                    }
                    resize(e, r, s=!0) {
                        this._width = e,
                        this._height = r,
                        s && this._constrain(),
                        this._calcMatrices()
                    }
                    getMaxBounds() {
                        return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new Lt([this._lngRange[0], this._latRange[0]],[this._lngRange[1], this._latRange[1]]) : null
                    }
                    setMaxBounds(e) {
                        e ? (this._lngRange = [e.getWest(), e.getEast()],
                        this._latRange = [e.getSouth(), e.getNorth()],
                        this._constrain()) : (this._lngRange = null,
                        this._latRange = [-o.ah, o.ah])
                    }
                    getConstrained(e, r) {
                        return this._callbacks.getConstrained(e, r)
                    }
                    getCameraQueryGeometry(e, r) {
                        if (r.length === 1)
                            return [r[0], e];
                        {
                            const {minX: s, minY: c, maxX: d, maxY: m} = o.a1.fromPoints(r).extend(e);
                            return [new o.P(s,c), new o.P(d,c), new o.P(d,m), new o.P(s,m), new o.P(s,c)]
                        }
                    }
                    _constrain() {
                        if (!this.center || !this._width || !this._height || this._constraining)
                            return;
                        this._constraining = !0;
                        const e = this._unmodified
                          , {center: r, zoom: s} = this.getConstrained(this.center, this.zoom);
                        this.setCenter(r),
                        this.setZoom(s),
                        this._unmodified = e,
                        this._constraining = !1
                    }
                    _calcMatrices() {
                        if (this._width && this._height) {
                            this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
                            let e = o.af(new Float64Array(16));
                            o.N(e, e, [this._width / 2, -this._height / 2, 1]),
                            o.M(e, e, [1, -1, 0]),
                            this._clipSpaceToPixelsMatrix = e,
                            e = o.af(new Float64Array(16)),
                            o.N(e, e, [1, -1, 1]),
                            o.M(e, e, [-1, -1, 0]),
                            o.N(e, e, [2 / this._width, 2 / this._height, 1]),
                            this._pixelsToClipSpaceMatrix = e,
                            this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height
                        }
                        this._callbacks.calcMatrices()
                    }
                    calculateCenterFromCameraLngLatAlt(e, r, s, c) {
                        const d = s !== void 0 ? s : this.bearing
                          , m = c = c !== void 0 ? c : this.pitch
                          , v = o.a0.fromLngLat(e, r)
                          , b = -Math.cos(o.ad(m))
                          , P = Math.sin(o.ad(m))
                          , M = P * Math.sin(o.ad(d))
                          , D = -P * Math.cos(o.ad(d));
                        let L = this.elevation;
                        const B = r - L;
                        let Z;
                        b * B >= 0 || Math.abs(b) < .1 ? (Z = 1e4,
                        L = r + Z * b) : Z = -B / b;
                        let te, ee, ne = o.aP(1, v.y), oe = 0;
                        do {
                            if (oe += 1,
                            oe > 10)
                                break;
                            ee = Z / ne,
                            te = new o.a0(v.x + M * ee,v.y + D * ee),
                            ne = 1 / te.meterInMercatorCoordinateUnits()
                        } while (Math.abs(Z - ee * ne) > 1e-12);
                        return {
                            center: te.toLngLat(),
                            elevation: L,
                            zoom: o.aj(this.height / 2 / Math.tan(this.fovInRadians / 2) / ee / this.tileSize)
                        }
                    }
                    recalculateZoomAndCenter(e) {
                        if (this.elevation - e == 0)
                            return;
                        const r = o.ai(1, this.center.lat) * this.worldSize
                          , s = this.cameraToCenterDistance / r
                          , c = o.a0.fromLngLat(this.center, this.elevation)
                          , d = ae(this.center, this.elevation, this.pitch, this.bearing, s);
                        this._elevation = e;
                        const m = this.calculateCenterFromCameraLngLatAlt(d.toLngLat(), o.aP(d.z, c.y), this.bearing, this.pitch);
                        this._elevation = m.elevation,
                        this._center = m.center,
                        this.setZoom(m.zoom)
                    }
                    getCameraPoint() {
                        const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
                        return this.centerPoint.add(new o.P(e * Math.sin(this.rollInRadians),e * Math.cos(this.rollInRadians)))
                    }
                    getCameraAltitude() {
                        return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation
                    }
                    getCameraLngLat() {
                        const e = o.ai(1, this.center.lat) * this.worldSize;
                        return ae(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat()
                    }
                    getMercatorTileCoordinates(e) {
                        if (!e)
                            return [0, 0, 1, 1];
                        const r = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
                        return [e.canonical.x / r, e.canonical.y / r, 1 / r / o.$, 1 / r / o.$]
                    }
                }
                class Da {
                    constructor(e, r) {
                        this.min = e,
                        this.max = r,
                        this.center = o.aQ([], o.aR([], this.min, this.max), .5)
                    }
                    quadrant(e) {
                        const r = [e % 2 == 0, e < 2]
                          , s = o.aS(this.min)
                          , c = o.aS(this.max);
                        for (let d = 0; d < r.length; d++)
                            s[d] = r[d] ? this.min[d] : this.center[d],
                            c[d] = r[d] ? this.center[d] : this.max[d];
                        return c[2] = this.max[2],
                        new Da(s,c)
                    }
                    distanceX(e) {
                        return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
                    }
                    distanceY(e) {
                        return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
                    }
                    intersectsFrustum(e) {
                        let r = !0;
                        for (let s = 0; s < e.planes.length; s++) {
                            const c = this.intersectsPlane(e.planes[s]);
                            if (c === 0)
                                return 0;
                            c === 1 && (r = !1)
                        }
                        return r ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1
                    }
                    intersectsPlane(e) {
                        let r = e[3]
                          , s = e[3];
                        for (let c = 0; c < 3; c++)
                            e[c] > 0 ? (r += e[c] * this.min[c],
                            s += e[c] * this.max[c]) : (s += e[c] * this.min[c],
                            r += e[c] * this.max[c]);
                        return r >= 0 ? 2 : s < 0 ? 0 : 1
                    }
                }
                class co {
                    distanceToTile2d(e, r, s, c) {
                        const d = c.distanceX([e, r])
                          , m = c.distanceY([e, r]);
                        return Math.hypot(d, m)
                    }
                    getWrap(e, r, s) {
                        return s
                    }
                    getTileBoundingVolume(e, r, s, c) {
                        var d, m;
                        let v = s
                          , b = s;
                        if (c != null && c.terrain) {
                            const M = new o.Z(e.z,r,e.z,e.x,e.y)
                              , D = c.terrain.getMinMaxElevation(M);
                            v = (d = D.minElevation) !== null && d !== void 0 ? d : s,
                            b = (m = D.maxElevation) !== null && m !== void 0 ? m : s
                        }
                        const P = 1 << e.z;
                        return new Da([r + e.x / P, e.y / P, v],[r + (e.x + 1) / P, (e.y + 1) / P, b])
                    }
                    allowVariableZoom(e, r) {
                        const s = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height
                          , c = o.ag(78.5 - s / 2, 0, 60);
                        return !!r.terrain || e.pitch > c
                    }
                    allowWorldCopies() {
                        return !0
                    }
                    prepareNextFrame() {}
                }
                class Gi {
                    constructor(e, r, s) {
                        this.points = e,
                        this.planes = r,
                        this.aabb = s
                    }
                    static fromInvProjectionMatrix(e, r=1, s=0, c, d) {
                        const m = d ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]]
                          , v = Math.pow(2, s)
                          , b = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(L => function(B, Z, te, ee) {
                            const ne = o.av([], B, Z)
                              , oe = 1 / ne[3] / te * ee;
                            return o.aX(ne, ne, [oe, oe, 1 / ne[3], oe])
                        }(L, e, r, v));
                        c && function(L, B, Z, te) {
                            const ee = te ? 4 : 0
                              , ne = te ? 0 : 4;
                            let oe = 0;
                            const me = []
                              , ce = [];
                            for (let pe = 0; pe < 4; pe++) {
                                const Fe = o.aT([], L[pe + ne], L[pe + ee])
                                  , Ye = o.aY(Fe);
                                o.aQ(Fe, Fe, 1 / Ye),
                                me.push(Ye),
                                ce.push(Fe)
                            }
                            for (let pe = 0; pe < 4; pe++) {
                                const Fe = o.aZ(L[pe + ee], ce[pe], Z);
                                oe = Fe !== null && Fe >= 0 ? Math.max(oe, Fe) : Math.max(oe, me[pe])
                            }
                            const Te = function(pe, Fe) {
                                const Ye = o.aT([], pe[Fe[0]], pe[Fe[1]])
                                  , $e = o.aT([], pe[Fe[2]], pe[Fe[1]])
                                  , He = [0, 0, 0, 0];
                                return o.aU(He, o.aV([], Ye, $e)),
                                He[3] = -o.aW(He, pe[Fe[0]]),
                                He
                            }(L, B)
                              , Pe = function(pe, Fe) {
                                const Ye = o.a_(pe)
                                  , $e = o.a$([], pe, 1 / Ye)
                                  , He = o.aT([], Fe, o.aQ([], $e, o.aW(Fe, $e)))
                                  , Je = o.a_(He);
                                if (Je > 0) {
                                    const qt = Math.sqrt(1 - $e[3] * $e[3])
                                      , Nt = o.aQ([], $e, -$e[3])
                                      , wt = o.aR([], Nt, o.aQ([], He, qt / Je));
                                    return o.b0(Fe, wt)
                                }
                                return null
                            }(Z, Te);
                            if (Pe !== null) {
                                const pe = Pe / o.aW(ce[0], Te);
                                oe = Math.min(oe, pe)
                            }
                            for (let pe = 0; pe < 4; pe++) {
                                const Fe = Math.min(oe, me[pe]);
                                L[pe + ne] = [L[pe + ee][0] + ce[pe][0] * Fe, L[pe + ee][1] + ce[pe][1] * Fe, L[pe + ee][2] + ce[pe][2] * Fe, 1]
                            }
                        }(b, m[0], c, d);
                        const P = m.map(L => {
                            const B = o.aT([], b[L[0]], b[L[1]])
                              , Z = o.aT([], b[L[2]], b[L[1]])
                              , te = o.aU([], o.aV([], B, Z))
                              , ee = -o.aW(te, b[L[1]]);
                            return te.concat(ee)
                        }
                        )
                          , M = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
                          , D = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
                        for (const L of b)
                            for (let B = 0; B < 3; B++)
                                M[B] = Math.min(M[B], L[B]),
                                D[B] = Math.max(D[B], L[B]);
                        return new Gi(b,P,new Da(M,D))
                    }
                }
                class Li {
                    get pixelsToClipSpaceMatrix() {
                        return this._helper.pixelsToClipSpaceMatrix
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._helper.clipSpaceToPixelsMatrix
                    }
                    get pixelsToGLUnits() {
                        return this._helper.pixelsToGLUnits
                    }
                    get centerOffset() {
                        return this._helper.centerOffset
                    }
                    get size() {
                        return this._helper.size
                    }
                    get rotationMatrix() {
                        return this._helper.rotationMatrix
                    }
                    get centerPoint() {
                        return this._helper.centerPoint
                    }
                    get pixelsPerMeter() {
                        return this._helper.pixelsPerMeter
                    }
                    setMinZoom(e) {
                        this._helper.setMinZoom(e)
                    }
                    setMaxZoom(e) {
                        this._helper.setMaxZoom(e)
                    }
                    setMinPitch(e) {
                        this._helper.setMinPitch(e)
                    }
                    setMaxPitch(e) {
                        this._helper.setMaxPitch(e)
                    }
                    setRenderWorldCopies(e) {
                        this._helper.setRenderWorldCopies(e)
                    }
                    setBearing(e) {
                        this._helper.setBearing(e)
                    }
                    setPitch(e) {
                        this._helper.setPitch(e)
                    }
                    setRoll(e) {
                        this._helper.setRoll(e)
                    }
                    setFov(e) {
                        this._helper.setFov(e)
                    }
                    setZoom(e) {
                        this._helper.setZoom(e)
                    }
                    setCenter(e) {
                        this._helper.setCenter(e)
                    }
                    setElevation(e) {
                        this._helper.setElevation(e)
                    }
                    setMinElevationForCurrentTile(e) {
                        this._helper.setMinElevationForCurrentTile(e)
                    }
                    setPadding(e) {
                        this._helper.setPadding(e)
                    }
                    interpolatePadding(e, r, s) {
                        return this._helper.interpolatePadding(e, r, s)
                    }
                    isPaddingEqual(e) {
                        return this._helper.isPaddingEqual(e)
                    }
                    resize(e, r, s=!0) {
                        this._helper.resize(e, r, s)
                    }
                    getMaxBounds() {
                        return this._helper.getMaxBounds()
                    }
                    setMaxBounds(e) {
                        this._helper.setMaxBounds(e)
                    }
                    overrideNearFarZ(e, r) {
                        this._helper.overrideNearFarZ(e, r)
                    }
                    clearNearFarZOverride() {
                        this._helper.clearNearFarZOverride()
                    }
                    getCameraQueryGeometry(e) {
                        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
                    }
                    get tileSize() {
                        return this._helper.tileSize
                    }
                    get tileZoom() {
                        return this._helper.tileZoom
                    }
                    get scale() {
                        return this._helper.scale
                    }
                    get worldSize() {
                        return this._helper.worldSize
                    }
                    get width() {
                        return this._helper.width
                    }
                    get height() {
                        return this._helper.height
                    }
                    get lngRange() {
                        return this._helper.lngRange
                    }
                    get latRange() {
                        return this._helper.latRange
                    }
                    get minZoom() {
                        return this._helper.minZoom
                    }
                    get maxZoom() {
                        return this._helper.maxZoom
                    }
                    get zoom() {
                        return this._helper.zoom
                    }
                    get center() {
                        return this._helper.center
                    }
                    get minPitch() {
                        return this._helper.minPitch
                    }
                    get maxPitch() {
                        return this._helper.maxPitch
                    }
                    get pitch() {
                        return this._helper.pitch
                    }
                    get pitchInRadians() {
                        return this._helper.pitchInRadians
                    }
                    get roll() {
                        return this._helper.roll
                    }
                    get rollInRadians() {
                        return this._helper.rollInRadians
                    }
                    get bearing() {
                        return this._helper.bearing
                    }
                    get bearingInRadians() {
                        return this._helper.bearingInRadians
                    }
                    get fov() {
                        return this._helper.fov
                    }
                    get fovInRadians() {
                        return this._helper.fovInRadians
                    }
                    get elevation() {
                        return this._helper.elevation
                    }
                    get minElevationForCurrentTile() {
                        return this._helper.minElevationForCurrentTile
                    }
                    get padding() {
                        return this._helper.padding
                    }
                    get unmodified() {
                        return this._helper.unmodified
                    }
                    get renderWorldCopies() {
                        return this._helper.renderWorldCopies
                    }
                    get cameraToCenterDistance() {
                        return this._helper.cameraToCenterDistance
                    }
                    get nearZ() {
                        return this._helper.nearZ
                    }
                    get farZ() {
                        return this._helper.farZ
                    }
                    get autoCalculateNearFarZ() {
                        return this._helper.autoCalculateNearFarZ
                    }
                    setTransitionState(e, r) {}
                    constructor(e, r, s, c, d) {
                        this._posMatrixCache = new Map,
                        this._alignedPosMatrixCache = new Map,
                        this._fogMatrixCacheF32 = new Map,
                        this._helper = new Ua({
                            calcMatrices: () => {
                                this._calcMatrices()
                            }
                            ,
                            getConstrained: (m, v) => this.getConstrained(m, v)
                        },e,r,s,c,d),
                        this._coveringTilesDetailsProvider = new co
                    }
                    clone() {
                        const e = new Li;
                        return e.apply(this),
                        e
                    }
                    apply(e, r, s) {
                        this._helper.apply(e, r, s)
                    }
                    get cameraPosition() {
                        return this._cameraPosition
                    }
                    get projectionMatrix() {
                        return this._projectionMatrix
                    }
                    get modelViewProjectionMatrix() {
                        return this._viewProjMatrix
                    }
                    get inverseProjectionMatrix() {
                        return this._invProjMatrix
                    }
                    get mercatorMatrix() {
                        return this._mercatorMatrix
                    }
                    getVisibleUnwrappedCoordinates(e) {
                        const r = [new o.b1(0,e)];
                        if (this._helper._renderWorldCopies) {
                            const s = this.screenPointToMercatorCoordinate(new o.P(0,0))
                              , c = this.screenPointToMercatorCoordinate(new o.P(this._helper._width,0))
                              , d = this.screenPointToMercatorCoordinate(new o.P(this._helper._width,this._helper._height))
                              , m = this.screenPointToMercatorCoordinate(new o.P(0,this._helper._height))
                              , v = Math.floor(Math.min(s.x, c.x, d.x, m.x))
                              , b = Math.floor(Math.max(s.x, c.x, d.x, m.x))
                              , P = 1;
                            for (let M = v - P; M <= b + P; M++)
                                M !== 0 && r.push(new o.b1(M,e))
                        }
                        return r
                    }
                    getCameraFrustum() {
                        return Gi.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize)
                    }
                    getClippingPlane() {
                        return null
                    }
                    getCoveringTilesDetailsProvider() {
                        return this._coveringTilesDetailsProvider
                    }
                    recalculateZoomAndCenter(e) {
                        const r = this.screenPointToLocation(this.centerPoint, e)
                          , s = e ? e.getElevationForLngLatZoom(r, this._helper._tileZoom) : 0;
                        this._helper.recalculateZoomAndCenter(s)
                    }
                    setLocationAtPoint(e, r) {
                        const s = o.ai(this.elevation, this.center.lat)
                          , c = this.screenPointToMercatorCoordinateAtZ(r, s)
                          , d = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, s)
                          , m = o.a0.fromLngLat(e)
                          , v = new o.a0(m.x - (c.x - d.x),m.y - (c.y - d.y));
                        this.setCenter(v == null ? void 0 : v.toLngLat()),
                        this._helper._renderWorldCopies && this.setCenter(this.center.wrap())
                    }
                    locationToScreenPoint(e, r) {
                        return r ? this.coordinatePoint(o.a0.fromLngLat(e), r.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(o.a0.fromLngLat(e))
                    }
                    screenPointToLocation(e, r) {
                        var s;
                        return (s = this.screenPointToMercatorCoordinate(e, r)) === null || s === void 0 ? void 0 : s.toLngLat()
                    }
                    screenPointToMercatorCoordinate(e, r) {
                        if (r) {
                            const s = r.pointCoordinate(e);
                            if (s != null)
                                return s
                        }
                        return this.screenPointToMercatorCoordinateAtZ(e)
                    }
                    screenPointToMercatorCoordinateAtZ(e, r) {
                        const s = r || 0
                          , c = [e.x, e.y, 0, 1]
                          , d = [e.x, e.y, 1, 1];
                        o.av(c, c, this._pixelMatrixInverse),
                        o.av(d, d, this._pixelMatrixInverse);
                        const m = c[3]
                          , v = d[3]
                          , b = c[1] / m
                          , P = d[1] / v
                          , M = c[2] / m
                          , D = d[2] / v
                          , L = M === D ? 0 : (s - M) / (D - M);
                        return new o.a0(o.C.number(c[0] / m, d[0] / v, L) / this.worldSize,o.C.number(b, P, L) / this.worldSize,s)
                    }
                    coordinatePoint(e, r=0, s=this._pixelMatrix) {
                        const c = [e.x * this.worldSize, e.y * this.worldSize, r, 1];
                        return o.av(c, c, s),
                        new o.P(c[0] / c[3],c[1] / c[3])
                    }
                    getBounds() {
                        const e = Math.max(0, this._helper._height / 2 - V(this));
                        return new Lt().extend(this.screenPointToLocation(new o.P(0,e))).extend(this.screenPointToLocation(new o.P(this._helper._width,e))).extend(this.screenPointToLocation(new o.P(this._helper._width,this._helper._height))).extend(this.screenPointToLocation(new o.P(0,this._helper._height)))
                    }
                    isPointOnMapSurface(e, r) {
                        return r ? r.pointCoordinate(e) != null : e.y > this.height / 2 - V(this)
                    }
                    calculatePosMatrix(e, r=!1, s) {
                        var c;
                        const d = (c = e.key) !== null && c !== void 0 ? c : o.b2(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y)
                          , m = r ? this._alignedPosMatrixCache : this._posMatrixCache;
                        if (m.has(d)) {
                            const P = m.get(d);
                            return s ? P.f32 : P.f64
                        }
                        const v = K(e, this.worldSize);
                        o.O(v, r ? this._alignedProjMatrix : this._viewProjMatrix, v);
                        const b = {
                            f64: v,
                            f32: new Float32Array(v)
                        };
                        return m.set(d, b),
                        s ? b.f32 : b.f64
                    }
                    calculateFogMatrix(e) {
                        const r = e.key
                          , s = this._fogMatrixCacheF32;
                        if (s.has(r))
                            return s.get(r);
                        const c = K(e, this.worldSize);
                        return o.O(c, this._fogMatrix, c),
                        s.set(r, new Float32Array(c)),
                        s.get(r)
                    }
                    getConstrained(e, r) {
                        r = o.ag(+r, this.minZoom, this.maxZoom);
                        const s = {
                            center: new o.S(e.lng,e.lat),
                            zoom: r
                        };
                        let c = this._helper._lngRange;
                        if (!this._helper._renderWorldCopies && c === null) {
                            const me = 179.9999999999;
                            c = [-me, me]
                        }
                        const d = this.tileSize * o.ae(s.zoom);
                        let m = 0
                          , v = d
                          , b = 0
                          , P = d
                          , M = 0
                          , D = 0;
                        const {x: L, y: B} = this.size;
                        if (this._helper._latRange) {
                            const me = this._helper._latRange;
                            m = o.U(me[1]) * d,
                            v = o.U(me[0]) * d,
                            v - m < B && (M = B / (v - m))
                        }
                        c && (b = o.aN(o.V(c[0]) * d, 0, d),
                        P = o.aN(o.V(c[1]) * d, 0, d),
                        P < b && (P += d),
                        P - b < L && (D = L / (P - b)));
                        const {x: Z, y: te} = be(d, e);
                        let ee, ne;
                        const oe = Math.max(D || 0, M || 0);
                        if (oe) {
                            const me = new o.P(D ? (P + b) / 2 : Z,M ? (v + m) / 2 : te);
                            return s.center = q(d, me).wrap(),
                            s.zoom += o.aj(oe),
                            s
                        }
                        if (this._helper._latRange) {
                            const me = B / 2;
                            te - me < m && (ne = m + me),
                            te + me > v && (ne = v - me)
                        }
                        if (c) {
                            const me = (b + P) / 2;
                            let ce = Z;
                            this._helper._renderWorldCopies && (ce = o.aN(Z, me - d / 2, me + d / 2));
                            const Te = L / 2;
                            ce - Te < b && (ee = b + Te),
                            ce + Te > P && (ee = P - Te)
                        }
                        if (ee !== void 0 || ne !== void 0) {
                            const me = new o.P(ee ?? Z,ne ?? te);
                            s.center = q(d, me).wrap()
                        }
                        return s
                    }
                    calculateCenterFromCameraLngLatAlt(e, r, s, c) {
                        return this._helper.calculateCenterFromCameraLngLatAlt(e, r, s, c)
                    }
                    _calculateNearFarZIfNeeded(e, r, s) {
                        if (!this._helper.autoCalculateNearFarZ)
                            return;
                        const c = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100)
                          , d = e - c * this._helper._pixelPerMeter / Math.cos(r)
                          , m = c < 0 ? d : e
                          , v = Math.PI / 2 + this.pitchInRadians
                          , b = o.ad(this.fov) * (Math.abs(Math.cos(o.ad(this.roll))) * this.height + Math.abs(Math.sin(o.ad(this.roll))) * this.width) / this.height * (.5 + s.y / this.height)
                          , P = Math.sin(b) * m / Math.sin(o.ag(Math.PI - v - b, .01, Math.PI - .01))
                          , M = V(this)
                          , D = Math.atan(M / this._helper.cameraToCenterDistance)
                          , L = o.ad(.75)
                          , B = D > L ? 2 * D * (.5 + s.y / (2 * M)) : L
                          , Z = Math.sin(B) * m / Math.sin(o.ag(Math.PI - v - B, .01, Math.PI - .01))
                          , te = Math.min(P, Z);
                        this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - r) * te + m),
                        this._helper._nearZ = this._helper._height / 50
                    }
                    _calcMatrices() {
                        if (!this._helper._height)
                            return;
                        const e = this.centerOffset
                          , r = be(this.worldSize, this.center)
                          , s = r.x
                          , c = r.y;
                        this._helper._pixelPerMeter = o.ai(1, this.center.lat) * this.worldSize;
                        const d = o.ad(Math.min(this.pitch, Tr))
                          , m = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(d));
                        let v;
                        this._calculateNearFarZIfNeeded(m, d, e),
                        v = new Float64Array(16),
                        o.b3(v, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ),
                        this._invProjMatrix = new Float64Array(16),
                        o.ap(this._invProjMatrix, v),
                        v[8] = 2 * -e.x / this._helper._width,
                        v[9] = 2 * e.y / this._helper._height,
                        this._projectionMatrix = o.b4(v),
                        o.N(v, v, [1, -1, 1]),
                        o.M(v, v, [0, 0, -this._helper.cameraToCenterDistance]),
                        o.b5(v, v, -this.rollInRadians),
                        o.b6(v, v, this.pitchInRadians),
                        o.b5(v, v, -this.bearingInRadians),
                        o.M(v, v, [-s, -c, 0]),
                        this._mercatorMatrix = o.N([], v, [this.worldSize, this.worldSize, this.worldSize]),
                        o.N(v, v, [1, 1, this._helper._pixelPerMeter]),
                        this._pixelMatrix = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, v),
                        o.M(v, v, [0, 0, -this.elevation]),
                        this._viewProjMatrix = v,
                        this._invViewProjMatrix = o.ap([], v);
                        const b = [0, 0, -1, 1];
                        o.av(b, b, this._invViewProjMatrix),
                        this._cameraPosition = [b[0] / b[3], b[1] / b[3], b[2] / b[3]],
                        this._fogMatrix = new Float64Array(16),
                        o.b3(this._fogMatrix, this.fovInRadians, this.width / this.height, m, this._helper._farZ),
                        this._fogMatrix[8] = 2 * -e.x / this.width,
                        this._fogMatrix[9] = 2 * e.y / this.height,
                        o.N(this._fogMatrix, this._fogMatrix, [1, -1, 1]),
                        o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]),
                        o.b5(this._fogMatrix, this._fogMatrix, -this.rollInRadians),
                        o.b6(this._fogMatrix, this._fogMatrix, this.pitchInRadians),
                        o.b5(this._fogMatrix, this._fogMatrix, -this.bearingInRadians),
                        o.M(this._fogMatrix, this._fogMatrix, [-s, -c, 0]),
                        o.N(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]),
                        o.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]),
                        this._pixelMatrix3D = o.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, v);
                        const P = this._helper._width % 2 / 2
                          , M = this._helper._height % 2 / 2
                          , D = Math.cos(this.bearingInRadians)
                          , L = Math.sin(-this.bearingInRadians)
                          , B = s - Math.round(s) + D * P + L * M
                          , Z = c - Math.round(c) + D * M + L * P
                          , te = new Float64Array(v);
                        if (o.M(te, te, [B > .5 ? B - 1 : B, Z > .5 ? Z - 1 : Z, 0]),
                        this._alignedProjMatrix = te,
                        v = o.ap(new Float64Array(16), this._pixelMatrix),
                        !v)
                            throw new Error("failed to invert matrix");
                        this._pixelMatrixInverse = v,
                        this._clearMatrixCaches()
                    }
                    _clearMatrixCaches() {
                        this._posMatrixCache.clear(),
                        this._alignedPosMatrixCache.clear(),
                        this._fogMatrixCacheF32.clear()
                    }
                    maxPitchScaleFactor() {
                        if (!this._pixelMatrixInverse)
                            return 1;
                        const e = this.screenPointToMercatorCoordinate(new o.P(0,0))
                          , r = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
                        return o.av(r, r, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance
                    }
                    getCameraPoint() {
                        return this._helper.getCameraPoint()
                    }
                    getCameraAltitude() {
                        return this._helper.getCameraAltitude()
                    }
                    getCameraLngLat() {
                        const e = o.ai(1, this.center.lat) * this.worldSize;
                        return ae(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat()
                    }
                    lngLatToCameraDepth(e, r) {
                        const s = o.a0.fromLngLat(e)
                          , c = [s.x * this.worldSize, s.y * this.worldSize, r, 1];
                        return o.av(c, c, this._viewProjMatrix),
                        c[2] / c[3]
                    }
                    getProjectionData(e) {
                        const {overscaledTileID: r, aligned: s, applyTerrainMatrix: c} = e
                          , d = this._helper.getMercatorTileCoordinates(r)
                          , m = r ? this.calculatePosMatrix(r, s, !0) : null;
                        let v;
                        return v = r && r.terrainRttPosMatrix32f && c ? r.terrainRttPosMatrix32f : m || o.b7(),
                        {
                            mainMatrix: v,
                            tileMercatorCoords: d,
                            clippingPlane: [0, 0, 0, 0],
                            projectionTransition: 0,
                            fallbackMatrix: v
                        }
                    }
                    isLocationOccluded(e) {
                        return !1
                    }
                    getPixelScale() {
                        return 1
                    }
                    getCircleRadiusCorrection() {
                        return 1
                    }
                    getPitchedTextCorrection(e, r, s) {
                        return 1
                    }
                    transformLightDirection(e) {
                        return o.aS(e)
                    }
                    getRayDirectionFromPixel(e) {
                        throw new Error("Not implemented.")
                    }
                    projectTileCoordinates(e, r, s, c) {
                        const d = this.calculatePosMatrix(s);
                        let m;
                        c ? (m = [e, r, c(e, r), 1],
                        o.av(m, m, d)) : (m = [e, r, 0, 1],
                        On(m, m, d));
                        const v = m[3];
                        return {
                            point: new o.P(m[0] / v,m[1] / v),
                            signedDistanceFromCamera: v,
                            isOccluded: !1
                        }
                    }
                    populateCache(e) {
                        for (const r of e)
                            this.calculatePosMatrix(r)
                    }
                    getMatrixForModel(e, r) {
                        const s = o.a0.fromLngLat(e, r)
                          , c = s.meterInMercatorCoordinateUnits()
                          , d = o.b8();
                        return o.M(d, d, [s.x, s.y, s.z]),
                        o.b5(d, d, Math.PI),
                        o.b6(d, d, Math.PI / 2),
                        o.N(d, d, [-c, c, c]),
                        d
                    }
                    getProjectionDataForCustomLayer(e=!0) {
                        const r = new o.Z(0,0,0,0,0)
                          , s = this.getProjectionData({
                            overscaledTileID: r,
                            applyGlobeMatrix: e
                        })
                          , c = K(r, this.worldSize);
                        o.O(c, this._viewProjMatrix, c),
                        s.tileMercatorCoords = [0, 0, 1, 1];
                        const d = [o.$, o.$, this.worldSize / this._helper.pixelsPerMeter]
                          , m = o.b9();
                        return o.N(m, c, d),
                        s.fallbackMatrix = m,
                        s.mainMatrix = m,
                        s
                    }
                    getFastPathSimpleProjectionMatrix(e) {
                        return this.calculatePosMatrix(e)
                    }
                }
                function sn() {
                    o.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.")
                }
                function on(h) {
                    if (h.useSlerp)
                        if (h.k < 1) {
                            const e = o.ba(h.startEulerAngles.roll, h.startEulerAngles.pitch, h.startEulerAngles.bearing)
                              , r = o.ba(h.endEulerAngles.roll, h.endEulerAngles.pitch, h.endEulerAngles.bearing)
                              , s = new Float64Array(4);
                            o.bb(s, e, r, h.k);
                            const c = o.bc(s);
                            h.tr.setRoll(c.roll),
                            h.tr.setPitch(c.pitch),
                            h.tr.setBearing(c.bearing)
                        } else
                            h.tr.setRoll(h.endEulerAngles.roll),
                            h.tr.setPitch(h.endEulerAngles.pitch),
                            h.tr.setBearing(h.endEulerAngles.bearing);
                    else
                        h.tr.setRoll(o.C.number(h.startEulerAngles.roll, h.endEulerAngles.roll, h.k)),
                        h.tr.setPitch(o.C.number(h.startEulerAngles.pitch, h.endEulerAngles.pitch, h.k)),
                        h.tr.setBearing(o.C.number(h.startEulerAngles.bearing, h.endEulerAngles.bearing, h.k))
                }
                function Di(h, e, r, s, c) {
                    const d = c.padding
                      , m = be(c.worldSize, r.getNorthWest())
                      , v = be(c.worldSize, r.getNorthEast())
                      , b = be(c.worldSize, r.getSouthEast())
                      , P = be(c.worldSize, r.getSouthWest())
                      , M = o.ad(-s)
                      , D = m.rotate(M)
                      , L = v.rotate(M)
                      , B = b.rotate(M)
                      , Z = P.rotate(M)
                      , te = new o.P(Math.max(D.x, L.x, Z.x, B.x),Math.max(D.y, L.y, Z.y, B.y))
                      , ee = new o.P(Math.min(D.x, L.x, Z.x, B.x),Math.min(D.y, L.y, Z.y, B.y))
                      , ne = te.sub(ee)
                      , oe = (c.width - (d.left + d.right + e.left + e.right)) / ne.x
                      , me = (c.height - (d.top + d.bottom + e.top + e.bottom)) / ne.y;
                    if (me < 0 || oe < 0)
                        return void sn();
                    const ce = Math.min(o.aj(c.scale * Math.min(oe, me)), h.maxZoom)
                      , Te = o.P.convert(h.offset)
                      , Pe = new o.P((e.left - e.right) / 2,(e.top - e.bottom) / 2).rotate(o.ad(s))
                      , pe = Te.add(Pe).mult(c.scale / o.ae(ce));
                    return {
                        center: q(c.worldSize, m.add(b).div(2).sub(pe)),
                        zoom: ce,
                        bearing: s
                    }
                }
                class tl {
                    get useGlobeControls() {
                        return !1
                    }
                    handlePanInertia(e, r) {
                        return {
                            easingOffset: e,
                            easingCenter: r.center
                        }
                    }
                    handleMapControlsRollPitchBearingZoom(e, r) {
                        e.bearingDelta && r.setBearing(r.bearing + e.bearingDelta),
                        e.pitchDelta && r.setPitch(r.pitch + e.pitchDelta),
                        e.rollDelta && r.setRoll(r.roll + e.rollDelta),
                        e.zoomDelta && r.setZoom(r.zoom + e.zoomDelta)
                    }
                    handleMapControlsPan(e, r, s) {
                        e.around.distSqr(r.centerPoint) < .01 || r.setLocationAtPoint(s, e.around)
                    }
                    cameraForBoxAndBearing(e, r, s, c, d) {
                        return Di(e, r, s, c, d)
                    }
                    handleJumpToCenterZoom(e, r) {
                        e.zoom !== (r.zoom !== void 0 ? +r.zoom : e.zoom) && e.setZoom(+r.zoom),
                        r.center !== void 0 && e.setCenter(o.S.convert(r.center))
                    }
                    handleEaseTo(e, r) {
                        const s = e.zoom
                          , c = e.padding
                          , d = {
                            roll: e.roll,
                            pitch: e.pitch,
                            bearing: e.bearing
                        }
                          , m = {
                            roll: r.roll === void 0 ? e.roll : r.roll,
                            pitch: r.pitch === void 0 ? e.pitch : r.pitch,
                            bearing: r.bearing === void 0 ? e.bearing : r.bearing
                        }
                          , v = r.zoom !== void 0
                          , b = !e.isPaddingEqual(r.padding);
                        let P = !1;
                        const M = v ? +r.zoom : e.zoom;
                        let D = e.centerPoint.add(r.offsetAsPoint);
                        const L = e.screenPointToLocation(D)
                          , {center: B, zoom: Z} = e.getConstrained(o.S.convert(r.center || L), M ?? s);
                        ea(e, B);
                        const te = be(e.worldSize, L)
                          , ee = be(e.worldSize, B).sub(te)
                          , ne = o.ae(Z - s);
                        return P = Z !== s,
                        {
                            easeFunc: oe => {
                                if (P && e.setZoom(o.C.number(s, Z, oe)),
                                o.bd(d, m) || on({
                                    startEulerAngles: d,
                                    endEulerAngles: m,
                                    tr: e,
                                    k: oe,
                                    useSlerp: d.roll != m.roll
                                }),
                                b && (e.interpolatePadding(c, r.padding, oe),
                                D = e.centerPoint.add(r.offsetAsPoint)),
                                r.around)
                                    e.setLocationAtPoint(r.around, r.aroundPoint);
                                else {
                                    const me = o.ae(e.zoom - s)
                                      , ce = Z > s ? Math.min(2, ne) : Math.max(.5, ne)
                                      , Te = Math.pow(ce, 1 - oe)
                                      , Pe = q(e.worldSize, te.add(ee.mult(oe * Te)).mult(me));
                                    e.setLocationAtPoint(e.renderWorldCopies ? Pe.wrap() : Pe, D)
                                }
                            }
                            ,
                            isZooming: P,
                            elevationCenter: B
                        }
                    }
                    handleFlyTo(e, r) {
                        const s = r.zoom !== void 0
                          , c = e.zoom
                          , d = e.getConstrained(o.S.convert(r.center || r.locationAtOffset), s ? +r.zoom : c)
                          , m = d.center
                          , v = d.zoom;
                        ea(e, m);
                        const b = be(e.worldSize, r.locationAtOffset)
                          , P = be(e.worldSize, m).sub(b)
                          , M = P.mag()
                          , D = o.ae(v - c);
                        let L;
                        if (r.minZoom !== void 0) {
                            const B = Math.min(+r.minZoom, c, v)
                              , Z = e.getConstrained(m, B).zoom;
                            L = o.ae(Z - c)
                        }
                        return {
                            easeFunc: (B, Z, te, ee) => {
                                e.setZoom(B === 1 ? v : c + o.aj(Z));
                                const ne = B === 1 ? m : q(e.worldSize, b.add(P.mult(te)).mult(Z));
                                e.setLocationAtPoint(e.renderWorldCopies ? ne.wrap() : ne, ee)
                            }
                            ,
                            scaleOfZoom: D,
                            targetCenter: m,
                            scaleOfMinZoom: L,
                            pixelPathLength: M
                        }
                    }
                }
                class ai {
                    constructor(e, r, s) {
                        this.blendFunction = e,
                        this.blendColor = r,
                        this.mask = s
                    }
                }
                ai.Replace = [1, 0],
                ai.disabled = new ai(ai.Replace,o.be.transparent,[!1, !1, !1, !1]),
                ai.unblended = new ai(ai.Replace,o.be.transparent,[!0, !0, !0, !0]),
                ai.alphaBlended = new ai([1, 771],o.be.transparent,[!0, !0, !0, !0]);
                const qn = 2305;
                class Hr {
                    constructor(e, r, s) {
                        this.enable = e,
                        this.mode = r,
                        this.frontFace = s
                    }
                }
                Hr.disabled = new Hr(!1,1029,qn),
                Hr.backCCW = new Hr(!0,1029,qn),
                Hr.frontCCW = new Hr(!0,1028,qn);
                class Xr {
                    constructor(e, r, s) {
                        this.func = e,
                        this.mask = r,
                        this.range = s
                    }
                }
                Xr.ReadOnly = !1,
                Xr.ReadWrite = !0,
                Xr.disabled = new Xr(519,Xr.ReadOnly,[0, 1]);
                const ls = 7680;
                class qr {
                    constructor(e, r, s, c, d, m) {
                        this.test = e,
                        this.ref = r,
                        this.mask = s,
                        this.fail = c,
                        this.depthFail = d,
                        this.pass = m
                    }
                }
                qr.disabled = new qr({
                    func: 519,
                    mask: 0
                },0,0,ls,ls,ls);
                const cs = new WeakMap;
                function kn(h) {
                    var e;
                    if (cs.has(h))
                        return cs.get(h);
                    {
                        const r = (e = h.getParameter(h.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
                        return cs.set(h, r),
                        r
                    }
                }
                class Is {
                    get awaitingQuery() {
                        return !!this._readbackQueue
                    }
                    constructor(e) {
                        this._readbackWaitFrames = 4,
                        this._measureWaitFrames = 6,
                        this._texWidth = 1,
                        this._texHeight = 1,
                        this._measuredError = 0,
                        this._updateCount = 0,
                        this._lastReadbackFrame = -1e3,
                        this._readbackQueue = null,
                        this._cachedRenderContext = e;
                        const r = e.context
                          , s = r.gl;
                        this._texFormat = s.RGBA,
                        this._texType = s.UNSIGNED_BYTE;
                        const c = new o.aK;
                        c.emplaceBack(-1, -1),
                        c.emplaceBack(2, -1),
                        c.emplaceBack(-1, 2);
                        const d = new o.aM;
                        d.emplaceBack(0, 1, 2),
                        this._fullscreenTriangle = new Qn(r.createVertexBuffer(c, sa.members),r.createIndexBuffer(d),o.aL.simpleSegment(0, 0, c.length, d.length)),
                        this._resultBuffer = new Uint8Array(4),
                        r.activeTexture.set(s.TEXTURE1);
                        const m = s.createTexture();
                        s.bindTexture(s.TEXTURE_2D, m),
                        s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE),
                        s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE),
                        s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.NEAREST),
                        s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.NEAREST),
                        s.texImage2D(s.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null),
                        this._fbo = r.createFramebuffer(this._texWidth, this._texHeight, !1, !1),
                        this._fbo.colorAttachment.set(m),
                        kn(s) && (this._pbo = s.createBuffer(),
                        s.bindBuffer(s.PIXEL_PACK_BUFFER, this._pbo),
                        s.bufferData(s.PIXEL_PACK_BUFFER, 4, s.STREAM_READ),
                        s.bindBuffer(s.PIXEL_PACK_BUFFER, null))
                    }
                    destroy() {
                        const e = this._cachedRenderContext.context.gl;
                        this._fullscreenTriangle.destroy(),
                        this._fbo.destroy(),
                        e.deleteBuffer(this._pbo),
                        this._fullscreenTriangle = null,
                        this._fbo = null,
                        this._pbo = null,
                        this._resultBuffer = null
                    }
                    updateErrorLoop(e, r) {
                        const s = this._updateCount;
                        return this._readbackQueue ? s >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : s >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, r),
                        this._updateCount++,
                        this._measuredError
                    }
                    _bindFramebuffer() {
                        const e = this._cachedRenderContext.context
                          , r = e.gl;
                        e.activeTexture.set(r.TEXTURE1),
                        r.bindTexture(r.TEXTURE_2D, this._fbo.colorAttachment.get()),
                        e.bindFramebuffer.set(this._fbo.framebuffer)
                    }
                    _renderErrorTexture(e, r) {
                        const s = this._cachedRenderContext.context
                          , c = s.gl;
                        if (this._bindFramebuffer(),
                        s.viewport.set([0, 0, this._texWidth, this._texHeight]),
                        s.clear({
                            color: o.be.transparent
                        }),
                        this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(s, c.TRIANGLES, Xr.disabled, qr.disabled, ai.unblended, Hr.disabled, ( (d, m) => ({
                            u_input: d,
                            u_output_expected: m
                        }))(e, r), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments),
                        this._pbo && kn(c)) {
                            c.bindBuffer(c.PIXEL_PACK_BUFFER, this._pbo),
                            c.readBuffer(c.COLOR_ATTACHMENT0),
                            c.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0),
                            c.bindBuffer(c.PIXEL_PACK_BUFFER, null);
                            const d = c.fenceSync(c.SYNC_GPU_COMMANDS_COMPLETE, 0);
                            c.flush(),
                            this._readbackQueue = {
                                frameNumberIssued: this._updateCount,
                                sync: d
                            }
                        } else
                            this._readbackQueue = {
                                frameNumberIssued: this._updateCount,
                                sync: null
                            }
                    }
                    _tryReadback() {
                        const e = this._cachedRenderContext.context.gl;
                        if (this._pbo && this._readbackQueue && kn(e)) {
                            const r = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
                            if (r === e.WAIT_FAILED)
                                return o.w("WebGL2 clientWaitSync failed."),
                                this._readbackQueue = null,
                                void (this._lastReadbackFrame = this._updateCount);
                            if (r === e.TIMEOUT_EXPIRED)
                                return;
                            e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo),
                            e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4),
                            e.bindBuffer(e.PIXEL_PACK_BUFFER, null)
                        } else
                            this._bindFramebuffer(),
                            e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
                        this._readbackQueue = null,
                        this._measuredError = Is._parseRGBA8float(this._resultBuffer),
                        this._lastReadbackFrame = this._updateCount
                    }
                    static _parseRGBA8float(e) {
                        let r = 0;
                        return r += e[0] / 256,
                        r += e[1] / 65536,
                        r += e[2] / 16777216,
                        e[3] < 127 && (r = -r),
                        r / 128
                    }
                }
                const Vn = o.$ / 128;
                function pc(h, e) {
                    const r = h.granularity !== void 0 ? Math.max(h.granularity, 1) : 1
                      , s = r + (h.generateBorders ? 2 : 0)
                      , c = r + (h.extendToNorthPole || h.generateBorders ? 1 : 0) + (h.extendToSouthPole || h.generateBorders ? 1 : 0)
                      , d = s + 1
                      , m = c + 1
                      , v = h.generateBorders ? -1 : 0
                      , b = h.generateBorders || h.extendToNorthPole ? -1 : 0
                      , P = r + (h.generateBorders ? 1 : 0)
                      , M = r + (h.generateBorders || h.extendToSouthPole ? 1 : 0)
                      , D = d * m
                      , L = s * c * 6
                      , B = d * m > 65536;
                    if (B && e === "16bit")
                        throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
                    const Z = B || e === "32bit"
                      , te = new Int16Array(2 * D);
                    let ee = 0;
                    for (let me = b; me <= M; me++)
                        for (let ce = v; ce <= P; ce++) {
                            let Te = ce / r * o.$;
                            ce === -1 && (Te = -Vn),
                            ce === r + 1 && (Te = o.$ + Vn);
                            let Pe = me / r * o.$;
                            me === -1 && (Pe = h.extendToNorthPole ? o.bg : -Vn),
                            me === r + 1 && (Pe = h.extendToSouthPole ? o.bh : o.$ + Vn),
                            te[ee++] = Te,
                            te[ee++] = Pe
                        }
                    const ne = Z ? new Uint32Array(L) : new Uint16Array(L);
                    let oe = 0;
                    for (let me = 0; me < c; me++)
                        for (let ce = 0; ce < s; ce++) {
                            const Te = ce + 1 + me * d
                              , Pe = ce + (me + 1) * d
                              , pe = ce + 1 + (me + 1) * d;
                            ne[oe++] = ce + me * d,
                            ne[oe++] = Pe,
                            ne[oe++] = Te,
                            ne[oe++] = Te,
                            ne[oe++] = Pe,
                            ne[oe++] = pe
                        }
                    return {
                        vertices: te.buffer.slice(0),
                        indices: ne.buffer.slice(0),
                        uses32bitIndices: Z
                    }
                }
                const Ca = new o.aJ({
                    fill: new o.bi(128,2),
                    line: new o.bi(512,0),
                    tile: new o.bi(128,32),
                    stencil: new o.bi(128,1),
                    circle: 3
                });
                class gh {
                    constructor() {
                        this._tileMeshCache = {},
                        this._errorCorrectionUsable = 0,
                        this._errorMeasurementLastValue = 0,
                        this._errorCorrectionPreviousValue = 0,
                        this._errorMeasurementLastChangeTime = -1e3
                    }
                    get name() {
                        return "vertical-perspective"
                    }
                    get transitionState() {
                        return 1
                    }
                    get useSubdivision() {
                        return !0
                    }
                    get shaderVariantName() {
                        return "globe"
                    }
                    get shaderDefine() {
                        return "#define GLOBE"
                    }
                    get shaderPreludeCode() {
                        return Ui.projectionGlobe
                    }
                    get vertexShaderPreludeCode() {
                        return Ui.projectionMercator.vertexSource
                    }
                    get subdivisionGranularity() {
                        return Ca
                    }
                    get useGlobeControls() {
                        return !0
                    }
                    get latitudeErrorCorrectionRadians() {
                        return this._errorCorrectionUsable
                    }
                    destroy() {
                        this._errorMeasurement && this._errorMeasurement.destroy()
                    }
                    updateGPUdependent(e) {
                        this._errorMeasurement || (this._errorMeasurement = new Is(e));
                        const r = o.U(this._errorQueryLatitudeDegrees)
                          , s = 2 * Math.atan(Math.exp(Math.PI - r * Math.PI * 2)) - .5 * Math.PI
                          , c = this._errorMeasurement.updateErrorLoop(r, s)
                          , d = he.now();
                        c !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable,
                        this._errorMeasurementLastValue = c,
                        this._errorMeasurementLastChangeTime = d);
                        const m = Math.min(Math.max((d - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
                        this._errorCorrectionUsable = o.bj(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, o.bk(m))
                    }
                    _getMeshKey(e) {
                        return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`
                    }
                    getMeshFromTileID(e, r, s, c, d) {
                        const m = (d === "stencil" ? Ca.stencil : Ca.tile).getGranularityForZoomLevel(r.z);
                        return this._getMesh(e, {
                            granularity: m,
                            generateBorders: s,
                            extendToNorthPole: r.y === 0 && c,
                            extendToSouthPole: r.y === (1 << r.z) - 1 && c
                        })
                    }
                    _getMesh(e, r) {
                        const s = this._getMeshKey(r);
                        if (s in this._tileMeshCache)
                            return this._tileMeshCache[s];
                        const c = function(d, m) {
                            const v = pc(m, "16bit")
                              , b = o.aK.deserialize({
                                arrayBuffer: v.vertices,
                                length: v.vertices.byteLength / 2 / 2
                            })
                              , P = o.aM.deserialize({
                                arrayBuffer: v.indices,
                                length: v.indices.byteLength / 2 / 3
                            });
                            return new Qn(d.createVertexBuffer(b, sa.members),d.createIndexBuffer(P),o.aL.simpleSegment(0, 0, b.length, P.length))
                        }(e, r);
                        return this._tileMeshCache[s] = c,
                        c
                    }
                    recalculate(e) {}
                    hasTransition() {
                        const e = he.now();
                        let r = !1;
                        return r = r || (e - this._errorMeasurementLastChangeTime) / 1e3 < .7,
                        r = r || this._errorMeasurement && this._errorMeasurement.awaitingQuery,
                        r
                    }
                    setErrorQueryLatitudeDegrees(e) {
                        this._errorQueryLatitudeDegrees = e
                    }
                }
                const vh = new o.r({
                    type: new o.D(o.v.projection.type)
                });
                class uo extends o.E {
                    constructor(e) {
                        super(),
                        this._transitionable = new o.t(vh),
                        this.setProjection(e),
                        this._transitioning = this._transitionable.untransitioned(),
                        this.recalculate(new o.F(0)),
                        this._mercatorProjection = new Ps,
                        this._verticalPerspectiveProjection = new gh
                    }
                    get transitionState() {
                        const e = this.properties.get("type");
                        if (typeof e == "string" && e === "mercator")
                            return 0;
                        if (typeof e == "string" && e === "vertical-perspective")
                            return 1;
                        if (e instanceof o.bl) {
                            if (e.from === "vertical-perspective" && e.to === "mercator")
                                return 1 - e.transition;
                            if (e.from === "mercator" && e.to === "vertical-perspective")
                                return e.transition
                        }
                        return 1
                    }
                    get useGlobeRendering() {
                        return this.transitionState > 0
                    }
                    get latitudeErrorCorrectionRadians() {
                        return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians
                    }
                    get currentProjection() {
                        return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection
                    }
                    get name() {
                        return "globe"
                    }
                    get useSubdivision() {
                        return this.currentProjection.useSubdivision
                    }
                    get shaderVariantName() {
                        return this.currentProjection.shaderVariantName
                    }
                    get shaderDefine() {
                        return this.currentProjection.shaderDefine
                    }
                    get shaderPreludeCode() {
                        return this.currentProjection.shaderPreludeCode
                    }
                    get vertexShaderPreludeCode() {
                        return this.currentProjection.vertexShaderPreludeCode
                    }
                    get subdivisionGranularity() {
                        return this.currentProjection.subdivisionGranularity
                    }
                    get useGlobeControls() {
                        return this.transitionState > 0
                    }
                    destroy() {
                        this._mercatorProjection.destroy(),
                        this._verticalPerspectiveProjection.destroy()
                    }
                    updateGPUdependent(e) {
                        this._mercatorProjection.updateGPUdependent(e),
                        this._verticalPerspectiveProjection.updateGPUdependent(e)
                    }
                    getMeshFromTileID(e, r, s, c, d) {
                        return this.currentProjection.getMeshFromTileID(e, r, s, c, d)
                    }
                    setProjection(e) {
                        this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator")
                    }
                    updateTransitions(e) {
                        this._transitioning = this._transitionable.transitioned(e, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition() || this.currentProjection.hasTransition()
                    }
                    recalculate(e) {
                        this.properties = this._transitioning.possiblyEvaluate(e)
                    }
                    setErrorQueryLatitudeDegrees(e) {
                        this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e),
                        this._mercatorProjection.setErrorQueryLatitudeDegrees(e)
                    }
                }
                function ho(h) {
                    const e = Ms(h.worldSize, h.center.lat);
                    return 2 * Math.PI * e
                }
                function pa(h, e, r, s, c) {
                    const d = 1 / (1 << c)
                      , m = e / o.$ * d + s * d
                      , v = o.bn((h / o.$ * d + r * d) * Math.PI * 2 + Math.PI, 2 * Math.PI)
                      , b = 2 * Math.atan(Math.exp(Math.PI - m * Math.PI * 2)) - .5 * Math.PI
                      , P = Math.cos(b)
                      , M = new Float64Array(3);
                    return M[0] = Math.sin(v) * P,
                    M[1] = Math.sin(b),
                    M[2] = Math.cos(v) * P,
                    M
                }
                function ln(h) {
                    return function(e, r) {
                        const s = Math.cos(r)
                          , c = new Float64Array(3);
                        return c[0] = Math.sin(e) * s,
                        c[1] = Math.sin(r),
                        c[2] = Math.cos(e) * s,
                        c
                    }(h.lng * Math.PI / 180, h.lat * Math.PI / 180)
                }
                function Ms(h, e) {
                    return h / (2 * Math.PI) / Math.cos(e * Math.PI / 180)
                }
                function po(h) {
                    const e = Math.asin(h[1]) / Math.PI * 180
                      , r = Math.sqrt(h[0] * h[0] + h[2] * h[2]);
                    if (r > 1e-6) {
                        const s = h[0] / r
                          , c = Math.acos(h[2] / r)
                          , d = (s > 0 ? c : -c) / Math.PI * 180;
                        return new o.S(o.aN(d, -180, 180),e)
                    }
                    return new o.S(0,e)
                }
                function As(h) {
                    return Math.cos(h * Math.PI / 180)
                }
                function Yi(h, e) {
                    const r = As(h)
                      , s = As(e);
                    return o.aj(s / r)
                }
                function fo(h, e) {
                    const r = h.rotate(e.bearingInRadians)
                      , s = e.zoom + Yi(e.center.lat, 0)
                      , c = o.bj(1 / As(e.center.lat), 1 / As(Math.min(Math.abs(e.center.lat), 60)), o.bm(s, 7, 3, 0, 1))
                      , d = 360 / ho({
                        worldSize: e.worldSize,
                        center: {
                            lat: e.center.lat
                        }
                    });
                    return new o.S(e.center.lng - r.x * d * c,o.ag(e.center.lat + r.y * d, -o.ah, o.ah))
                }
                function ks(h) {
                    const e = .5 * h
                      , r = Math.sin(e)
                      , s = Math.cos(e);
                    return Math.log(r + s) - Math.log(s - r)
                }
                function Es(h, e, r, s) {
                    const c = h.lat + r * s;
                    if (Math.abs(r) > 1) {
                        const d = (Math.sign(h.lat + r) !== Math.sign(h.lat) ? -Math.abs(h.lat) : Math.abs(h.lat)) * Math.PI / 180
                          , m = Math.abs(h.lat + r) * Math.PI / 180
                          , v = ks(d + s * (m - d))
                          , b = ks(d)
                          , P = ks(m);
                        return new o.S(h.lng + e * ((v - b) / (P - b)),c)
                    }
                    return new o.S(h.lng + e * s,c)
                }
                class Wd {
                    constructor(e) {
                        this._cachePrevious = new Map,
                        this._cache = new Map,
                        this._hadAnyChanges = !1,
                        this._boundingVolumeFactory = e
                    }
                    swapBuffers() {
                        if (!this._hadAnyChanges)
                            return;
                        const e = this._cachePrevious;
                        this._cachePrevious = this._cache,
                        this._cache = e,
                        this._cache.clear(),
                        this._hadAnyChanges = !1
                    }
                    getTileBoundingVolume(e, r, s, c) {
                        const d = `${e.z}_${e.x}_${e.y}_${c != null && c.terrain ? "t" : ""}`
                          , m = this._cache.get(d);
                        if (m)
                            return m;
                        const v = this._cachePrevious.get(d);
                        if (v)
                            return this._cache.set(d, v),
                            v;
                        const b = this._boundingVolumeFactory(e, r, s, c);
                        return this._cache.set(d, b),
                        this._hadAnyChanges = !0,
                        b
                    }
                }
                class Ga {
                    constructor(e, r, s, c) {
                        this.min = s,
                        this.max = c,
                        this.points = e,
                        this.planes = r
                    }
                    static fromAabb(e, r) {
                        const s = [];
                        for (let c = 0; c < 8; c++)
                            s.push([1 & ~c ? e[0] : r[0], (c >> 1 & 1) == 1 ? r[1] : e[1], (c >> 2 & 1) == 1 ? r[2] : e[2]]);
                        return new Ga(s,[[-1, 0, 0, r[0]], [1, 0, 0, -e[0]], [0, -1, 0, r[1]], [0, 1, 0, -e[1]], [0, 0, -1, r[2]], [0, 0, 1, -e[2]]],e,r)
                    }
                    static fromCenterSizeAngles(e, r, s) {
                        const c = o.bq([], s[0], s[1], s[2])
                          , d = o.br([], [r[0], 0, 0], c)
                          , m = o.br([], [0, r[1], 0], c)
                          , v = o.br([], [0, 0, r[2]], c)
                          , b = [...e]
                          , P = [...e];
                        for (let D = 0; D < 8; D++)
                            for (let L = 0; L < 3; L++) {
                                const B = e[L] + d[L] * (1 & ~D ? -1 : 1) + m[L] * ((D >> 1 & 1) == 1 ? 1 : -1) + v[L] * ((D >> 2 & 1) == 1 ? 1 : -1);
                                b[L] = Math.min(b[L], B),
                                P[L] = Math.max(P[L], B)
                            }
                        const M = [];
                        for (let D = 0; D < 8; D++) {
                            const L = [...e];
                            o.aR(L, L, o.aQ([], d, 1 & ~D ? -1 : 1)),
                            o.aR(L, L, o.aQ([], m, (D >> 1 & 1) == 1 ? 1 : -1)),
                            o.aR(L, L, o.aQ([], v, (D >> 2 & 1) == 1 ? 1 : -1)),
                            M.push(L)
                        }
                        return new Ga(M,[[...d, -o.aW(d, M[0])], [...m, -o.aW(m, M[0])], [...v, -o.aW(v, M[0])], [-d[0], -d[1], -d[2], -o.aW(d, M[7])], [-m[0], -m[1], -m[2], -o.aW(m, M[7])], [-v[0], -v[1], -v[2], -o.aW(v, M[7])]],b,P)
                    }
                    intersectsFrustum(e) {
                        let r = !0;
                        const s = this.points.length
                          , c = this.planes.length
                          , d = e.planes.length
                          , m = e.points.length;
                        for (let v = 0; v < d; v++) {
                            const b = e.planes[v];
                            let P = 0;
                            for (let M = 0; M < s; M++) {
                                const D = this.points[M];
                                b[0] * D[0] + b[1] * D[1] + b[2] * D[2] + b[3] >= 0 && P++
                            }
                            if (P === 0)
                                return 0;
                            P < s && (r = !1)
                        }
                        if (r)
                            return 2;
                        for (let v = 0; v < c; v++) {
                            const b = this.planes[v];
                            let P = 0;
                            for (let M = 0; M < m; M++) {
                                const D = e.points[M];
                                b[0] * D[0] + b[1] * D[1] + b[2] * D[2] + b[3] >= 0 && P++
                            }
                            if (P === 0)
                                return 0
                        }
                        return 1
                    }
                    intersectsPlane(e) {
                        const r = this.points.length;
                        let s = 0;
                        for (let c = 0; c < r; c++) {
                            const d = this.points[c];
                            e[0] * d[0] + e[1] * d[1] + e[2] * d[2] + e[3] >= 0 && s++
                        }
                        return s === r ? 2 : s === 0 ? 0 : 1
                    }
                }
                function mo(h, e, r) {
                    const s = h - e;
                    return s < 0 ? -s : Math.max(0, s - r)
                }
                function fc(h, e, r, s, c) {
                    const d = h - r;
                    let m;
                    return m = d < 0 ? Math.min(-d, 1 + d - c) : d > 1 ? Math.min(Math.max(d - c, 0), 1 - d) : 0,
                    Math.max(m, mo(e, s, c))
                }
                class Xd {
                    constructor() {
                        this._boundingVolumeCache = new Wd(this._computeTileBoundingVolume)
                    }
                    prepareNextFrame() {
                        this._boundingVolumeCache.swapBuffers()
                    }
                    distanceToTile2d(e, r, s, c) {
                        const d = 1 << s.z
                          , m = 1 / d
                          , v = s.x / d
                          , b = s.y / d;
                        let P = 2;
                        return P = Math.min(P, fc(e, r, v, b, m)),
                        P = Math.min(P, fc(e, r, v + .5, -b - m, m)),
                        P = Math.min(P, fc(e, r, v + .5, 2 - b - m, m)),
                        P
                    }
                    getWrap(e, r, s) {
                        const c = 1 << r.z
                          , d = 1 / c
                          , m = r.x / c
                          , v = mo(e.x, m, d)
                          , b = mo(e.x, m - 1, d)
                          , P = mo(e.x, m + 1, d)
                          , M = Math.min(v, b, P);
                        return M === P ? 1 : M === b ? -1 : 0
                    }
                    allowVariableZoom(e, r) {
                        return je(e, r) > 4
                    }
                    allowWorldCopies() {
                        return !1
                    }
                    getTileBoundingVolume(e, r, s, c) {
                        return this._boundingVolumeCache.getTileBoundingVolume(e, r, s, c)
                    }
                    _computeTileBoundingVolume(e, r, s, c) {
                        var d, m;
                        let v = s
                          , b = s;
                        if (c != null && c.terrain) {
                            const P = new o.Z(e.z,r,e.z,e.x,e.y)
                              , M = c.terrain.getMinMaxElevation(P);
                            v = (d = M.minElevation) !== null && d !== void 0 ? d : s,
                            b = (m = M.maxElevation) !== null && m !== void 0 ? m : s
                        }
                        if (v /= o.bt,
                        b /= o.bt,
                        v += 1,
                        b += 1,
                        e.z <= 0)
                            return Ga.fromAabb([-b, -b, -b], [b, b, b]);
                        if (e.z === 1)
                            return Ga.fromAabb([e.x === 0 ? -b : 0, e.y === 0 ? 0 : -b, -b], [e.x === 0 ? 0 : b, e.y === 0 ? b : 0, b]);
                        {
                            const P = [pa(0, 0, e.x, e.y, e.z), pa(o.$, 0, e.x, e.y, e.z), pa(o.$, o.$, e.x, e.y, e.z), pa(0, o.$, e.x, e.y, e.z)]
                              , M = [];
                            for (const He of P)
                                M.push(o.aQ([], He, b));
                            if (b !== v)
                                for (const He of P)
                                    M.push(o.aQ([], He, v));
                            e.y === 0 && M.push([0, 1, 0]),
                            e.y === (1 << e.z) - 1 && M.push([0, -1, 0]);
                            const D = [1, 1, 1]
                              , L = [-1, -1, -1];
                            for (const He of M)
                                for (let Je = 0; Je < 3; Je++)
                                    D[Je] = Math.min(D[Je], He[Je]),
                                    L[Je] = Math.max(L[Je], He[Je]);
                            const B = pa(o.$ / 2, o.$ / 2, e.x, e.y, e.z)
                              , Z = o.aV([], [0, 1, 0], B);
                            o.aU(Z, Z);
                            const te = o.aV([], B, Z);
                            o.aU(te, te);
                            const ee = o.aV([], P[2], P[1]);
                            o.aU(ee, ee);
                            const ne = o.aV([], P[0], P[3]);
                            o.aU(ne, ne),
                            M.push(o.aQ([], B, b)),
                            e.y >= (1 << e.z) / 2 && M.push(o.aQ([], pa(o.$ / 2, 0, e.x, e.y, e.z), b)),
                            e.y < (1 << e.z) / 2 && M.push(o.aQ([], pa(o.$ / 2, o.$, e.x, e.y, e.z), b));
                            const oe = En(B, M)
                              , me = En(te, M)
                              , ce = [-B[0], -B[1], -B[2], oe.max]
                              , Te = [B[0], B[1], B[2], -oe.min]
                              , Pe = [-te[0], -te[1], -te[2], me.max]
                              , pe = [te[0], te[1], te[2], -me.min]
                              , Fe = [...ee, 0]
                              , Ye = [...ne, 0]
                              , $e = [];
                            return e.y === 0 ? $e.push(o.bs(Ye, Fe, ce), o.bs(Ye, Fe, Te)) : $e.push(o.bs(Pe, Fe, ce), o.bs(Pe, Fe, Te), o.bs(Pe, Ye, ce), o.bs(Pe, Ye, Te)),
                            e.y === (1 << e.z) - 1 ? $e.push(o.bs(Ye, Fe, ce), o.bs(Ye, Fe, Te)) : $e.push(o.bs(pe, Fe, ce), o.bs(pe, Fe, Te), o.bs(pe, Ye, ce), o.bs(pe, Ye, Te)),
                            new Ga($e,[ce, Te, Pe, pe, Fe, Ye],D,L)
                        }
                    }
                }
                function En(h, e) {
                    let r = 1 / 0
                      , s = -1 / 0;
                    for (const c of e) {
                        const d = o.aW(h, c);
                        r = Math.min(r, d),
                        s = Math.max(s, d)
                    }
                    return {
                        min: r,
                        max: s
                    }
                }
                class zs {
                    get pixelsToClipSpaceMatrix() {
                        return this._helper.pixelsToClipSpaceMatrix
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._helper.clipSpaceToPixelsMatrix
                    }
                    get pixelsToGLUnits() {
                        return this._helper.pixelsToGLUnits
                    }
                    get centerOffset() {
                        return this._helper.centerOffset
                    }
                    get size() {
                        return this._helper.size
                    }
                    get rotationMatrix() {
                        return this._helper.rotationMatrix
                    }
                    get centerPoint() {
                        return this._helper.centerPoint
                    }
                    get pixelsPerMeter() {
                        return this._helper.pixelsPerMeter
                    }
                    setMinZoom(e) {
                        this._helper.setMinZoom(e)
                    }
                    setMaxZoom(e) {
                        this._helper.setMaxZoom(e)
                    }
                    setMinPitch(e) {
                        this._helper.setMinPitch(e)
                    }
                    setMaxPitch(e) {
                        this._helper.setMaxPitch(e)
                    }
                    setRenderWorldCopies(e) {
                        this._helper.setRenderWorldCopies(e)
                    }
                    setBearing(e) {
                        this._helper.setBearing(e)
                    }
                    setPitch(e) {
                        this._helper.setPitch(e)
                    }
                    setRoll(e) {
                        this._helper.setRoll(e)
                    }
                    setFov(e) {
                        this._helper.setFov(e)
                    }
                    setZoom(e) {
                        this._helper.setZoom(e)
                    }
                    setCenter(e) {
                        this._helper.setCenter(e)
                    }
                    setElevation(e) {
                        this._helper.setElevation(e)
                    }
                    setMinElevationForCurrentTile(e) {
                        this._helper.setMinElevationForCurrentTile(e)
                    }
                    setPadding(e) {
                        this._helper.setPadding(e)
                    }
                    interpolatePadding(e, r, s) {
                        return this._helper.interpolatePadding(e, r, s)
                    }
                    isPaddingEqual(e) {
                        return this._helper.isPaddingEqual(e)
                    }
                    resize(e, r) {
                        this._helper.resize(e, r)
                    }
                    getMaxBounds() {
                        return this._helper.getMaxBounds()
                    }
                    setMaxBounds(e) {
                        this._helper.setMaxBounds(e)
                    }
                    overrideNearFarZ(e, r) {
                        this._helper.overrideNearFarZ(e, r)
                    }
                    clearNearFarZOverride() {
                        this._helper.clearNearFarZOverride()
                    }
                    getCameraQueryGeometry(e) {
                        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
                    }
                    get tileSize() {
                        return this._helper.tileSize
                    }
                    get tileZoom() {
                        return this._helper.tileZoom
                    }
                    get scale() {
                        return this._helper.scale
                    }
                    get worldSize() {
                        return this._helper.worldSize
                    }
                    get width() {
                        return this._helper.width
                    }
                    get height() {
                        return this._helper.height
                    }
                    get lngRange() {
                        return this._helper.lngRange
                    }
                    get latRange() {
                        return this._helper.latRange
                    }
                    get minZoom() {
                        return this._helper.minZoom
                    }
                    get maxZoom() {
                        return this._helper.maxZoom
                    }
                    get zoom() {
                        return this._helper.zoom
                    }
                    get center() {
                        return this._helper.center
                    }
                    get minPitch() {
                        return this._helper.minPitch
                    }
                    get maxPitch() {
                        return this._helper.maxPitch
                    }
                    get pitch() {
                        return this._helper.pitch
                    }
                    get pitchInRadians() {
                        return this._helper.pitchInRadians
                    }
                    get roll() {
                        return this._helper.roll
                    }
                    get rollInRadians() {
                        return this._helper.rollInRadians
                    }
                    get bearing() {
                        return this._helper.bearing
                    }
                    get bearingInRadians() {
                        return this._helper.bearingInRadians
                    }
                    get fov() {
                        return this._helper.fov
                    }
                    get fovInRadians() {
                        return this._helper.fovInRadians
                    }
                    get elevation() {
                        return this._helper.elevation
                    }
                    get minElevationForCurrentTile() {
                        return this._helper.minElevationForCurrentTile
                    }
                    get padding() {
                        return this._helper.padding
                    }
                    get unmodified() {
                        return this._helper.unmodified
                    }
                    get renderWorldCopies() {
                        return this._helper.renderWorldCopies
                    }
                    get nearZ() {
                        return this._helper.nearZ
                    }
                    get farZ() {
                        return this._helper.farZ
                    }
                    get autoCalculateNearFarZ() {
                        return this._helper.autoCalculateNearFarZ
                    }
                    setTransitionState(e) {}
                    constructor() {
                        this._cachedClippingPlane = o.bu(),
                        this._projectionMatrix = o.b8(),
                        this._globeViewProjMatrix32f = o.b7(),
                        this._globeViewProjMatrixNoCorrection = o.b8(),
                        this._globeViewProjMatrixNoCorrectionInverted = o.b8(),
                        this._globeProjMatrixInverted = o.b8(),
                        this._cameraPosition = o.bo(),
                        this._globeLatitudeErrorCorrectionRadians = 0,
                        this._helper = new Ua({
                            calcMatrices: () => {
                                this._calcMatrices()
                            }
                            ,
                            getConstrained: (e, r) => this.getConstrained(e, r)
                        }),
                        this._coveringTilesDetailsProvider = new Xd
                    }
                    clone() {
                        const e = new zs;
                        return e.apply(this),
                        e
                    }
                    apply(e, r) {
                        this._globeLatitudeErrorCorrectionRadians = r || 0,
                        this._helper.apply(e)
                    }
                    get projectionMatrix() {
                        return this._projectionMatrix
                    }
                    get modelViewProjectionMatrix() {
                        return this._globeViewProjMatrixNoCorrection
                    }
                    get inverseProjectionMatrix() {
                        return this._globeProjMatrixInverted
                    }
                    get cameraPosition() {
                        const e = o.bo();
                        return e[0] = this._cameraPosition[0],
                        e[1] = this._cameraPosition[1],
                        e[2] = this._cameraPosition[2],
                        e
                    }
                    get cameraToCenterDistance() {
                        return this._helper.cameraToCenterDistance
                    }
                    getProjectionData(e) {
                        const {overscaledTileID: r, applyGlobeMatrix: s} = e
                          , c = this._helper.getMercatorTileCoordinates(r);
                        return {
                            mainMatrix: this._globeViewProjMatrix32f,
                            tileMercatorCoords: c,
                            clippingPlane: this._cachedClippingPlane,
                            projectionTransition: s ? 1 : 0,
                            fallbackMatrix: this._globeViewProjMatrix32f
                        }
                    }
                    _computeClippingPlane(e) {
                        const r = this.pitchInRadians
                          , s = this.cameraToCenterDistance / e
                          , c = Math.sin(r) * s
                          , d = Math.cos(r) * s + 1
                          , m = 1 / Math.sqrt(c * c + d * d) * 1;
                        let v = -c
                          , b = d;
                        const P = Math.sqrt(v * v + b * b);
                        v /= P,
                        b /= P;
                        const M = [0, v, b];
                        o.bv(M, M, [0, 0, 0], -this.bearingInRadians),
                        o.bw(M, M, [0, 0, 0], -1 * this.center.lat * Math.PI / 180),
                        o.bx(M, M, [0, 0, 0], this.center.lng * Math.PI / 180);
                        const D = 1 / o.aY(M);
                        return o.aQ(M, M, D),
                        [...M, -m * D]
                    }
                    isLocationOccluded(e) {
                        return !this.isSurfacePointVisible(ln(e))
                    }
                    transformLightDirection(e) {
                        const r = this._helper._center.lng * Math.PI / 180
                          , s = this._helper._center.lat * Math.PI / 180
                          , c = Math.cos(s)
                          , d = [Math.sin(r) * c, Math.sin(s), Math.cos(r) * c]
                          , m = [d[2], 0, -d[0]]
                          , v = [0, 0, 0];
                        o.aV(v, m, d),
                        o.aU(m, m),
                        o.aU(v, v);
                        const b = [0, 0, 0];
                        return o.aU(b, [m[0] * e[0] + v[0] * e[1] + d[0] * e[2], m[1] * e[0] + v[1] * e[1] + d[1] * e[2], m[2] * e[0] + v[2] * e[1] + d[2] * e[2]]),
                        b
                    }
                    getPixelScale() {
                        return 1 / Math.cos(this._helper._center.lat * Math.PI / 180)
                    }
                    getCircleRadiusCorrection() {
                        return Math.cos(this._helper._center.lat * Math.PI / 180)
                    }
                    getPitchedTextCorrection(e, r, s) {
                        const c = function(v, b, P) {
                            const M = 1 / (1 << P.z);
                            return new o.a0(v / o.$ * M + P.x * M,b / o.$ * M + P.y * M)
                        }(e, r, s.canonical)
                          , d = (m = c.y,
                        [o.bn(c.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - m * Math.PI * 2)) - .5 * Math.PI]);
                        var m;
                        return this.getCircleRadiusCorrection() / Math.cos(d[1])
                    }
                    projectTileCoordinates(e, r, s, c) {
                        const d = s.canonical
                          , m = pa(e, r, d.x, d.y, d.z)
                          , v = 1 + (c ? c(e, r) : 0) / o.bt
                          , b = [m[0] * v, m[1] * v, m[2] * v, 1];
                        o.av(b, b, this._globeViewProjMatrixNoCorrection);
                        const P = this._cachedClippingPlane
                          , M = P[0] * m[0] + P[1] * m[1] + P[2] * m[2] + P[3] < 0;
                        return {
                            point: new o.P(b[0] / b[3],b[1] / b[3]),
                            signedDistanceFromCamera: b[3],
                            isOccluded: M
                        }
                    }
                    _calcMatrices() {
                        if (!this._helper._width || !this._helper._height)
                            return;
                        const e = Ms(this.worldSize, this.center.lat)
                          , r = o.b9()
                          , s = o.b9();
                        this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5,
                        this._helper._farZ = this.cameraToCenterDistance + 2 * e),
                        o.b3(r, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
                        const c = this.centerOffset;
                        r[8] = 2 * -c.x / this._helper._width,
                        r[9] = 2 * c.y / this._helper._height,
                        this._projectionMatrix = o.b4(r),
                        this._globeProjMatrixInverted = o.b9(),
                        o.ap(this._globeProjMatrixInverted, r),
                        o.M(r, r, [0, 0, -this.cameraToCenterDistance]),
                        o.b5(r, r, this.rollInRadians),
                        o.b6(r, r, -this.pitchInRadians),
                        o.b5(r, r, this.bearingInRadians),
                        o.M(r, r, [0, 0, -e]);
                        const d = o.bo();
                        d[0] = e,
                        d[1] = e,
                        d[2] = e,
                        o.b6(s, r, this.center.lat * Math.PI / 180),
                        o.by(s, s, -this.center.lng * Math.PI / 180),
                        o.N(s, s, d),
                        this._globeViewProjMatrixNoCorrection = s,
                        o.b6(r, r, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians),
                        o.by(r, r, -this.center.lng * Math.PI / 180),
                        o.N(r, r, d),
                        this._globeViewProjMatrix32f = new Float32Array(r),
                        this._globeViewProjMatrixNoCorrectionInverted = o.b9(),
                        o.ap(this._globeViewProjMatrixNoCorrectionInverted, s);
                        const m = o.bo();
                        this._cameraPosition = o.bo(),
                        this._cameraPosition[2] = this.cameraToCenterDistance / e,
                        o.bv(this._cameraPosition, this._cameraPosition, m, -this.rollInRadians),
                        o.bw(this._cameraPosition, this._cameraPosition, m, this.pitchInRadians),
                        o.bv(this._cameraPosition, this._cameraPosition, m, -this.bearingInRadians),
                        o.aR(this._cameraPosition, this._cameraPosition, [0, 0, 1]),
                        o.bw(this._cameraPosition, this._cameraPosition, m, -this.center.lat * Math.PI / 180),
                        o.bx(this._cameraPosition, this._cameraPosition, m, this.center.lng * Math.PI / 180),
                        this._cachedClippingPlane = this._computeClippingPlane(e);
                        const v = o.b4(this._globeViewProjMatrixNoCorrectionInverted);
                        o.N(v, v, [1, 1, -1]),
                        this._cachedFrustum = Gi.fromInvProjectionMatrix(v, 1, 0, this._cachedClippingPlane, !0)
                    }
                    calculateFogMatrix(e) {
                        o.w("calculateFogMatrix is not supported on globe projection.");
                        const r = o.b9();
                        return o.af(r),
                        r
                    }
                    getVisibleUnwrappedCoordinates(e) {
                        return [new o.b1(0,e)]
                    }
                    getCameraFrustum() {
                        return this._cachedFrustum
                    }
                    getClippingPlane() {
                        return this._cachedClippingPlane
                    }
                    getCoveringTilesDetailsProvider() {
                        return this._coveringTilesDetailsProvider
                    }
                    recalculateZoomAndCenter(e) {
                        e && o.w("terrain is not fully supported on vertical perspective projection."),
                        this._helper.recalculateZoomAndCenter(0)
                    }
                    maxPitchScaleFactor() {
                        return 1
                    }
                    getCameraPoint() {
                        return this._helper.getCameraPoint()
                    }
                    getCameraAltitude() {
                        return this._helper.getCameraAltitude()
                    }
                    getCameraLngLat() {
                        return this._helper.getCameraLngLat()
                    }
                    lngLatToCameraDepth(e, r) {
                        if (!this._globeViewProjMatrixNoCorrection)
                            return 1;
                        const s = ln(e);
                        o.aQ(s, s, 1 + r / o.bt);
                        const c = o.bu();
                        return o.av(c, [s[0], s[1], s[2], 1], this._globeViewProjMatrixNoCorrection),
                        c[2] / c[3]
                    }
                    populateCache(e) {}
                    getBounds() {
                        const e = .5 * this.width
                          , r = .5 * this.height
                          , s = [new o.P(0,0), new o.P(e,0), new o.P(this.width,0), new o.P(this.width,r), new o.P(this.width,this.height), new o.P(e,this.height), new o.P(0,this.height), new o.P(0,r)]
                          , c = [];
                        for (const D of s)
                            c.push(this.unprojectScreenPoint(D));
                        let d = 0
                          , m = 0
                          , v = 0
                          , b = 0;
                        const P = this.center;
                        for (const D of c) {
                            const L = o.bz(P.lng, D.lng)
                              , B = o.bz(P.lat, D.lat);
                            L < m && (m = L),
                            L > d && (d = L),
                            B < b && (b = B),
                            B > v && (v = B)
                        }
                        const M = [P.lng + m, P.lat + b, P.lng + d, P.lat + v];
                        return this.isSurfacePointOnScreen([0, 1, 0]) && (M[3] = 90,
                        M[0] = -180,
                        M[2] = 180),
                        this.isSurfacePointOnScreen([0, -1, 0]) && (M[1] = -90,
                        M[0] = -180,
                        M[2] = 180),
                        new Lt(M)
                    }
                    getConstrained(e, r) {
                        const s = o.ag(e.lat, -o.ah, o.ah)
                          , c = o.ag(+r, this.minZoom + Yi(0, s), this.maxZoom);
                        return {
                            center: new o.S(e.lng,s),
                            zoom: c
                        }
                    }
                    calculateCenterFromCameraLngLatAlt(e, r, s, c) {
                        return this._helper.calculateCenterFromCameraLngLatAlt(e, r, s, c)
                    }
                    setLocationAtPoint(e, r) {
                        const s = ln(this.unprojectScreenPoint(r))
                          , c = ln(e)
                          , d = o.bo();
                        o.bA(d);
                        const m = o.bo();
                        o.bx(m, s, d, -this.center.lng * Math.PI / 180),
                        o.bw(m, m, d, this.center.lat * Math.PI / 180);
                        const v = c[0] * c[0] + c[2] * c[2]
                          , b = m[0] * m[0];
                        if (v < b)
                            return;
                        const P = Math.sqrt(v - b)
                          , M = -P
                          , D = o.bB(c[0], c[2], m[0], P)
                          , L = o.bB(c[0], c[2], m[0], M)
                          , B = o.bo();
                        o.bx(B, c, d, -D);
                        const Z = o.bB(B[1], B[2], m[1], m[2])
                          , te = o.bo();
                        o.bx(te, c, d, -L);
                        const ee = o.bB(te[1], te[2], m[1], m[2])
                          , ne = .5 * Math.PI
                          , oe = Z >= -ne && Z <= ne
                          , me = ee >= -ne && ee <= ne;
                        let ce, Te;
                        if (oe && me) {
                            const Ye = this.center.lng * Math.PI / 180
                              , $e = this.center.lat * Math.PI / 180;
                            o.bC(D, Ye) + o.bC(Z, $e) < o.bC(L, Ye) + o.bC(ee, $e) ? (ce = D,
                            Te = Z) : (ce = L,
                            Te = ee)
                        } else if (oe)
                            ce = D,
                            Te = Z;
                        else {
                            if (!me)
                                return;
                            ce = L,
                            Te = ee
                        }
                        const Pe = ce / Math.PI * 180
                          , pe = Te / Math.PI * 180
                          , Fe = this.center.lat;
                        this.setCenter(new o.S(Pe,o.ag(pe, -90, 90))),
                        this.setZoom(this.zoom + Yi(Fe, this.center.lat))
                    }
                    locationToScreenPoint(e, r) {
                        const s = ln(e);
                        if (r) {
                            const c = r.getElevationForLngLatZoom(e, this._helper._tileZoom);
                            o.aQ(s, s, 1 + c / o.bt)
                        }
                        return this._projectSurfacePointToScreen(s)
                    }
                    _projectSurfacePointToScreen(e) {
                        const r = o.bu();
                        return o.av(r, [...e, 1], this._globeViewProjMatrixNoCorrection),
                        r[0] /= r[3],
                        r[1] /= r[3],
                        new o.P((.5 * r[0] + .5) * this.width,(.5 * -r[1] + .5) * this.height)
                    }
                    screenPointToMercatorCoordinate(e, r) {
                        if (r) {
                            const s = r.pointCoordinate(e);
                            if (s)
                                return s
                        }
                        return o.a0.fromLngLat(this.unprojectScreenPoint(e))
                    }
                    screenPointToLocation(e, r) {
                        var s;
                        return (s = this.screenPointToMercatorCoordinate(e, r)) === null || s === void 0 ? void 0 : s.toLngLat()
                    }
                    isPointOnMapSurface(e, r) {
                        const s = this._cameraPosition
                          , c = this.getRayDirectionFromPixel(e);
                        return !!this.rayPlanetIntersection(s, c)
                    }
                    getRayDirectionFromPixel(e) {
                        const r = o.bu();
                        r[0] = e.x / this.width * 2 - 1,
                        r[1] = -1 * (e.y / this.height * 2 - 1),
                        r[2] = 1,
                        r[3] = 1,
                        o.av(r, r, this._globeViewProjMatrixNoCorrectionInverted),
                        r[0] /= r[3],
                        r[1] /= r[3],
                        r[2] /= r[3];
                        const s = o.bo();
                        s[0] = r[0] - this._cameraPosition[0],
                        s[1] = r[1] - this._cameraPosition[1],
                        s[2] = r[2] - this._cameraPosition[2];
                        const c = o.bo();
                        return o.aU(c, s),
                        c
                    }
                    isSurfacePointVisible(e) {
                        const r = this._cachedClippingPlane;
                        return r[0] * e[0] + r[1] * e[1] + r[2] * e[2] + r[3] >= 0
                    }
                    isSurfacePointOnScreen(e) {
                        if (!this.isSurfacePointVisible(e))
                            return !1;
                        const r = o.bu();
                        return o.av(r, [...e, 1], this._globeViewProjMatrixNoCorrection),
                        r[0] /= r[3],
                        r[1] /= r[3],
                        r[2] /= r[3],
                        r[0] > -1 && r[0] < 1 && r[1] > -1 && r[1] < 1 && r[2] > -1 && r[2] < 1
                    }
                    rayPlanetIntersection(e, r) {
                        const s = o.aW(e, r)
                          , c = o.bo()
                          , d = o.bo();
                        o.aQ(d, r, s),
                        o.aT(c, e, d);
                        const m = 1 - o.aW(c, c);
                        if (m < 0)
                            return null;
                        const v = o.aW(e, e) - 1
                          , b = -s + (s < 0 ? 1 : -1) * Math.sqrt(m)
                          , P = v / b
                          , M = b;
                        return {
                            tMin: Math.min(P, M),
                            tMax: Math.max(P, M)
                        }
                    }
                    unprojectScreenPoint(e) {
                        const r = this._cameraPosition
                          , s = this.getRayDirectionFromPixel(e)
                          , c = this.rayPlanetIntersection(r, s);
                        if (c) {
                            const M = o.bo();
                            o.aR(M, r, [s[0] * c.tMin, s[1] * c.tMin, s[2] * c.tMin]);
                            const D = o.bo();
                            return o.aU(D, M),
                            po(D)
                        }
                        const d = this._cachedClippingPlane
                          , m = d[0] * s[0] + d[1] * s[1] + d[2] * s[2]
                          , v = -o.b0(d, r) / m
                          , b = o.bo();
                        if (v > 0)
                            o.aR(b, r, [s[0] * v, s[1] * v, s[2] * v]);
                        else {
                            const M = o.bo();
                            o.aR(M, r, [2 * s[0], 2 * s[1], 2 * s[2]]);
                            const D = o.b0(this._cachedClippingPlane, M);
                            o.aT(b, M, [this._cachedClippingPlane[0] * D, this._cachedClippingPlane[1] * D, this._cachedClippingPlane[2] * D])
                        }
                        const P = function(M) {
                            const D = o.bo();
                            return D[0] = M[0] * -M[3],
                            D[1] = M[1] * -M[3],
                            D[2] = M[2] * -M[3],
                            {
                                center: D,
                                radius: Math.sqrt(1 - M[3] * M[3])
                            }
                        }(d);
                        return po(function(M, D, L) {
                            const B = o.bo();
                            o.aT(B, L, M);
                            const Z = o.bo();
                            return o.bp(Z, M, B, D / o.a_(B)),
                            Z
                        }(P.center, P.radius, b))
                    }
                    getMatrixForModel(e, r) {
                        const s = o.S.convert(e)
                          , c = 1 / o.bt
                          , d = o.b8();
                        return o.by(d, d, s.lng / 180 * Math.PI),
                        o.b6(d, d, -s.lat / 180 * Math.PI),
                        o.M(d, d, [0, 0, 1 + r / o.bt]),
                        o.b6(d, d, .5 * Math.PI),
                        o.N(d, d, [c, c, c]),
                        d
                    }
                    getProjectionDataForCustomLayer(e=!0) {
                        const r = this.getProjectionData({
                            overscaledTileID: new o.Z(0,0,0,0,0),
                            applyGlobeMatrix: e
                        });
                        return r.tileMercatorCoords = [0, 0, 1, 1],
                        r
                    }
                    getFastPathSimpleProjectionMatrix(e) {}
                }
                class ta {
                    get pixelsToClipSpaceMatrix() {
                        return this._helper.pixelsToClipSpaceMatrix
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._helper.clipSpaceToPixelsMatrix
                    }
                    get pixelsToGLUnits() {
                        return this._helper.pixelsToGLUnits
                    }
                    get centerOffset() {
                        return this._helper.centerOffset
                    }
                    get size() {
                        return this._helper.size
                    }
                    get rotationMatrix() {
                        return this._helper.rotationMatrix
                    }
                    get centerPoint() {
                        return this._helper.centerPoint
                    }
                    get pixelsPerMeter() {
                        return this._helper.pixelsPerMeter
                    }
                    setMinZoom(e) {
                        this._helper.setMinZoom(e)
                    }
                    setMaxZoom(e) {
                        this._helper.setMaxZoom(e)
                    }
                    setMinPitch(e) {
                        this._helper.setMinPitch(e)
                    }
                    setMaxPitch(e) {
                        this._helper.setMaxPitch(e)
                    }
                    setRenderWorldCopies(e) {
                        this._helper.setRenderWorldCopies(e)
                    }
                    setBearing(e) {
                        this._helper.setBearing(e)
                    }
                    setPitch(e) {
                        this._helper.setPitch(e)
                    }
                    setRoll(e) {
                        this._helper.setRoll(e)
                    }
                    setFov(e) {
                        this._helper.setFov(e)
                    }
                    setZoom(e) {
                        this._helper.setZoom(e)
                    }
                    setCenter(e) {
                        this._helper.setCenter(e)
                    }
                    setElevation(e) {
                        this._helper.setElevation(e)
                    }
                    setMinElevationForCurrentTile(e) {
                        this._helper.setMinElevationForCurrentTile(e)
                    }
                    setPadding(e) {
                        this._helper.setPadding(e)
                    }
                    interpolatePadding(e, r, s) {
                        return this._helper.interpolatePadding(e, r, s)
                    }
                    isPaddingEqual(e) {
                        return this._helper.isPaddingEqual(e)
                    }
                    resize(e, r, s=!0) {
                        this._helper.resize(e, r, s)
                    }
                    getMaxBounds() {
                        return this._helper.getMaxBounds()
                    }
                    setMaxBounds(e) {
                        this._helper.setMaxBounds(e)
                    }
                    overrideNearFarZ(e, r) {
                        this._helper.overrideNearFarZ(e, r)
                    }
                    clearNearFarZOverride() {
                        this._helper.clearNearFarZOverride()
                    }
                    getCameraQueryGeometry(e) {
                        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
                    }
                    get tileSize() {
                        return this._helper.tileSize
                    }
                    get tileZoom() {
                        return this._helper.tileZoom
                    }
                    get scale() {
                        return this._helper.scale
                    }
                    get worldSize() {
                        return this._helper.worldSize
                    }
                    get width() {
                        return this._helper.width
                    }
                    get height() {
                        return this._helper.height
                    }
                    get lngRange() {
                        return this._helper.lngRange
                    }
                    get latRange() {
                        return this._helper.latRange
                    }
                    get minZoom() {
                        return this._helper.minZoom
                    }
                    get maxZoom() {
                        return this._helper.maxZoom
                    }
                    get zoom() {
                        return this._helper.zoom
                    }
                    get center() {
                        return this._helper.center
                    }
                    get minPitch() {
                        return this._helper.minPitch
                    }
                    get maxPitch() {
                        return this._helper.maxPitch
                    }
                    get pitch() {
                        return this._helper.pitch
                    }
                    get pitchInRadians() {
                        return this._helper.pitchInRadians
                    }
                    get roll() {
                        return this._helper.roll
                    }
                    get rollInRadians() {
                        return this._helper.rollInRadians
                    }
                    get bearing() {
                        return this._helper.bearing
                    }
                    get bearingInRadians() {
                        return this._helper.bearingInRadians
                    }
                    get fov() {
                        return this._helper.fov
                    }
                    get fovInRadians() {
                        return this._helper.fovInRadians
                    }
                    get elevation() {
                        return this._helper.elevation
                    }
                    get minElevationForCurrentTile() {
                        return this._helper.minElevationForCurrentTile
                    }
                    get padding() {
                        return this._helper.padding
                    }
                    get unmodified() {
                        return this._helper.unmodified
                    }
                    get renderWorldCopies() {
                        return this._helper.renderWorldCopies
                    }
                    get cameraToCenterDistance() {
                        return this._helper.cameraToCenterDistance
                    }
                    get nearZ() {
                        return this._helper.nearZ
                    }
                    get farZ() {
                        return this._helper.farZ
                    }
                    get autoCalculateNearFarZ() {
                        return this._helper.autoCalculateNearFarZ
                    }
                    get isGlobeRendering() {
                        return this._globeness > 0
                    }
                    setTransitionState(e, r) {
                        this._globeness = e,
                        this._globeLatitudeErrorCorrectionRadians = r,
                        this._calcMatrices(),
                        this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(),
                        this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame()
                    }
                    get currentTransform() {
                        return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform
                    }
                    constructor() {
                        this._globeLatitudeErrorCorrectionRadians = 0,
                        this._globeness = 1,
                        this._helper = new Ua({
                            calcMatrices: () => {
                                this._calcMatrices()
                            }
                            ,
                            getConstrained: (e, r) => this.getConstrained(e, r)
                        }),
                        this._globeness = 1,
                        this._mercatorTransform = new Li,
                        this._verticalPerspectiveTransform = new zs
                    }
                    clone() {
                        const e = new ta;
                        return e._globeness = this._globeness,
                        e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians,
                        e.apply(this),
                        e
                    }
                    apply(e) {
                        this._helper.apply(e),
                        this._mercatorTransform.apply(this),
                        this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians)
                    }
                    get projectionMatrix() {
                        return this.currentTransform.projectionMatrix
                    }
                    get modelViewProjectionMatrix() {
                        return this.currentTransform.modelViewProjectionMatrix
                    }
                    get inverseProjectionMatrix() {
                        return this.currentTransform.inverseProjectionMatrix
                    }
                    get cameraPosition() {
                        return this.currentTransform.cameraPosition
                    }
                    getProjectionData(e) {
                        const r = this._mercatorTransform.getProjectionData(e)
                          , s = this._verticalPerspectiveTransform.getProjectionData(e);
                        return {
                            mainMatrix: this.isGlobeRendering ? s.mainMatrix : r.mainMatrix,
                            clippingPlane: s.clippingPlane,
                            tileMercatorCoords: s.tileMercatorCoords,
                            projectionTransition: e.applyGlobeMatrix ? this._globeness : 0,
                            fallbackMatrix: r.fallbackMatrix
                        }
                    }
                    isLocationOccluded(e) {
                        return this.currentTransform.isLocationOccluded(e)
                    }
                    transformLightDirection(e) {
                        return this.currentTransform.transformLightDirection(e)
                    }
                    getPixelScale() {
                        return o.bj(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness)
                    }
                    getCircleRadiusCorrection() {
                        return o.bj(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness)
                    }
                    getPitchedTextCorrection(e, r, s) {
                        const c = this._mercatorTransform.getPitchedTextCorrection(e, r, s)
                          , d = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, r, s);
                        return o.bj(c, d, this._globeness)
                    }
                    projectTileCoordinates(e, r, s, c) {
                        return this.currentTransform.projectTileCoordinates(e, r, s, c)
                    }
                    _calcMatrices() {
                        this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians),
                        this._helper._nearZ = this._verticalPerspectiveTransform.nearZ,
                        this._helper._farZ = this._verticalPerspectiveTransform.farZ,
                        this._mercatorTransform.apply(this, !0, this.isGlobeRendering),
                        this._helper._nearZ = this._mercatorTransform.nearZ,
                        this._helper._farZ = this._mercatorTransform.farZ)
                    }
                    calculateFogMatrix(e) {
                        return this.currentTransform.calculateFogMatrix(e)
                    }
                    getVisibleUnwrappedCoordinates(e) {
                        return this.currentTransform.getVisibleUnwrappedCoordinates(e)
                    }
                    getCameraFrustum() {
                        return this.currentTransform.getCameraFrustum()
                    }
                    getClippingPlane() {
                        return this.currentTransform.getClippingPlane()
                    }
                    getCoveringTilesDetailsProvider() {
                        return this.currentTransform.getCoveringTilesDetailsProvider()
                    }
                    recalculateZoomAndCenter(e) {
                        this._mercatorTransform.recalculateZoomAndCenter(e),
                        this._verticalPerspectiveTransform.recalculateZoomAndCenter(e)
                    }
                    maxPitchScaleFactor() {
                        return this._mercatorTransform.maxPitchScaleFactor()
                    }
                    getCameraPoint() {
                        return this._helper.getCameraPoint()
                    }
                    getCameraAltitude() {
                        return this._helper.getCameraAltitude()
                    }
                    getCameraLngLat() {
                        return this._helper.getCameraLngLat()
                    }
                    lngLatToCameraDepth(e, r) {
                        return this.currentTransform.lngLatToCameraDepth(e, r)
                    }
                    populateCache(e) {
                        this._mercatorTransform.populateCache(e),
                        this._verticalPerspectiveTransform.populateCache(e)
                    }
                    getBounds() {
                        return this.currentTransform.getBounds()
                    }
                    getConstrained(e, r) {
                        return this.currentTransform.getConstrained(e, r)
                    }
                    calculateCenterFromCameraLngLatAlt(e, r, s, c) {
                        return this._helper.calculateCenterFromCameraLngLatAlt(e, r, s, c)
                    }
                    setLocationAtPoint(e, r) {
                        if (!this.isGlobeRendering)
                            return this._mercatorTransform.setLocationAtPoint(e, r),
                            void this.apply(this._mercatorTransform);
                        this._verticalPerspectiveTransform.setLocationAtPoint(e, r),
                        this.apply(this._verticalPerspectiveTransform)
                    }
                    locationToScreenPoint(e, r) {
                        return this.currentTransform.locationToScreenPoint(e, r)
                    }
                    screenPointToMercatorCoordinate(e, r) {
                        return this.currentTransform.screenPointToMercatorCoordinate(e, r)
                    }
                    screenPointToLocation(e, r) {
                        return this.currentTransform.screenPointToLocation(e, r)
                    }
                    isPointOnMapSurface(e, r) {
                        return this.currentTransform.isPointOnMapSurface(e, r)
                    }
                    getRayDirectionFromPixel(e) {
                        return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e)
                    }
                    getMatrixForModel(e, r) {
                        return this.currentTransform.getMatrixForModel(e, r)
                    }
                    getProjectionDataForCustomLayer(e=!0) {
                        const r = this._mercatorTransform.getProjectionDataForCustomLayer(e);
                        if (!this.isGlobeRendering)
                            return r;
                        const s = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
                        return s.fallbackMatrix = r.mainMatrix,
                        s
                    }
                    getFastPathSimpleProjectionMatrix(e) {
                        return this.currentTransform.getFastPathSimpleProjectionMatrix(e)
                    }
                }
                class Zn {
                    get useGlobeControls() {
                        return !0
                    }
                    handlePanInertia(e, r) {
                        const s = fo(e, r);
                        return Math.abs(s.lng - r.center.lng) > 180 && (s.lng = r.center.lng + 179.5 * Math.sign(s.lng - r.center.lng)),
                        {
                            easingCenter: s,
                            easingOffset: new o.P(0,0)
                        }
                    }
                    handleMapControlsRollPitchBearingZoom(e, r) {
                        const s = e.around
                          , c = r.screenPointToLocation(s);
                        e.bearingDelta && r.setBearing(r.bearing + e.bearingDelta),
                        e.pitchDelta && r.setPitch(r.pitch + e.pitchDelta),
                        e.rollDelta && r.setRoll(r.roll + e.rollDelta);
                        const d = r.zoom;
                        e.zoomDelta && r.setZoom(r.zoom + e.zoomDelta);
                        const m = r.zoom - d;
                        if (m === 0)
                            return;
                        const v = o.bz(r.center.lng, c.lng)
                          , b = v / (Math.abs(v / 180) + 1)
                          , P = o.bz(r.center.lat, c.lat)
                          , M = r.getRayDirectionFromPixel(s)
                          , D = r.cameraPosition
                          , L = -1 * o.aW(D, M)
                          , B = o.bo();
                        o.aR(B, D, [M[0] * L, M[1] * L, M[2] * L]);
                        const Z = o.aY(B) - 1
                          , te = Math.exp(.5 * -Math.max(Z - .3, 0))
                          , ee = Ms(r.worldSize, r.center.lat) / Math.min(r.width, r.height)
                          , ne = o.bm(ee, .9, .5, 1, .25)
                          , oe = (1 - o.ae(-m)) * Math.min(te, ne)
                          , me = r.center.lat
                          , ce = r.zoom
                          , Te = new o.S(r.center.lng + b * oe,o.ag(r.center.lat + P * oe, -o.ah, o.ah));
                        r.setLocationAtPoint(c, s);
                        const Pe = r.center
                          , pe = o.bm(Math.abs(v), 45, 85, 0, 1)
                          , Fe = o.bm(ee, .75, .35, 0, 1)
                          , Ye = Math.pow(Math.max(pe, Fe), .25)
                          , $e = o.bz(Pe.lng, Te.lng)
                          , He = o.bz(Pe.lat, Te.lat);
                        r.setCenter(new o.S(Pe.lng + $e * Ye,Pe.lat + He * Ye).wrap()),
                        r.setZoom(ce + Yi(me, r.center.lat))
                    }
                    handleMapControlsPan(e, r, s) {
                        if (!e.panDelta)
                            return;
                        const c = r.center.lat
                          , d = r.zoom;
                        r.setCenter(fo(e.panDelta, r).wrap()),
                        r.setZoom(d + Yi(c, r.center.lat))
                    }
                    cameraForBoxAndBearing(e, r, s, c, d) {
                        const m = Di(e, r, s, c, d)
                          , v = r.left / d.width * 2 - 1
                          , b = (d.width - r.right) / d.width * 2 - 1
                          , P = r.top / d.height * -2 + 1
                          , M = (d.height - r.bottom) / d.height * -2 + 1
                          , D = o.bz(s.getWest(), s.getEast()) < 0
                          , L = D ? s.getEast() : s.getWest()
                          , B = D ? s.getWest() : s.getEast()
                          , Z = Math.max(s.getNorth(), s.getSouth())
                          , te = Math.min(s.getNorth(), s.getSouth())
                          , ee = L + .5 * o.bz(L, B)
                          , ne = Z + .5 * o.bz(Z, te)
                          , oe = d.clone();
                        oe.setCenter(m.center),
                        oe.setBearing(m.bearing),
                        oe.setPitch(0),
                        oe.setRoll(0),
                        oe.setZoom(m.zoom);
                        const me = oe.modelViewProjectionMatrix
                          , ce = [ln(s.getNorthWest()), ln(s.getNorthEast()), ln(s.getSouthWest()), ln(s.getSouthEast()), ln(new o.S(B,ne)), ln(new o.S(L,ne)), ln(new o.S(ee,Z)), ln(new o.S(ee,te))]
                          , Te = ln(m.center);
                        let Pe = Number.POSITIVE_INFINITY;
                        for (const pe of ce)
                            v < 0 && (Pe = Zn.getLesserNonNegativeNonNull(Pe, Zn.solveVectorScale(pe, Te, me, "x", v))),
                            b > 0 && (Pe = Zn.getLesserNonNegativeNonNull(Pe, Zn.solveVectorScale(pe, Te, me, "x", b))),
                            P > 0 && (Pe = Zn.getLesserNonNegativeNonNull(Pe, Zn.solveVectorScale(pe, Te, me, "y", P))),
                            M < 0 && (Pe = Zn.getLesserNonNegativeNonNull(Pe, Zn.solveVectorScale(pe, Te, me, "y", M)));
                        if (Number.isFinite(Pe) && Pe !== 0)
                            return m.zoom = oe.zoom + o.aj(Pe),
                            m;
                        sn()
                    }
                    handleJumpToCenterZoom(e, r) {
                        const s = e.center.lat
                          , c = e.getConstrained(r.center ? o.S.convert(r.center) : e.center, e.zoom).center;
                        e.setCenter(c.wrap());
                        const d = r.zoom !== void 0 ? +r.zoom : e.zoom + Yi(s, c.lat);
                        e.zoom !== d && e.setZoom(d)
                    }
                    handleEaseTo(e, r) {
                        const s = e.zoom
                          , c = e.center
                          , d = e.padding
                          , m = {
                            roll: e.roll,
                            pitch: e.pitch,
                            bearing: e.bearing
                        }
                          , v = {
                            roll: r.roll === void 0 ? e.roll : r.roll,
                            pitch: r.pitch === void 0 ? e.pitch : r.pitch,
                            bearing: r.bearing === void 0 ? e.bearing : r.bearing
                        }
                          , b = r.zoom !== void 0
                          , P = !e.isPaddingEqual(r.padding);
                        let M = !1;
                        const D = r.center ? o.S.convert(r.center) : c
                          , L = e.getConstrained(D, s).center;
                        ea(e, L);
                        const B = e.clone();
                        B.setCenter(L),
                        B.setZoom(b ? +r.zoom : s + Yi(c.lat, D.lat)),
                        B.setBearing(r.bearing);
                        const Z = new o.P(o.ag(e.centerPoint.x + r.offsetAsPoint.x, 0, e.width),o.ag(e.centerPoint.y + r.offsetAsPoint.y, 0, e.height));
                        B.setLocationAtPoint(L, Z);
                        const te = (r.offset && r.offsetAsPoint.mag()) > 0 ? B.center : L
                          , ee = b ? +r.zoom : s + Yi(c.lat, te.lat)
                          , ne = s + Yi(c.lat, 0)
                          , oe = ee + Yi(te.lat, 0)
                          , me = o.bz(c.lng, te.lng)
                          , ce = o.bz(c.lat, te.lat)
                          , Te = o.ae(oe - ne);
                        return M = ee !== s,
                        {
                            easeFunc: Pe => {
                                if (o.bd(m, v) || on({
                                    startEulerAngles: m,
                                    endEulerAngles: v,
                                    tr: e,
                                    k: Pe,
                                    useSlerp: m.roll != v.roll
                                }),
                                P && e.interpolatePadding(d, r.padding, Pe),
                                r.around)
                                    o.w("Easing around a point is not supported under globe projection."),
                                    e.setLocationAtPoint(r.around, r.aroundPoint);
                                else {
                                    const pe = oe > ne ? Math.min(2, Te) : Math.max(.5, Te)
                                      , Fe = Math.pow(pe, 1 - Pe)
                                      , Ye = Es(c, me, ce, Pe * Fe);
                                    e.setCenter(Ye.wrap())
                                }
                                if (M) {
                                    const pe = o.C.number(ne, oe, Pe) + Yi(0, e.center.lat);
                                    e.setZoom(pe)
                                }
                            }
                            ,
                            isZooming: M,
                            elevationCenter: te
                        }
                    }
                    handleFlyTo(e, r) {
                        const s = r.zoom !== void 0
                          , c = e.center
                          , d = e.zoom
                          , m = e.padding
                          , v = !e.isPaddingEqual(r.padding)
                          , b = e.getConstrained(o.S.convert(r.center || r.locationAtOffset), d).center
                          , P = s ? +r.zoom : e.zoom + Yi(e.center.lat, b.lat)
                          , M = e.clone();
                        M.setCenter(b),
                        M.setZoom(P),
                        M.setBearing(r.bearing);
                        const D = new o.P(o.ag(e.centerPoint.x + r.offsetAsPoint.x, 0, e.width),o.ag(e.centerPoint.y + r.offsetAsPoint.y, 0, e.height));
                        M.setLocationAtPoint(b, D);
                        const L = M.center;
                        ea(e, L);
                        const B = function(ce, Te, Pe) {
                            const pe = ln(Te)
                              , Fe = ln(Pe)
                              , Ye = o.aW(pe, Fe)
                              , $e = Math.acos(Ye)
                              , He = ho(ce);
                            return $e / (2 * Math.PI) * He
                        }(e, c, L)
                          , Z = d + Yi(c.lat, 0)
                          , te = P + Yi(L.lat, 0)
                          , ee = o.ae(te - Z);
                        let ne;
                        if (typeof r.minZoom == "number") {
                            const ce = +r.minZoom + Yi(L.lat, 0)
                              , Te = Math.min(ce, Z, te) + Yi(0, L.lat)
                              , Pe = e.getConstrained(L, Te).zoom + Yi(L.lat, 0);
                            ne = o.ae(Pe - Z)
                        }
                        const oe = o.bz(c.lng, L.lng)
                          , me = o.bz(c.lat, L.lat);
                        return {
                            easeFunc: (ce, Te, Pe, pe) => {
                                const Fe = Es(c, oe, me, Pe);
                                v && e.interpolatePadding(m, r.padding, ce);
                                const Ye = ce === 1 ? L : Fe;
                                e.setCenter(Ye.wrap());
                                const $e = Z + o.aj(Te);
                                e.setZoom(ce === 1 ? P : $e + Yi(0, Ye.lat))
                            }
                            ,
                            scaleOfZoom: ee,
                            targetCenter: L,
                            scaleOfMinZoom: ne,
                            pixelPathLength: B
                        }
                    }
                    static solveVectorScale(e, r, s, c, d) {
                        const m = c === "x" ? [s[0], s[4], s[8], s[12]] : [s[1], s[5], s[9], s[13]]
                          , v = [s[3], s[7], s[11], s[15]]
                          , b = e[0] * m[0] + e[1] * m[1] + e[2] * m[2]
                          , P = e[0] * v[0] + e[1] * v[1] + e[2] * v[2]
                          , M = r[0] * m[0] + r[1] * m[1] + r[2] * m[2]
                          , D = r[0] * v[0] + r[1] * v[1] + r[2] * v[2];
                        return M + d * P === b + d * D || v[3] * (b - M) + m[3] * (D - P) + b * D == M * P ? null : (M + m[3] - d * D - d * v[3]) / (M - b - d * D + d * P)
                    }
                    static getLesserNonNegativeNonNull(e, r) {
                        return r !== null && r >= 0 && r < e ? r : e
                    }
                }
                class mc {
                    constructor(e) {
                        this._globe = e,
                        this._mercatorCameraHelper = new tl,
                        this._verticalPerspectiveCameraHelper = new Zn
                    }
                    get useGlobeControls() {
                        return this._globe.useGlobeRendering
                    }
                    get currentHelper() {
                        return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper
                    }
                    handlePanInertia(e, r) {
                        return this.currentHelper.handlePanInertia(e, r)
                    }
                    handleMapControlsRollPitchBearingZoom(e, r) {
                        return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, r)
                    }
                    handleMapControlsPan(e, r, s) {
                        this.currentHelper.handleMapControlsPan(e, r, s)
                    }
                    cameraForBoxAndBearing(e, r, s, c, d) {
                        return this.currentHelper.cameraForBoxAndBearing(e, r, s, c, d)
                    }
                    handleJumpToCenterZoom(e, r) {
                        this.currentHelper.handleJumpToCenterZoom(e, r)
                    }
                    handleEaseTo(e, r) {
                        return this.currentHelper.handleEaseTo(e, r)
                    }
                    handleFlyTo(e, r) {
                        return this.currentHelper.handleFlyTo(e, r)
                    }
                }
                const _o = (h, e) => o.y(h, e && e.filter(r => r.identifier !== "source.canvas"))
                  , Ls = o.bD();
                class _c extends o.E {
                    constructor(e, r={}) {
                        super(),
                        this._rtlPluginLoaded = () => {
                            for (const s in this.sourceCaches) {
                                const c = this.sourceCaches[s].getSource().type;
                                c !== "vector" && c !== "geojson" || this.sourceCaches[s].reload()
                            }
                        }
                        ,
                        this.map = e,
                        this.dispatcher = new Ft(ht(),e._getMapId()),
                        this.dispatcher.registerMessageHandler("GG", (s, c) => this.getGlyphs(s, c)),
                        this.dispatcher.registerMessageHandler("GI", (s, c) => this.getImages(s, c)),
                        this.imageManager = new et,
                        this.imageManager.setEventedParent(this),
                        this.glyphManager = new ct(e._requestManager,r.localIdeographFontFamily),
                        this.lineAtlas = new ue(256,512),
                        this.crossTileSymbolIndex = new en,
                        this._spritesImagesIds = {},
                        this._layers = {},
                        this._order = [],
                        this.sourceCaches = {},
                        this.zoomHistory = new o.bE,
                        this._loaded = !1,
                        this._availableImages = [],
                        this._globalState = {},
                        this._resetUpdates(),
                        this.dispatcher.broadcast("SR", o.bF()),
                        vr().on(Xt, this._rtlPluginLoaded),
                        this.on("data", s => {
                            if (s.dataType !== "source" || s.sourceDataType !== "metadata")
                                return;
                            const c = this.sourceCaches[s.sourceId];
                            if (!c)
                                return;
                            const d = c.getSource();
                            if (d && d.vectorLayerIds)
                                for (const m in this._layers) {
                                    const v = this._layers[m];
                                    v.source === d.id && this._validateLayer(v)
                                }
                        }
                        )
                    }
                    setGlobalStateProperty(e, r) {
                        var s, c, d;
                        this._checkLoaded();
                        const m = r === null ? (d = (c = (s = this.stylesheet.state) === null || s === void 0 ? void 0 : s[e]) === null || c === void 0 ? void 0 : c.default) !== null && d !== void 0 ? d : null : r;
                        if (o.bG(m, this._globalState[e]))
                            return this;
                        this._globalState[e] = m;
                        const v = this._findGlobalStateAffectedSources([e]);
                        for (const b in this.sourceCaches)
                            v.has(b) && (this._reloadSource(b),
                            this._changed = !0)
                    }
                    getGlobalState() {
                        return this._globalState
                    }
                    setGlobalState(e) {
                        this._checkLoaded();
                        const r = [];
                        for (const c in e)
                            !o.bG(this._globalState[c], e[c].default) && (r.push(c),
                            this._globalState[c] = e[c].default);
                        const s = this._findGlobalStateAffectedSources(r);
                        for (const c in this.sourceCaches)
                            s.has(c) && (this._reloadSource(c),
                            this._changed = !0)
                    }
                    _findGlobalStateAffectedSources(e) {
                        if (e.length === 0)
                            return new Set;
                        const r = new Set;
                        for (const s in this._layers) {
                            const c = this._layers[s]
                              , d = c.getLayoutAffectingGlobalStateRefs();
                            for (const m of e)
                                d.has(m) && r.add(c.source)
                        }
                        return r
                    }
                    loadURL(e, r={}, s) {
                        this.fire(new o.l("dataloading",{
                            dataType: "style"
                        })),
                        r.validate = typeof r.validate != "boolean" || r.validate;
                        const c = this.map._requestManager.transformRequest(e, "Style");
                        this._loadStyleRequest = new AbortController;
                        const d = this._loadStyleRequest;
                        o.j(c, this._loadStyleRequest).then(m => {
                            this._loadStyleRequest = null,
                            this._load(m.data, r, s)
                        }
                        ).catch(m => {
                            this._loadStyleRequest = null,
                            m && !d.signal.aborted && this.fire(new o.k(m))
                        }
                        )
                    }
                    loadJSON(e, r={}, s) {
                        this.fire(new o.l("dataloading",{
                            dataType: "style"
                        })),
                        this._frameRequest = new AbortController,
                        he.frameAsync(this._frameRequest).then( () => {
                            this._frameRequest = null,
                            r.validate = r.validate !== !1,
                            this._load(e, r, s)
                        }
                        ).catch( () => {}
                        )
                    }
                    loadEmpty() {
                        this.fire(new o.l("dataloading",{
                            dataType: "style"
                        })),
                        this._load(Ls, {
                            validate: !1
                        })
                    }
                    _load(e, r, s) {
                        var c, d, m;
                        const v = r.transformStyle ? r.transformStyle(s, e) : e;
                        if (!r.validate || !_o(this, o.z(v))) {
                            this._loaded = !0,
                            this.stylesheet = v;
                            for (const b in v.sources)
                                this.addSource(b, v.sources[b], {
                                    validate: !1
                                });
                            v.sprite ? this._loadSprite(v.sprite) : this.imageManager.setLoaded(!0),
                            this.glyphManager.setURL(v.glyphs),
                            this._createLayers(),
                            this.light = new Q(this.stylesheet.light),
                            this._setProjectionInternal(((c = this.stylesheet.projection) === null || c === void 0 ? void 0 : c.type) || "mercator"),
                            this.sky = new xe(this.stylesheet.sky),
                            this.map.setTerrain((d = this.stylesheet.terrain) !== null && d !== void 0 ? d : null),
                            this.setGlobalState((m = this.stylesheet.state) !== null && m !== void 0 ? m : null),
                            this.fire(new o.l("data",{
                                dataType: "style"
                            })),
                            this.fire(new o.l("style.load"))
                        }
                    }
                    _createLayers() {
                        const e = o.bH(this.stylesheet.layers);
                        this.dispatcher.broadcast("SL", e),
                        this._order = e.map(r => r.id),
                        this._layers = {},
                        this._serializedLayers = null;
                        for (const r of e) {
                            const s = o.bI(r);
                            s.setEventedParent(this, {
                                layer: {
                                    id: r.id
                                }
                            }),
                            this._layers[r.id] = s
                        }
                    }
                    _loadSprite(e, r=!1, s=void 0) {
                        let c;
                        this.imageManager.setLoaded(!1),
                        this._spriteRequest = new AbortController,
                        function(d, m, v, b) {
                            return o._(this, void 0, void 0, function*() {
                                const P = rt(d)
                                  , M = v > 1 ? "@2x" : ""
                                  , D = {}
                                  , L = {};
                                for (const {id: B, url: Z} of P) {
                                    const te = m.transformRequest(Ue(Z, M, ".json"), "SpriteJSON");
                                    D[B] = o.j(te, b);
                                    const ee = m.transformRequest(Ue(Z, M, ".png"), "SpriteImage");
                                    L[B] = Ze.getImage(ee, b)
                                }
                                return yield Promise.all([...Object.values(D), ...Object.values(L)]),
                                function(B, Z) {
                                    return o._(this, void 0, void 0, function*() {
                                        const te = {};
                                        for (const ee in B) {
                                            te[ee] = {};
                                            const ne = he.getImageCanvasContext((yield Z[ee]).data)
                                              , oe = (yield B[ee]).data;
                                            for (const me in oe) {
                                                const {width: ce, height: Te, x: Pe, y: pe, sdf: Fe, pixelRatio: Ye, stretchX: $e, stretchY: He, content: Je, textFitWidth: qt, textFitHeight: Nt} = oe[me];
                                                te[ee][me] = {
                                                    data: null,
                                                    pixelRatio: Ye,
                                                    sdf: Fe,
                                                    stretchX: $e,
                                                    stretchY: He,
                                                    content: Je,
                                                    textFitWidth: qt,
                                                    textFitHeight: Nt,
                                                    spriteData: {
                                                        width: ce,
                                                        height: Te,
                                                        x: Pe,
                                                        y: pe,
                                                        context: ne
                                                    }
                                                }
                                            }
                                        }
                                        return te
                                    })
                                }(D, L)
                            })
                        }(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(d => {
                            if (this._spriteRequest = null,
                            d)
                                for (const m in d) {
                                    this._spritesImagesIds[m] = [];
                                    const v = this._spritesImagesIds[m] ? this._spritesImagesIds[m].filter(b => !(b in d)) : [];
                                    for (const b of v)
                                        this.imageManager.removeImage(b),
                                        this._changedImages[b] = !0;
                                    for (const b in d[m]) {
                                        const P = m === "default" ? b : `${m}:${b}`;
                                        this._spritesImagesIds[m].push(P),
                                        P in this.imageManager.images ? this.imageManager.updateImage(P, d[m][b], !1) : this.imageManager.addImage(P, d[m][b]),
                                        r && (this._changedImages[P] = !0)
                                    }
                                }
                        }
                        ).catch(d => {
                            this._spriteRequest = null,
                            c = d,
                            this.fire(new o.k(c))
                        }
                        ).finally( () => {
                            this.imageManager.setLoaded(!0),
                            this._availableImages = this.imageManager.listImages(),
                            r && (this._changed = !0),
                            this.dispatcher.broadcast("SI", this._availableImages),
                            this.fire(new o.l("data",{
                                dataType: "style"
                            })),
                            s && s(c)
                        }
                        )
                    }
                    _unloadSprite() {
                        for (const e of Object.values(this._spritesImagesIds).flat())
                            this.imageManager.removeImage(e),
                            this._changedImages[e] = !0;
                        this._spritesImagesIds = {},
                        this._availableImages = this.imageManager.listImages(),
                        this._changed = !0,
                        this.dispatcher.broadcast("SI", this._availableImages),
                        this.fire(new o.l("data",{
                            dataType: "style"
                        }))
                    }
                    _validateLayer(e) {
                        const r = this.sourceCaches[e.source];
                        if (!r)
                            return;
                        const s = e.sourceLayer;
                        if (!s)
                            return;
                        const c = r.getSource();
                        (c.type === "geojson" || c.vectorLayerIds && c.vectorLayerIds.indexOf(s) === -1) && this.fire(new o.k(new Error(`Source layer "${s}" does not exist on source "${c.id}" as specified by style layer "${e.id}".`)))
                    }
                    loaded() {
                        if (!this._loaded || Object.keys(this._updatedSources).length)
                            return !1;
                        for (const e in this.sourceCaches)
                            if (!this.sourceCaches[e].loaded())
                                return !1;
                        return !!this.imageManager.isLoaded()
                    }
                    _serializeByIds(e, r=!1) {
                        const s = this._serializedAllLayers();
                        if (!e || e.length === 0)
                            return Object.values(r ? o.bJ(s) : s);
                        const c = [];
                        for (const d of e)
                            if (s[d]) {
                                const m = r ? o.bJ(s[d]) : s[d];
                                c.push(m)
                            }
                        return c
                    }
                    _serializedAllLayers() {
                        let e = this._serializedLayers;
                        if (e)
                            return e;
                        e = this._serializedLayers = {};
                        const r = Object.keys(this._layers);
                        for (const s of r) {
                            const c = this._layers[s];
                            c.type !== "custom" && (e[s] = c.serialize())
                        }
                        return e
                    }
                    hasTransitions() {
                        var e, r, s;
                        if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((r = this.sky) === null || r === void 0) && r.hasTransition() || !((s = this.projection) === null || s === void 0) && s.hasTransition())
                            return !0;
                        for (const c in this.sourceCaches)
                            if (this.sourceCaches[c].hasTransition())
                                return !0;
                        for (const c in this._layers)
                            if (this._layers[c].hasTransition())
                                return !0;
                        return !1
                    }
                    _checkLoaded() {
                        if (!this._loaded)
                            throw new Error("Style is not done loading.")
                    }
                    update(e) {
                        if (!this._loaded)
                            return;
                        const r = this._changed;
                        if (r) {
                            const c = Object.keys(this._updatedLayers)
                              , d = Object.keys(this._removedLayers);
                            (c.length || d.length) && this._updateWorkerLayers(c, d);
                            for (const m in this._updatedSources) {
                                const v = this._updatedSources[m];
                                if (v === "reload")
                                    this._reloadSource(m);
                                else {
                                    if (v !== "clear")
                                        throw new Error(`Invalid action ${v}`);
                                    this._clearSource(m)
                                }
                            }
                            this._updateTilesForChangedImages(),
                            this._updateTilesForChangedGlyphs();
                            for (const m in this._updatedPaintProps)
                                this._layers[m].updateTransitions(e);
                            this.light.updateTransitions(e),
                            this.sky.updateTransitions(e),
                            this._resetUpdates()
                        }
                        const s = {};
                        for (const c in this.sourceCaches) {
                            const d = this.sourceCaches[c];
                            s[c] = d.used,
                            d.used = !1
                        }
                        for (const c of this._order) {
                            const d = this._layers[c];
                            d.recalculate(e, this._availableImages),
                            !d.isHidden(e.zoom) && d.source && (this.sourceCaches[d.source].used = !0)
                        }
                        for (const c in s) {
                            const d = this.sourceCaches[c];
                            !!s[c] != !!d.used && d.fire(new o.l("data",{
                                sourceDataType: "visibility",
                                dataType: "source",
                                sourceId: c
                            }))
                        }
                        this.light.recalculate(e),
                        this.sky.recalculate(e),
                        this.projection.recalculate(e),
                        this.z = e.zoom,
                        r && this.fire(new o.l("data",{
                            dataType: "style"
                        }))
                    }
                    _updateTilesForChangedImages() {
                        const e = Object.keys(this._changedImages);
                        if (e.length) {
                            for (const r in this.sourceCaches)
                                this.sourceCaches[r].reloadTilesForDependencies(["icons", "patterns"], e);
                            this._changedImages = {}
                        }
                    }
                    _updateTilesForChangedGlyphs() {
                        if (this._glyphsDidChange) {
                            for (const e in this.sourceCaches)
                                this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
                            this._glyphsDidChange = !1
                        }
                    }
                    _updateWorkerLayers(e, r) {
                        this.dispatcher.broadcast("UL", {
                            layers: this._serializeByIds(e, !1),
                            removedIds: r
                        })
                    }
                    _resetUpdates() {
                        this._changed = !1,
                        this._updatedLayers = {},
                        this._removedLayers = {},
                        this._updatedSources = {},
                        this._updatedPaintProps = {},
                        this._changedImages = {},
                        this._glyphsDidChange = !1
                    }
                    setState(e, r={}) {
                        var s;
                        this._checkLoaded();
                        const c = this.serialize();
                        if (e = r.transformStyle ? r.transformStyle(c, e) : e,
                        ((s = r.validate) === null || s === void 0 || s) && _o(this, o.z(e)))
                            return !1;
                        (e = o.bJ(e)).layers = o.bH(e.layers);
                        const d = o.bK(c, e)
                          , m = this._getOperationsToPerform(d);
                        if (m.unimplemented.length > 0)
                            throw new Error(`Unimplemented: ${m.unimplemented.join(", ")}.`);
                        if (m.operations.length === 0)
                            return !1;
                        for (const v of m.operations)
                            v();
                        return this.stylesheet = e,
                        this._serializedLayers = null,
                        !0
                    }
                    _getOperationsToPerform(e) {
                        const r = []
                          , s = [];
                        for (const c of e)
                            switch (c.command) {
                            case "setCenter":
                            case "setZoom":
                            case "setBearing":
                            case "setPitch":
                            case "setRoll":
                                continue;
                            case "addLayer":
                                r.push( () => this.addLayer.apply(this, c.args));
                                break;
                            case "removeLayer":
                                r.push( () => this.removeLayer.apply(this, c.args));
                                break;
                            case "setPaintProperty":
                                r.push( () => this.setPaintProperty.apply(this, c.args));
                                break;
                            case "setLayoutProperty":
                                r.push( () => this.setLayoutProperty.apply(this, c.args));
                                break;
                            case "setFilter":
                                r.push( () => this.setFilter.apply(this, c.args));
                                break;
                            case "addSource":
                                r.push( () => this.addSource.apply(this, c.args));
                                break;
                            case "removeSource":
                                r.push( () => this.removeSource.apply(this, c.args));
                                break;
                            case "setLayerZoomRange":
                                r.push( () => this.setLayerZoomRange.apply(this, c.args));
                                break;
                            case "setLight":
                                r.push( () => this.setLight.apply(this, c.args));
                                break;
                            case "setGeoJSONSourceData":
                                r.push( () => this.setGeoJSONSourceData.apply(this, c.args));
                                break;
                            case "setGlyphs":
                                r.push( () => this.setGlyphs.apply(this, c.args));
                                break;
                            case "setSprite":
                                r.push( () => this.setSprite.apply(this, c.args));
                                break;
                            case "setTerrain":
                                r.push( () => this.map.setTerrain.apply(this, c.args));
                                break;
                            case "setSky":
                                r.push( () => this.setSky.apply(this, c.args));
                                break;
                            case "setProjection":
                                this.setProjection.apply(this, c.args);
                                break;
                            case "setGlobalState":
                                r.push( () => this.setGlobalState.apply(this, c.args));
                                break;
                            case "setTransition":
                                r.push( () => {}
                                );
                                break;
                            default:
                                s.push(c.command)
                            }
                        return {
                            operations: r,
                            unimplemented: s
                        }
                    }
                    addImage(e, r) {
                        if (this.getImage(e))
                            return this.fire(new o.k(new Error(`An image named "${e}" already exists.`)));
                        this.imageManager.addImage(e, r),
                        this._afterImageUpdated(e)
                    }
                    updateImage(e, r) {
                        this.imageManager.updateImage(e, r)
                    }
                    getImage(e) {
                        return this.imageManager.getImage(e)
                    }
                    removeImage(e) {
                        if (!this.getImage(e))
                            return this.fire(new o.k(new Error(`An image named "${e}" does not exist.`)));
                        this.imageManager.removeImage(e),
                        this._afterImageUpdated(e)
                    }
                    _afterImageUpdated(e) {
                        this._availableImages = this.imageManager.listImages(),
                        this._changedImages[e] = !0,
                        this._changed = !0,
                        this.dispatcher.broadcast("SI", this._availableImages),
                        this.fire(new o.l("data",{
                            dataType: "style"
                        }))
                    }
                    listImages() {
                        return this._checkLoaded(),
                        this.imageManager.listImages()
                    }
                    addSource(e, r, s={}) {
                        if (this._checkLoaded(),
                        this.sourceCaches[e] !== void 0)
                            throw new Error(`Source "${e}" already exists.`);
                        if (!r.type)
                            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(r).join(", ")}.`);
                        if (["vector", "raster", "geojson", "video", "image"].indexOf(r.type) >= 0 && this._validate(o.z.source, `sources.${e}`, r, null, s))
                            return;
                        this.map && this.map._collectResourceTiming && (r.collectResourceTiming = !0);
                        const c = this.sourceCaches[e] = new Ke(e,r,this.dispatcher);
                        c.style = this,
                        c.setEventedParent(this, () => ({
                            isSourceLoaded: c.loaded(),
                            source: c.serialize(),
                            sourceId: e
                        })),
                        c.onAdd(this.map),
                        this._changed = !0
                    }
                    removeSource(e) {
                        if (this._checkLoaded(),
                        this.sourceCaches[e] === void 0)
                            throw new Error("There is no source with this ID");
                        for (const s in this._layers)
                            if (this._layers[s].source === e)
                                return this.fire(new o.k(new Error(`Source "${e}" cannot be removed while layer "${s}" is using it.`)));
                        const r = this.sourceCaches[e];
                        delete this.sourceCaches[e],
                        delete this._updatedSources[e],
                        r.fire(new o.l("data",{
                            sourceDataType: "metadata",
                            dataType: "source",
                            sourceId: e
                        })),
                        r.setEventedParent(null),
                        r.onRemove(this.map),
                        this._changed = !0
                    }
                    setGeoJSONSourceData(e, r) {
                        if (this._checkLoaded(),
                        this.sourceCaches[e] === void 0)
                            throw new Error(`There is no source with this ID=${e}`);
                        const s = this.sourceCaches[e].getSource();
                        if (s.type !== "geojson")
                            throw new Error(`geojsonSource.type is ${s.type}, which is !== 'geojson`);
                        s.setData(r),
                        this._changed = !0
                    }
                    getSource(e) {
                        return this.sourceCaches[e] && this.sourceCaches[e].getSource()
                    }
                    addLayer(e, r, s={}) {
                        this._checkLoaded();
                        const c = e.id;
                        if (this.getLayer(c))
                            return void this.fire(new o.k(new Error(`Layer "${c}" already exists on this map.`)));
                        let d;
                        if (e.type === "custom") {
                            if (_o(this, o.bL(e)))
                                return;
                            d = o.bI(e)
                        } else {
                            if ("source"in e && typeof e.source == "object" && (this.addSource(c, e.source),
                            e = o.bJ(e),
                            e = o.e(e, {
                                source: c
                            })),
                            this._validate(o.z.layer, `layers.${c}`, e, {
                                arrayIndex: -1
                            }, s))
                                return;
                            d = o.bI(e),
                            this._validateLayer(d),
                            d.setEventedParent(this, {
                                layer: {
                                    id: c
                                }
                            })
                        }
                        const m = r ? this._order.indexOf(r) : this._order.length;
                        if (r && m === -1)
                            this.fire(new o.k(new Error(`Cannot add layer "${c}" before non-existing layer "${r}".`)));
                        else {
                            if (this._order.splice(m, 0, c),
                            this._layerOrderChanged = !0,
                            this._layers[c] = d,
                            this._removedLayers[c] && d.source && d.type !== "custom") {
                                const v = this._removedLayers[c];
                                delete this._removedLayers[c],
                                v.type !== d.type ? this._updatedSources[d.source] = "clear" : (this._updatedSources[d.source] = "reload",
                                this.sourceCaches[d.source].pause())
                            }
                            this._updateLayer(d),
                            d.onAdd && d.onAdd(this.map)
                        }
                    }
                    moveLayer(e, r) {
                        if (this._checkLoaded(),
                        this._changed = !0,
                        !this._layers[e])
                            return void this.fire(new o.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
                        if (e === r)
                            return;
                        const s = this._order.indexOf(e);
                        this._order.splice(s, 1);
                        const c = r ? this._order.indexOf(r) : this._order.length;
                        r && c === -1 ? this.fire(new o.k(new Error(`Cannot move layer "${e}" before non-existing layer "${r}".`))) : (this._order.splice(c, 0, e),
                        this._layerOrderChanged = !0)
                    }
                    removeLayer(e) {
                        this._checkLoaded();
                        const r = this._layers[e];
                        if (!r)
                            return void this.fire(new o.k(new Error(`Cannot remove non-existing layer "${e}".`)));
                        r.setEventedParent(null);
                        const s = this._order.indexOf(e);
                        this._order.splice(s, 1),
                        this._layerOrderChanged = !0,
                        this._changed = !0,
                        this._removedLayers[e] = r,
                        delete this._layers[e],
                        this._serializedLayers && delete this._serializedLayers[e],
                        delete this._updatedLayers[e],
                        delete this._updatedPaintProps[e],
                        r.onRemove && r.onRemove(this.map)
                    }
                    getLayer(e) {
                        return this._layers[e]
                    }
                    getLayersOrder() {
                        return [...this._order]
                    }
                    hasLayer(e) {
                        return e in this._layers
                    }
                    setLayerZoomRange(e, r, s) {
                        this._checkLoaded();
                        const c = this.getLayer(e);
                        c ? c.minzoom === r && c.maxzoom === s || (r != null && (c.minzoom = r),
                        s != null && (c.maxzoom = s),
                        this._updateLayer(c)) : this.fire(new o.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)))
                    }
                    setFilter(e, r, s={}) {
                        this._checkLoaded();
                        const c = this.getLayer(e);
                        if (c) {
                            if (!o.bG(c.filter, r))
                                return r == null ? (c.setFilter(void 0),
                                void this._updateLayer(c)) : void (this._validate(o.z.filter, `layers.${c.id}.filter`, r, null, s) || (c.setFilter(o.bJ(r)),
                                this._updateLayer(c)))
                        } else
                            this.fire(new o.k(new Error(`Cannot filter non-existing layer "${e}".`)))
                    }
                    getFilter(e) {
                        return o.bJ(this.getLayer(e).filter)
                    }
                    setLayoutProperty(e, r, s, c={}) {
                        this._checkLoaded();
                        const d = this.getLayer(e);
                        d ? o.bG(d.getLayoutProperty(r), s) || (d.setLayoutProperty(r, s, c),
                        this._updateLayer(d)) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${e}".`)))
                    }
                    getLayoutProperty(e, r) {
                        const s = this.getLayer(e);
                        if (s)
                            return s.getLayoutProperty(r);
                        this.fire(new o.k(new Error(`Cannot get style of non-existing layer "${e}".`)))
                    }
                    setPaintProperty(e, r, s, c={}) {
                        this._checkLoaded();
                        const d = this.getLayer(e);
                        d ? o.bG(d.getPaintProperty(r), s) || (d.setPaintProperty(r, s, c) && this._updateLayer(d),
                        this._changed = !0,
                        this._updatedPaintProps[e] = !0,
                        this._serializedLayers = null) : this.fire(new o.k(new Error(`Cannot style non-existing layer "${e}".`)))
                    }
                    getPaintProperty(e, r) {
                        return this.getLayer(e).getPaintProperty(r)
                    }
                    setFeatureState(e, r) {
                        this._checkLoaded();
                        const s = e.source
                          , c = e.sourceLayer
                          , d = this.sourceCaches[s];
                        if (d === void 0)
                            return void this.fire(new o.k(new Error(`The source '${s}' does not exist in the map's style.`)));
                        const m = d.getSource().type;
                        m === "geojson" && c ? this.fire(new o.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : m !== "vector" || c ? (e.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))),
                        d.setFeatureState(c, e.id, r)) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
                    }
                    removeFeatureState(e, r) {
                        this._checkLoaded();
                        const s = e.source
                          , c = this.sourceCaches[s];
                        if (c === void 0)
                            return void this.fire(new o.k(new Error(`The source '${s}' does not exist in the map's style.`)));
                        const d = c.getSource().type
                          , m = d === "vector" ? e.sourceLayer : void 0;
                        d !== "vector" || m ? r && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new o.k(new Error("A feature id is required to remove its specific state property."))) : c.removeFeatureState(m, e.id, r) : this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
                    }
                    getFeatureState(e) {
                        this._checkLoaded();
                        const r = e.source
                          , s = e.sourceLayer
                          , c = this.sourceCaches[r];
                        if (c !== void 0)
                            return c.getSource().type !== "vector" || s ? (e.id === void 0 && this.fire(new o.k(new Error("The feature id parameter must be provided."))),
                            c.getFeatureState(s, e.id)) : void this.fire(new o.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
                        this.fire(new o.k(new Error(`The source '${r}' does not exist in the map's style.`)))
                    }
                    getTransition() {
                        return o.e({
                            duration: 300,
                            delay: 0
                        }, this.stylesheet && this.stylesheet.transition)
                    }
                    serialize() {
                        if (!this._loaded)
                            return;
                        const e = o.bM(this.sourceCaches, d => d.serialize())
                          , r = this._serializeByIds(this._order, !0)
                          , s = this.map.getTerrain() || void 0
                          , c = this.stylesheet;
                        return o.bN({
                            version: c.version,
                            name: c.name,
                            metadata: c.metadata,
                            light: c.light,
                            sky: c.sky,
                            center: c.center,
                            zoom: c.zoom,
                            bearing: c.bearing,
                            pitch: c.pitch,
                            sprite: c.sprite,
                            glyphs: c.glyphs,
                            transition: c.transition,
                            projection: c.projection,
                            sources: e,
                            layers: r,
                            terrain: s
                        }, d => d !== void 0)
                    }
                    _updateLayer(e) {
                        this._updatedLayers[e.id] = !0,
                        e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload",
                        this.sourceCaches[e.source].pause()),
                        this._serializedLayers = null,
                        this._changed = !0
                    }
                    _flattenAndSortRenderedFeatures(e) {
                        const r = m => this._layers[m].type === "fill-extrusion"
                          , s = {}
                          , c = [];
                        for (let m = this._order.length - 1; m >= 0; m--) {
                            const v = this._order[m];
                            if (r(v)) {
                                s[v] = m;
                                for (const b of e) {
                                    const P = b[v];
                                    if (P)
                                        for (const M of P)
                                            c.push(M)
                                }
                            }
                        }
                        c.sort( (m, v) => v.intersectionZ - m.intersectionZ);
                        const d = [];
                        for (let m = this._order.length - 1; m >= 0; m--) {
                            const v = this._order[m];
                            if (r(v))
                                for (let b = c.length - 1; b >= 0; b--) {
                                    const P = c[b].feature;
                                    if (s[P.layer.id] < m)
                                        break;
                                    d.push(P),
                                    c.pop()
                                }
                            else
                                for (const b of e) {
                                    const P = b[v];
                                    if (P)
                                        for (const M of P)
                                            d.push(M.feature)
                                }
                        }
                        return d
                    }
                    queryRenderedFeatures(e, r, s) {
                        r && r.filter && this._validate(o.z.filter, "queryRenderedFeatures.filter", r.filter, null, r);
                        const c = {};
                        if (r && r.layers) {
                            if (!(Array.isArray(r.layers) || r.layers instanceof Set))
                                return this.fire(new o.k(new Error("parameters.layers must be an Array or a Set of strings"))),
                                [];
                            for (const P of r.layers) {
                                const M = this._layers[P];
                                if (!M)
                                    return this.fire(new o.k(new Error(`The layer '${P}' does not exist in the map's style and cannot be queried for features.`))),
                                    [];
                                c[M.source] = !0
                            }
                        }
                        const d = [];
                        r.availableImages = this._availableImages;
                        const m = this._serializedAllLayers()
                          , v = r.layers instanceof Set ? r.layers : Array.isArray(r.layers) ? new Set(r.layers) : null
                          , b = Object.assign(Object.assign({}, r), {
                            layers: v
                        });
                        for (const P in this.sourceCaches)
                            r.layers && !c[P] || d.push(kt(this.sourceCaches[P], this._layers, m, e, b, s, this.map.terrain ? (M, D, L) => this.map.terrain.getElevation(M, D, L) : void 0));
                        return this.placement && d.push(function(P, M, D, L, B, Z, te) {
                            const ee = {}
                              , ne = Z.queryRenderedSymbols(L)
                              , oe = [];
                            for (const me of Object.keys(ne).map(Number))
                                oe.push(te[me]);
                            oe.sort(xt);
                            for (const me of oe) {
                                const ce = me.featureIndex.lookupSymbolFeatures(ne[me.bucketInstanceId], M, me.bucketIndex, me.sourceLayerIndex, B.filter, B.layers, B.availableImages, P);
                                for (const Te in ce) {
                                    const Pe = ee[Te] = ee[Te] || []
                                      , pe = ce[Te];
                                    pe.sort( (Fe, Ye) => {
                                        const $e = me.featureSortOrder;
                                        if ($e) {
                                            const He = $e.indexOf(Fe.featureIndex);
                                            return $e.indexOf(Ye.featureIndex) - He
                                        }
                                        return Ye.featureIndex - Fe.featureIndex
                                    }
                                    );
                                    for (const Fe of pe)
                                        Pe.push(Fe)
                                }
                            }
                            return function(me, ce, Te) {
                                for (const Pe in me)
                                    for (const pe of me[Pe])
                                        Pt(pe, Te[ce[Pe].source]);
                                return me
                            }(ee, P, D)
                        }(this._layers, m, this.sourceCaches, e, b, this.placement.collisionIndex, this.placement.retainedQueryData)),
                        this._flattenAndSortRenderedFeatures(d)
                    }
                    querySourceFeatures(e, r) {
                        r && r.filter && this._validate(o.z.filter, "querySourceFeatures.filter", r.filter, null, r);
                        const s = this.sourceCaches[e];
                        return s ? function(c, d) {
                            const m = c.getRenderableIds().map(P => c.getTileByID(P))
                              , v = []
                              , b = {};
                            for (let P = 0; P < m.length; P++) {
                                const M = m[P]
                                  , D = M.tileID.canonical.key;
                                b[D] || (b[D] = !0,
                                M.querySourceFeatures(v, d))
                            }
                            return v
                        }(s, r) : []
                    }
                    getLight() {
                        return this.light.getLight()
                    }
                    setLight(e, r={}) {
                        this._checkLoaded();
                        const s = this.light.getLight();
                        let c = !1;
                        for (const m in e)
                            if (!o.bG(e[m], s[m])) {
                                c = !0;
                                break
                            }
                        if (!c)
                            return;
                        const d = {
                            now: he.now(),
                            transition: o.e({
                                duration: 300,
                                delay: 0
                            }, this.stylesheet.transition)
                        };
                        this.light.setLight(e, r),
                        this.light.updateTransitions(d)
                    }
                    getProjection() {
                        var e;
                        return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection
                    }
                    setProjection(e) {
                        if (this._checkLoaded(),
                        this.projection) {
                            if (this.projection.name === e.type)
                                return;
                            this.projection.destroy(),
                            delete this.projection
                        }
                        this.stylesheet.projection = e,
                        this._setProjectionInternal(e.type)
                    }
                    getSky() {
                        var e;
                        return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky
                    }
                    setSky(e, r={}) {
                        this._checkLoaded();
                        const s = this.getSky();
                        let c = !1;
                        if (!e && !s)
                            return;
                        if (e && !s)
                            c = !0;
                        else if (!e && s)
                            c = !0;
                        else
                            for (const m in e)
                                if (!o.bG(e[m], s[m])) {
                                    c = !0;
                                    break
                                }
                        if (!c)
                            return;
                        const d = {
                            now: he.now(),
                            transition: o.e({
                                duration: 300,
                                delay: 0
                            }, this.stylesheet.transition)
                        };
                        this.stylesheet.sky = e,
                        this.sky.setSky(e, r),
                        this.sky.updateTransitions(d)
                    }
                    _setProjectionInternal(e) {
                        const r = function(s) {
                            if (Array.isArray(s)) {
                                const c = new uo({
                                    type: s
                                });
                                return {
                                    projection: c,
                                    transform: new ta,
                                    cameraHelper: new mc(c)
                                }
                            }
                            switch (s) {
                            case "mercator":
                                return {
                                    projection: new Ps,
                                    transform: new Li,
                                    cameraHelper: new tl
                                };
                            case "globe":
                                {
                                    const c = new uo({
                                        type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"]
                                    });
                                    return {
                                        projection: c,
                                        transform: new ta,
                                        cameraHelper: new mc(c)
                                    }
                                }
                            case "vertical-perspective":
                                return {
                                    projection: new gh,
                                    transform: new zs,
                                    cameraHelper: new Zn
                                };
                            default:
                                return o.w(`Unknown projection name: ${s}. Falling back to mercator projection.`),
                                {
                                    projection: new Ps,
                                    transform: new Li,
                                    cameraHelper: new tl
                                }
                            }
                        }(e);
                        this.projection = r.projection,
                        this.map.migrateProjection(r.transform, r.cameraHelper);
                        for (const s in this.sourceCaches)
                            this.sourceCaches[s].reload()
                    }
                    _validate(e, r, s, c, d={}) {
                        return (!d || d.validate !== !1) && _o(this, e.call(o.z, o.e({
                            key: r,
                            style: this.serialize(),
                            value: s,
                            styleSpec: o.v
                        }, c)))
                    }
                    _remove(e=!0) {
                        this._frameRequest && (this._frameRequest.abort(),
                        this._frameRequest = null),
                        this._loadStyleRequest && (this._loadStyleRequest.abort(),
                        this._loadStyleRequest = null),
                        this._spriteRequest && (this._spriteRequest.abort(),
                        this._spriteRequest = null),
                        vr().off(Xt, this._rtlPluginLoaded);
                        for (const r in this._layers)
                            this._layers[r].setEventedParent(null);
                        for (const r in this.sourceCaches) {
                            const s = this.sourceCaches[r];
                            s.setEventedParent(null),
                            s.onRemove(this.map)
                        }
                        this.imageManager.setEventedParent(null),
                        this.setEventedParent(null),
                        e && this.dispatcher.broadcast("RM", void 0),
                        this.dispatcher.remove(e)
                    }
                    _clearSource(e) {
                        this.sourceCaches[e].clearTiles()
                    }
                    _reloadSource(e) {
                        this.sourceCaches[e].resume(),
                        this.sourceCaches[e].reload()
                    }
                    _updateSources(e) {
                        for (const r in this.sourceCaches)
                            this.sourceCaches[r].update(e, this.map.terrain)
                    }
                    _generateCollisionBoxes() {
                        for (const e in this.sourceCaches)
                            this._reloadSource(e)
                    }
                    _updatePlacement(e, r, s, c, d=!1) {
                        let m = !1
                          , v = !1;
                        const b = {};
                        for (const P of this._order) {
                            const M = this._layers[P];
                            if (M.type !== "symbol")
                                continue;
                            if (!b[M.source]) {
                                const L = this.sourceCaches[M.source];
                                b[M.source] = L.getRenderableIds(!0).map(B => L.getTileByID(B)).sort( (B, Z) => Z.tileID.overscaledZ - B.tileID.overscaledZ || (B.tileID.isLessThan(Z.tileID) ? -1 : 1))
                            }
                            const D = this.crossTileSymbolIndex.addLayer(M, b[M.source], e.center.lng);
                            m = m || D
                        }
                        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order),
                        ((d = d || this._layerOrderChanged || s === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(he.now(), e.zoom)) && (this.pauseablePlacement = new Ki(e,this.map.terrain,this._order,d,r,s,c,this.placement),
                        this._layerOrderChanged = !1),
                        this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, b),
                        this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(he.now()),
                        v = !0),
                        m && this.pauseablePlacement.placement.setStale()),
                        v || m)
                            for (const P of this._order) {
                                const M = this._layers[P];
                                M.type === "symbol" && this.placement.updateLayerOpacities(M, b[M.source])
                            }
                        return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(he.now())
                    }
                    _releaseSymbolFadeTiles() {
                        for (const e in this.sourceCaches)
                            this.sourceCaches[e].releaseSymbolFadeTiles()
                    }
                    getImages(e, r) {
                        return o._(this, void 0, void 0, function*() {
                            const s = yield this.imageManager.getImages(r.icons);
                            this._updateTilesForChangedImages();
                            const c = this.sourceCaches[r.source];
                            return c && c.setDependencies(r.tileID.key, r.type, r.icons),
                            s
                        })
                    }
                    getGlyphs(e, r) {
                        return o._(this, void 0, void 0, function*() {
                            const s = yield this.glyphManager.getGlyphs(r.stacks)
                              , c = this.sourceCaches[r.source];
                            return c && c.setDependencies(r.tileID.key, r.type, [""]),
                            s
                        })
                    }
                    getGlyphsUrl() {
                        return this.stylesheet.glyphs || null
                    }
                    setGlyphs(e, r={}) {
                        this._checkLoaded(),
                        e && this._validate(o.z.glyphs, "glyphs", e, null, r) || (this._glyphsDidChange = !0,
                        this.stylesheet.glyphs = e,
                        this.glyphManager.entries = {},
                        this.glyphManager.setURL(e))
                    }
                    addSprite(e, r, s={}, c) {
                        this._checkLoaded();
                        const d = [{
                            id: e,
                            url: r
                        }]
                          , m = [...rt(this.stylesheet.sprite), ...d];
                        this._validate(o.z.sprite, "sprite", m, null, s) || (this.stylesheet.sprite = m,
                        this._loadSprite(d, !0, c))
                    }
                    removeSprite(e) {
                        this._checkLoaded();
                        const r = rt(this.stylesheet.sprite);
                        if (r.find(s => s.id === e)) {
                            if (this._spritesImagesIds[e])
                                for (const s of this._spritesImagesIds[e])
                                    this.imageManager.removeImage(s),
                                    this._changedImages[s] = !0;
                            r.splice(r.findIndex(s => s.id === e), 1),
                            this.stylesheet.sprite = r.length > 0 ? r : void 0,
                            delete this._spritesImagesIds[e],
                            this._availableImages = this.imageManager.listImages(),
                            this._changed = !0,
                            this.dispatcher.broadcast("SI", this._availableImages),
                            this.fire(new o.l("data",{
                                dataType: "style"
                            }))
                        } else
                            this.fire(new o.k(new Error(`Sprite "${e}" doesn't exists on this map.`)))
                    }
                    getSprite() {
                        return rt(this.stylesheet.sprite)
                    }
                    setSprite(e, r={}, s) {
                        this._checkLoaded(),
                        e && this._validate(o.z.sprite, "sprite", e, null, r) || (this.stylesheet.sprite = e,
                        e ? this._loadSprite(e, !0, s) : (this._unloadSprite(),
                        s && s(null)))
                    }
                }
                var Kd = o.aI([{
                    name: "a_pos",
                    type: "Int16",
                    components: 2
                }, {
                    name: "a_texture_pos",
                    type: "Int16",
                    components: 2
                }]);
                class Yd {
                    constructor() {
                        this.boundProgram = null,
                        this.boundLayoutVertexBuffer = null,
                        this.boundPaintVertexBuffers = [],
                        this.boundIndexBuffer = null,
                        this.boundVertexOffset = null,
                        this.boundDynamicVertexBuffer = null,
                        this.vao = null
                    }
                    bind(e, r, s, c, d, m, v, b, P) {
                        this.context = e;
                        let M = this.boundPaintVertexBuffers.length !== c.length;
                        for (let D = 0; !M && D < c.length; D++)
                            this.boundPaintVertexBuffers[D] !== c[D] && (M = !0);
                        !this.vao || this.boundProgram !== r || this.boundLayoutVertexBuffer !== s || M || this.boundIndexBuffer !== d || this.boundVertexOffset !== m || this.boundDynamicVertexBuffer !== v || this.boundDynamicVertexBuffer2 !== b || this.boundDynamicVertexBuffer3 !== P ? this.freshBind(r, s, c, d, m, v, b, P) : (e.bindVertexArray.set(this.vao),
                        v && v.bind(),
                        d && d.dynamicDraw && d.bind(),
                        b && b.bind(),
                        P && P.bind())
                    }
                    freshBind(e, r, s, c, d, m, v, b) {
                        const P = e.numAttributes
                          , M = this.context
                          , D = M.gl;
                        this.vao && this.destroy(),
                        this.vao = M.createVertexArray(),
                        M.bindVertexArray.set(this.vao),
                        this.boundProgram = e,
                        this.boundLayoutVertexBuffer = r,
                        this.boundPaintVertexBuffers = s,
                        this.boundIndexBuffer = c,
                        this.boundVertexOffset = d,
                        this.boundDynamicVertexBuffer = m,
                        this.boundDynamicVertexBuffer2 = v,
                        this.boundDynamicVertexBuffer3 = b,
                        r.enableAttributes(D, e);
                        for (const L of s)
                            L.enableAttributes(D, e);
                        m && m.enableAttributes(D, e),
                        v && v.enableAttributes(D, e),
                        b && b.enableAttributes(D, e),
                        r.bind(),
                        r.setVertexAttribPointers(D, e, d);
                        for (const L of s)
                            L.bind(),
                            L.setVertexAttribPointers(D, e, d);
                        m && (m.bind(),
                        m.setVertexAttribPointers(D, e, d)),
                        c && c.bind(),
                        v && (v.bind(),
                        v.setVertexAttribPointers(D, e, d)),
                        b && (b.bind(),
                        b.setVertexAttribPointers(D, e, d)),
                        M.currentNumAttributes = P
                    }
                    destroy() {
                        this.vao && (this.context.deleteVertexArray(this.vao),
                        this.vao = null)
                    }
                }
                const Jd = (h, e, r, s, c) => ({
                    u_texture: 0,
                    u_ele_delta: h,
                    u_fog_matrix: e,
                    u_fog_color: r ? r.properties.get("fog-color") : o.be.white,
                    u_fog_ground_blend: r ? r.properties.get("fog-ground-blend") : 1,
                    u_fog_ground_blend_opacity: c ? 0 : r ? r.calculateFogBlendOpacity(s) : 0,
                    u_horizon_color: r ? r.properties.get("horizon-color") : o.be.white,
                    u_horizon_fog_blend: r ? r.properties.get("horizon-fog-blend") : 1,
                    u_is_globe_mode: c ? 1 : 0
                })
                  , Qd = {
                    mainMatrix: "u_projection_matrix",
                    tileMercatorCoords: "u_projection_tile_mercator_coords",
                    clippingPlane: "u_projection_clipping_plane",
                    projectionTransition: "u_projection_transition",
                    fallbackMatrix: "u_projection_fallback_matrix"
                };
                function rl(h) {
                    const e = [];
                    for (let r = 0; r < h.length; r++) {
                        if (h[r] === null)
                            continue;
                        const s = h[r].split(" ");
                        e.push(s.pop())
                    }
                    return e
                }
                class il {
                    constructor(e, r, s, c, d, m, v, b, P=[]) {
                        const M = e.gl;
                        this.program = M.createProgram();
                        const D = rl(r.staticAttributes)
                          , L = s ? s.getBinderAttributes() : []
                          , B = D.concat(L)
                          , Z = Ui.prelude.staticUniforms ? rl(Ui.prelude.staticUniforms) : []
                          , te = v.staticUniforms ? rl(v.staticUniforms) : []
                          , ee = r.staticUniforms ? rl(r.staticUniforms) : []
                          , ne = s ? s.getBinderUniforms() : []
                          , oe = Z.concat(te).concat(ee).concat(ne)
                          , me = [];
                        for (const $e of oe)
                            me.indexOf($e) < 0 && me.push($e);
                        const ce = s ? s.defines() : [];
                        kn(M) && ce.unshift("#version 300 es"),
                        d && ce.push("#define OVERDRAW_INSPECTOR;"),
                        m && ce.push("#define TERRAIN3D;"),
                        b && ce.push(b),
                        P && ce.push(...P);
                        let Te = ce.concat(Ui.prelude.fragmentSource, v.fragmentSource, r.fragmentSource).join(`
`)
                          , Pe = ce.concat(Ui.prelude.vertexSource, v.vertexSource, r.vertexSource).join(`
`);
                        kn(M) || (Te = function($e) {
                            return $e.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(")
                        }(Te),
                        Pe = function($e) {
                            return $e.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(")
                        }(Pe));
                        const pe = M.createShader(M.FRAGMENT_SHADER);
                        if (M.isContextLost())
                            return void (this.failedToCreate = !0);
                        if (M.shaderSource(pe, Te),
                        M.compileShader(pe),
                        !M.getShaderParameter(pe, M.COMPILE_STATUS))
                            throw new Error(`Could not compile fragment shader: ${M.getShaderInfoLog(pe)}`);
                        M.attachShader(this.program, pe);
                        const Fe = M.createShader(M.VERTEX_SHADER);
                        if (M.isContextLost())
                            return void (this.failedToCreate = !0);
                        if (M.shaderSource(Fe, Pe),
                        M.compileShader(Fe),
                        !M.getShaderParameter(Fe, M.COMPILE_STATUS))
                            throw new Error(`Could not compile vertex shader: ${M.getShaderInfoLog(Fe)}`);
                        M.attachShader(this.program, Fe),
                        this.attributes = {};
                        const Ye = {};
                        this.numAttributes = B.length;
                        for (let $e = 0; $e < this.numAttributes; $e++)
                            B[$e] && (M.bindAttribLocation(this.program, $e, B[$e]),
                            this.attributes[B[$e]] = $e);
                        if (M.linkProgram(this.program),
                        !M.getProgramParameter(this.program, M.LINK_STATUS))
                            throw new Error(`Program failed to link: ${M.getProgramInfoLog(this.program)}`);
                        M.deleteShader(Fe),
                        M.deleteShader(pe);
                        for (let $e = 0; $e < me.length; $e++) {
                            const He = me[$e];
                            if (He && !Ye[He]) {
                                const Je = M.getUniformLocation(this.program, He);
                                Je && (Ye[He] = Je)
                            }
                        }
                        this.fixedUniforms = c(e, Ye),
                        this.terrainUniforms = ( ($e, He) => ({
                            u_depth: new o.bO($e,He.u_depth),
                            u_terrain: new o.bO($e,He.u_terrain),
                            u_terrain_dim: new o.bf($e,He.u_terrain_dim),
                            u_terrain_matrix: new o.bQ($e,He.u_terrain_matrix),
                            u_terrain_unpack: new o.bR($e,He.u_terrain_unpack),
                            u_terrain_exaggeration: new o.bf($e,He.u_terrain_exaggeration)
                        }))(e, Ye),
                        this.projectionUniforms = ( ($e, He) => ({
                            u_projection_matrix: new o.bQ($e,He.u_projection_matrix),
                            u_projection_tile_mercator_coords: new o.bR($e,He.u_projection_tile_mercator_coords),
                            u_projection_clipping_plane: new o.bR($e,He.u_projection_clipping_plane),
                            u_projection_transition: new o.bf($e,He.u_projection_transition),
                            u_projection_fallback_matrix: new o.bQ($e,He.u_projection_fallback_matrix)
                        }))(e, Ye),
                        this.binderUniforms = s ? s.getUniforms(e, Ye) : []
                    }
                    draw(e, r, s, c, d, m, v, b, P, M, D, L, B, Z, te, ee, ne, oe, me) {
                        const ce = e.gl;
                        if (this.failedToCreate)
                            return;
                        if (e.program.set(this.program),
                        e.setDepthMode(s),
                        e.setStencilMode(c),
                        e.setColorMode(d),
                        e.setCullFace(m),
                        b) {
                            e.activeTexture.set(ce.TEXTURE2),
                            ce.bindTexture(ce.TEXTURE_2D, b.depthTexture),
                            e.activeTexture.set(ce.TEXTURE3),
                            ce.bindTexture(ce.TEXTURE_2D, b.texture);
                            for (const Pe in this.terrainUniforms)
                                this.terrainUniforms[Pe].set(b[Pe])
                        }
                        if (P)
                            for (const Pe in P)
                                this.projectionUniforms[Qd[Pe]].set(P[Pe]);
                        if (v)
                            for (const Pe in this.fixedUniforms)
                                this.fixedUniforms[Pe].set(v[Pe]);
                        ee && ee.setUniforms(e, this.binderUniforms, Z, {
                            zoom: te
                        });
                        let Te = 0;
                        switch (r) {
                        case ce.LINES:
                            Te = 2;
                            break;
                        case ce.TRIANGLES:
                            Te = 3;
                            break;
                        case ce.LINE_STRIP:
                            Te = 1
                        }
                        for (const Pe of B.get()) {
                            const pe = Pe.vaos || (Pe.vaos = {});
                            (pe[M] || (pe[M] = new Yd)).bind(e, this, D, ee ? ee.getPaintVertexBuffers() : [], L, Pe.vertexOffset, ne, oe, me),
                            ce.drawElements(r, Pe.primitiveLength * Te, ce.UNSIGNED_SHORT, Pe.primitiveOffset * Te * 2)
                        }
                    }
                }
                function nl(h, e, r) {
                    const s = 1 / o.aB(r, 1, e.transform.tileZoom)
                      , c = Math.pow(2, r.tileID.overscaledZ)
                      , d = r.tileSize * Math.pow(2, e.transform.tileZoom) / c
                      , m = d * (r.tileID.canonical.x + r.tileID.wrap * c)
                      , v = d * r.tileID.canonical.y;
                    return {
                        u_image: 0,
                        u_texsize: r.imageAtlasTexture.size,
                        u_scale: [s, h.fromScale, h.toScale],
                        u_fade: h.t,
                        u_pixel_coord_upper: [m >> 16, v >> 16],
                        u_pixel_coord_lower: [65535 & m, 65535 & v]
                    }
                }
                const go = (h, e, r, s) => {
                    const c = h.style.light
                      , d = c.properties.get("position")
                      , m = [d.x, d.y, d.z]
                      , v = o.bU();
                    c.properties.get("anchor") === "viewport" && o.bV(v, h.transform.bearingInRadians),
                    o.bW(m, m, v);
                    const b = h.transform.transformLightDirection(m)
                      , P = c.properties.get("color");
                    return {
                        u_lightpos: m,
                        u_lightpos_globe: b,
                        u_lightintensity: c.properties.get("intensity"),
                        u_lightcolor: [P.r, P.g, P.b],
                        u_vertical_gradient: +e,
                        u_opacity: r,
                        u_fill_translate: s
                    }
                }
                  , gc = (h, e, r, s, c, d, m) => o.e(go(h, e, r, s), nl(d, h, m), {
                    u_height_factor: -Math.pow(2, c.overscaledZ) / m.tileSize / 8
                })
                  , al = (h, e, r, s) => o.e(nl(e, h, r), {
                    u_fill_translate: s
                })
                  , Sa = (h, e) => ({
                    u_world: h,
                    u_fill_translate: e
                })
                  , ep = (h, e, r, s, c) => o.e(al(h, e, r, c), {
                    u_world: s
                })
                  , vc = (h, e, r, s, c) => {
                    const d = h.transform;
                    let m, v, b = 0;
                    if (r.paint.get("circle-pitch-alignment") === "map") {
                        const P = o.aB(e, 1, d.zoom);
                        m = !0,
                        v = [P, P],
                        b = P / (o.$ * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * c
                    } else
                        m = !1,
                        v = d.pixelsToGLUnits;
                    return {
                        u_camera_to_center_distance: d.cameraToCenterDistance,
                        u_scale_with_map: +(r.paint.get("circle-pitch-scale") === "map"),
                        u_pitch_with_map: +m,
                        u_device_pixel_ratio: h.pixelRatio,
                        u_extrude_scale: v,
                        u_globe_extrude_scale: b,
                        u_translate: s
                    }
                }
                  , vo = h => ({
                    u_pixel_extrude_scale: [1 / h.width, 1 / h.height]
                })
                  , yo = h => ({
                    u_viewport_size: [h.width, h.height]
                })
                  , yh = (h, e=1) => ({
                    u_color: h,
                    u_overlay: 0,
                    u_overlay_scale: e
                })
                  , xo = (h, e, r, s) => {
                    const c = o.aB(h, 1, e) / (o.$ * Math.pow(2, h.tileID.overscaledZ)) * 2 * Math.PI * s;
                    return {
                        u_extrude_scale: o.aB(h, 1, e),
                        u_intensity: r,
                        u_globe_extrude_scale: c
                    }
                }
                  , xh = (h, e, r, s) => {
                    const c = o.L();
                    o.bX(c, 0, h.width, h.height, 0, 0, 1);
                    const d = h.context.gl;
                    return {
                        u_matrix: c,
                        u_world: [d.drawingBufferWidth, d.drawingBufferHeight],
                        u_image: r,
                        u_color_ramp: s,
                        u_opacity: e.paint.get("heatmap-opacity")
                    }
                }
                  , Ds = (h, e, r) => {
                    const s = r.paint.get("hillshade-accent-color");
                    let c;
                    switch (r.paint.get("hillshade-method")) {
                    case "basic":
                        c = 4;
                        break;
                    case "combined":
                        c = 1;
                        break;
                    case "igor":
                        c = 2;
                        break;
                    case "multidirectional":
                        c = 3;
                        break;
                    default:
                        c = 0
                    }
                    const d = r.getIlluminationProperties();
                    for (let m = 0; m < d.directionRadians.length; m++)
                        r.paint.get("hillshade-illumination-anchor") === "viewport" && (d.directionRadians[m] += h.transform.bearingInRadians);
                    return {
                        u_image: 0,
                        u_latrange: bh(0, e.tileID),
                        u_exaggeration: r.paint.get("hillshade-exaggeration"),
                        u_altitudes: d.altitudeRadians,
                        u_azimuths: d.directionRadians,
                        u_accent: s,
                        u_method: c,
                        u_highlights: d.highlightColor,
                        u_shadows: d.shadowColor
                    }
                }
                  , tp = (h, e) => {
                    const r = e.stride
                      , s = o.L();
                    return o.bX(s, 0, o.$, -o.$, 0, 0, 1),
                    o.M(s, s, [0, -o.$, 0]),
                    {
                        u_matrix: s,
                        u_image: 1,
                        u_dimension: [r, r],
                        u_zoom: h.overscaledZ,
                        u_unpack: e.getUnpackVector()
                    }
                }
                ;
                function bh(h, e) {
                    const r = Math.pow(2, e.canonical.z)
                      , s = e.canonical.y;
                    return [new o.a0(0,s / r).toLngLat().lat, new o.a0(0,(s + 1) / r).toLngLat().lat]
                }
                const rp = (h, e, r=0) => ({
                    u_image: 0,
                    u_unpack: e.getUnpackVector(),
                    u_dimension: [e.stride, e.stride],
                    u_elevation_stops: 1,
                    u_color_stops: 4,
                    u_color_ramp_size: r,
                    u_opacity: h.paint.get("color-relief-opacity")
                })
                  , sl = (h, e, r, s) => {
                    const c = h.transform;
                    return {
                        u_translation: bc(h, e, r),
                        u_ratio: s / o.aB(e, 1, c.zoom),
                        u_device_pixel_ratio: h.pixelRatio,
                        u_units_to_pixels: [1 / c.pixelsToGLUnits[0], 1 / c.pixelsToGLUnits[1]]
                    }
                }
                  , yc = (h, e, r, s, c) => o.e(sl(h, e, r, s), {
                    u_image: 0,
                    u_image_height: c
                })
                  , wh = (h, e, r, s, c) => {
                    const d = h.transform
                      , m = xc(e, d);
                    return {
                        u_translation: bc(h, e, r),
                        u_texsize: e.imageAtlasTexture.size,
                        u_ratio: s / o.aB(e, 1, d.zoom),
                        u_device_pixel_ratio: h.pixelRatio,
                        u_image: 0,
                        u_scale: [m, c.fromScale, c.toScale],
                        u_fade: c.t,
                        u_units_to_pixels: [1 / d.pixelsToGLUnits[0], 1 / d.pixelsToGLUnits[1]]
                    }
                }
                  , Th = (h, e, r, s, c, d) => {
                    const m = h.lineAtlas
                      , v = xc(e, h.transform)
                      , b = r.layout.get("line-cap") === "round"
                      , P = m.getDash(c.from, b)
                      , M = m.getDash(c.to, b)
                      , D = P.width * d.fromScale
                      , L = M.width * d.toScale;
                    return o.e(sl(h, e, r, s), {
                        u_patternscale_a: [v / D, -P.height / 2],
                        u_patternscale_b: [v / L, -M.height / 2],
                        u_sdfgamma: m.width / (256 * Math.min(D, L) * h.pixelRatio) / 2,
                        u_image: 0,
                        u_tex_y_a: P.y,
                        u_tex_y_b: M.y,
                        u_mix: d.t
                    })
                }
                ;
                function xc(h, e) {
                    return 1 / o.aB(h, 1, e.tileZoom)
                }
                function bc(h, e, r) {
                    return o.aC(h.transform, e, r.paint.get("line-translate"), r.paint.get("line-translate-anchor"))
                }
                const us = (h, e, r, s, c) => {
                    return {
                        u_tl_parent: h,
                        u_scale_parent: e,
                        u_buffer_scale: 1,
                        u_fade_t: r.mix,
                        u_opacity: r.opacity * s.paint.get("raster-opacity"),
                        u_image0: 0,
                        u_image1: 1,
                        u_brightness_low: s.paint.get("raster-brightness-min"),
                        u_brightness_high: s.paint.get("raster-brightness-max"),
                        u_saturation_factor: (m = s.paint.get("raster-saturation"),
                        m > 0 ? 1 - 1 / (1.001 - m) : -m),
                        u_contrast_factor: (d = s.paint.get("raster-contrast"),
                        d > 0 ? 1 / (1 - d) : 1 + d),
                        u_spin_weights: Ch(s.paint.get("raster-hue-rotate")),
                        u_coords_top: [c[0].x, c[0].y, c[1].x, c[1].y],
                        u_coords_bottom: [c[3].x, c[3].y, c[2].x, c[2].y]
                    };
                    var d, m
                }
                ;
                function Ch(h) {
                    h *= Math.PI / 180;
                    const e = Math.sin(h)
                      , r = Math.cos(h);
                    return [(2 * r + 1) / 3, (-Math.sqrt(3) * e - r + 1) / 3, (Math.sqrt(3) * e - r + 1) / 3]
                }
                const wc = (h, e, r, s, c, d, m, v, b, P, M, D, L) => {
                    const B = m.transform;
                    return {
                        u_is_size_zoom_constant: +(h === "constant" || h === "source"),
                        u_is_size_feature_constant: +(h === "constant" || h === "camera"),
                        u_size_t: e ? e.uSizeT : 0,
                        u_size: e ? e.uSize : 0,
                        u_camera_to_center_distance: B.cameraToCenterDistance,
                        u_pitch: B.pitch / 360 * 2 * Math.PI,
                        u_rotate_symbol: +r,
                        u_aspect_ratio: B.width / B.height,
                        u_fade_change: m.options.fadeDuration ? m.symbolFadeChange : 1,
                        u_label_plane_matrix: v,
                        u_coord_matrix: b,
                        u_is_text: +M,
                        u_pitch_with_map: +s,
                        u_is_along_line: c,
                        u_is_variable_anchor: d,
                        u_texsize: D,
                        u_texture: 0,
                        u_translation: P,
                        u_pitched_scale: L
                    }
                }
                  , Rs = (h, e, r, s, c, d, m, v, b, P, M, D, L, B) => {
                    const Z = m.transform;
                    return o.e(wc(h, e, r, s, c, d, m, v, b, P, M, D, B), {
                        u_gamma_scale: s ? Math.cos(Z.pitch * Math.PI / 180) * Z.cameraToCenterDistance : 1,
                        u_device_pixel_ratio: m.pixelRatio,
                        u_is_halo: 1
                    })
                }
                  , ip = (h, e, r, s, c, d, m, v, b, P, M, D, L) => o.e(Rs(h, e, r, s, c, d, m, v, b, P, !0, M, 0, L), {
                    u_texsize_icon: D,
                    u_texture_icon: 1
                })
                  , ol = (h, e) => ({
                    u_opacity: h,
                    u_color: e
                })
                  , np = (h, e, r, s, c) => o.e(function(d, m, v, b) {
                    const P = v.imageManager.getPattern(d.from.toString())
                      , M = v.imageManager.getPattern(d.to.toString())
                      , {width: D, height: L} = v.imageManager.getPixelSize()
                      , B = Math.pow(2, b.tileID.overscaledZ)
                      , Z = b.tileSize * Math.pow(2, v.transform.tileZoom) / B
                      , te = Z * (b.tileID.canonical.x + b.tileID.wrap * B)
                      , ee = Z * b.tileID.canonical.y;
                    return {
                        u_image: 0,
                        u_pattern_tl_a: P.tl,
                        u_pattern_br_a: P.br,
                        u_pattern_tl_b: M.tl,
                        u_pattern_br_b: M.br,
                        u_texsize: [D, L],
                        u_mix: m.t,
                        u_pattern_size_a: P.displaySize,
                        u_pattern_size_b: M.displaySize,
                        u_scale_a: m.fromScale,
                        u_scale_b: m.toScale,
                        u_tile_units_to_pixels: 1 / o.aB(b, 1, v.transform.tileZoom),
                        u_pixel_coord_upper: [te >> 16, ee >> 16],
                        u_pixel_coord_lower: [65535 & te, 65535 & ee]
                    }
                }(r, c, e, s), {
                    u_opacity: h
                })
                  , Sh = (h, e) => {}
                  , Ph = {
                    fillExtrusion: (h, e) => ({
                        u_lightpos: new o.bS(h,e.u_lightpos),
                        u_lightpos_globe: new o.bS(h,e.u_lightpos_globe),
                        u_lightintensity: new o.bf(h,e.u_lightintensity),
                        u_lightcolor: new o.bS(h,e.u_lightcolor),
                        u_vertical_gradient: new o.bf(h,e.u_vertical_gradient),
                        u_opacity: new o.bf(h,e.u_opacity),
                        u_fill_translate: new o.bT(h,e.u_fill_translate)
                    }),
                    fillExtrusionPattern: (h, e) => ({
                        u_lightpos: new o.bS(h,e.u_lightpos),
                        u_lightpos_globe: new o.bS(h,e.u_lightpos_globe),
                        u_lightintensity: new o.bf(h,e.u_lightintensity),
                        u_lightcolor: new o.bS(h,e.u_lightcolor),
                        u_vertical_gradient: new o.bf(h,e.u_vertical_gradient),
                        u_height_factor: new o.bf(h,e.u_height_factor),
                        u_opacity: new o.bf(h,e.u_opacity),
                        u_fill_translate: new o.bT(h,e.u_fill_translate),
                        u_image: new o.bO(h,e.u_image),
                        u_texsize: new o.bT(h,e.u_texsize),
                        u_pixel_coord_upper: new o.bT(h,e.u_pixel_coord_upper),
                        u_pixel_coord_lower: new o.bT(h,e.u_pixel_coord_lower),
                        u_scale: new o.bS(h,e.u_scale),
                        u_fade: new o.bf(h,e.u_fade)
                    }),
                    fill: (h, e) => ({
                        u_fill_translate: new o.bT(h,e.u_fill_translate)
                    }),
                    fillPattern: (h, e) => ({
                        u_image: new o.bO(h,e.u_image),
                        u_texsize: new o.bT(h,e.u_texsize),
                        u_pixel_coord_upper: new o.bT(h,e.u_pixel_coord_upper),
                        u_pixel_coord_lower: new o.bT(h,e.u_pixel_coord_lower),
                        u_scale: new o.bS(h,e.u_scale),
                        u_fade: new o.bf(h,e.u_fade),
                        u_fill_translate: new o.bT(h,e.u_fill_translate)
                    }),
                    fillOutline: (h, e) => ({
                        u_world: new o.bT(h,e.u_world),
                        u_fill_translate: new o.bT(h,e.u_fill_translate)
                    }),
                    fillOutlinePattern: (h, e) => ({
                        u_world: new o.bT(h,e.u_world),
                        u_image: new o.bO(h,e.u_image),
                        u_texsize: new o.bT(h,e.u_texsize),
                        u_pixel_coord_upper: new o.bT(h,e.u_pixel_coord_upper),
                        u_pixel_coord_lower: new o.bT(h,e.u_pixel_coord_lower),
                        u_scale: new o.bS(h,e.u_scale),
                        u_fade: new o.bf(h,e.u_fade),
                        u_fill_translate: new o.bT(h,e.u_fill_translate)
                    }),
                    circle: (h, e) => ({
                        u_camera_to_center_distance: new o.bf(h,e.u_camera_to_center_distance),
                        u_scale_with_map: new o.bO(h,e.u_scale_with_map),
                        u_pitch_with_map: new o.bO(h,e.u_pitch_with_map),
                        u_extrude_scale: new o.bT(h,e.u_extrude_scale),
                        u_device_pixel_ratio: new o.bf(h,e.u_device_pixel_ratio),
                        u_globe_extrude_scale: new o.bf(h,e.u_globe_extrude_scale),
                        u_translate: new o.bT(h,e.u_translate)
                    }),
                    collisionBox: (h, e) => ({
                        u_pixel_extrude_scale: new o.bT(h,e.u_pixel_extrude_scale)
                    }),
                    collisionCircle: (h, e) => ({
                        u_viewport_size: new o.bT(h,e.u_viewport_size)
                    }),
                    debug: (h, e) => ({
                        u_color: new o.bP(h,e.u_color),
                        u_overlay: new o.bO(h,e.u_overlay),
                        u_overlay_scale: new o.bf(h,e.u_overlay_scale)
                    }),
                    depth: Sh,
                    clippingMask: Sh,
                    heatmap: (h, e) => ({
                        u_extrude_scale: new o.bf(h,e.u_extrude_scale),
                        u_intensity: new o.bf(h,e.u_intensity),
                        u_globe_extrude_scale: new o.bf(h,e.u_globe_extrude_scale)
                    }),
                    heatmapTexture: (h, e) => ({
                        u_matrix: new o.bQ(h,e.u_matrix),
                        u_world: new o.bT(h,e.u_world),
                        u_image: new o.bO(h,e.u_image),
                        u_color_ramp: new o.bO(h,e.u_color_ramp),
                        u_opacity: new o.bf(h,e.u_opacity)
                    }),
                    hillshade: (h, e) => ({
                        u_image: new o.bO(h,e.u_image),
                        u_latrange: new o.bT(h,e.u_latrange),
                        u_exaggeration: new o.bf(h,e.u_exaggeration),
                        u_altitudes: new o.bZ(h,e.u_altitudes),
                        u_azimuths: new o.bZ(h,e.u_azimuths),
                        u_accent: new o.bP(h,e.u_accent),
                        u_method: new o.bO(h,e.u_method),
                        u_shadows: new o.bY(h,e.u_shadows),
                        u_highlights: new o.bY(h,e.u_highlights)
                    }),
                    hillshadePrepare: (h, e) => ({
                        u_matrix: new o.bQ(h,e.u_matrix),
                        u_image: new o.bO(h,e.u_image),
                        u_dimension: new o.bT(h,e.u_dimension),
                        u_zoom: new o.bf(h,e.u_zoom),
                        u_unpack: new o.bR(h,e.u_unpack)
                    }),
                    colorRelief: (h, e) => ({
                        u_image: new o.bO(h,e.u_image),
                        u_unpack: new o.bR(h,e.u_unpack),
                        u_dimension: new o.bT(h,e.u_dimension),
                        u_elevation_stops: new o.bO(h,e.u_elevation_stops),
                        u_color_stops: new o.bO(h,e.u_color_stops),
                        u_color_ramp_size: new o.bO(h,e.u_color_ramp_size),
                        u_opacity: new o.bf(h,e.u_opacity)
                    }),
                    line: (h, e) => ({
                        u_translation: new o.bT(h,e.u_translation),
                        u_ratio: new o.bf(h,e.u_ratio),
                        u_device_pixel_ratio: new o.bf(h,e.u_device_pixel_ratio),
                        u_units_to_pixels: new o.bT(h,e.u_units_to_pixels)
                    }),
                    lineGradient: (h, e) => ({
                        u_translation: new o.bT(h,e.u_translation),
                        u_ratio: new o.bf(h,e.u_ratio),
                        u_device_pixel_ratio: new o.bf(h,e.u_device_pixel_ratio),
                        u_units_to_pixels: new o.bT(h,e.u_units_to_pixels),
                        u_image: new o.bO(h,e.u_image),
                        u_image_height: new o.bf(h,e.u_image_height)
                    }),
                    linePattern: (h, e) => ({
                        u_translation: new o.bT(h,e.u_translation),
                        u_texsize: new o.bT(h,e.u_texsize),
                        u_ratio: new o.bf(h,e.u_ratio),
                        u_device_pixel_ratio: new o.bf(h,e.u_device_pixel_ratio),
                        u_image: new o.bO(h,e.u_image),
                        u_units_to_pixels: new o.bT(h,e.u_units_to_pixels),
                        u_scale: new o.bS(h,e.u_scale),
                        u_fade: new o.bf(h,e.u_fade)
                    }),
                    lineSDF: (h, e) => ({
                        u_translation: new o.bT(h,e.u_translation),
                        u_ratio: new o.bf(h,e.u_ratio),
                        u_device_pixel_ratio: new o.bf(h,e.u_device_pixel_ratio),
                        u_units_to_pixels: new o.bT(h,e.u_units_to_pixels),
                        u_patternscale_a: new o.bT(h,e.u_patternscale_a),
                        u_patternscale_b: new o.bT(h,e.u_patternscale_b),
                        u_sdfgamma: new o.bf(h,e.u_sdfgamma),
                        u_image: new o.bO(h,e.u_image),
                        u_tex_y_a: new o.bf(h,e.u_tex_y_a),
                        u_tex_y_b: new o.bf(h,e.u_tex_y_b),
                        u_mix: new o.bf(h,e.u_mix)
                    }),
                    raster: (h, e) => ({
                        u_tl_parent: new o.bT(h,e.u_tl_parent),
                        u_scale_parent: new o.bf(h,e.u_scale_parent),
                        u_buffer_scale: new o.bf(h,e.u_buffer_scale),
                        u_fade_t: new o.bf(h,e.u_fade_t),
                        u_opacity: new o.bf(h,e.u_opacity),
                        u_image0: new o.bO(h,e.u_image0),
                        u_image1: new o.bO(h,e.u_image1),
                        u_brightness_low: new o.bf(h,e.u_brightness_low),
                        u_brightness_high: new o.bf(h,e.u_brightness_high),
                        u_saturation_factor: new o.bf(h,e.u_saturation_factor),
                        u_contrast_factor: new o.bf(h,e.u_contrast_factor),
                        u_spin_weights: new o.bS(h,e.u_spin_weights),
                        u_coords_top: new o.bR(h,e.u_coords_top),
                        u_coords_bottom: new o.bR(h,e.u_coords_bottom)
                    }),
                    symbolIcon: (h, e) => ({
                        u_is_size_zoom_constant: new o.bO(h,e.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new o.bO(h,e.u_is_size_feature_constant),
                        u_size_t: new o.bf(h,e.u_size_t),
                        u_size: new o.bf(h,e.u_size),
                        u_camera_to_center_distance: new o.bf(h,e.u_camera_to_center_distance),
                        u_pitch: new o.bf(h,e.u_pitch),
                        u_rotate_symbol: new o.bO(h,e.u_rotate_symbol),
                        u_aspect_ratio: new o.bf(h,e.u_aspect_ratio),
                        u_fade_change: new o.bf(h,e.u_fade_change),
                        u_label_plane_matrix: new o.bQ(h,e.u_label_plane_matrix),
                        u_coord_matrix: new o.bQ(h,e.u_coord_matrix),
                        u_is_text: new o.bO(h,e.u_is_text),
                        u_pitch_with_map: new o.bO(h,e.u_pitch_with_map),
                        u_is_along_line: new o.bO(h,e.u_is_along_line),
                        u_is_variable_anchor: new o.bO(h,e.u_is_variable_anchor),
                        u_texsize: new o.bT(h,e.u_texsize),
                        u_texture: new o.bO(h,e.u_texture),
                        u_translation: new o.bT(h,e.u_translation),
                        u_pitched_scale: new o.bf(h,e.u_pitched_scale)
                    }),
                    symbolSDF: (h, e) => ({
                        u_is_size_zoom_constant: new o.bO(h,e.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new o.bO(h,e.u_is_size_feature_constant),
                        u_size_t: new o.bf(h,e.u_size_t),
                        u_size: new o.bf(h,e.u_size),
                        u_camera_to_center_distance: new o.bf(h,e.u_camera_to_center_distance),
                        u_pitch: new o.bf(h,e.u_pitch),
                        u_rotate_symbol: new o.bO(h,e.u_rotate_symbol),
                        u_aspect_ratio: new o.bf(h,e.u_aspect_ratio),
                        u_fade_change: new o.bf(h,e.u_fade_change),
                        u_label_plane_matrix: new o.bQ(h,e.u_label_plane_matrix),
                        u_coord_matrix: new o.bQ(h,e.u_coord_matrix),
                        u_is_text: new o.bO(h,e.u_is_text),
                        u_pitch_with_map: new o.bO(h,e.u_pitch_with_map),
                        u_is_along_line: new o.bO(h,e.u_is_along_line),
                        u_is_variable_anchor: new o.bO(h,e.u_is_variable_anchor),
                        u_texsize: new o.bT(h,e.u_texsize),
                        u_texture: new o.bO(h,e.u_texture),
                        u_gamma_scale: new o.bf(h,e.u_gamma_scale),
                        u_device_pixel_ratio: new o.bf(h,e.u_device_pixel_ratio),
                        u_is_halo: new o.bO(h,e.u_is_halo),
                        u_translation: new o.bT(h,e.u_translation),
                        u_pitched_scale: new o.bf(h,e.u_pitched_scale)
                    }),
                    symbolTextAndIcon: (h, e) => ({
                        u_is_size_zoom_constant: new o.bO(h,e.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new o.bO(h,e.u_is_size_feature_constant),
                        u_size_t: new o.bf(h,e.u_size_t),
                        u_size: new o.bf(h,e.u_size),
                        u_camera_to_center_distance: new o.bf(h,e.u_camera_to_center_distance),
                        u_pitch: new o.bf(h,e.u_pitch),
                        u_rotate_symbol: new o.bO(h,e.u_rotate_symbol),
                        u_aspect_ratio: new o.bf(h,e.u_aspect_ratio),
                        u_fade_change: new o.bf(h,e.u_fade_change),
                        u_label_plane_matrix: new o.bQ(h,e.u_label_plane_matrix),
                        u_coord_matrix: new o.bQ(h,e.u_coord_matrix),
                        u_is_text: new o.bO(h,e.u_is_text),
                        u_pitch_with_map: new o.bO(h,e.u_pitch_with_map),
                        u_is_along_line: new o.bO(h,e.u_is_along_line),
                        u_is_variable_anchor: new o.bO(h,e.u_is_variable_anchor),
                        u_texsize: new o.bT(h,e.u_texsize),
                        u_texsize_icon: new o.bT(h,e.u_texsize_icon),
                        u_texture: new o.bO(h,e.u_texture),
                        u_texture_icon: new o.bO(h,e.u_texture_icon),
                        u_gamma_scale: new o.bf(h,e.u_gamma_scale),
                        u_device_pixel_ratio: new o.bf(h,e.u_device_pixel_ratio),
                        u_is_halo: new o.bO(h,e.u_is_halo),
                        u_translation: new o.bT(h,e.u_translation),
                        u_pitched_scale: new o.bf(h,e.u_pitched_scale)
                    }),
                    background: (h, e) => ({
                        u_opacity: new o.bf(h,e.u_opacity),
                        u_color: new o.bP(h,e.u_color)
                    }),
                    backgroundPattern: (h, e) => ({
                        u_opacity: new o.bf(h,e.u_opacity),
                        u_image: new o.bO(h,e.u_image),
                        u_pattern_tl_a: new o.bT(h,e.u_pattern_tl_a),
                        u_pattern_br_a: new o.bT(h,e.u_pattern_br_a),
                        u_pattern_tl_b: new o.bT(h,e.u_pattern_tl_b),
                        u_pattern_br_b: new o.bT(h,e.u_pattern_br_b),
                        u_texsize: new o.bT(h,e.u_texsize),
                        u_mix: new o.bf(h,e.u_mix),
                        u_pattern_size_a: new o.bT(h,e.u_pattern_size_a),
                        u_pattern_size_b: new o.bT(h,e.u_pattern_size_b),
                        u_scale_a: new o.bf(h,e.u_scale_a),
                        u_scale_b: new o.bf(h,e.u_scale_b),
                        u_pixel_coord_upper: new o.bT(h,e.u_pixel_coord_upper),
                        u_pixel_coord_lower: new o.bT(h,e.u_pixel_coord_lower),
                        u_tile_units_to_pixels: new o.bf(h,e.u_tile_units_to_pixels)
                    }),
                    terrain: (h, e) => ({
                        u_texture: new o.bO(h,e.u_texture),
                        u_ele_delta: new o.bf(h,e.u_ele_delta),
                        u_fog_matrix: new o.bQ(h,e.u_fog_matrix),
                        u_fog_color: new o.bP(h,e.u_fog_color),
                        u_fog_ground_blend: new o.bf(h,e.u_fog_ground_blend),
                        u_fog_ground_blend_opacity: new o.bf(h,e.u_fog_ground_blend_opacity),
                        u_horizon_color: new o.bP(h,e.u_horizon_color),
                        u_horizon_fog_blend: new o.bf(h,e.u_horizon_fog_blend),
                        u_is_globe_mode: new o.bf(h,e.u_is_globe_mode)
                    }),
                    terrainDepth: (h, e) => ({
                        u_ele_delta: new o.bf(h,e.u_ele_delta)
                    }),
                    terrainCoords: (h, e) => ({
                        u_texture: new o.bO(h,e.u_texture),
                        u_terrain_coords_id: new o.bf(h,e.u_terrain_coords_id),
                        u_ele_delta: new o.bf(h,e.u_ele_delta)
                    }),
                    projectionErrorMeasurement: (h, e) => ({
                        u_input: new o.bf(h,e.u_input),
                        u_output_expected: new o.bf(h,e.u_output_expected)
                    }),
                    atmosphere: (h, e) => ({
                        u_sun_pos: new o.bS(h,e.u_sun_pos),
                        u_atmosphere_blend: new o.bf(h,e.u_atmosphere_blend),
                        u_globe_position: new o.bS(h,e.u_globe_position),
                        u_globe_radius: new o.bf(h,e.u_globe_radius),
                        u_inv_proj_matrix: new o.bQ(h,e.u_inv_proj_matrix)
                    }),
                    sky: (h, e) => ({
                        u_sky_color: new o.bP(h,e.u_sky_color),
                        u_horizon_color: new o.bP(h,e.u_horizon_color),
                        u_horizon: new o.bT(h,e.u_horizon),
                        u_horizon_normal: new o.bT(h,e.u_horizon_normal),
                        u_sky_horizon_blend: new o.bf(h,e.u_sky_horizon_blend),
                        u_sky_blend: new o.bf(h,e.u_sky_blend)
                    })
                };
                class Ih {
                    constructor(e, r, s) {
                        this.context = e;
                        const c = e.gl;
                        this.buffer = c.createBuffer(),
                        this.dynamicDraw = !!s,
                        this.context.unbindVAO(),
                        e.bindElementBuffer.set(this.buffer),
                        c.bufferData(c.ELEMENT_ARRAY_BUFFER, r.arrayBuffer, this.dynamicDraw ? c.DYNAMIC_DRAW : c.STATIC_DRAW),
                        this.dynamicDraw || delete r.arrayBuffer
                    }
                    bind() {
                        this.context.bindElementBuffer.set(this.buffer)
                    }
                    updateData(e) {
                        const r = this.context.gl;
                        if (!this.dynamicDraw)
                            throw new Error("Attempted to update data while not in dynamic mode.");
                        this.context.unbindVAO(),
                        this.bind(),
                        r.bufferSubData(r.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer)
                    }
                    destroy() {
                        this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                        delete this.buffer)
                    }
                }
                const Mh = {
                    Int8: "BYTE",
                    Uint8: "UNSIGNED_BYTE",
                    Int16: "SHORT",
                    Uint16: "UNSIGNED_SHORT",
                    Int32: "INT",
                    Uint32: "UNSIGNED_INT",
                    Float32: "FLOAT"
                };
                class Tc {
                    constructor(e, r, s, c) {
                        this.length = r.length,
                        this.attributes = s,
                        this.itemSize = r.bytesPerElement,
                        this.dynamicDraw = c,
                        this.context = e;
                        const d = e.gl;
                        this.buffer = d.createBuffer(),
                        e.bindVertexBuffer.set(this.buffer),
                        d.bufferData(d.ARRAY_BUFFER, r.arrayBuffer, this.dynamicDraw ? d.DYNAMIC_DRAW : d.STATIC_DRAW),
                        this.dynamicDraw || delete r.arrayBuffer
                    }
                    bind() {
                        this.context.bindVertexBuffer.set(this.buffer)
                    }
                    updateData(e) {
                        if (e.length !== this.length)
                            throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
                        const r = this.context.gl;
                        this.bind(),
                        r.bufferSubData(r.ARRAY_BUFFER, 0, e.arrayBuffer)
                    }
                    enableAttributes(e, r) {
                        for (let s = 0; s < this.attributes.length; s++) {
                            const c = r.attributes[this.attributes[s].name];
                            c !== void 0 && e.enableVertexAttribArray(c)
                        }
                    }
                    setVertexAttribPointers(e, r, s) {
                        for (let c = 0; c < this.attributes.length; c++) {
                            const d = this.attributes[c]
                              , m = r.attributes[d.name];
                            m !== void 0 && e.vertexAttribPointer(m, d.components, e[Mh[d.type]], !1, this.itemSize, d.offset + this.itemSize * (s || 0))
                        }
                    }
                    destroy() {
                        this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                        delete this.buffer)
                    }
                }
                class pi {
                    constructor(e) {
                        this.gl = e.gl,
                        this.default = this.getDefault(),
                        this.current = this.default,
                        this.dirty = !1
                    }
                    get() {
                        return this.current
                    }
                    set(e) {}
                    getDefault() {
                        return this.default
                    }
                    setDefault() {
                        this.set(this.default)
                    }
                }
                class ll extends pi {
                    getDefault() {
                        return o.be.transparent
                    }
                    set(e) {
                        const r = this.current;
                        (e.r !== r.r || e.g !== r.g || e.b !== r.b || e.a !== r.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Ra extends pi {
                    getDefault() {
                        return 1
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.clearDepth(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Cc extends pi {
                    getDefault() {
                        return 0
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.clearStencil(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Sc extends pi {
                    getDefault() {
                        return [!0, !0, !0, !0]
                    }
                    set(e) {
                        const r = this.current;
                        (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || e[3] !== r[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Pc extends pi {
                    getDefault() {
                        return !0
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.depthMask(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Ah extends pi {
                    getDefault() {
                        return 255
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.stencilMask(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Ic extends pi {
                    getDefault() {
                        return {
                            func: this.gl.ALWAYS,
                            ref: 0,
                            mask: 255
                        }
                    }
                    set(e) {
                        const r = this.current;
                        (e.func !== r.func || e.ref !== r.ref || e.mask !== r.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class hs extends pi {
                    getDefault() {
                        const e = this.gl;
                        return [e.KEEP, e.KEEP, e.KEEP]
                    }
                    set(e) {
                        const r = this.current;
                        (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Mc extends pi {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const r = this.gl;
                        e ? r.enable(r.STENCIL_TEST) : r.disable(r.STENCIL_TEST),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class ap extends pi {
                    getDefault() {
                        return [0, 1]
                    }
                    set(e) {
                        const r = this.current;
                        (e[0] !== r[0] || e[1] !== r[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class sp extends pi {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const r = this.gl;
                        e ? r.enable(r.DEPTH_TEST) : r.disable(r.DEPTH_TEST),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class op extends pi {
                    getDefault() {
                        return this.gl.LESS
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.depthFunc(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class lp extends pi {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const r = this.gl;
                        e ? r.enable(r.BLEND) : r.disable(r.BLEND),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class kh extends pi {
                    getDefault() {
                        const e = this.gl;
                        return [e.ONE, e.ZERO]
                    }
                    set(e) {
                        const r = this.current;
                        (e[0] !== r[0] || e[1] !== r[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class cp extends pi {
                    getDefault() {
                        return o.be.transparent
                    }
                    set(e) {
                        const r = this.current;
                        (e.r !== r.r || e.g !== r.g || e.b !== r.b || e.a !== r.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Eh extends pi {
                    getDefault() {
                        return this.gl.FUNC_ADD
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.blendEquation(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class cl extends pi {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const r = this.gl;
                        e ? r.enable(r.CULL_FACE) : r.disable(r.CULL_FACE),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class ul extends pi {
                    getDefault() {
                        return this.gl.BACK
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.cullFace(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class hl extends pi {
                    getDefault() {
                        return this.gl.CCW
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.frontFace(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Ac extends pi {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.useProgram(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class ds extends pi {
                    getDefault() {
                        return this.gl.TEXTURE0
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.activeTexture(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class bo extends pi {
                    getDefault() {
                        const e = this.gl;
                        return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight]
                    }
                    set(e) {
                        const r = this.current;
                        (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || e[3] !== r[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Bs extends pi {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const r = this.gl;
                        r.bindFramebuffer(r.FRAMEBUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class oa extends pi {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const r = this.gl;
                        r.bindRenderbuffer(r.RENDERBUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class zh extends pi {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const r = this.gl;
                        r.bindTexture(r.TEXTURE_2D, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class Lh extends pi {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const r = this.gl;
                        r.bindBuffer(r.ARRAY_BUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class kc extends pi {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        const r = this.gl;
                        r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class ps extends pi {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        var r;
                        if (e === this.current && !this.dirty)
                            return;
                        const s = this.gl;
                        kn(s) ? s.bindVertexArray(e) : (r = s.getExtension("OES_vertex_array_object")) === null || r === void 0 || r.bindVertexArrayOES(e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class dl extends pi {
                    getDefault() {
                        return 4
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const r = this.gl;
                        r.pixelStorei(r.UNPACK_ALIGNMENT, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class pl extends pi {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const r = this.gl;
                        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class wo extends pi {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const r = this.gl;
                        r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class Fs extends pi {
                    constructor(e, r) {
                        super(e),
                        this.context = e,
                        this.parent = r
                    }
                    getDefault() {
                        return null
                    }
                }
                class Dh extends Fs {
                    setDirty() {
                        this.dirty = !0
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        this.context.bindFramebuffer.set(this.parent);
                        const r = this.gl;
                        r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, e, 0),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class Os extends Fs {
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        this.context.bindFramebuffer.set(this.parent);
                        const r = this.gl;
                        r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.RENDERBUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class Ns extends Fs {
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        this.context.bindFramebuffer.set(this.parent);
                        const r = this.gl;
                        r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                const Ec = "Framebuffer is not complete";
                class zc {
                    constructor(e, r, s, c, d) {
                        this.context = e,
                        this.width = r,
                        this.height = s;
                        const m = e.gl
                          , v = this.framebuffer = m.createFramebuffer();
                        if (this.colorAttachment = new Dh(e,v),
                        c)
                            this.depthAttachment = d ? new Ns(e,v) : new Os(e,v);
                        else if (d)
                            throw new Error("Stencil cannot be set without depth");
                        if (m.checkFramebufferStatus(m.FRAMEBUFFER) !== m.FRAMEBUFFER_COMPLETE)
                            throw new Error(Ec)
                    }
                    destroy() {
                        const e = this.context.gl
                          , r = this.colorAttachment.get();
                        if (r && e.deleteTexture(r),
                        this.depthAttachment) {
                            const s = this.depthAttachment.get();
                            s && e.deleteRenderbuffer(s)
                        }
                        e.deleteFramebuffer(this.framebuffer)
                    }
                }
                class ei {
                    constructor(e) {
                        var r, s;
                        if (this.gl = e,
                        this.clearColor = new ll(this),
                        this.clearDepth = new Ra(this),
                        this.clearStencil = new Cc(this),
                        this.colorMask = new Sc(this),
                        this.depthMask = new Pc(this),
                        this.stencilMask = new Ah(this),
                        this.stencilFunc = new Ic(this),
                        this.stencilOp = new hs(this),
                        this.stencilTest = new Mc(this),
                        this.depthRange = new ap(this),
                        this.depthTest = new sp(this),
                        this.depthFunc = new op(this),
                        this.blend = new lp(this),
                        this.blendFunc = new kh(this),
                        this.blendColor = new cp(this),
                        this.blendEquation = new Eh(this),
                        this.cullFace = new cl(this),
                        this.cullFaceSide = new ul(this),
                        this.frontFace = new hl(this),
                        this.program = new Ac(this),
                        this.activeTexture = new ds(this),
                        this.viewport = new bo(this),
                        this.bindFramebuffer = new Bs(this),
                        this.bindRenderbuffer = new oa(this),
                        this.bindTexture = new zh(this),
                        this.bindVertexBuffer = new Lh(this),
                        this.bindElementBuffer = new kc(this),
                        this.bindVertexArray = new ps(this),
                        this.pixelStoreUnpack = new dl(this),
                        this.pixelStoreUnpackPremultiplyAlpha = new pl(this),
                        this.pixelStoreUnpackFlipY = new wo(this),
                        this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),
                        this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)),
                        this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE),
                        kn(e)) {
                            this.HALF_FLOAT = e.HALF_FLOAT;
                            const c = e.getExtension("EXT_color_buffer_half_float");
                            this.RGBA16F = (r = e.RGBA16F) !== null && r !== void 0 ? r : c == null ? void 0 : c.RGBA16F_EXT,
                            this.RGB16F = (s = e.RGB16F) !== null && s !== void 0 ? s : c == null ? void 0 : c.RGB16F_EXT,
                            e.getExtension("EXT_color_buffer_float")
                        } else {
                            e.getExtension("EXT_color_buffer_half_float"),
                            e.getExtension("OES_texture_half_float_linear");
                            const c = e.getExtension("OES_texture_half_float");
                            this.HALF_FLOAT = c == null ? void 0 : c.HALF_FLOAT_OES
                        }
                    }
                    setDefault() {
                        this.unbindVAO(),
                        this.clearColor.setDefault(),
                        this.clearDepth.setDefault(),
                        this.clearStencil.setDefault(),
                        this.colorMask.setDefault(),
                        this.depthMask.setDefault(),
                        this.stencilMask.setDefault(),
                        this.stencilFunc.setDefault(),
                        this.stencilOp.setDefault(),
                        this.stencilTest.setDefault(),
                        this.depthRange.setDefault(),
                        this.depthTest.setDefault(),
                        this.depthFunc.setDefault(),
                        this.blend.setDefault(),
                        this.blendFunc.setDefault(),
                        this.blendColor.setDefault(),
                        this.blendEquation.setDefault(),
                        this.cullFace.setDefault(),
                        this.cullFaceSide.setDefault(),
                        this.frontFace.setDefault(),
                        this.program.setDefault(),
                        this.activeTexture.setDefault(),
                        this.bindFramebuffer.setDefault(),
                        this.pixelStoreUnpack.setDefault(),
                        this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                        this.pixelStoreUnpackFlipY.setDefault()
                    }
                    setDirty() {
                        this.clearColor.dirty = !0,
                        this.clearDepth.dirty = !0,
                        this.clearStencil.dirty = !0,
                        this.colorMask.dirty = !0,
                        this.depthMask.dirty = !0,
                        this.stencilMask.dirty = !0,
                        this.stencilFunc.dirty = !0,
                        this.stencilOp.dirty = !0,
                        this.stencilTest.dirty = !0,
                        this.depthRange.dirty = !0,
                        this.depthTest.dirty = !0,
                        this.depthFunc.dirty = !0,
                        this.blend.dirty = !0,
                        this.blendFunc.dirty = !0,
                        this.blendColor.dirty = !0,
                        this.blendEquation.dirty = !0,
                        this.cullFace.dirty = !0,
                        this.cullFaceSide.dirty = !0,
                        this.frontFace.dirty = !0,
                        this.program.dirty = !0,
                        this.activeTexture.dirty = !0,
                        this.viewport.dirty = !0,
                        this.bindFramebuffer.dirty = !0,
                        this.bindRenderbuffer.dirty = !0,
                        this.bindTexture.dirty = !0,
                        this.bindVertexBuffer.dirty = !0,
                        this.bindElementBuffer.dirty = !0,
                        this.bindVertexArray.dirty = !0,
                        this.pixelStoreUnpack.dirty = !0,
                        this.pixelStoreUnpackPremultiplyAlpha.dirty = !0,
                        this.pixelStoreUnpackFlipY.dirty = !0
                    }
                    createIndexBuffer(e, r) {
                        return new Ih(this,e,r)
                    }
                    createVertexBuffer(e, r, s) {
                        return new Tc(this,e,r,s)
                    }
                    createRenderbuffer(e, r, s) {
                        const c = this.gl
                          , d = c.createRenderbuffer();
                        return this.bindRenderbuffer.set(d),
                        c.renderbufferStorage(c.RENDERBUFFER, e, r, s),
                        this.bindRenderbuffer.set(null),
                        d
                    }
                    createFramebuffer(e, r, s, c) {
                        return new zc(this,e,r,s,c)
                    }
                    clear({color: e, depth: r, stencil: s}) {
                        const c = this.gl;
                        let d = 0;
                        e && (d |= c.COLOR_BUFFER_BIT,
                        this.clearColor.set(e),
                        this.colorMask.set([!0, !0, !0, !0])),
                        r !== void 0 && (d |= c.DEPTH_BUFFER_BIT,
                        this.depthRange.set([0, 1]),
                        this.clearDepth.set(r),
                        this.depthMask.set(!0)),
                        s !== void 0 && (d |= c.STENCIL_BUFFER_BIT,
                        this.clearStencil.set(s),
                        this.stencilMask.set(255)),
                        c.clear(d)
                    }
                    setCullFace(e) {
                        e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0),
                        this.cullFaceSide.set(e.mode),
                        this.frontFace.set(e.frontFace))
                    }
                    setDepthMode(e) {
                        e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0),
                        this.depthFunc.set(e.func),
                        this.depthMask.set(e.mask),
                        this.depthRange.set(e.range)) : this.depthTest.set(!1)
                    }
                    setStencilMode(e) {
                        e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0),
                        this.stencilMask.set(e.mask),
                        this.stencilOp.set([e.fail, e.depthFail, e.pass]),
                        this.stencilFunc.set({
                            func: e.test.func,
                            ref: e.ref,
                            mask: e.test.mask
                        })) : this.stencilTest.set(!1)
                    }
                    setColorMode(e) {
                        o.bG(e.blendFunction, ai.Replace) ? this.blend.set(!1) : (this.blend.set(!0),
                        this.blendFunc.set(e.blendFunction),
                        this.blendColor.set(e.blendColor)),
                        this.colorMask.set(e.mask)
                    }
                    createVertexArray() {
                        var e;
                        return kn(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES()
                    }
                    deleteVertexArray(e) {
                        var r;
                        return kn(this.gl) ? this.gl.deleteVertexArray(e) : (r = this.gl.getExtension("OES_vertex_array_object")) === null || r === void 0 ? void 0 : r.deleteVertexArrayOES(e)
                    }
                    unbindVAO() {
                        this.bindVertexArray.set(null)
                    }
                }
                let fs;
                function Rh(h, e, r, s, c) {
                    const d = h.context
                      , m = h.transform
                      , v = d.gl
                      , b = h.useProgram("collisionBox")
                      , P = [];
                    let M = 0
                      , D = 0;
                    for (let ne = 0; ne < s.length; ne++) {
                        const oe = s[ne]
                          , me = e.getTile(oe).getBucket(r);
                        if (!me)
                            continue;
                        const ce = c ? me.textCollisionBox : me.iconCollisionBox
                          , Te = me.collisionCircleArray;
                        Te.length > 0 && (P.push({
                            circleArray: Te,
                            circleOffset: D,
                            coord: oe
                        }),
                        M += Te.length / 4,
                        D = M),
                        ce && b.draw(d, v.LINES, Xr.disabled, qr.disabled, h.colorModeForRenderPass(), Hr.disabled, vo(h.transform), h.style.map.terrain && h.style.map.terrain.getTerrainData(oe), m.getProjectionData({
                            overscaledTileID: oe,
                            applyGlobeMatrix: !0,
                            applyTerrainMatrix: !0
                        }), r.id, ce.layoutVertexBuffer, ce.indexBuffer, ce.segments, null, h.transform.zoom, null, null, ce.collisionVertexBuffer)
                    }
                    if (!c || !P.length)
                        return;
                    const L = h.useProgram("collisionCircle")
                      , B = new o.b_;
                    B.resize(4 * M),
                    B._trim();
                    let Z = 0;
                    for (const ne of P)
                        for (let oe = 0; oe < ne.circleArray.length / 4; oe++) {
                            const me = 4 * oe
                              , ce = ne.circleArray[me + 0]
                              , Te = ne.circleArray[me + 1]
                              , Pe = ne.circleArray[me + 2]
                              , pe = ne.circleArray[me + 3];
                            B.emplace(Z++, ce, Te, Pe, pe, 0),
                            B.emplace(Z++, ce, Te, Pe, pe, 1),
                            B.emplace(Z++, ce, Te, Pe, pe, 2),
                            B.emplace(Z++, ce, Te, Pe, pe, 3)
                        }
                    (!fs || fs.length < 2 * M) && (fs = function(ne) {
                        const oe = 2 * ne
                          , me = new o.c0;
                        me.resize(oe),
                        me._trim();
                        for (let ce = 0; ce < oe; ce++) {
                            const Te = 6 * ce;
                            me.uint16[Te + 0] = 4 * ce + 0,
                            me.uint16[Te + 1] = 4 * ce + 1,
                            me.uint16[Te + 2] = 4 * ce + 2,
                            me.uint16[Te + 3] = 4 * ce + 2,
                            me.uint16[Te + 4] = 4 * ce + 3,
                            me.uint16[Te + 5] = 4 * ce + 0
                        }
                        return me
                    }(M));
                    const te = d.createIndexBuffer(fs, !0)
                      , ee = d.createVertexBuffer(B, o.b$.members, !0);
                    for (const ne of P) {
                        const oe = yo(h.transform);
                        L.draw(d, v.TRIANGLES, Xr.disabled, qr.disabled, h.colorModeForRenderPass(), Hr.disabled, oe, h.style.map.terrain && h.style.map.terrain.getTerrainData(ne.coord), null, r.id, ee, te, o.aL.simpleSegment(0, 2 * ne.circleOffset, ne.circleArray.length, ne.circleArray.length / 2), null, h.transform.zoom, null, null, null)
                    }
                    ee.destroy(),
                    te.destroy()
                }
                const Bh = o.af(new Float32Array(16));
                function To(h, e, r, s, c, d) {
                    const {horizontalAlign: m, verticalAlign: v} = o.aG(h);
                    return new o.P((-(m - .5) * e / c + s[0]) * d,(-(v - .5) * r / c + s[1]) * d)
                }
                function up(h, e, r, s, c, d) {
                    const m = e.tileAnchorPoint.add(new o.P(e.translation[0],e.translation[1]));
                    if (e.pitchWithMap) {
                        let v = s.mult(d);
                        r || (v = v.rotate(-c));
                        const b = m.add(v);
                        return yt(b.x, b.y, e.pitchedLabelPlaneMatrix, e.getElevation).point
                    }
                    if (r) {
                        const v = St(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(h)
                          , b = Math.atan(v.y / v.x) + (v.x < 0 ? Math.PI : 0);
                        return h.add(s.rotate(b))
                    }
                    return h.add(s)
                }
                function hp(h, e, r, s, c, d, m, v, b, P, M, D) {
                    const L = h.text.placedSymbolArray
                      , B = h.text.dynamicLayoutVertexArray
                      , Z = h.icon.dynamicLayoutVertexArray
                      , te = {};
                    B.clear();
                    for (let ee = 0; ee < L.length; ee++) {
                        const ne = L.get(ee)
                          , oe = ne.hidden || !ne.crossTileID || h.allowVerticalPlacement && !ne.placedOrientation ? null : s[ne.crossTileID];
                        if (oe) {
                            const me = new o.P(ne.anchorX,ne.anchorY)
                              , ce = {
                                getElevation: D,
                                width: c.width,
                                height: c.height,
                                pitchedLabelPlaneMatrix: d,
                                pitchWithMap: r,
                                transform: c,
                                tileAnchorPoint: me,
                                translation: P,
                                unwrappedTileID: M
                            }
                              , Te = r ? pr(me.x, me.y, ce) : St(me.x, me.y, ce)
                              , Pe = Mt(c.cameraToCenterDistance, Te.signedDistanceFromCamera);
                            let pe = o.ao(h.textSizeData, v, ne) * Pe / o.aA;
                            r && (pe *= h.tilePixelRatio / m);
                            const {width: Fe, height: Ye, anchor: $e, textOffset: He, textBoxScale: Je} = oe
                              , qt = To($e, Fe, Ye, He, Je, pe)
                              , Nt = c.getPitchedTextCorrection(me.x + P[0], me.y + P[1], M)
                              , wt = up(Te.point, ce, e, qt, -c.bearingInRadians, Nt)
                              , rr = h.allowVerticalPlacement && ne.placedOrientation === o.an.vertical ? Math.PI / 2 : 0;
                            for (let Kr = 0; Kr < ne.numGlyphs; Kr++)
                                o.au(B, wt, rr);
                            b && ne.associatedIconIndex >= 0 && (te[ne.associatedIconIndex] = {
                                shiftedAnchor: wt,
                                angle: rr
                            })
                        } else
                            $i(ne.numGlyphs, B)
                    }
                    if (b) {
                        Z.clear();
                        const ee = h.icon.placedSymbolArray;
                        for (let ne = 0; ne < ee.length; ne++) {
                            const oe = ee.get(ne);
                            if (oe.hidden)
                                $i(oe.numGlyphs, Z);
                            else {
                                const me = te[ne];
                                if (me)
                                    for (let ce = 0; ce < oe.numGlyphs; ce++)
                                        o.au(Z, me.shiftedAnchor, me.angle);
                                else
                                    $i(oe.numGlyphs, Z)
                            }
                        }
                        h.icon.dynamicLayoutVertexBuffer.updateData(Z)
                    }
                    h.text.dynamicLayoutVertexBuffer.updateData(B)
                }
                function Fh(h, e, r) {
                    return r.iconsInText && e ? "symbolTextAndIcon" : h ? "symbolSDF" : "symbolIcon"
                }
                function Oh(h, e, r, s, c, d, m, v, b, P, M, D, L) {
                    const B = h.context
                      , Z = B.gl
                      , te = h.transform
                      , ee = v === "map"
                      , ne = b === "map"
                      , oe = v !== "viewport" && r.layout.get("symbol-placement") !== "point"
                      , me = ee && !ne && !oe
                      , ce = !r.layout.get("symbol-sort-key").isConstant();
                    let Te = !1;
                    const Pe = h.getDepthModeForSublayer(0, Xr.ReadOnly)
                      , pe = r._unevaluatedLayout.hasValue("text-variable-anchor") || r._unevaluatedLayout.hasValue("text-variable-anchor-offset")
                      , Fe = []
                      , Ye = te.getCircleRadiusCorrection();
                    for (const $e of s) {
                        const He = e.getTile($e)
                          , Je = He.getBucket(r);
                        if (!Je)
                            continue;
                        const qt = c ? Je.text : Je.icon;
                        if (!qt || !qt.segments.get().length || !qt.hasVisibleVertices)
                            continue;
                        const Nt = qt.programConfigurations.get(r.id)
                          , wt = c || Je.sdfIcons
                          , rr = c ? Je.textSizeData : Je.iconSizeData
                          , Kr = ne || te.pitch !== 0
                          , fi = h.useProgram(Fh(wt, c, Je), Nt)
                          , Bi = o.am(rr, te.zoom)
                          , xi = h.style.map.terrain && h.style.map.terrain.getTerrainData($e);
                        let Fi, Ti, bi, Ci, vn = [0, 0], li = null;
                        if (c)
                            Ti = He.glyphAtlasTexture,
                            bi = Z.LINEAR,
                            Fi = He.glyphAtlasTexture.size,
                            Je.iconsInText && (vn = He.imageAtlasTexture.size,
                            li = He.imageAtlasTexture,
                            Ci = Kr || h.options.rotating || h.options.zooming || rr.kind === "composite" || rr.kind === "camera" ? Z.LINEAR : Z.NEAREST);
                        else {
                            const Zi = r.layout.get("icon-size").constantOr(0) !== 1 || Je.iconsNeedLinear;
                            Ti = He.imageAtlasTexture,
                            bi = wt || h.options.rotating || h.options.zooming || Zi || Kr ? Z.LINEAR : Z.NEAREST,
                            Fi = He.imageAtlasTexture.size
                        }
                        const cn = o.aB(He, 1, h.transform.zoom)
                          , yn = wr(ee, h.transform, cn)
                          , Ja = o.L();
                        o.ap(Ja, yn);
                        const Qa = ci(ne, ee, h.transform, cn)
                          , es = o.aC(te, He, d, m)
                          , Ma = te.getProjectionData({
                            overscaledTileID: $e,
                            applyGlobeMatrix: !L,
                            applyTerrainMatrix: !0
                        })
                          , Fo = pe && Je.hasTextData()
                          , Oo = r.layout.get("icon-text-fit") !== "none" && Fo && Je.hasIconData();
                        if (oe) {
                            const Zi = h.style.map.terrain ? (Dn, tn) => h.style.map.terrain.getElevation($e, Dn, tn) : null
                              , Mi = r.layout.get("text-rotation-alignment") === "map";
                            Fr(Je, h, c, yn, Ja, ne, P, Mi, $e.toUnwrapped(), te.width, te.height, es, Zi)
                        }
                        const Ys = c && pe || Oo
                          , Un = oe || Ys ? Bh : ne ? yn : h.transform.clipSpaceToPixelsMatrix
                          , _a = wt && r.paint.get(c ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
                        let ts;
                        ts = wt ? Je.iconsInText ? ip(rr.kind, Bi, me, ne, oe, Ys, h, Un, Qa, es, Fi, vn, Ye) : Rs(rr.kind, Bi, me, ne, oe, Ys, h, Un, Qa, es, c, Fi, 0, Ye) : wc(rr.kind, Bi, me, ne, oe, Ys, h, Un, Qa, es, c, Fi, Ye);
                        const gs = {
                            program: fi,
                            buffers: qt,
                            uniformValues: ts,
                            projectionData: Ma,
                            atlasTexture: Ti,
                            atlasTextureIcon: li,
                            atlasInterpolation: bi,
                            atlasInterpolationIcon: Ci,
                            isSDF: wt,
                            hasHalo: _a
                        };
                        if (ce && Je.canOverlap) {
                            Te = !0;
                            const Zi = qt.segments.get();
                            for (const Mi of Zi)
                                Fe.push({
                                    segments: new o.aL([Mi]),
                                    sortKey: Mi.sortKey,
                                    state: gs,
                                    terrainData: xi
                                })
                        } else
                            Fe.push({
                                segments: qt.segments,
                                sortKey: 0,
                                state: gs,
                                terrainData: xi
                            })
                    }
                    Te && Fe.sort( ($e, He) => $e.sortKey - He.sortKey);
                    for (const $e of Fe) {
                        const He = $e.state;
                        if (B.activeTexture.set(Z.TEXTURE0),
                        He.atlasTexture.bind(He.atlasInterpolation, Z.CLAMP_TO_EDGE),
                        He.atlasTextureIcon && (B.activeTexture.set(Z.TEXTURE1),
                        He.atlasTextureIcon && He.atlasTextureIcon.bind(He.atlasInterpolationIcon, Z.CLAMP_TO_EDGE)),
                        He.isSDF) {
                            const Je = He.uniformValues;
                            He.hasHalo && (Je.u_is_halo = 1,
                            fl(He.buffers, $e.segments, r, h, He.program, Pe, M, D, Je, He.projectionData, $e.terrainData)),
                            Je.u_is_halo = 0
                        }
                        fl(He.buffers, $e.segments, r, h, He.program, Pe, M, D, He.uniformValues, He.projectionData, $e.terrainData)
                    }
                }
                function fl(h, e, r, s, c, d, m, v, b, P, M) {
                    const D = s.context;
                    c.draw(D, D.gl.TRIANGLES, d, m, v, Hr.backCCW, b, M, P, r.id, h.layoutVertexBuffer, h.indexBuffer, e, r.paint, s.transform.zoom, h.programConfigurations.get(r.id), h.dynamicLayoutVertexBuffer, h.opacityVertexBuffer)
                }
                function ml(h, e, r, s, c) {
                    const d = h.context
                      , m = d.gl
                      , v = qr.disabled
                      , b = new ai([m.ONE, m.ONE],o.be.transparent,[!0, !0, !0, !0])
                      , P = e.getBucket(r);
                    if (!P)
                        return;
                    const M = s.key;
                    let D = r.heatmapFbos.get(M);
                    D || (D = Co(d, e.tileSize, e.tileSize),
                    r.heatmapFbos.set(M, D)),
                    d.bindFramebuffer.set(D.framebuffer),
                    d.viewport.set([0, 0, e.tileSize, e.tileSize]),
                    d.clear({
                        color: o.be.transparent
                    });
                    const L = P.programConfigurations.get(r.id)
                      , B = h.useProgram("heatmap", L, !c)
                      , Z = h.transform.getProjectionData({
                        overscaledTileID: e.tileID,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                    })
                      , te = h.style.map.terrain.getTerrainData(s);
                    B.draw(d, m.TRIANGLES, Xr.disabled, v, b, Hr.disabled, xo(e, h.transform.zoom, r.paint.get("heatmap-intensity"), 1), te, Z, r.id, P.layoutVertexBuffer, P.indexBuffer, P.segments, r.paint, h.transform.zoom, L)
                }
                function _l(h, e, r, s, c) {
                    const d = h.context
                      , m = d.gl
                      , v = h.transform;
                    d.setColorMode(h.colorModeForRenderPass());
                    const b = gl(d, e)
                      , P = r.key
                      , M = e.heatmapFbos.get(P);
                    if (!M)
                        return;
                    d.activeTexture.set(m.TEXTURE0),
                    m.bindTexture(m.TEXTURE_2D, M.colorAttachment.get()),
                    d.activeTexture.set(m.TEXTURE1),
                    b.bind(m.LINEAR, m.CLAMP_TO_EDGE);
                    const D = v.getProjectionData({
                        overscaledTileID: r,
                        applyTerrainMatrix: c,
                        applyGlobeMatrix: !s
                    });
                    h.useProgram("heatmapTexture").draw(d, m.TRIANGLES, Xr.disabled, qr.disabled, h.colorModeForRenderPass(), Hr.disabled, xh(h, e, 0, 1), null, D, e.id, h.rasterBoundsBuffer, h.quadTriangleIndexBuffer, h.rasterBoundsSegments, e.paint, v.zoom),
                    M.destroy(),
                    e.heatmapFbos.delete(P)
                }
                function Co(h, e, r) {
                    var s, c;
                    const d = h.gl
                      , m = d.createTexture();
                    d.bindTexture(d.TEXTURE_2D, m),
                    d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE),
                    d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE),
                    d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.LINEAR),
                    d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.LINEAR);
                    const v = (s = h.HALF_FLOAT) !== null && s !== void 0 ? s : d.UNSIGNED_BYTE
                      , b = (c = h.RGBA16F) !== null && c !== void 0 ? c : d.RGBA;
                    d.texImage2D(d.TEXTURE_2D, 0, b, e, r, 0, d.RGBA, v, null);
                    const P = h.createFramebuffer(e, r, !1, !1);
                    return P.colorAttachment.set(m),
                    P
                }
                function gl(h, e) {
                    return e.colorRampTexture || (e.colorRampTexture = new o.T(h,e.colorRamp,h.gl.RGBA)),
                    e.colorRampTexture
                }
                function Lc(h, e, r, s, c) {
                    if (!r || !s || !s.imageAtlas)
                        return;
                    const d = s.imageAtlas.patternPositions;
                    let m = d[r.to.toString()]
                      , v = d[r.from.toString()];
                    if (!m && v && (m = v),
                    !v && m && (v = m),
                    !m || !v) {
                        const b = c.getPaintProperty(e);
                        m = d[b],
                        v = d[b]
                    }
                    m && v && h.setConstantPatternPositions(m, v)
                }
                function So(h, e, r, s, c, d, m, v) {
                    const b = h.context.gl
                      , P = "fill-pattern"
                      , M = r.paint.get(P)
                      , D = M && M.constantOr(1)
                      , L = r.getCrossfadeParameters();
                    let B, Z, te, ee, ne;
                    const oe = h.transform
                      , me = r.paint.get("fill-translate")
                      , ce = r.paint.get("fill-translate-anchor");
                    m ? (Z = D && !r.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline",
                    B = b.LINES) : (Z = D ? "fillPattern" : "fill",
                    B = b.TRIANGLES);
                    const Te = M.constantOr(null);
                    for (const Pe of s) {
                        const pe = e.getTile(Pe);
                        if (D && !pe.patternsLoaded())
                            continue;
                        const Fe = pe.getBucket(r);
                        if (!Fe)
                            continue;
                        const Ye = Fe.programConfigurations.get(r.id)
                          , $e = h.useProgram(Z, Ye)
                          , He = h.style.map.terrain && h.style.map.terrain.getTerrainData(Pe);
                        D && (h.context.activeTexture.set(b.TEXTURE0),
                        pe.imageAtlasTexture.bind(b.LINEAR, b.CLAMP_TO_EDGE),
                        Ye.updatePaintBuffers(L)),
                        Lc(Ye, P, Te, pe, r);
                        const Je = oe.getProjectionData({
                            overscaledTileID: Pe,
                            applyGlobeMatrix: !v,
                            applyTerrainMatrix: !0
                        })
                          , qt = o.aC(oe, pe, me, ce);
                        if (m) {
                            ee = Fe.indexBuffer2,
                            ne = Fe.segments2;
                            const wt = [b.drawingBufferWidth, b.drawingBufferHeight];
                            te = Z === "fillOutlinePattern" && D ? ep(h, L, pe, wt, qt) : Sa(wt, qt)
                        } else
                            ee = Fe.indexBuffer,
                            ne = Fe.segments,
                            te = D ? al(h, L, pe, qt) : {
                                u_fill_translate: qt
                            };
                        const Nt = h.stencilModeForClipping(Pe);
                        $e.draw(h.context, B, c, Nt, d, Hr.backCCW, te, He, Je, r.id, Fe.layoutVertexBuffer, ee, ne, r.paint, h.transform.zoom, Ye)
                    }
                }
                function js(h, e, r, s, c, d, m, v) {
                    const b = h.context
                      , P = b.gl
                      , M = "fill-extrusion-pattern"
                      , D = r.paint.get(M)
                      , L = D.constantOr(1)
                      , B = r.getCrossfadeParameters()
                      , Z = r.paint.get("fill-extrusion-opacity")
                      , te = D.constantOr(null)
                      , ee = h.transform;
                    for (const ne of s) {
                        const oe = e.getTile(ne)
                          , me = oe.getBucket(r);
                        if (!me)
                            continue;
                        const ce = h.style.map.terrain && h.style.map.terrain.getTerrainData(ne)
                          , Te = me.programConfigurations.get(r.id)
                          , Pe = h.useProgram(L ? "fillExtrusionPattern" : "fillExtrusion", Te);
                        L && (h.context.activeTexture.set(P.TEXTURE0),
                        oe.imageAtlasTexture.bind(P.LINEAR, P.CLAMP_TO_EDGE),
                        Te.updatePaintBuffers(B));
                        const pe = ee.getProjectionData({
                            overscaledTileID: ne,
                            applyGlobeMatrix: !v,
                            applyTerrainMatrix: !0
                        });
                        Lc(Te, M, te, oe, r);
                        const Fe = o.aC(ee, oe, r.paint.get("fill-extrusion-translate"), r.paint.get("fill-extrusion-translate-anchor"))
                          , Ye = r.paint.get("fill-extrusion-vertical-gradient")
                          , $e = L ? gc(h, Ye, Z, Fe, ne, B, oe) : go(h, Ye, Z, Fe);
                        Pe.draw(b, b.gl.TRIANGLES, c, d, m, Hr.backCCW, $e, ce, pe, r.id, me.layoutVertexBuffer, me.indexBuffer, me.segments, r.paint, h.transform.zoom, Te, h.style.map.terrain && me.centroidVertexBuffer)
                    }
                }
                function qs(h, e, r, s, c, d, m, v, b) {
                    var P;
                    const M = h.style.projection
                      , D = h.context
                      , L = h.transform
                      , B = D.gl
                      , Z = [`#define NUM_ILLUMINATION_SOURCES ${r.paint.get("hillshade-highlight-color").values.length}`]
                      , te = h.useProgram("hillshade", null, !1, Z)
                      , ee = !h.options.moving;
                    for (const ne of s) {
                        const oe = e.getTile(ne)
                          , me = oe.fbo;
                        if (!me)
                            continue;
                        const ce = M.getMeshFromTileID(D, ne.canonical, v, !0, "raster")
                          , Te = (P = h.style.map.terrain) === null || P === void 0 ? void 0 : P.getTerrainData(ne);
                        D.activeTexture.set(B.TEXTURE0),
                        B.bindTexture(B.TEXTURE_2D, me.colorAttachment.get());
                        const Pe = L.getProjectionData({
                            overscaledTileID: ne,
                            aligned: ee,
                            applyGlobeMatrix: !b,
                            applyTerrainMatrix: !0
                        });
                        te.draw(D, B.TRIANGLES, d, c[ne.overscaledZ], m, Hr.backCCW, Ds(h, oe, r), Te, Pe, r.id, ce.vertexBuffer, ce.indexBuffer, ce.segments)
                    }
                }
                function Po(h, e, r, s, c, d, m, v, b) {
                    var P;
                    const M = h.style.projection
                      , D = h.context
                      , L = h.transform
                      , B = D.gl
                      , Z = h.useProgram("colorRelief")
                      , te = !h.options.moving;
                    let ee = !0
                      , ne = 0;
                    for (const oe of s) {
                        const me = e.getTile(oe)
                          , ce = me.dem;
                        if (ee) {
                            const $e = B.getParameter(B.MAX_TEXTURE_SIZE)
                              , {elevationTexture: He, colorTexture: Je} = r.getColorRampTextures(D, $e, ce.getUnpackVector());
                            D.activeTexture.set(B.TEXTURE1),
                            He.bind(B.NEAREST, B.CLAMP_TO_EDGE),
                            D.activeTexture.set(B.TEXTURE4),
                            Je.bind(B.LINEAR, B.CLAMP_TO_EDGE),
                            ee = !1,
                            ne = He.size[0]
                        }
                        if (!ce || !ce.data)
                            continue;
                        const Te = ce.stride
                          , Pe = ce.getPixels();
                        if (D.activeTexture.set(B.TEXTURE0),
                        D.pixelStoreUnpackPremultiplyAlpha.set(!1),
                        me.demTexture = me.demTexture || h.getTileTexture(Te),
                        me.demTexture) {
                            const $e = me.demTexture;
                            $e.update(Pe, {
                                premultiply: !1
                            }),
                            $e.bind(B.LINEAR, B.CLAMP_TO_EDGE)
                        } else
                            me.demTexture = new o.T(D,Pe,B.RGBA,{
                                premultiply: !1
                            }),
                            me.demTexture.bind(B.LINEAR, B.CLAMP_TO_EDGE);
                        const pe = M.getMeshFromTileID(D, oe.canonical, v, !0, "raster")
                          , Fe = (P = h.style.map.terrain) === null || P === void 0 ? void 0 : P.getTerrainData(oe)
                          , Ye = L.getProjectionData({
                            overscaledTileID: oe,
                            aligned: te,
                            applyGlobeMatrix: !b,
                            applyTerrainMatrix: !0
                        });
                        Z.draw(D, B.TRIANGLES, d, c[oe.overscaledZ], m, Hr.backCCW, rp(r, me.dem, ne), Fe, Ye, r.id, pe.vertexBuffer, pe.indexBuffer, pe.segments)
                    }
                }
                const Dc = [new o.P(0,0), new o.P(o.$,0), new o.P(o.$,o.$), new o.P(0,o.$)];
                function Ha(h, e, r, s, c, d, m, v, b=!1, P=!1) {
                    const M = s[s.length - 1].overscaledZ
                      , D = h.context
                      , L = D.gl
                      , B = h.useProgram("raster")
                      , Z = h.transform
                      , te = h.style.projection
                      , ee = h.colorModeForRenderPass()
                      , ne = !h.options.moving;
                    for (const oe of s) {
                        const me = h.getDepthModeForSublayer(oe.overscaledZ - M, r.paint.get("raster-opacity") === 1 ? Xr.ReadWrite : Xr.ReadOnly, L.LESS)
                          , ce = e.getTile(oe);
                        ce.registerFadeDuration(r.paint.get("raster-fade-duration"));
                        const Te = e.findLoadedParent(oe, 0)
                          , Pe = e.findLoadedSibling(oe)
                          , pe = dp(ce, Te || Pe || null, e, r, h.transform, h.style.map.terrain);
                        let Fe, Ye;
                        const $e = r.paint.get("raster-resampling") === "nearest" ? L.NEAREST : L.LINEAR;
                        D.activeTexture.set(L.TEXTURE0),
                        ce.texture.bind($e, L.CLAMP_TO_EDGE, L.LINEAR_MIPMAP_NEAREST),
                        D.activeTexture.set(L.TEXTURE1),
                        Te ? (Te.texture.bind($e, L.CLAMP_TO_EDGE, L.LINEAR_MIPMAP_NEAREST),
                        Fe = Math.pow(2, Te.tileID.overscaledZ - ce.tileID.overscaledZ),
                        Ye = [ce.tileID.canonical.x * Fe % 1, ce.tileID.canonical.y * Fe % 1]) : ce.texture.bind($e, L.CLAMP_TO_EDGE, L.LINEAR_MIPMAP_NEAREST),
                        ce.texture.useMipmap && D.extTextureFilterAnisotropic && h.transform.pitch > 20 && L.texParameterf(L.TEXTURE_2D, D.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, D.extTextureFilterAnisotropicMax);
                        const He = h.style.map.terrain && h.style.map.terrain.getTerrainData(oe)
                          , Je = Z.getProjectionData({
                            overscaledTileID: oe,
                            aligned: ne,
                            applyGlobeMatrix: !P,
                            applyTerrainMatrix: !0
                        })
                          , qt = us(Ye || [0, 0], Fe || 1, pe, r, v)
                          , Nt = te.getMeshFromTileID(D, oe.canonical, d, m, "raster");
                        B.draw(D, L.TRIANGLES, me, c ? c[oe.overscaledZ] : qr.disabled, ee, b ? Hr.frontCCW : Hr.backCCW, qt, He, Je, r.id, Nt.vertexBuffer, Nt.indexBuffer, Nt.segments)
                    }
                }
                function dp(h, e, r, s, c, d) {
                    const m = s.paint.get("raster-fade-duration");
                    if (!d && m > 0) {
                        const v = he.now()
                          , b = (v - h.timeAdded) / m
                          , P = e ? (v - e.timeAdded) / m : -1
                          , M = r.getSource()
                          , D = je(c, {
                            tileSize: M.tileSize,
                            roundZoom: M.roundZoom
                        })
                          , L = !e || Math.abs(e.tileID.overscaledZ - D) > Math.abs(h.tileID.overscaledZ - D)
                          , B = L && h.refreshedUponExpiration ? 1 : o.ag(L ? b : 1 - P, 0, 1);
                        return h.refreshedUponExpiration && b >= 1 && (h.refreshedUponExpiration = !1),
                        e ? {
                            opacity: 1,
                            mix: 1 - B
                        } : {
                            opacity: B,
                            mix: 0
                        }
                    }
                    return {
                        opacity: 1,
                        mix: 0
                    }
                }
                const Nh = new o.be(1,0,0,1)
                  , vl = new o.be(0,1,0,1)
                  , Rc = new o.be(0,0,1,1)
                  , jh = new o.be(1,0,1,1)
                  , qh = new o.be(0,1,1,1);
                function Io(h, e, r, s) {
                    xl(h, 0, e + r / 2, h.transform.width, r, s)
                }
                function yl(h, e, r, s) {
                    xl(h, e - r / 2, 0, r, h.transform.height, s)
                }
                function xl(h, e, r, s, c, d) {
                    const m = h.context
                      , v = m.gl;
                    v.enable(v.SCISSOR_TEST),
                    v.scissor(e * h.pixelRatio, r * h.pixelRatio, s * h.pixelRatio, c * h.pixelRatio),
                    m.clear({
                        color: d
                    }),
                    v.disable(v.SCISSOR_TEST)
                }
                function Vh(h, e, r) {
                    const s = h.context
                      , c = s.gl
                      , d = h.useProgram("debug")
                      , m = Xr.disabled
                      , v = qr.disabled
                      , b = h.colorModeForRenderPass()
                      , P = "$debug"
                      , M = h.style.map.terrain && h.style.map.terrain.getTerrainData(r);
                    s.activeTexture.set(c.TEXTURE0);
                    const D = e.getTileByID(r.key).latestRawTileData
                      , L = Math.floor((D && D.byteLength || 0) / 1024)
                      , B = e.getTile(r).tileSize
                      , Z = 512 / Math.min(B, 512) * (r.overscaledZ / h.transform.zoom) * .5;
                    let te = r.canonical.toString();
                    r.overscaledZ !== r.canonical.z && (te += ` => ${r.overscaledZ}`),
                    function(ne, oe) {
                        ne.initDebugOverlayCanvas();
                        const me = ne.debugOverlayCanvas
                          , ce = ne.context.gl
                          , Te = ne.debugOverlayCanvas.getContext("2d");
                        Te.clearRect(0, 0, me.width, me.height),
                        Te.shadowColor = "white",
                        Te.shadowBlur = 2,
                        Te.lineWidth = 1.5,
                        Te.strokeStyle = "white",
                        Te.textBaseline = "top",
                        Te.font = "bold 36px Open Sans, sans-serif",
                        Te.fillText(oe, 5, 5),
                        Te.strokeText(oe, 5, 5),
                        ne.debugOverlayTexture.update(me),
                        ne.debugOverlayTexture.bind(ce.LINEAR, ce.CLAMP_TO_EDGE)
                    }(h, `${te} ${L}kB`);
                    const ee = h.transform.getProjectionData({
                        overscaledTileID: r,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                    });
                    d.draw(s, c.TRIANGLES, m, v, ai.alphaBlended, Hr.disabled, yh(o.be.transparent, Z), null, ee, P, h.debugBuffer, h.quadTriangleIndexBuffer, h.debugSegments),
                    d.draw(s, c.LINE_STRIP, m, v, b, Hr.disabled, yh(o.be.red), M, ee, P, h.debugBuffer, h.tileBorderIndexBuffer, h.debugSegments)
                }
                function ji(h, e, r, s) {
                    const {isRenderingGlobe: c} = s
                      , d = h.context
                      , m = d.gl
                      , v = h.transform
                      , b = h.colorModeForRenderPass()
                      , P = h.getDepthModeFor3D()
                      , M = h.useProgram("terrain");
                    d.bindFramebuffer.set(null),
                    d.viewport.set([0, 0, h.width, h.height]);
                    for (const D of r) {
                        const L = e.getTerrainMesh(D.tileID)
                          , B = h.renderToTexture.getTexture(D)
                          , Z = e.getTerrainData(D.tileID);
                        d.activeTexture.set(m.TEXTURE0),
                        m.bindTexture(m.TEXTURE_2D, B.texture);
                        const te = e.getMeshFrameDelta(v.zoom)
                          , ee = v.calculateFogMatrix(D.tileID.toUnwrapped())
                          , ne = Jd(te, ee, h.style.sky, v.pitch, c)
                          , oe = v.getProjectionData({
                            overscaledTileID: D.tileID,
                            applyTerrainMatrix: !1,
                            applyGlobeMatrix: !0
                        });
                        M.draw(d, m.TRIANGLES, P, qr.disabled, b, Hr.backCCW, ne, Z, oe, "terrain", L.vertexBuffer, L.indexBuffer, L.segments)
                    }
                }
                function Wa(h, e) {
                    if (!e.mesh) {
                        const r = new o.aK;
                        r.emplaceBack(-1, -1),
                        r.emplaceBack(1, -1),
                        r.emplaceBack(1, 1),
                        r.emplaceBack(-1, 1);
                        const s = new o.aM;
                        s.emplaceBack(0, 1, 2),
                        s.emplaceBack(0, 2, 3),
                        e.mesh = new Qn(h.createVertexBuffer(r, sa.members),h.createIndexBuffer(s),o.aL.simpleSegment(0, 0, r.length, s.length))
                    }
                    return e.mesh
                }
                class la {
                    constructor(e, r) {
                        this.context = new ei(e),
                        this.transform = r,
                        this._tileTextures = {},
                        this.terrainFacilitator = {
                            dirty: !0,
                            matrix: o.af(new Float64Array(16)),
                            renderTime: 0
                        },
                        this.setup(),
                        this.numSublayers = Ke.maxUnderzooming + Ke.maxOverzooming + 1,
                        this.depthEpsilon = 1 / Math.pow(2, 16),
                        this.crossTileSymbolIndex = new en
                    }
                    resize(e, r, s) {
                        if (this.width = Math.floor(e * s),
                        this.height = Math.floor(r * s),
                        this.pixelRatio = s,
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.style)
                            for (const c of this.style._order)
                                this.style._layers[c].resize()
                    }
                    setup() {
                        const e = this.context
                          , r = new o.aK;
                        r.emplaceBack(0, 0),
                        r.emplaceBack(o.$, 0),
                        r.emplaceBack(0, o.$),
                        r.emplaceBack(o.$, o.$),
                        this.tileExtentBuffer = e.createVertexBuffer(r, sa.members),
                        this.tileExtentSegments = o.aL.simpleSegment(0, 0, 4, 2);
                        const s = new o.aK;
                        s.emplaceBack(0, 0),
                        s.emplaceBack(o.$, 0),
                        s.emplaceBack(0, o.$),
                        s.emplaceBack(o.$, o.$),
                        this.debugBuffer = e.createVertexBuffer(s, sa.members),
                        this.debugSegments = o.aL.simpleSegment(0, 0, 4, 5);
                        const c = new o.c5;
                        c.emplaceBack(0, 0, 0, 0),
                        c.emplaceBack(o.$, 0, o.$, 0),
                        c.emplaceBack(0, o.$, 0, o.$),
                        c.emplaceBack(o.$, o.$, o.$, o.$),
                        this.rasterBoundsBuffer = e.createVertexBuffer(c, Kd.members),
                        this.rasterBoundsSegments = o.aL.simpleSegment(0, 0, 4, 2);
                        const d = new o.aK;
                        d.emplaceBack(0, 0),
                        d.emplaceBack(o.$, 0),
                        d.emplaceBack(0, o.$),
                        d.emplaceBack(o.$, o.$),
                        this.rasterBoundsBufferPosOnly = e.createVertexBuffer(d, sa.members),
                        this.rasterBoundsSegmentsPosOnly = o.aL.simpleSegment(0, 0, 4, 5);
                        const m = new o.aK;
                        m.emplaceBack(0, 0),
                        m.emplaceBack(1, 0),
                        m.emplaceBack(0, 1),
                        m.emplaceBack(1, 1),
                        this.viewportBuffer = e.createVertexBuffer(m, sa.members),
                        this.viewportSegments = o.aL.simpleSegment(0, 0, 4, 2);
                        const v = new o.c6;
                        v.emplaceBack(0),
                        v.emplaceBack(1),
                        v.emplaceBack(3),
                        v.emplaceBack(2),
                        v.emplaceBack(0),
                        this.tileBorderIndexBuffer = e.createIndexBuffer(v);
                        const b = new o.aM;
                        b.emplaceBack(1, 0, 2),
                        b.emplaceBack(1, 2, 3),
                        this.quadTriangleIndexBuffer = e.createIndexBuffer(b);
                        const P = this.context.gl;
                        this.stencilClearMode = new qr({
                            func: P.ALWAYS,
                            mask: 0
                        },0,255,P.ZERO,P.ZERO,P.ZERO),
                        this.tileExtentMesh = new Qn(this.tileExtentBuffer,this.quadTriangleIndexBuffer,this.tileExtentSegments)
                    }
                    clearStencil() {
                        const e = this.context
                          , r = e.gl;
                        this.nextStencilID = 1,
                        this.currentStencilSource = void 0;
                        const s = o.L();
                        o.bX(s, 0, this.width, this.height, 0, 0, 1),
                        o.N(s, s, [r.drawingBufferWidth, r.drawingBufferHeight, 0]);
                        const c = {
                            mainMatrix: s,
                            tileMercatorCoords: [0, 0, 1, 1],
                            clippingPlane: [0, 0, 0, 0],
                            projectionTransition: 0,
                            fallbackMatrix: s
                        };
                        this.useProgram("clippingMask", null, !0).draw(e, r.TRIANGLES, Xr.disabled, this.stencilClearMode, ai.disabled, Hr.disabled, null, null, c, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
                    }
                    _renderTileClippingMasks(e, r, s) {
                        if (this.currentStencilSource === e.source || !e.isTileClipped() || !r || !r.length)
                            return;
                        this.currentStencilSource = e.source,
                        this.nextStencilID + r.length > 256 && this.clearStencil();
                        const c = this.context;
                        c.setColorMode(ai.disabled),
                        c.setDepthMode(Xr.disabled);
                        const d = {};
                        for (const m of r)
                            d[m.key] = this.nextStencilID++;
                        this._renderTileMasks(d, r, s, !0),
                        this._renderTileMasks(d, r, s, !1),
                        this._tileClippingMaskIDs = d
                    }
                    _renderTileMasks(e, r, s, c) {
                        const d = this.context
                          , m = d.gl
                          , v = this.style.projection
                          , b = this.transform
                          , P = this.useProgram("clippingMask");
                        for (const M of r) {
                            const D = e[M.key]
                              , L = this.style.map.terrain && this.style.map.terrain.getTerrainData(M)
                              , B = v.getMeshFromTileID(this.context, M.canonical, c, !0, "stencil")
                              , Z = b.getProjectionData({
                                overscaledTileID: M,
                                applyGlobeMatrix: !s,
                                applyTerrainMatrix: !0
                            });
                            P.draw(d, m.TRIANGLES, Xr.disabled, new qr({
                                func: m.ALWAYS,
                                mask: 0
                            },D,255,m.KEEP,m.KEEP,m.REPLACE), ai.disabled, s ? Hr.disabled : Hr.backCCW, null, L, Z, "$clipping", B.vertexBuffer, B.indexBuffer, B.segments)
                        }
                    }
                    _renderTilesDepthBuffer() {
                        const e = this.context
                          , r = e.gl
                          , s = this.style.projection
                          , c = this.transform
                          , d = this.useProgram("depth")
                          , m = this.getDepthModeFor3D()
                          , v = Oe(c, {
                            tileSize: c.tileSize
                        });
                        for (const b of v) {
                            const P = this.style.map.terrain && this.style.map.terrain.getTerrainData(b)
                              , M = s.getMeshFromTileID(this.context, b.canonical, !0, !0, "raster")
                              , D = c.getProjectionData({
                                overscaledTileID: b,
                                applyGlobeMatrix: !0,
                                applyTerrainMatrix: !0
                            });
                            d.draw(e, r.TRIANGLES, m, qr.disabled, ai.disabled, Hr.backCCW, null, P, D, "$clipping", M.vertexBuffer, M.indexBuffer, M.segments)
                        }
                    }
                    stencilModeFor3D() {
                        this.currentStencilSource = void 0,
                        this.nextStencilID + 1 > 256 && this.clearStencil();
                        const e = this.nextStencilID++
                          , r = this.context.gl;
                        return new qr({
                            func: r.NOTEQUAL,
                            mask: 255
                        },e,255,r.KEEP,r.KEEP,r.REPLACE)
                    }
                    stencilModeForClipping(e) {
                        const r = this.context.gl;
                        return new qr({
                            func: r.EQUAL,
                            mask: 255
                        },this._tileClippingMaskIDs[e.key],0,r.KEEP,r.KEEP,r.REPLACE)
                    }
                    getStencilConfigForOverlapAndUpdateStencilID(e) {
                        const r = this.context.gl
                          , s = e.sort( (m, v) => v.overscaledZ - m.overscaledZ)
                          , c = s[s.length - 1].overscaledZ
                          , d = s[0].overscaledZ - c + 1;
                        if (d > 1) {
                            this.currentStencilSource = void 0,
                            this.nextStencilID + d > 256 && this.clearStencil();
                            const m = {};
                            for (let v = 0; v < d; v++)
                                m[v + c] = new qr({
                                    func: r.GEQUAL,
                                    mask: 255
                                },v + this.nextStencilID,255,r.KEEP,r.KEEP,r.REPLACE);
                            return this.nextStencilID += d,
                            [m, s]
                        }
                        return [{
                            [c]: qr.disabled
                        }, s]
                    }
                    stencilConfigForOverlapTwoPass(e) {
                        const r = this.context.gl
                          , s = e.sort( (m, v) => v.overscaledZ - m.overscaledZ)
                          , c = s[s.length - 1].overscaledZ
                          , d = s[0].overscaledZ - c + 1;
                        if (this.clearStencil(),
                        d > 1) {
                            const m = {}
                              , v = {};
                            for (let b = 0; b < d; b++)
                                m[b + c] = new qr({
                                    func: r.GREATER,
                                    mask: 255
                                },d + 1 + b,255,r.KEEP,r.KEEP,r.REPLACE),
                                v[b + c] = new qr({
                                    func: r.GREATER,
                                    mask: 255
                                },1 + b,255,r.KEEP,r.KEEP,r.REPLACE);
                            return this.nextStencilID = 2 * d + 1,
                            [m, v, s]
                        }
                        return this.nextStencilID = 3,
                        [{
                            [c]: new qr({
                                func: r.GREATER,
                                mask: 255
                            },2,255,r.KEEP,r.KEEP,r.REPLACE)
                        }, {
                            [c]: new qr({
                                func: r.GREATER,
                                mask: 255
                            },1,255,r.KEEP,r.KEEP,r.REPLACE)
                        }, s]
                    }
                    colorModeForRenderPass() {
                        const e = this.context.gl;
                        return this._showOverdrawInspector ? new ai([e.CONSTANT_COLOR, e.ONE],new o.be(.125,.125,.125,0),[!0, !0, !0, !0]) : this.renderPass === "opaque" ? ai.unblended : ai.alphaBlended
                    }
                    getDepthModeForSublayer(e, r, s) {
                        if (!this.opaquePassEnabledForLayer())
                            return Xr.disabled;
                        const c = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
                        return new Xr(s || this.context.gl.LEQUAL,r,[c, c])
                    }
                    getDepthModeFor3D() {
                        return new Xr(this.context.gl.LEQUAL,Xr.ReadWrite,this.depthRangeFor3D)
                    }
                    opaquePassEnabledForLayer() {
                        return this.currentLayer < this.opaquePassCutoff
                    }
                    render(e, r) {
                        var s, c;
                        this.style = e,
                        this.options = r,
                        this.lineAtlas = e.lineAtlas,
                        this.imageManager = e.imageManager,
                        this.glyphManager = e.glyphManager,
                        this.symbolFadeChange = e.placement.symbolFadeChange(he.now()),
                        this.imageManager.beginFrame();
                        const d = this.style._order
                          , m = this.style.sourceCaches
                          , v = {}
                          , b = {}
                          , P = {}
                          , M = {
                            isRenderingToTexture: !1,
                            isRenderingGlobe: ((s = e.projection) === null || s === void 0 ? void 0 : s.transitionState) > 0
                        };
                        for (const L in m) {
                            const B = m[L];
                            B.used && B.prepare(this.context),
                            v[L] = B.getVisibleCoordinates(!1),
                            b[L] = v[L].slice().reverse(),
                            P[L] = B.getVisibleCoordinates(!0).reverse()
                        }
                        this.opaquePassCutoff = 1 / 0;
                        for (let L = 0; L < d.length; L++)
                            if (this.style._layers[d[L]].is3D()) {
                                this.opaquePassCutoff = L;
                                break
                            }
                        this.maybeDrawDepthAndCoords(!1),
                        this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom),
                        this.opaquePassCutoff = 0),
                        this.renderPass = "offscreen";
                        for (const L of d) {
                            const B = this.style._layers[L];
                            if (!B.hasOffscreenPass() || B.isHidden(this.transform.zoom))
                                continue;
                            const Z = b[B.source];
                            (B.type === "custom" || Z.length) && this.renderLayer(this, m[B.source], B, Z, M)
                        }
                        if ((c = this.style.projection) === null || c === void 0 || c.updateGPUdependent({
                            context: this.context,
                            useProgram: L => this.useProgram(L)
                        }),
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.context.bindFramebuffer.set(null),
                        this.context.clear({
                            color: r.showOverdrawInspector ? o.be.black : o.be.transparent,
                            depth: 1
                        }),
                        this.clearStencil(),
                        this.style.sky && function(L, B) {
                            const Z = L.context
                              , te = Z.gl
                              , ee = ( (Pe, pe, Fe) => {
                                const Ye = Math.cos(pe.rollInRadians)
                                  , $e = Math.sin(pe.rollInRadians)
                                  , He = V(pe)
                                  , Je = pe.getProjectionData({
                                    overscaledTileID: null,
                                    applyGlobeMatrix: !0,
                                    applyTerrainMatrix: !0
                                }).projectionTransition;
                                return {
                                    u_sky_color: Pe.properties.get("sky-color"),
                                    u_horizon_color: Pe.properties.get("horizon-color"),
                                    u_horizon: [(pe.width / 2 - He * $e) * Fe, (pe.height / 2 + He * Ye) * Fe],
                                    u_horizon_normal: [-$e, Ye],
                                    u_sky_horizon_blend: Pe.properties.get("sky-horizon-blend") * pe.height / 2 * Fe,
                                    u_sky_blend: Je
                                }
                            }
                            )(B, L.style.map.transform, L.pixelRatio)
                              , ne = new Xr(te.LEQUAL,Xr.ReadWrite,[0, 1])
                              , oe = qr.disabled
                              , me = L.colorModeForRenderPass()
                              , ce = L.useProgram("sky")
                              , Te = Wa(Z, B);
                            ce.draw(Z, te.TRIANGLES, ne, oe, me, Hr.disabled, ee, null, void 0, "sky", Te.vertexBuffer, Te.indexBuffer, Te.segments)
                        }(this, this.style.sky),
                        this._showOverdrawInspector = r.showOverdrawInspector,
                        this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon],
                        !this.renderToTexture)
                            for (this.renderPass = "opaque",
                            this.currentLayer = d.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                                const L = this.style._layers[d[this.currentLayer]]
                                  , B = m[L.source]
                                  , Z = v[L.source];
                                this._renderTileClippingMasks(L, Z, !1),
                                this.renderLayer(this, B, L, Z, M)
                            }
                        this.renderPass = "translucent";
                        let D = !1;
                        for (this.currentLayer = 0; this.currentLayer < d.length; this.currentLayer++) {
                            const L = this.style._layers[d[this.currentLayer]]
                              , B = m[L.source];
                            if (this.renderToTexture && this.renderToTexture.renderLayer(L, M))
                                continue;
                            this.opaquePassEnabledForLayer() || D || (D = !0,
                            M.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
                            const Z = (L.type === "symbol" ? P : b)[L.source];
                            this._renderTileClippingMasks(L, v[L.source], !!this.renderToTexture),
                            this.renderLayer(this, B, L, Z, M)
                        }
                        if (M.isRenderingGlobe && function(L, B, Z) {
                            const te = L.context
                              , ee = te.gl
                              , ne = L.useProgram("atmosphere")
                              , oe = new Xr(ee.LEQUAL,Xr.ReadOnly,[0, 1])
                              , me = L.transform
                              , ce = function(Je, qt) {
                                const Nt = Je.properties.get("position")
                                  , wt = [-Nt.x, -Nt.y, -Nt.z]
                                  , rr = o.af(new Float64Array(16));
                                return Je.properties.get("anchor") === "map" && (o.b5(rr, rr, qt.rollInRadians),
                                o.b6(rr, rr, -qt.pitchInRadians),
                                o.b5(rr, rr, qt.bearingInRadians),
                                o.b6(rr, rr, qt.center.lat * Math.PI / 180),
                                o.by(rr, rr, -qt.center.lng * Math.PI / 180)),
                                o.c4(wt, wt, rr),
                                wt
                            }(Z, L.transform)
                              , Te = me.getProjectionData({
                                overscaledTileID: null,
                                applyGlobeMatrix: !0,
                                applyTerrainMatrix: !0
                            })
                              , Pe = B.properties.get("atmosphere-blend") * Te.projectionTransition;
                            if (Pe === 0)
                                return;
                            const pe = Ms(me.worldSize, me.center.lat)
                              , Fe = me.inverseProjectionMatrix
                              , Ye = new Float64Array(4);
                            Ye[3] = 1,
                            o.av(Ye, Ye, me.modelViewProjectionMatrix),
                            Ye[0] /= Ye[3],
                            Ye[1] /= Ye[3],
                            Ye[2] /= Ye[3],
                            Ye[3] = 1,
                            o.av(Ye, Ye, Fe),
                            Ye[0] /= Ye[3],
                            Ye[1] /= Ye[3],
                            Ye[2] /= Ye[3],
                            Ye[3] = 1;
                            const $e = ( (Je, qt, Nt, wt, rr) => ({
                                u_sun_pos: Je,
                                u_atmosphere_blend: qt,
                                u_globe_position: Nt,
                                u_globe_radius: wt,
                                u_inv_proj_matrix: rr
                            }))(ce, Pe, [Ye[0], Ye[1], Ye[2]], pe, Fe)
                              , He = Wa(te, B);
                            ne.draw(te, ee.TRIANGLES, oe, qr.disabled, ai.alphaBlended, Hr.disabled, $e, null, null, "atmosphere", He.vertexBuffer, He.indexBuffer, He.segments)
                        }(this, this.style.sky, this.style.light),
                        this.options.showTileBoundaries) {
                            const L = function(B, Z) {
                                let te = null;
                                const ee = Object.values(B._layers).flatMap(ce => ce.source && !ce.isHidden(Z) ? [B.sourceCaches[ce.source]] : [])
                                  , ne = ee.filter(ce => ce.getSource().type === "vector")
                                  , oe = ee.filter(ce => ce.getSource().type !== "vector")
                                  , me = ce => {
                                    (!te || te.getSource().maxzoom < ce.getSource().maxzoom) && (te = ce)
                                }
                                ;
                                return ne.forEach(ce => me(ce)),
                                te || oe.forEach(ce => me(ce)),
                                te
                            }(this.style, this.transform.zoom);
                            L && function(B, Z, te) {
                                for (let ee = 0; ee < te.length; ee++)
                                    Vh(B, Z, te[ee])
                            }(this, L, L.getVisibleCoordinates())
                        }
                        this.options.showPadding && function(L) {
                            const B = L.transform.padding;
                            Io(L, L.transform.height - (B.top || 0), 3, Nh),
                            Io(L, B.bottom || 0, 3, vl),
                            yl(L, B.left || 0, 3, Rc),
                            yl(L, L.transform.width - (B.right || 0), 3, jh);
                            const Z = L.transform.centerPoint;
                            (function(te, ee, ne, oe) {
                                xl(te, ee - 1, ne - 10, 2, 20, oe),
                                xl(te, ee - 10, ne - 1, 20, 2, oe)
                            }
                            )(L, Z.x, L.transform.height - Z.y, qh)
                        }(this),
                        this.context.setDefault()
                    }
                    maybeDrawDepthAndCoords(e) {
                        if (!this.style || !this.style.map || !this.style.map.terrain)
                            return;
                        const r = this.terrainFacilitator.matrix
                          , s = this.transform.modelViewProjectionMatrix;
                        let c = this.terrainFacilitator.dirty;
                        c || (c = e ? !o.c7(r, s) : !o.c8(r, s)),
                        c || (c = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)),
                        c && (o.c9(r, s),
                        this.terrainFacilitator.renderTime = Date.now(),
                        this.terrainFacilitator.dirty = !1,
                        function(d, m) {
                            const v = d.context
                              , b = v.gl
                              , P = d.transform
                              , M = ai.unblended
                              , D = new Xr(b.LEQUAL,Xr.ReadWrite,[0, 1])
                              , L = m.sourceCache.getRenderableTiles()
                              , B = d.useProgram("terrainDepth");
                            v.bindFramebuffer.set(m.getFramebuffer("depth").framebuffer),
                            v.viewport.set([0, 0, d.width / devicePixelRatio, d.height / devicePixelRatio]),
                            v.clear({
                                color: o.be.transparent,
                                depth: 1
                            });
                            for (const Z of L) {
                                const te = m.getTerrainMesh(Z.tileID)
                                  , ee = m.getTerrainData(Z.tileID)
                                  , ne = P.getProjectionData({
                                    overscaledTileID: Z.tileID,
                                    applyTerrainMatrix: !1,
                                    applyGlobeMatrix: !0
                                })
                                  , oe = {
                                    u_ele_delta: m.getMeshFrameDelta(P.zoom)
                                };
                                B.draw(v, b.TRIANGLES, D, qr.disabled, M, Hr.backCCW, oe, ee, ne, "terrain", te.vertexBuffer, te.indexBuffer, te.segments)
                            }
                            v.bindFramebuffer.set(null),
                            v.viewport.set([0, 0, d.width, d.height])
                        }(this, this.style.map.terrain),
                        function(d, m) {
                            const v = d.context
                              , b = v.gl
                              , P = d.transform
                              , M = ai.unblended
                              , D = new Xr(b.LEQUAL,Xr.ReadWrite,[0, 1])
                              , L = m.getCoordsTexture()
                              , B = m.sourceCache.getRenderableTiles()
                              , Z = d.useProgram("terrainCoords");
                            v.bindFramebuffer.set(m.getFramebuffer("coords").framebuffer),
                            v.viewport.set([0, 0, d.width / devicePixelRatio, d.height / devicePixelRatio]),
                            v.clear({
                                color: o.be.transparent,
                                depth: 1
                            }),
                            m.coordsIndex = [];
                            for (const te of B) {
                                const ee = m.getTerrainMesh(te.tileID)
                                  , ne = m.getTerrainData(te.tileID);
                                v.activeTexture.set(b.TEXTURE0),
                                b.bindTexture(b.TEXTURE_2D, L.texture);
                                const oe = {
                                    u_terrain_coords_id: (255 - m.coordsIndex.length) / 255,
                                    u_texture: 0,
                                    u_ele_delta: m.getMeshFrameDelta(P.zoom)
                                }
                                  , me = P.getProjectionData({
                                    overscaledTileID: te.tileID,
                                    applyTerrainMatrix: !1,
                                    applyGlobeMatrix: !0
                                });
                                Z.draw(v, b.TRIANGLES, D, qr.disabled, M, Hr.backCCW, oe, ne, me, "terrain", ee.vertexBuffer, ee.indexBuffer, ee.segments),
                                m.coordsIndex.push(te.tileID.key)
                            }
                            v.bindFramebuffer.set(null),
                            v.viewport.set([0, 0, d.width, d.height])
                        }(this, this.style.map.terrain))
                    }
                    renderLayer(e, r, s, c, d) {
                        s.isHidden(this.transform.zoom) || (s.type === "background" || s.type === "custom" || (c || []).length) && (this.id = s.id,
                        o.ca(s) ? function(m, v, b, P, M, D) {
                            if (m.renderPass !== "translucent")
                                return;
                            const {isRenderingToTexture: L} = D
                              , B = qr.disabled
                              , Z = m.colorModeForRenderPass();
                            (b._unevaluatedLayout.hasValue("text-variable-anchor") || b._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(te, ee, ne, oe, me, ce, Te, Pe, pe) {
                                const Fe = ee.transform
                                  , Ye = ee.style.map.terrain
                                  , $e = me === "map"
                                  , He = ce === "map";
                                for (const Je of te) {
                                    const qt = oe.getTile(Je)
                                      , Nt = qt.getBucket(ne);
                                    if (!Nt || !Nt.text || !Nt.text.segments.get().length)
                                        continue;
                                    const wt = o.am(Nt.textSizeData, Fe.zoom)
                                      , rr = o.aB(qt, 1, ee.transform.zoom)
                                      , Kr = wr($e, ee.transform, rr)
                                      , fi = ne.layout.get("icon-text-fit") !== "none" && Nt.hasIconData();
                                    if (wt) {
                                        const Bi = Math.pow(2, Fe.zoom - qt.tileID.overscaledZ)
                                          , xi = Ye ? (Fi, Ti) => Ye.getElevation(Je, Fi, Ti) : null;
                                        hp(Nt, $e, He, pe, Fe, Kr, Bi, wt, fi, o.aC(Fe, qt, Te, Pe), Je.toUnwrapped(), xi)
                                    }
                                }
                            }(P, m, b, v, b.layout.get("text-rotation-alignment"), b.layout.get("text-pitch-alignment"), b.paint.get("text-translate"), b.paint.get("text-translate-anchor"), M),
                            b.paint.get("icon-opacity").constantOr(1) !== 0 && Oh(m, v, b, P, !1, b.paint.get("icon-translate"), b.paint.get("icon-translate-anchor"), b.layout.get("icon-rotation-alignment"), b.layout.get("icon-pitch-alignment"), b.layout.get("icon-keep-upright"), B, Z, L),
                            b.paint.get("text-opacity").constantOr(1) !== 0 && Oh(m, v, b, P, !0, b.paint.get("text-translate"), b.paint.get("text-translate-anchor"), b.layout.get("text-rotation-alignment"), b.layout.get("text-pitch-alignment"), b.layout.get("text-keep-upright"), B, Z, L),
                            v.map.showCollisionBoxes && (Rh(m, v, b, P, !0),
                            Rh(m, v, b, P, !1))
                        }(e, r, s, c, this.style.placement.variableOffsets, d) : o.cb(s) ? function(m, v, b, P, M) {
                            if (m.renderPass !== "translucent")
                                return;
                            const {isRenderingToTexture: D} = M
                              , L = b.paint.get("circle-opacity")
                              , B = b.paint.get("circle-stroke-width")
                              , Z = b.paint.get("circle-stroke-opacity")
                              , te = !b.layout.get("circle-sort-key").isConstant();
                            if (L.constantOr(1) === 0 && (B.constantOr(1) === 0 || Z.constantOr(1) === 0))
                                return;
                            const ee = m.context
                              , ne = ee.gl
                              , oe = m.transform
                              , me = m.getDepthModeForSublayer(0, Xr.ReadOnly)
                              , ce = qr.disabled
                              , Te = m.colorModeForRenderPass()
                              , Pe = []
                              , pe = oe.getCircleRadiusCorrection();
                            for (let Fe = 0; Fe < P.length; Fe++) {
                                const Ye = P[Fe]
                                  , $e = v.getTile(Ye)
                                  , He = $e.getBucket(b);
                                if (!He)
                                    continue;
                                const Je = b.paint.get("circle-translate")
                                  , qt = b.paint.get("circle-translate-anchor")
                                  , Nt = o.aC(oe, $e, Je, qt)
                                  , wt = He.programConfigurations.get(b.id)
                                  , rr = m.useProgram("circle", wt)
                                  , Kr = He.layoutVertexBuffer
                                  , fi = He.indexBuffer
                                  , Bi = m.style.map.terrain && m.style.map.terrain.getTerrainData(Ye)
                                  , xi = {
                                    programConfiguration: wt,
                                    program: rr,
                                    layoutVertexBuffer: Kr,
                                    indexBuffer: fi,
                                    uniformValues: vc(m, $e, b, Nt, pe),
                                    terrainData: Bi,
                                    projectionData: oe.getProjectionData({
                                        overscaledTileID: Ye,
                                        applyGlobeMatrix: !D,
                                        applyTerrainMatrix: !0
                                    })
                                };
                                if (te) {
                                    const Fi = He.segments.get();
                                    for (const Ti of Fi)
                                        Pe.push({
                                            segments: new o.aL([Ti]),
                                            sortKey: Ti.sortKey,
                                            state: xi
                                        })
                                } else
                                    Pe.push({
                                        segments: He.segments,
                                        sortKey: 0,
                                        state: xi
                                    })
                            }
                            te && Pe.sort( (Fe, Ye) => Fe.sortKey - Ye.sortKey);
                            for (const Fe of Pe) {
                                const {programConfiguration: Ye, program: $e, layoutVertexBuffer: He, indexBuffer: Je, uniformValues: qt, terrainData: Nt, projectionData: wt} = Fe.state;
                                $e.draw(ee, ne.TRIANGLES, me, ce, Te, Hr.backCCW, qt, Nt, wt, b.id, He, Je, Fe.segments, b.paint, m.transform.zoom, Ye)
                            }
                        }(e, r, s, c, d) : o.cc(s) ? function(m, v, b, P, M) {
                            if (b.paint.get("heatmap-opacity") === 0)
                                return;
                            const D = m.context
                              , {isRenderingToTexture: L, isRenderingGlobe: B} = M;
                            if (m.style.map.terrain) {
                                for (const Z of P) {
                                    const te = v.getTile(Z);
                                    v.hasRenderableParent(Z) || (m.renderPass === "offscreen" ? ml(m, te, b, Z, B) : m.renderPass === "translucent" && _l(m, b, Z, L, B))
                                }
                                D.viewport.set([0, 0, m.width, m.height])
                            } else
                                m.renderPass === "offscreen" ? function(Z, te, ee, ne) {
                                    const oe = Z.context
                                      , me = oe.gl
                                      , ce = Z.transform
                                      , Te = qr.disabled
                                      , Pe = new ai([me.ONE, me.ONE],o.be.transparent,[!0, !0, !0, !0]);
                                    (function(pe, Fe, Ye) {
                                        const $e = pe.gl;
                                        pe.activeTexture.set($e.TEXTURE1),
                                        pe.viewport.set([0, 0, Fe.width / 4, Fe.height / 4]);
                                        let He = Ye.heatmapFbos.get(o.c1);
                                        He ? ($e.bindTexture($e.TEXTURE_2D, He.colorAttachment.get()),
                                        pe.bindFramebuffer.set(He.framebuffer)) : (He = Co(pe, Fe.width / 4, Fe.height / 4),
                                        Ye.heatmapFbos.set(o.c1, He))
                                    }
                                    )(oe, Z, ee),
                                    oe.clear({
                                        color: o.be.transparent
                                    });
                                    for (let pe = 0; pe < ne.length; pe++) {
                                        const Fe = ne[pe];
                                        if (te.hasRenderableParent(Fe))
                                            continue;
                                        const Ye = te.getTile(Fe)
                                          , $e = Ye.getBucket(ee);
                                        if (!$e)
                                            continue;
                                        const He = $e.programConfigurations.get(ee.id)
                                          , Je = Z.useProgram("heatmap", He)
                                          , qt = ce.getProjectionData({
                                            overscaledTileID: Fe,
                                            applyGlobeMatrix: !0,
                                            applyTerrainMatrix: !1
                                        })
                                          , Nt = ce.getCircleRadiusCorrection();
                                        Je.draw(oe, me.TRIANGLES, Xr.disabled, Te, Pe, Hr.backCCW, xo(Ye, ce.zoom, ee.paint.get("heatmap-intensity"), Nt), null, qt, ee.id, $e.layoutVertexBuffer, $e.indexBuffer, $e.segments, ee.paint, ce.zoom, He)
                                    }
                                    oe.viewport.set([0, 0, Z.width, Z.height])
                                }(m, v, b, P) : m.renderPass === "translucent" && function(Z, te) {
                                    const ee = Z.context
                                      , ne = ee.gl;
                                    ee.setColorMode(Z.colorModeForRenderPass());
                                    const oe = te.heatmapFbos.get(o.c1);
                                    oe && (ee.activeTexture.set(ne.TEXTURE0),
                                    ne.bindTexture(ne.TEXTURE_2D, oe.colorAttachment.get()),
                                    ee.activeTexture.set(ne.TEXTURE1),
                                    gl(ee, te).bind(ne.LINEAR, ne.CLAMP_TO_EDGE),
                                    Z.useProgram("heatmapTexture").draw(ee, ne.TRIANGLES, Xr.disabled, qr.disabled, Z.colorModeForRenderPass(), Hr.disabled, xh(Z, te, 0, 1), null, null, te.id, Z.viewportBuffer, Z.quadTriangleIndexBuffer, Z.viewportSegments, te.paint, Z.transform.zoom))
                                }(m, b)
                        }(e, r, s, c, d) : o.cd(s) ? function(m, v, b, P, M) {
                            if (m.renderPass !== "translucent")
                                return;
                            const {isRenderingToTexture: D} = M
                              , L = b.paint.get("line-opacity")
                              , B = b.paint.get("line-width");
                            if (L.constantOr(1) === 0 || B.constantOr(1) === 0)
                                return;
                            const Z = m.getDepthModeForSublayer(0, Xr.ReadOnly)
                              , te = m.colorModeForRenderPass()
                              , ee = b.paint.get("line-dasharray")
                              , ne = b.paint.get("line-pattern")
                              , oe = ne.constantOr(1)
                              , me = b.paint.get("line-gradient")
                              , ce = b.getCrossfadeParameters()
                              , Te = oe ? "linePattern" : ee ? "lineSDF" : me ? "lineGradient" : "line"
                              , Pe = m.context
                              , pe = Pe.gl
                              , Fe = m.transform;
                            let Ye = !0;
                            for (const $e of P) {
                                const He = v.getTile($e);
                                if (oe && !He.patternsLoaded())
                                    continue;
                                const Je = He.getBucket(b);
                                if (!Je)
                                    continue;
                                const qt = Je.programConfigurations.get(b.id)
                                  , Nt = m.context.program.get()
                                  , wt = m.useProgram(Te, qt)
                                  , rr = Ye || wt.program !== Nt
                                  , Kr = m.style.map.terrain && m.style.map.terrain.getTerrainData($e)
                                  , fi = ne.constantOr(null);
                                if (fi && He.imageAtlas) {
                                    const bi = He.imageAtlas
                                      , Ci = bi.patternPositions[fi.to.toString()]
                                      , vn = bi.patternPositions[fi.from.toString()];
                                    Ci && vn && qt.setConstantPatternPositions(Ci, vn)
                                }
                                const Bi = Fe.getProjectionData({
                                    overscaledTileID: $e,
                                    applyGlobeMatrix: !D,
                                    applyTerrainMatrix: !0
                                })
                                  , xi = Fe.getPixelScale()
                                  , Fi = oe ? wh(m, He, b, xi, ce) : ee ? Th(m, He, b, xi, ee, ce) : me ? yc(m, He, b, xi, Je.lineClipsArray.length) : sl(m, He, b, xi);
                                if (oe)
                                    Pe.activeTexture.set(pe.TEXTURE0),
                                    He.imageAtlasTexture.bind(pe.LINEAR, pe.CLAMP_TO_EDGE),
                                    qt.updatePaintBuffers(ce);
                                else if (ee && (rr || m.lineAtlas.dirty))
                                    Pe.activeTexture.set(pe.TEXTURE0),
                                    m.lineAtlas.bind(Pe);
                                else if (me) {
                                    const bi = Je.gradients[b.id];
                                    let Ci = bi.texture;
                                    if (b.gradientVersion !== bi.version) {
                                        let vn = 256;
                                        if (b.stepInterpolant) {
                                            const li = v.getSource().maxzoom
                                              , cn = $e.canonical.z === li ? Math.ceil(1 << m.transform.maxZoom - $e.canonical.z) : 1;
                                            vn = o.ag(o.c2(Je.maxLineLength / o.$ * 1024 * cn), 256, Pe.maxTextureSize)
                                        }
                                        bi.gradient = o.c3({
                                            expression: b.gradientExpression(),
                                            evaluationKey: "lineProgress",
                                            resolution: vn,
                                            image: bi.gradient || void 0,
                                            clips: Je.lineClipsArray
                                        }),
                                        bi.texture ? bi.texture.update(bi.gradient) : bi.texture = new o.T(Pe,bi.gradient,pe.RGBA),
                                        bi.version = b.gradientVersion,
                                        Ci = bi.texture
                                    }
                                    Pe.activeTexture.set(pe.TEXTURE0),
                                    Ci.bind(b.stepInterpolant ? pe.NEAREST : pe.LINEAR, pe.CLAMP_TO_EDGE)
                                }
                                const Ti = m.stencilModeForClipping($e);
                                wt.draw(Pe, pe.TRIANGLES, Z, Ti, te, Hr.disabled, Fi, Kr, Bi, b.id, Je.layoutVertexBuffer, Je.indexBuffer, Je.segments, b.paint, m.transform.zoom, qt, Je.layoutVertexBuffer2),
                                Ye = !1
                            }
                        }(e, r, s, c, d) : o.ce(s) ? function(m, v, b, P, M) {
                            const D = b.paint.get("fill-color")
                              , L = b.paint.get("fill-opacity");
                            if (L.constantOr(1) === 0)
                                return;
                            const {isRenderingToTexture: B} = M
                              , Z = m.colorModeForRenderPass()
                              , te = b.paint.get("fill-pattern")
                              , ee = m.opaquePassEnabledForLayer() && !te.constantOr(1) && D.constantOr(o.be.transparent).a === 1 && L.constantOr(0) === 1 ? "opaque" : "translucent";
                            if (m.renderPass === ee) {
                                const ne = m.getDepthModeForSublayer(1, m.renderPass === "opaque" ? Xr.ReadWrite : Xr.ReadOnly);
                                So(m, v, b, P, ne, Z, !1, B)
                            }
                            if (m.renderPass === "translucent" && b.paint.get("fill-antialias")) {
                                const ne = m.getDepthModeForSublayer(b.getPaintProperty("fill-outline-color") ? 2 : 0, Xr.ReadOnly);
                                So(m, v, b, P, ne, Z, !0, B)
                            }
                        }(e, r, s, c, d) : o.cf(s) ? function(m, v, b, P, M) {
                            const D = b.paint.get("fill-extrusion-opacity");
                            if (D === 0)
                                return;
                            const {isRenderingToTexture: L} = M;
                            if (m.renderPass === "translucent") {
                                const B = new Xr(m.context.gl.LEQUAL,Xr.ReadWrite,m.depthRangeFor3D);
                                if (D !== 1 || b.paint.get("fill-extrusion-pattern").constantOr(1))
                                    js(m, v, b, P, B, qr.disabled, ai.disabled, L),
                                    js(m, v, b, P, B, m.stencilModeFor3D(), m.colorModeForRenderPass(), L);
                                else {
                                    const Z = m.colorModeForRenderPass();
                                    js(m, v, b, P, B, qr.disabled, Z, L)
                                }
                            }
                        }(e, r, s, c, d) : o.cg(s) ? function(m, v, b, P, M) {
                            if (m.renderPass !== "offscreen" && m.renderPass !== "translucent")
                                return;
                            const {isRenderingToTexture: D} = M
                              , L = m.context
                              , B = m.style.projection.useSubdivision
                              , Z = m.getDepthModeForSublayer(0, Xr.ReadOnly)
                              , te = m.colorModeForRenderPass();
                            if (m.renderPass === "offscreen")
                                (function(ee, ne, oe, me, ce, Te, Pe) {
                                    const pe = ee.context
                                      , Fe = pe.gl;
                                    for (const Ye of oe) {
                                        const $e = ne.getTile(Ye)
                                          , He = $e.dem;
                                        if (!He || !He.data || !$e.needsHillshadePrepare)
                                            continue;
                                        const Je = He.dim
                                          , qt = He.stride
                                          , Nt = He.getPixels();
                                        if (pe.activeTexture.set(Fe.TEXTURE1),
                                        pe.pixelStoreUnpackPremultiplyAlpha.set(!1),
                                        $e.demTexture = $e.demTexture || ee.getTileTexture(qt),
                                        $e.demTexture) {
                                            const rr = $e.demTexture;
                                            rr.update(Nt, {
                                                premultiply: !1
                                            }),
                                            rr.bind(Fe.NEAREST, Fe.CLAMP_TO_EDGE)
                                        } else
                                            $e.demTexture = new o.T(pe,Nt,Fe.RGBA,{
                                                premultiply: !1
                                            }),
                                            $e.demTexture.bind(Fe.NEAREST, Fe.CLAMP_TO_EDGE);
                                        pe.activeTexture.set(Fe.TEXTURE0);
                                        let wt = $e.fbo;
                                        if (!wt) {
                                            const rr = new o.T(pe,{
                                                width: Je,
                                                height: Je,
                                                data: null
                                            },Fe.RGBA);
                                            rr.bind(Fe.LINEAR, Fe.CLAMP_TO_EDGE),
                                            wt = $e.fbo = pe.createFramebuffer(Je, Je, !0, !1),
                                            wt.colorAttachment.set(rr.texture)
                                        }
                                        pe.bindFramebuffer.set(wt.framebuffer),
                                        pe.viewport.set([0, 0, Je, Je]),
                                        ee.useProgram("hillshadePrepare").draw(pe, Fe.TRIANGLES, ce, Te, Pe, Hr.disabled, tp($e.tileID, He), null, null, me.id, ee.rasterBoundsBuffer, ee.quadTriangleIndexBuffer, ee.rasterBoundsSegments),
                                        $e.needsHillshadePrepare = !1
                                    }
                                }
                                )(m, v, P, b, Z, qr.disabled, te),
                                L.viewport.set([0, 0, m.width, m.height]);
                            else if (m.renderPass === "translucent")
                                if (B) {
                                    const [ee,ne,oe] = m.stencilConfigForOverlapTwoPass(P);
                                    qs(m, v, b, oe, ee, Z, te, !1, D),
                                    qs(m, v, b, oe, ne, Z, te, !0, D)
                                } else {
                                    const [ee,ne] = m.getStencilConfigForOverlapAndUpdateStencilID(P);
                                    qs(m, v, b, ne, ee, Z, te, !1, D)
                                }
                        }(e, r, s, c, d) : o.ch(s) ? function(m, v, b, P, M) {
                            if (m.renderPass !== "translucent" || !P.length)
                                return;
                            const {isRenderingToTexture: D} = M
                              , L = m.style.projection.useSubdivision
                              , B = m.getDepthModeForSublayer(0, Xr.ReadOnly)
                              , Z = m.colorModeForRenderPass();
                            if (L) {
                                const [te,ee,ne] = m.stencilConfigForOverlapTwoPass(P);
                                Po(m, v, b, ne, te, B, Z, !1, D),
                                Po(m, v, b, ne, ee, B, Z, !0, D)
                            } else {
                                const [te,ee] = m.getStencilConfigForOverlapAndUpdateStencilID(P);
                                Po(m, v, b, ee, te, B, Z, !1, D)
                            }
                        }(e, r, s, c, d) : o.ci(s) ? function(m, v, b, P, M) {
                            if (m.renderPass !== "translucent" || b.paint.get("raster-opacity") === 0 || !P.length)
                                return;
                            const {isRenderingToTexture: D} = M
                              , L = v.getSource()
                              , B = m.style.projection.useSubdivision;
                            if (L instanceof tr)
                                Ha(m, v, b, P, null, !1, !1, L.tileCoords, L.flippedWindingOrder, D);
                            else if (B) {
                                const [Z,te,ee] = m.stencilConfigForOverlapTwoPass(P);
                                Ha(m, v, b, ee, Z, !1, !0, Dc, !1, D),
                                Ha(m, v, b, ee, te, !0, !0, Dc, !1, D)
                            } else {
                                const [Z,te] = m.getStencilConfigForOverlapAndUpdateStencilID(P);
                                Ha(m, v, b, te, Z, !1, !0, Dc, !1, D)
                            }
                        }(e, r, s, c, d) : o.cj(s) ? function(m, v, b, P, M) {
                            const D = b.paint.get("background-color")
                              , L = b.paint.get("background-opacity");
                            if (L === 0)
                                return;
                            const {isRenderingToTexture: B} = M
                              , Z = m.context
                              , te = Z.gl
                              , ee = m.style.projection
                              , ne = m.transform
                              , oe = ne.tileSize
                              , me = b.paint.get("background-pattern");
                            if (m.isPatternMissing(me))
                                return;
                            const ce = !me && D.a === 1 && L === 1 && m.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                            if (m.renderPass !== ce)
                                return;
                            const Te = qr.disabled
                              , Pe = m.getDepthModeForSublayer(0, ce === "opaque" ? Xr.ReadWrite : Xr.ReadOnly)
                              , pe = m.colorModeForRenderPass()
                              , Fe = m.useProgram(me ? "backgroundPattern" : "background")
                              , Ye = P || Oe(ne, {
                                tileSize: oe,
                                terrain: m.style.map.terrain
                            });
                            me && (Z.activeTexture.set(te.TEXTURE0),
                            m.imageManager.bind(m.context));
                            const $e = b.getCrossfadeParameters();
                            for (const He of Ye) {
                                const Je = ne.getProjectionData({
                                    overscaledTileID: He,
                                    applyGlobeMatrix: !B,
                                    applyTerrainMatrix: !0
                                })
                                  , qt = me ? np(L, m, me, {
                                    tileID: He,
                                    tileSize: oe
                                }, $e) : ol(L, D)
                                  , Nt = m.style.map.terrain && m.style.map.terrain.getTerrainData(He)
                                  , wt = ee.getMeshFromTileID(Z, He.canonical, !1, !0, "raster");
                                Fe.draw(Z, te.TRIANGLES, Pe, Te, pe, Hr.backCCW, qt, Nt, Je, b.id, wt.vertexBuffer, wt.indexBuffer, wt.segments)
                            }
                        }(e, 0, s, c, d) : o.ck(s) && function(m, v, b, P) {
                            const {isRenderingGlobe: M} = P
                              , D = m.context
                              , L = b.implementation
                              , B = m.style.projection
                              , Z = m.transform
                              , te = Z.getProjectionDataForCustomLayer(M)
                              , ee = {
                                farZ: Z.farZ,
                                nearZ: Z.nearZ,
                                fov: Z.fov * Math.PI / 180,
                                modelViewProjectionMatrix: Z.modelViewProjectionMatrix,
                                projectionMatrix: Z.projectionMatrix,
                                shaderData: {
                                    variantName: B.shaderVariantName,
                                    vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${B.shaderPreludeCode.vertexSource}`,
                                    define: B.shaderDefine
                                },
                                defaultProjectionData: te
                            }
                              , ne = L.renderingMode ? L.renderingMode : "2d";
                            if (m.renderPass === "offscreen") {
                                const oe = L.prerender;
                                oe && (m.setCustomLayerDefaults(),
                                D.setColorMode(m.colorModeForRenderPass()),
                                oe.call(L, D.gl, ee),
                                D.setDirty(),
                                m.setBaseState())
                            } else if (m.renderPass === "translucent") {
                                m.setCustomLayerDefaults(),
                                D.setColorMode(m.colorModeForRenderPass()),
                                D.setStencilMode(qr.disabled);
                                const oe = ne === "3d" ? m.getDepthModeFor3D() : m.getDepthModeForSublayer(0, Xr.ReadOnly);
                                D.setDepthMode(oe),
                                L.render(D.gl, ee),
                                D.setDirty(),
                                m.setBaseState(),
                                D.bindFramebuffer.set(null)
                            }
                        }(e, 0, s, d))
                    }
                    saveTileTexture(e) {
                        const r = this._tileTextures[e.size[0]];
                        r ? r.push(e) : this._tileTextures[e.size[0]] = [e]
                    }
                    getTileTexture(e) {
                        const r = this._tileTextures[e];
                        return r && r.length > 0 ? r.pop() : null
                    }
                    isPatternMissing(e) {
                        if (!e)
                            return !1;
                        if (!e.from || !e.to)
                            return !0;
                        const r = this.imageManager.getPattern(e.from.toString())
                          , s = this.imageManager.getPattern(e.to.toString());
                        return !r || !s
                    }
                    useProgram(e, r, s=!1, c=[]) {
                        this.cache = this.cache || {};
                        const d = !!this.style.map.terrain
                          , m = this.style.projection
                          , v = s ? Ui.projectionMercator : m.shaderPreludeCode
                          , b = s ? da : m.shaderDefine
                          , P = e + (r ? r.cacheKey : "") + `/${s ? os : m.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (d ? "/terrain" : "") + (c ? `/${c.join("/")}` : "");
                        return this.cache[P] || (this.cache[P] = new il(this.context,Ui[e],r,Ph[e],this._showOverdrawInspector,d,v,b,c)),
                        this.cache[P]
                    }
                    setCustomLayerDefaults() {
                        this.context.unbindVAO(),
                        this.context.cullFace.setDefault(),
                        this.context.activeTexture.setDefault(),
                        this.context.pixelStoreUnpack.setDefault(),
                        this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                        this.context.pixelStoreUnpackFlipY.setDefault()
                    }
                    setBaseState() {
                        const e = this.context.gl;
                        this.context.cullFace.set(!1),
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.context.blendEquation.set(e.FUNC_ADD)
                    }
                    initDebugOverlayCanvas() {
                        this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"),
                        this.debugOverlayCanvas.width = 512,
                        this.debugOverlayCanvas.height = 512,
                        this.debugOverlayTexture = new o.T(this.context,this.debugOverlayCanvas,this.context.gl.RGBA))
                    }
                    destroy() {
                        this.debugOverlayTexture && this.debugOverlayTexture.destroy()
                    }
                    overLimit() {
                        const {drawingBufferWidth: e, drawingBufferHeight: r} = this.context.gl;
                        return this.width !== e || this.height !== r
                    }
                }
                function bl(h, e) {
                    let r, s = !1, c = null, d = null;
                    const m = () => {
                        c = null,
                        s && (h.apply(d, r),
                        c = setTimeout(m, e),
                        s = !1)
                    }
                    ;
                    return (...v) => (s = !0,
                    d = this,
                    r = v,
                    c || m(),
                    c)
                }
                class Mo {
                    constructor(e) {
                        this._getCurrentHash = () => {
                            const r = window.location.hash.replace("#", "");
                            if (this._hashName) {
                                let s;
                                return r.split("&").map(c => c.split("=")).forEach(c => {
                                    c[0] === this._hashName && (s = c)
                                }
                                ),
                                (s && s[1] || "").split("/")
                            }
                            return r.split("/")
                        }
                        ,
                        this._onHashChange = () => {
                            const r = this._getCurrentHash();
                            if (!this._isValidHash(r))
                                return !1;
                            const s = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(r[3] || 0) : this._map.getBearing();
                            return this._map.jumpTo({
                                center: [+r[2], +r[1]],
                                zoom: +r[0],
                                bearing: s,
                                pitch: +(r[4] || 0)
                            }),
                            !0
                        }
                        ,
                        this._updateHashUnthrottled = () => {
                            const r = window.location.href.replace(/(#.*)?$/, this.getHashString());
                            window.history.replaceState(window.history.state, null, r)
                        }
                        ,
                        this._removeHash = () => {
                            const r = this._getCurrentHash();
                            if (r.length === 0)
                                return;
                            const s = r.join("/");
                            let c = s;
                            c.split("&").length > 0 && (c = c.split("&")[0]),
                            this._hashName && (c = `${this._hashName}=${s}`);
                            let d = window.location.hash.replace(c, "");
                            d.startsWith("#&") ? d = d.slice(0, 1) + d.slice(2) : d === "#" && (d = "");
                            let m = window.location.href.replace(/(#.+)?$/, d);
                            m = m.replace("&&", "&"),
                            window.history.replaceState(window.history.state, null, m)
                        }
                        ,
                        this._updateHash = bl(this._updateHashUnthrottled, 300),
                        this._hashName = e && encodeURIComponent(e)
                    }
                    addTo(e) {
                        return this._map = e,
                        addEventListener("hashchange", this._onHashChange, !1),
                        this._map.on("moveend", this._updateHash),
                        this
                    }
                    remove() {
                        return removeEventListener("hashchange", this._onHashChange, !1),
                        this._map.off("moveend", this._updateHash),
                        clearTimeout(this._updateHash()),
                        this._removeHash(),
                        delete this._map,
                        this
                    }
                    getHashString(e) {
                        const r = this._map.getCenter()
                          , s = Math.round(100 * this._map.getZoom()) / 100
                          , c = Math.ceil((s * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10)
                          , d = Math.pow(10, c)
                          , m = Math.round(r.lng * d) / d
                          , v = Math.round(r.lat * d) / d
                          , b = this._map.getBearing()
                          , P = this._map.getPitch();
                        let M = "";
                        if (M += e ? `/${m}/${v}/${s}` : `${s}/${v}/${m}`,
                        (b || P) && (M += "/" + Math.round(10 * b) / 10),
                        P && (M += `/${Math.round(P)}`),
                        this._hashName) {
                            const D = this._hashName;
                            let L = !1;
                            const B = window.location.hash.slice(1).split("&").map(Z => {
                                const te = Z.split("=")[0];
                                return te === D ? (L = !0,
                                `${te}=${M}`) : Z
                            }
                            ).filter(Z => Z);
                            return L || B.push(`${D}=${M}`),
                            `#${B.join("&")}`
                        }
                        return `#${M}`
                    }
                    _isValidHash(e) {
                        if (e.length < 3 || e.some(isNaN))
                            return !1;
                        try {
                            new o.S(+e[2],+e[1])
                        } catch {
                            return !1
                        }
                        const r = +e[0]
                          , s = +(e[3] || 0)
                          , c = +(e[4] || 0);
                        return r >= this._map.getMinZoom() && r <= this._map.getMaxZoom() && s >= -180 && s <= 180 && c >= this._map.getMinPitch() && c <= this._map.getMaxPitch()
                    }
                }
                const Vs = {
                    linearity: .3,
                    easing: o.cl(0, 0, .3, 1)
                }
                  , Zs = o.e({
                    deceleration: 2500,
                    maxSpeed: 1400
                }, Vs)
                  , Bc = o.e({
                    deceleration: 20,
                    maxSpeed: 1400
                }, Vs)
                  , Ao = o.e({
                    deceleration: 1e3,
                    maxSpeed: 360
                }, Vs)
                  , Fc = o.e({
                    deceleration: 1e3,
                    maxSpeed: 90
                }, Vs)
                  , Zh = o.e({
                    deceleration: 1e3,
                    maxSpeed: 360
                }, Vs);
                class $h {
                    constructor(e) {
                        this._map = e,
                        this.clear()
                    }
                    clear() {
                        this._inertiaBuffer = []
                    }
                    record(e) {
                        this._drainInertiaBuffer(),
                        this._inertiaBuffer.push({
                            time: he.now(),
                            settings: e
                        })
                    }
                    _drainInertiaBuffer() {
                        const e = this._inertiaBuffer
                          , r = he.now();
                        for (; e.length > 0 && r - e[0].time > 160; )
                            e.shift()
                    }
                    _onMoveEnd(e) {
                        if (this._drainInertiaBuffer(),
                        this._inertiaBuffer.length < 2)
                            return;
                        const r = {
                            zoom: 0,
                            bearing: 0,
                            pitch: 0,
                            roll: 0,
                            pan: new o.P(0,0),
                            pinchAround: void 0,
                            around: void 0
                        };
                        for (const {settings: d} of this._inertiaBuffer)
                            r.zoom += d.zoomDelta || 0,
                            r.bearing += d.bearingDelta || 0,
                            r.pitch += d.pitchDelta || 0,
                            r.roll += d.rollDelta || 0,
                            d.panDelta && r.pan._add(d.panDelta),
                            d.around && (r.around = d.around),
                            d.pinchAround && (r.pinchAround = d.pinchAround);
                        const s = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time
                          , c = {};
                        if (r.pan.mag()) {
                            const d = Us(r.pan.mag(), s, o.e({}, Zs, e || {}))
                              , m = r.pan.mult(d.amount / r.pan.mag())
                              , v = this._map.cameraHelper.handlePanInertia(m, this._map.transform);
                            c.center = v.easingCenter,
                            c.offset = v.easingOffset,
                            $s(c, d)
                        }
                        if (r.zoom) {
                            const d = Us(r.zoom, s, Bc);
                            c.zoom = this._map.transform.zoom + d.amount,
                            $s(c, d)
                        }
                        if (r.bearing) {
                            const d = Us(r.bearing, s, Ao);
                            c.bearing = this._map.transform.bearing + o.ag(d.amount, -179, 179),
                            $s(c, d)
                        }
                        if (r.pitch) {
                            const d = Us(r.pitch, s, Fc);
                            c.pitch = this._map.transform.pitch + d.amount,
                            $s(c, d)
                        }
                        if (r.roll) {
                            const d = Us(r.roll, s, Zh);
                            c.roll = this._map.transform.roll + o.ag(d.amount, -179, 179),
                            $s(c, d)
                        }
                        if (c.zoom || c.bearing) {
                            const d = r.pinchAround === void 0 ? r.around : r.pinchAround;
                            c.around = d ? this._map.unproject(d) : this._map.getCenter()
                        }
                        return this.clear(),
                        o.e(c, {
                            noMoveStart: !0
                        })
                    }
                }
                function $s(h, e) {
                    (!h.duration || h.duration < e.duration) && (h.duration = e.duration,
                    h.easing = e.easing)
                }
                function Us(h, e, r) {
                    const {maxSpeed: s, linearity: c, deceleration: d} = r
                      , m = o.ag(h * c / (e / 1e3), -s, s)
                      , v = Math.abs(m) / (d * c);
                    return {
                        easing: r.easing,
                        duration: 1e3 * v,
                        amount: m * (v / 2)
                    }
                }
                class $n extends o.l {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(e, r, s, c={}) {
                        s = s instanceof MouseEvent ? s : new MouseEvent(e,s);
                        const d = X.mousePos(r.getCanvas(), s)
                          , m = r.unproject(d);
                        super(e, o.e({
                            point: d,
                            lngLat: m,
                            originalEvent: s
                        }, c)),
                        this._defaultPrevented = !1,
                        this.target = r
                    }
                }
                class fa extends o.l {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(e, r, s) {
                        const c = e === "touchend" ? s.changedTouches : s.touches
                          , d = X.touchPos(r.getCanvasContainer(), c)
                          , m = d.map(b => r.unproject(b))
                          , v = d.reduce( (b, P, M, D) => b.add(P.div(D.length)), new o.P(0,0));
                        super(e, {
                            points: d,
                            point: v,
                            lngLats: m,
                            lngLat: r.unproject(v),
                            originalEvent: s
                        }),
                        this._defaultPrevented = !1
                    }
                }
                class Oc extends o.l {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(e, r, s) {
                        super(e, {
                            originalEvent: s
                        }),
                        this._defaultPrevented = !1
                    }
                }
                class Uh {
                    constructor(e, r) {
                        this._map = e,
                        this._clickTolerance = r.clickTolerance
                    }
                    reset() {
                        delete this._mousedownPos
                    }
                    wheel(e) {
                        return this._firePreventable(new Oc(e.type,this._map,e))
                    }
                    mousedown(e, r) {
                        return this._mousedownPos = r,
                        this._firePreventable(new $n(e.type,this._map,e))
                    }
                    mouseup(e) {
                        this._map.fire(new $n(e.type,this._map,e))
                    }
                    click(e, r) {
                        this._mousedownPos && this._mousedownPos.dist(r) >= this._clickTolerance || this._map.fire(new $n(e.type,this._map,e))
                    }
                    dblclick(e) {
                        return this._firePreventable(new $n(e.type,this._map,e))
                    }
                    mouseover(e) {
                        this._map.fire(new $n(e.type,this._map,e))
                    }
                    mouseout(e) {
                        this._map.fire(new $n(e.type,this._map,e))
                    }
                    touchstart(e) {
                        return this._firePreventable(new fa(e.type,this._map,e))
                    }
                    touchmove(e) {
                        this._map.fire(new fa(e.type,this._map,e))
                    }
                    touchend(e) {
                        this._map.fire(new fa(e.type,this._map,e))
                    }
                    touchcancel(e) {
                        this._map.fire(new fa(e.type,this._map,e))
                    }
                    _firePreventable(e) {
                        if (this._map.fire(e),
                        e.defaultPrevented)
                            return {}
                    }
                    isEnabled() {
                        return !0
                    }
                    isActive() {
                        return !1
                    }
                    enable() {}
                    disable() {}
                }
                class Gh {
                    constructor(e) {
                        this._map = e
                    }
                    reset() {
                        this._delayContextMenu = !1,
                        this._ignoreContextMenu = !0,
                        delete this._contextMenuEvent
                    }
                    mousemove(e) {
                        this._map.fire(new $n(e.type,this._map,e))
                    }
                    mousedown() {
                        this._delayContextMenu = !0,
                        this._ignoreContextMenu = !1
                    }
                    mouseup() {
                        this._delayContextMenu = !1,
                        this._contextMenuEvent && (this._map.fire(new $n("contextmenu",this._map,this._contextMenuEvent)),
                        delete this._contextMenuEvent)
                    }
                    contextmenu(e) {
                        this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new $n(e.type,this._map,e)),
                        this._map.listens("contextmenu") && e.preventDefault()
                    }
                    isEnabled() {
                        return !0
                    }
                    isActive() {
                        return !1
                    }
                    enable() {}
                    disable() {}
                }
                class Gs {
                    constructor(e) {
                        this._map = e
                    }
                    get transform() {
                        return this._map._requestedCameraState || this._map.transform
                    }
                    get center() {
                        return {
                            lng: this.transform.center.lng,
                            lat: this.transform.center.lat
                        }
                    }
                    get zoom() {
                        return this.transform.zoom
                    }
                    get pitch() {
                        return this.transform.pitch
                    }
                    get bearing() {
                        return this.transform.bearing
                    }
                    unproject(e) {
                        return this.transform.screenPointToLocation(o.P.convert(e), this._map.terrain)
                    }
                }
                class Nc {
                    constructor(e, r) {
                        this._map = e,
                        this._tr = new Gs(e),
                        this._el = e.getCanvasContainer(),
                        this._container = e.getContainer(),
                        this._clickTolerance = r.clickTolerance || 1
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return !!this._active
                    }
                    enable() {
                        this.isEnabled() || (this._enabled = !0)
                    }
                    disable() {
                        this.isEnabled() && (this._enabled = !1)
                    }
                    mousedown(e, r) {
                        this.isEnabled() && e.shiftKey && e.button === 0 && (X.disableDrag(),
                        this._startPos = this._lastPos = r,
                        this._active = !0)
                    }
                    mousemoveWindow(e, r) {
                        if (!this._active)
                            return;
                        const s = r;
                        if (this._lastPos.equals(s) || !this._box && s.dist(this._startPos) < this._clickTolerance)
                            return;
                        const c = this._startPos;
                        this._lastPos = s,
                        this._box || (this._box = X.create("div", "maplibregl-boxzoom", this._container),
                        this._container.classList.add("maplibregl-crosshair"),
                        this._fireEvent("boxzoomstart", e));
                        const d = Math.min(c.x, s.x)
                          , m = Math.max(c.x, s.x)
                          , v = Math.min(c.y, s.y)
                          , b = Math.max(c.y, s.y);
                        X.setTransform(this._box, `translate(${d}px,${v}px)`),
                        this._box.style.width = m - d + "px",
                        this._box.style.height = b - v + "px"
                    }
                    mouseupWindow(e, r) {
                        if (!this._active || e.button !== 0)
                            return;
                        const s = this._startPos
                          , c = r;
                        if (this.reset(),
                        X.suppressClick(),
                        s.x !== c.x || s.y !== c.y)
                            return this._map.fire(new o.l("boxzoomend",{
                                originalEvent: e
                            })),
                            {
                                cameraAnimation: d => d.fitScreenCoordinates(s, c, this._tr.bearing, {
                                    linear: !0
                                })
                            };
                        this._fireEvent("boxzoomcancel", e)
                    }
                    keydown(e) {
                        this._active && e.keyCode === 27 && (this.reset(),
                        this._fireEvent("boxzoomcancel", e))
                    }
                    reset() {
                        this._active = !1,
                        this._container.classList.remove("maplibregl-crosshair"),
                        this._box && (X.remove(this._box),
                        this._box = null),
                        X.enableDrag(),
                        delete this._startPos,
                        delete this._lastPos
                    }
                    _fireEvent(e, r) {
                        return this._map.fire(new o.l(e,{
                            originalEvent: r
                        }))
                    }
                }
                function wl(h, e) {
                    if (h.length !== e.length)
                        throw new Error(`The number of touches and points are not equal - touches ${h.length}, points ${e.length}`);
                    const r = {};
                    for (let s = 0; s < h.length; s++)
                        r[h[s].identifier] = e[s];
                    return r
                }
                class Hh {
                    constructor(e) {
                        this.reset(),
                        this.numTouches = e.numTouches
                    }
                    reset() {
                        delete this.centroid,
                        delete this.startTime,
                        delete this.touches,
                        this.aborted = !1
                    }
                    touchstart(e, r, s) {
                        (this.centroid || s.length > this.numTouches) && (this.aborted = !0),
                        this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp),
                        s.length === this.numTouches && (this.centroid = function(c) {
                            const d = new o.P(0,0);
                            for (const m of c)
                                d._add(m);
                            return d.div(c.length)
                        }(r),
                        this.touches = wl(s, r)))
                    }
                    touchmove(e, r, s) {
                        if (this.aborted || !this.centroid)
                            return;
                        const c = wl(s, r);
                        for (const d in this.touches) {
                            const m = c[d];
                            (!m || m.dist(this.touches[d]) > 30) && (this.aborted = !0)
                        }
                    }
                    touchend(e, r, s) {
                        if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0),
                        s.length === 0) {
                            const c = !this.aborted && this.centroid;
                            if (this.reset(),
                            c)
                                return c
                        }
                    }
                }
                class Tl {
                    constructor(e) {
                        this.singleTap = new Hh(e),
                        this.numTaps = e.numTaps,
                        this.reset()
                    }
                    reset() {
                        this.lastTime = 1 / 0,
                        delete this.lastTap,
                        this.count = 0,
                        this.singleTap.reset()
                    }
                    touchstart(e, r, s) {
                        this.singleTap.touchstart(e, r, s)
                    }
                    touchmove(e, r, s) {
                        this.singleTap.touchmove(e, r, s)
                    }
                    touchend(e, r, s) {
                        const c = this.singleTap.touchend(e, r, s);
                        if (c) {
                            const d = e.timeStamp - this.lastTime < 500
                              , m = !this.lastTap || this.lastTap.dist(c) < 30;
                            if (d && m || this.reset(),
                            this.count++,
                            this.lastTime = e.timeStamp,
                            this.lastTap = c,
                            this.count === this.numTaps)
                                return this.reset(),
                                c
                        }
                    }
                }
                class Cl {
                    constructor(e) {
                        this._tr = new Gs(e),
                        this._zoomIn = new Tl({
                            numTouches: 1,
                            numTaps: 2
                        }),
                        this._zoomOut = new Tl({
                            numTouches: 2,
                            numTaps: 1
                        }),
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._zoomIn.reset(),
                        this._zoomOut.reset()
                    }
                    touchstart(e, r, s) {
                        this._zoomIn.touchstart(e, r, s),
                        this._zoomOut.touchstart(e, r, s)
                    }
                    touchmove(e, r, s) {
                        this._zoomIn.touchmove(e, r, s),
                        this._zoomOut.touchmove(e, r, s)
                    }
                    touchend(e, r, s) {
                        const c = this._zoomIn.touchend(e, r, s)
                          , d = this._zoomOut.touchend(e, r, s)
                          , m = this._tr;
                        return c ? (this._active = !0,
                        e.preventDefault(),
                        setTimeout( () => this.reset(), 0),
                        {
                            cameraAnimation: v => v.easeTo({
                                duration: 300,
                                zoom: m.zoom + 1,
                                around: m.unproject(c)
                            }, {
                                originalEvent: e
                            })
                        }) : d ? (this._active = !0,
                        e.preventDefault(),
                        setTimeout( () => this.reset(), 0),
                        {
                            cameraAnimation: v => v.easeTo({
                                duration: 300,
                                zoom: m.zoom - 1,
                                around: m.unproject(d)
                            }, {
                                originalEvent: e
                            })
                        }) : void 0
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class Hs {
                    constructor(e) {
                        this._enabled = !!e.enable,
                        this._moveStateManager = e.moveStateManager,
                        this._clickTolerance = e.clickTolerance || 1,
                        this._moveFunction = e.move,
                        this._activateOnStart = !!e.activateOnStart,
                        e.assignEvents(this),
                        this.reset()
                    }
                    reset(e) {
                        this._active = !1,
                        this._moved = !1,
                        delete this._lastPoint,
                        this._moveStateManager.endMove(e)
                    }
                    _move(...e) {
                        const r = this._moveFunction(...e);
                        if (r.bearingDelta || r.pitchDelta || r.rollDelta || r.around || r.panDelta)
                            return this._active = !0,
                            r
                    }
                    dragStart(e, r) {
                        this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e),
                        this._lastPoint = Array.isArray(r) ? r[0] : r,
                        this._activateOnStart && this._lastPoint && (this._active = !0))
                    }
                    dragMove(e, r) {
                        if (!this.isEnabled())
                            return;
                        const s = this._lastPoint;
                        if (!s)
                            return;
                        if (e.preventDefault(),
                        !this._moveStateManager.isValidMoveEvent(e))
                            return void this.reset(e);
                        const c = Array.isArray(r) ? r[0] : r;
                        return !this._moved && c.dist(s) < this._clickTolerance ? void 0 : (this._moved = !0,
                        this._lastPoint = c,
                        this._move(s, c))
                    }
                    dragEnd(e) {
                        this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && X.suppressClick(),
                        this.reset(e))
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                    getClickTolerance() {
                        return this._clickTolerance
                    }
                }
                const ca = 0
                  , ma = 2
                  , Wh = {
                    [ca]: 1,
                    [ma]: 2
                };
                class zn {
                    constructor(e) {
                        this._correctEvent = e.checkCorrectEvent
                    }
                    startMove(e) {
                        const r = X.mouseButton(e);
                        this._eventButton = r
                    }
                    endMove(e) {
                        delete this._eventButton
                    }
                    isValidStartEvent(e) {
                        return this._correctEvent(e)
                    }
                    isValidMoveEvent(e) {
                        return !function(r, s) {
                            const c = Wh[s];
                            return r.buttons === void 0 || (r.buttons & c) !== c
                        }(e, this._eventButton)
                    }
                    isValidEndEvent(e) {
                        return X.mouseButton(e) === this._eventButton
                    }
                }
                class Ws {
                    constructor() {
                        this._firstTouch = void 0
                    }
                    _isOneFingerTouch(e) {
                        return e.targetTouches.length === 1
                    }
                    _isSameTouchEvent(e) {
                        return e.targetTouches[0].identifier === this._firstTouch
                    }
                    startMove(e) {
                        this._firstTouch = e.targetTouches[0].identifier
                    }
                    endMove(e) {
                        delete this._firstTouch
                    }
                    isValidStartEvent(e) {
                        return this._isOneFingerTouch(e)
                    }
                    isValidMoveEvent(e) {
                        return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
                    }
                    isValidEndEvent(e) {
                        return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
                    }
                }
                class pp {
                    constructor(e=new zn({
                        checkCorrectEvent: () => !0
                    }), r=new Ws) {
                        this.mouseMoveStateManager = e,
                        this.oneFingerTouchMoveStateManager = r
                    }
                    _executeRelevantHandler(e, r, s) {
                        return e instanceof MouseEvent ? r(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? s(e) : void 0
                    }
                    startMove(e) {
                        this._executeRelevantHandler(e, r => this.mouseMoveStateManager.startMove(r), r => this.oneFingerTouchMoveStateManager.startMove(r))
                    }
                    endMove(e) {
                        this._executeRelevantHandler(e, r => this.mouseMoveStateManager.endMove(r), r => this.oneFingerTouchMoveStateManager.endMove(r))
                    }
                    isValidStartEvent(e) {
                        return this._executeRelevantHandler(e, r => this.mouseMoveStateManager.isValidStartEvent(r), r => this.oneFingerTouchMoveStateManager.isValidStartEvent(r))
                    }
                    isValidMoveEvent(e) {
                        return this._executeRelevantHandler(e, r => this.mouseMoveStateManager.isValidMoveEvent(r), r => this.oneFingerTouchMoveStateManager.isValidMoveEvent(r))
                    }
                    isValidEndEvent(e) {
                        return this._executeRelevantHandler(e, r => this.mouseMoveStateManager.isValidEndEvent(r), r => this.oneFingerTouchMoveStateManager.isValidEndEvent(r))
                    }
                }
                const Sl = h => {
                    h.mousedown = h.dragStart,
                    h.mousemoveWindow = h.dragMove,
                    h.mouseup = h.dragEnd,
                    h.contextmenu = e => {
                        e.preventDefault()
                    }
                }
                ;
                class fp {
                    constructor(e, r) {
                        this._clickTolerance = e.clickTolerance || 1,
                        this._map = r,
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._touches = {},
                        this._sum = new o.P(0,0)
                    }
                    _shouldBePrevented(e) {
                        return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1)
                    }
                    touchstart(e, r, s) {
                        return this._calculateTransform(e, r, s)
                    }
                    touchmove(e, r, s) {
                        if (this._active) {
                            if (!this._shouldBePrevented(s.length))
                                return e.preventDefault(),
                                this._calculateTransform(e, r, s);
                            this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e)
                        }
                    }
                    touchend(e, r, s) {
                        this._calculateTransform(e, r, s),
                        this._active && this._shouldBePrevented(s.length) && this.reset()
                    }
                    touchcancel() {
                        this.reset()
                    }
                    _calculateTransform(e, r, s) {
                        s.length > 0 && (this._active = !0);
                        const c = wl(s, r)
                          , d = new o.P(0,0)
                          , m = new o.P(0,0);
                        let v = 0;
                        for (const P in c) {
                            const M = c[P]
                              , D = this._touches[P];
                            D && (d._add(M),
                            m._add(M.sub(D)),
                            v++,
                            c[P] = M)
                        }
                        if (this._touches = c,
                        this._shouldBePrevented(v) || !m.mag())
                            return;
                        const b = m.div(v);
                        return this._sum._add(b),
                        this._sum.mag() < this._clickTolerance ? void 0 : {
                            around: d.div(v),
                            panDelta: b
                        }
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class jc {
                    constructor() {
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        delete this._firstTwoTouches
                    }
                    touchstart(e, r, s) {
                        this._firstTwoTouches || s.length < 2 || (this._firstTwoTouches = [s[0].identifier, s[1].identifier],
                        this._start([r[0], r[1]]))
                    }
                    touchmove(e, r, s) {
                        if (!this._firstTwoTouches)
                            return;
                        e.preventDefault();
                        const [c,d] = this._firstTwoTouches
                          , m = ko(s, r, c)
                          , v = ko(s, r, d);
                        if (!m || !v)
                            return;
                        const b = this._aroundCenter ? null : m.add(v).div(2);
                        return this._move([m, v], b, e)
                    }
                    touchend(e, r, s) {
                        if (!this._firstTwoTouches)
                            return;
                        const [c,d] = this._firstTwoTouches
                          , m = ko(s, r, c)
                          , v = ko(s, r, d);
                        m && v || (this._active && X.suppressClick(),
                        this.reset())
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable(e) {
                        this._enabled = !0,
                        this._aroundCenter = !!e && e.around === "center"
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return !!this._active
                    }
                }
                function ko(h, e, r) {
                    for (let s = 0; s < h.length; s++)
                        if (h[s].identifier === r)
                            return e[s]
                }
                function Xs(h, e) {
                    return Math.log(h / e) / Math.LN2
                }
                class Pa extends jc {
                    reset() {
                        super.reset(),
                        delete this._distance,
                        delete this._startDistance
                    }
                    _start(e) {
                        this._startDistance = this._distance = e[0].dist(e[1])
                    }
                    _move(e, r) {
                        const s = this._distance;
                        if (this._distance = e[0].dist(e[1]),
                        this._active || !(Math.abs(Xs(this._distance, this._startDistance)) < .1))
                            return this._active = !0,
                            {
                                zoomDelta: Xs(this._distance, s),
                                pinchAround: r
                            }
                    }
                }
                function Wt(h, e) {
                    return 180 * h.angleWith(e) / Math.PI
                }
                class qc extends jc {
                    reset() {
                        super.reset(),
                        delete this._minDiameter,
                        delete this._startVector,
                        delete this._vector
                    }
                    _start(e) {
                        this._startVector = this._vector = e[0].sub(e[1]),
                        this._minDiameter = e[0].dist(e[1])
                    }
                    _move(e, r, s) {
                        const c = this._vector;
                        if (this._vector = e[0].sub(e[1]),
                        this._active || !this._isBelowThreshold(this._vector))
                            return this._active = !0,
                            {
                                bearingDelta: Wt(this._vector, c),
                                pinchAround: r
                            }
                    }
                    _isBelowThreshold(e) {
                        this._minDiameter = Math.min(this._minDiameter, e.mag());
                        const r = 25 / (Math.PI * this._minDiameter) * 360
                          , s = Wt(e, this._startVector);
                        return Math.abs(s) < r
                    }
                }
                function Eo(h) {
                    return Math.abs(h.y) > Math.abs(h.x)
                }
                class Vc extends jc {
                    constructor(e) {
                        super(),
                        this._currentTouchCount = 0,
                        this._map = e
                    }
                    reset() {
                        super.reset(),
                        this._valid = void 0,
                        delete this._firstMove,
                        delete this._lastPoints
                    }
                    touchstart(e, r, s) {
                        super.touchstart(e, r, s),
                        this._currentTouchCount = s.length
                    }
                    _start(e) {
                        this._lastPoints = e,
                        Eo(e[0].sub(e[1])) && (this._valid = !1)
                    }
                    _move(e, r, s) {
                        if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3)
                            return;
                        const c = e[0].sub(this._lastPoints[0])
                          , d = e[1].sub(this._lastPoints[1]);
                        return this._valid = this.gestureBeginsVertically(c, d, s.timeStamp),
                        this._valid ? (this._lastPoints = e,
                        this._active = !0,
                        {
                            pitchDelta: (c.y + d.y) / 2 * -.5
                        }) : void 0
                    }
                    gestureBeginsVertically(e, r, s) {
                        if (this._valid !== void 0)
                            return this._valid;
                        const c = e.mag() >= 2
                          , d = r.mag() >= 2;
                        if (!c && !d)
                            return;
                        if (!c || !d)
                            return this._firstMove === void 0 && (this._firstMove = s),
                            s - this._firstMove < 100 && void 0;
                        const m = e.y > 0 == r.y > 0;
                        return Eo(e) && Eo(r) && m
                    }
                }
                const zo = {
                    panStep: 100,
                    bearingStep: 15,
                    pitchStep: 10
                };
                class Ks {
                    constructor(e) {
                        this._tr = new Gs(e);
                        const r = zo;
                        this._panStep = r.panStep,
                        this._bearingStep = r.bearingStep,
                        this._pitchStep = r.pitchStep,
                        this._rotationDisabled = !1
                    }
                    reset() {
                        this._active = !1
                    }
                    keydown(e) {
                        if (e.altKey || e.ctrlKey || e.metaKey)
                            return;
                        let r = 0
                          , s = 0
                          , c = 0
                          , d = 0
                          , m = 0;
                        switch (e.keyCode) {
                        case 61:
                        case 107:
                        case 171:
                        case 187:
                            r = 1;
                            break;
                        case 189:
                        case 109:
                        case 173:
                            r = -1;
                            break;
                        case 37:
                            e.shiftKey ? s = -1 : (e.preventDefault(),
                            d = -1);
                            break;
                        case 39:
                            e.shiftKey ? s = 1 : (e.preventDefault(),
                            d = 1);
                            break;
                        case 38:
                            e.shiftKey ? c = 1 : (e.preventDefault(),
                            m = -1);
                            break;
                        case 40:
                            e.shiftKey ? c = -1 : (e.preventDefault(),
                            m = 1);
                            break;
                        default:
                            return
                        }
                        return this._rotationDisabled && (s = 0,
                        c = 0),
                        {
                            cameraAnimation: v => {
                                const b = this._tr;
                                v.easeTo({
                                    duration: 300,
                                    easeId: "keyboardHandler",
                                    easing: Zc,
                                    zoom: r ? Math.round(b.zoom) + r * (e.shiftKey ? 2 : 1) : b.zoom,
                                    bearing: b.bearing + s * this._bearingStep,
                                    pitch: b.pitch + c * this._pitchStep,
                                    offset: [-d * this._panStep, -m * this._panStep],
                                    center: b.center
                                }, {
                                    originalEvent: e
                                })
                            }
                        }
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                    disableRotation() {
                        this._rotationDisabled = !0
                    }
                    enableRotation() {
                        this._rotationDisabled = !1
                    }
                }
                function Zc(h) {
                    return h * (2 - h)
                }
                const ti = 4.000244140625
                  , $c = 1 / 450;
                class Xh {
                    constructor(e, r) {
                        this._onTimeout = s => {
                            this._type = "wheel",
                            this._delta -= this._lastValue,
                            this._active || this._start(s)
                        }
                        ,
                        this._map = e,
                        this._tr = new Gs(e),
                        this._triggerRenderFrame = r,
                        this._delta = 0,
                        this._defaultZoomRate = .01,
                        this._wheelZoomRate = $c
                    }
                    setZoomRate(e) {
                        this._defaultZoomRate = e
                    }
                    setWheelZoomRate(e) {
                        this._wheelZoomRate = e
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return !!this._active || this._finishTimeout !== void 0
                    }
                    isZooming() {
                        return !!this._zooming
                    }
                    enable(e) {
                        this.isEnabled() || (this._enabled = !0,
                        this._aroundCenter = !!e && e.around === "center")
                    }
                    disable() {
                        this.isEnabled() && (this._enabled = !1)
                    }
                    _shouldBePrevented(e) {
                        return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e))
                    }
                    wheel(e) {
                        if (!this.isEnabled())
                            return;
                        if (this._shouldBePrevented(e))
                            return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
                        let r = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
                        const s = he.now()
                          , c = s - (this._lastWheelEventTime || 0);
                        this._lastWheelEventTime = s,
                        r !== 0 && r % ti == 0 ? this._type = "wheel" : r !== 0 && Math.abs(r) < 4 ? this._type = "trackpad" : c > 400 ? (this._type = null,
                        this._lastValue = r,
                        this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(c * r) < 200 ? "trackpad" : "wheel",
                        this._timeout && (clearTimeout(this._timeout),
                        this._timeout = null,
                        r += this._lastValue)),
                        e.shiftKey && r && (r /= 4),
                        this._type && (this._lastWheelEvent = e,
                        this._delta -= r,
                        this._active || this._start(e)),
                        e.preventDefault()
                    }
                    _start(e) {
                        if (!this._delta)
                            return;
                        this._frameId && (this._frameId = null),
                        this._active = !0,
                        this.isZooming() || (this._zooming = !0),
                        this._finishTimeout && (clearTimeout(this._finishTimeout),
                        delete this._finishTimeout);
                        const r = X.mousePos(this._map.getCanvas(), e)
                          , s = this._tr;
                        this._aroundPoint = this._aroundCenter ? s.transform.locationToScreenPoint(o.S.convert(s.center)) : r,
                        this._frameId || (this._frameId = !0,
                        this._triggerRenderFrame())
                    }
                    renderFrame() {
                        if (!this._frameId || (this._frameId = null,
                        !this.isActive()))
                            return;
                        const e = this._tr.transform;
                        if (typeof this._lastExpectedZoom == "number") {
                            const v = e.zoom - this._lastExpectedZoom;
                            typeof this._startZoom == "number" && (this._startZoom += v),
                            typeof this._targetZoom == "number" && (this._targetZoom += v)
                        }
                        if (this._delta !== 0) {
                            const v = this._type === "wheel" && Math.abs(this._delta) > ti ? this._wheelZoomRate : this._defaultZoomRate;
                            let b = 2 / (1 + Math.exp(-Math.abs(this._delta * v)));
                            this._delta < 0 && b !== 0 && (b = 1 / b);
                            const P = typeof this._targetZoom != "number" ? e.scale : o.ae(this._targetZoom);
                            this._targetZoom = e.getConstrained(e.getCameraLngLat(), o.aj(P * b)).zoom,
                            this._type === "wheel" && (this._startZoom = e.zoom,
                            this._easing = this._smoothOutEasing(200)),
                            this._delta = 0
                        }
                        const r = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom
                          , s = this._startZoom
                          , c = this._easing;
                        let d, m = !1;
                        if (this._type === "wheel" && s && c) {
                            const v = he.now() - this._lastWheelEventTime
                              , b = Math.min((v + 5) / 200, 1)
                              , P = c(b);
                            d = o.C.number(s, r, P),
                            b < 1 ? this._frameId || (this._frameId = !0) : m = !0
                        } else
                            d = r,
                            m = !0;
                        return this._active = !0,
                        m && (this._active = !1,
                        this._finishTimeout = setTimeout( () => {
                            this._zooming = !1,
                            this._triggerRenderFrame(),
                            delete this._targetZoom,
                            delete this._lastExpectedZoom,
                            delete this._finishTimeout
                        }
                        , 200)),
                        this._lastExpectedZoom = d,
                        {
                            noInertia: !0,
                            needsRenderFrame: !m,
                            zoomDelta: d - e.zoom,
                            around: this._aroundPoint,
                            originalEvent: this._lastWheelEvent
                        }
                    }
                    _smoothOutEasing(e) {
                        let r = o.cn;
                        if (this._prevEase) {
                            const s = this._prevEase
                              , c = (he.now() - s.start) / s.duration
                              , d = s.easing(c + .01) - s.easing(c)
                              , m = .27 / Math.sqrt(d * d + 1e-4) * .01
                              , v = Math.sqrt(.0729 - m * m);
                            r = o.cl(m, v, .25, 1)
                        }
                        return this._prevEase = {
                            start: he.now(),
                            duration: e,
                            easing: r
                        },
                        r
                    }
                    reset() {
                        this._active = !1,
                        this._zooming = !1,
                        delete this._targetZoom,
                        delete this._lastExpectedZoom,
                        this._finishTimeout && (clearTimeout(this._finishTimeout),
                        delete this._finishTimeout)
                    }
                }
                class Pl {
                    constructor(e, r) {
                        this._clickZoom = e,
                        this._tapZoom = r
                    }
                    enable() {
                        this._clickZoom.enable(),
                        this._tapZoom.enable()
                    }
                    disable() {
                        this._clickZoom.disable(),
                        this._tapZoom.disable()
                    }
                    isEnabled() {
                        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
                    }
                    isActive() {
                        return this._clickZoom.isActive() || this._tapZoom.isActive()
                    }
                }
                class mp {
                    constructor(e) {
                        this._tr = new Gs(e),
                        this.reset()
                    }
                    reset() {
                        this._active = !1
                    }
                    dblclick(e, r) {
                        return e.preventDefault(),
                        {
                            cameraAnimation: s => {
                                s.easeTo({
                                    duration: 300,
                                    zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
                                    around: this._tr.unproject(r)
                                }, {
                                    originalEvent: e
                                })
                            }
                        }
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class _p {
                    constructor() {
                        this._tap = new Tl({
                            numTouches: 1,
                            numTaps: 1
                        }),
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        delete this._swipePoint,
                        delete this._swipeTouch,
                        delete this._tapTime,
                        delete this._tapPoint,
                        this._tap.reset()
                    }
                    touchstart(e, r, s) {
                        if (!this._swipePoint)
                            if (this._tapTime) {
                                const c = r[0]
                                  , d = e.timeStamp - this._tapTime < 500
                                  , m = this._tapPoint.dist(c) < 30;
                                d && m ? s.length > 0 && (this._swipePoint = c,
                                this._swipeTouch = s[0].identifier) : this.reset()
                            } else
                                this._tap.touchstart(e, r, s)
                    }
                    touchmove(e, r, s) {
                        if (this._tapTime) {
                            if (this._swipePoint) {
                                if (s[0].identifier !== this._swipeTouch)
                                    return;
                                const c = r[0]
                                  , d = c.y - this._swipePoint.y;
                                return this._swipePoint = c,
                                e.preventDefault(),
                                this._active = !0,
                                {
                                    zoomDelta: d / 128
                                }
                            }
                        } else
                            this._tap.touchmove(e, r, s)
                    }
                    touchend(e, r, s) {
                        if (this._tapTime)
                            this._swipePoint && s.length === 0 && this.reset();
                        else {
                            const c = this._tap.touchend(e, r, s);
                            c && (this._tapTime = e.timeStamp,
                            this._tapPoint = c)
                        }
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class Uc {
                    constructor(e, r, s) {
                        this._el = e,
                        this._mousePan = r,
                        this._touchPan = s
                    }
                    enable(e) {
                        this._inertiaOptions = e || {},
                        this._mousePan.enable(),
                        this._touchPan.enable(),
                        this._el.classList.add("maplibregl-touch-drag-pan")
                    }
                    disable() {
                        this._mousePan.disable(),
                        this._touchPan.disable(),
                        this._el.classList.remove("maplibregl-touch-drag-pan")
                    }
                    isEnabled() {
                        return this._mousePan.isEnabled() && this._touchPan.isEnabled()
                    }
                    isActive() {
                        return this._mousePan.isActive() || this._touchPan.isActive()
                    }
                }
                class Il {
                    constructor(e, r, s, c) {
                        this._pitchWithRotate = e.pitchWithRotate,
                        this._rollEnabled = e.rollEnabled,
                        this._mouseRotate = r,
                        this._mousePitch = s,
                        this._mouseRoll = c
                    }
                    enable() {
                        this._mouseRotate.enable(),
                        this._pitchWithRotate && this._mousePitch.enable(),
                        this._rollEnabled && this._mouseRoll.enable()
                    }
                    disable() {
                        this._mouseRotate.disable(),
                        this._mousePitch.disable(),
                        this._mouseRoll.disable()
                    }
                    isEnabled() {
                        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled())
                    }
                    isActive() {
                        return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive()
                    }
                }
                class Gc {
                    constructor(e, r, s, c) {
                        this._el = e,
                        this._touchZoom = r,
                        this._touchRotate = s,
                        this._tapDragZoom = c,
                        this._rotationDisabled = !1,
                        this._enabled = !0
                    }
                    enable(e) {
                        this._touchZoom.enable(e),
                        this._rotationDisabled || this._touchRotate.enable(e),
                        this._tapDragZoom.enable(),
                        this._el.classList.add("maplibregl-touch-zoom-rotate")
                    }
                    disable() {
                        this._touchZoom.disable(),
                        this._touchRotate.disable(),
                        this._tapDragZoom.disable(),
                        this._el.classList.remove("maplibregl-touch-zoom-rotate")
                    }
                    isEnabled() {
                        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
                    }
                    isActive() {
                        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
                    }
                    disableRotation() {
                        this._rotationDisabled = !0,
                        this._touchRotate.disable()
                    }
                    enableRotation() {
                        this._rotationDisabled = !1,
                        this._touchZoom.isEnabled() && this._touchRotate.enable()
                    }
                }
                class Kh {
                    constructor(e, r) {
                        this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey",
                        this._map = e,
                        this._options = r,
                        this._enabled = !1
                    }
                    isActive() {
                        return !1
                    }
                    reset() {}
                    _setupUI() {
                        if (this._container)
                            return;
                        const e = this._map.getCanvasContainer();
                        e.classList.add("maplibregl-cooperative-gestures"),
                        this._container = X.create("div", "maplibregl-cooperative-gesture-screen", e);
                        let r = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
                        this._bypassKey === "metaKey" && (r = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
                        const s = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText")
                          , c = document.createElement("div");
                        c.className = "maplibregl-desktop-message",
                        c.textContent = r,
                        this._container.appendChild(c);
                        const d = document.createElement("div");
                        d.className = "maplibregl-mobile-message",
                        d.textContent = s,
                        this._container.appendChild(d),
                        this._container.setAttribute("aria-hidden", "true")
                    }
                    _destroyUI() {
                        this._container && (X.remove(this._container),
                        this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")),
                        delete this._container
                    }
                    enable() {
                        this._setupUI(),
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this._destroyUI()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isBypassed(e) {
                        return e[this._bypassKey]
                    }
                    notifyGestureBlocked(e, r) {
                        this._enabled && (this._map.fire(new o.l("cooperativegestureprevented",{
                            gestureType: e,
                            originalEvent: r
                        })),
                        this._container.classList.add("maplibregl-show"),
                        setTimeout( () => {
                            this._container.classList.remove("maplibregl-show")
                        }
                        , 100))
                    }
                }
                const Lo = h => h.zoom || h.drag || h.roll || h.pitch || h.rotate;
                class gp extends o.l {
                }
                function Hc(h) {
                    return h.panDelta && h.panDelta.mag() || h.zoomDelta || h.bearingDelta || h.pitchDelta || h.rollDelta
                }
                class Xa {
                    constructor(e, r) {
                        this.handleWindowEvent = c => {
                            this.handleEvent(c, `${c.type}Window`)
                        }
                        ,
                        this.handleEvent = (c, d) => {
                            if (c.type === "blur")
                                return void this.stop(!0);
                            this._updatingCamera = !0;
                            const m = c.type === "renderFrame" ? void 0 : c
                              , v = {
                                needsRenderFrame: !1
                            }
                              , b = {}
                              , P = {};
                            for (const {handlerName: L, handler: B, allowed: Z} of this._handlers) {
                                if (!B.isEnabled())
                                    continue;
                                let te;
                                if (this._blockedByActive(P, Z, L))
                                    B.reset();
                                else if (B[d || c.type]) {
                                    if (o.co(c, d || c.type)) {
                                        const ee = X.mousePos(this._map.getCanvas(), c);
                                        te = B[d || c.type](c, ee)
                                    } else if (o.cp(c, d || c.type)) {
                                        const ee = this._getMapTouches(c.touches)
                                          , ne = X.touchPos(this._map.getCanvas(), ee);
                                        te = B[d || c.type](c, ne, ee)
                                    } else
                                        o.cq(d || c.type) || (te = B[d || c.type](c));
                                    this.mergeHandlerResult(v, b, te, L, m),
                                    te && te.needsRenderFrame && this._triggerRenderFrame()
                                }
                                (te || B.isActive()) && (P[L] = B)
                            }
                            const M = {};
                            for (const L in this._previousActiveHandlers)
                                P[L] || (M[L] = m);
                            this._previousActiveHandlers = P,
                            (Object.keys(M).length || Hc(v)) && (this._changes.push([v, b, M]),
                            this._triggerRenderFrame()),
                            (Object.keys(P).length || Hc(v)) && this._map._stop(!0),
                            this._updatingCamera = !1;
                            const {cameraAnimation: D} = v;
                            D && (this._inertia.clear(),
                            this._fireEvents({}, {}, !0),
                            this._changes = [],
                            D(this._map))
                        }
                        ,
                        this._map = e,
                        this._el = this._map.getCanvasContainer(),
                        this._handlers = [],
                        this._handlersById = {},
                        this._changes = [],
                        this._inertia = new $h(e),
                        this._bearingSnap = r.bearingSnap,
                        this._previousActiveHandlers = {},
                        this._eventsInProgress = {},
                        this._addDefaultHandlers(r);
                        const s = this._el;
                        this._listeners = [[s, "touchstart", {
                            passive: !0
                        }], [s, "touchmove", {
                            passive: !1
                        }], [s, "touchend", void 0], [s, "touchcancel", void 0], [s, "mousedown", void 0], [s, "mousemove", void 0], [s, "mouseup", void 0], [document, "mousemove", {
                            capture: !0
                        }], [document, "mouseup", void 0], [s, "mouseover", void 0], [s, "mouseout", void 0], [s, "dblclick", void 0], [s, "click", void 0], [s, "keydown", {
                            capture: !1
                        }], [s, "keyup", void 0], [s, "wheel", {
                            passive: !1
                        }], [s, "contextmenu", void 0], [window, "blur", void 0]];
                        for (const [c,d,m] of this._listeners)
                            X.addEventListener(c, d, c === document ? this.handleWindowEvent : this.handleEvent, m)
                    }
                    destroy() {
                        for (const [e,r,s] of this._listeners)
                            X.removeEventListener(e, r, e === document ? this.handleWindowEvent : this.handleEvent, s)
                    }
                    _addDefaultHandlers(e) {
                        const r = this._map
                          , s = r.getCanvasContainer();
                        this._add("mapEvent", new Uh(r,e));
                        const c = r.boxZoom = new Nc(r,e);
                        this._add("boxZoom", c),
                        e.interactive && e.boxZoom && c.enable();
                        const d = r.cooperativeGestures = new Kh(r,e.cooperativeGestures);
                        this._add("cooperativeGestures", d),
                        e.cooperativeGestures && d.enable();
                        const m = new Cl(r)
                          , v = new mp(r);
                        r.doubleClickZoom = new Pl(v,m),
                        this._add("tapZoom", m),
                        this._add("clickZoom", v),
                        e.interactive && e.doubleClickZoom && r.doubleClickZoom.enable();
                        const b = new _p;
                        this._add("tapDragZoom", b);
                        const P = r.touchPitch = new Vc(r);
                        this._add("touchPitch", P),
                        e.interactive && e.touchPitch && r.touchPitch.enable(e.touchPitch);
                        const M = () => r.project(r.getCenter())
                          , D = function({enable: ce, clickTolerance: Te, aroundCenter: Pe=!0, minPixelCenterThreshold: pe=100, rotateDegreesPerPixelMoved: Fe=.8}, Ye) {
                            const $e = new zn({
                                checkCorrectEvent: He => X.mouseButton(He) === 0 && He.ctrlKey || X.mouseButton(He) === 2 && !He.ctrlKey
                            });
                            return new Hs({
                                clickTolerance: Te,
                                move: (He, Je) => {
                                    const qt = Ye();
                                    if (Pe && Math.abs(qt.y - He.y) > pe)
                                        return {
                                            bearingDelta: o.cm(new o.P(He.x,Je.y), Je, qt)
                                        };
                                    let Nt = (Je.x - He.x) * Fe;
                                    return Pe && Je.y < qt.y && (Nt = -Nt),
                                    {
                                        bearingDelta: Nt
                                    }
                                }
                                ,
                                moveStateManager: $e,
                                enable: ce,
                                assignEvents: Sl
                            })
                        }(e, M)
                          , L = function({enable: ce, clickTolerance: Te, pitchDegreesPerPixelMoved: Pe=-.5}) {
                            const pe = new zn({
                                checkCorrectEvent: Fe => X.mouseButton(Fe) === 0 && Fe.ctrlKey || X.mouseButton(Fe) === 2
                            });
                            return new Hs({
                                clickTolerance: Te,
                                move: (Fe, Ye) => ({
                                    pitchDelta: (Ye.y - Fe.y) * Pe
                                }),
                                moveStateManager: pe,
                                enable: ce,
                                assignEvents: Sl
                            })
                        }(e)
                          , B = function({enable: ce, clickTolerance: Te, rollDegreesPerPixelMoved: Pe=.3}, pe) {
                            const Fe = new zn({
                                checkCorrectEvent: Ye => X.mouseButton(Ye) === 2 && Ye.ctrlKey
                            });
                            return new Hs({
                                clickTolerance: Te,
                                move: (Ye, $e) => {
                                    const He = pe();
                                    let Je = ($e.x - Ye.x) * Pe;
                                    return $e.y < He.y && (Je = -Je),
                                    {
                                        rollDelta: Je
                                    }
                                }
                                ,
                                moveStateManager: Fe,
                                enable: ce,
                                assignEvents: Sl
                            })
                        }(e, M);
                        r.dragRotate = new Il(e,D,L,B),
                        this._add("mouseRotate", D, ["mousePitch"]),
                        this._add("mousePitch", L, ["mouseRotate", "mouseRoll"]),
                        this._add("mouseRoll", B, ["mousePitch"]),
                        e.interactive && e.dragRotate && r.dragRotate.enable();
                        const Z = function({enable: ce, clickTolerance: Te}) {
                            const Pe = new zn({
                                checkCorrectEvent: pe => X.mouseButton(pe) === 0 && !pe.ctrlKey
                            });
                            return new Hs({
                                clickTolerance: Te,
                                move: (pe, Fe) => ({
                                    around: Fe,
                                    panDelta: Fe.sub(pe)
                                }),
                                activateOnStart: !0,
                                moveStateManager: Pe,
                                enable: ce,
                                assignEvents: Sl
                            })
                        }(e)
                          , te = new fp(e,r);
                        r.dragPan = new Uc(s,Z,te),
                        this._add("mousePan", Z),
                        this._add("touchPan", te, ["touchZoom", "touchRotate"]),
                        e.interactive && e.dragPan && r.dragPan.enable(e.dragPan);
                        const ee = new qc
                          , ne = new Pa;
                        r.touchZoomRotate = new Gc(s,ne,ee,b),
                        this._add("touchRotate", ee, ["touchPan", "touchZoom"]),
                        this._add("touchZoom", ne, ["touchPan", "touchRotate"]),
                        e.interactive && e.touchZoomRotate && r.touchZoomRotate.enable(e.touchZoomRotate);
                        const oe = r.scrollZoom = new Xh(r, () => this._triggerRenderFrame());
                        this._add("scrollZoom", oe, ["mousePan"]),
                        e.interactive && e.scrollZoom && r.scrollZoom.enable(e.scrollZoom);
                        const me = r.keyboard = new Ks(r);
                        this._add("keyboard", me),
                        e.interactive && e.keyboard && r.keyboard.enable(),
                        this._add("blockableMapEvent", new Gh(r))
                    }
                    _add(e, r, s) {
                        this._handlers.push({
                            handlerName: e,
                            handler: r,
                            allowed: s
                        }),
                        this._handlersById[e] = r
                    }
                    stop(e) {
                        if (!this._updatingCamera) {
                            for (const {handler: r} of this._handlers)
                                r.reset();
                            this._inertia.clear(),
                            this._fireEvents({}, {}, e),
                            this._changes = []
                        }
                    }
                    isActive() {
                        for (const {handler: e} of this._handlers)
                            if (e.isActive())
                                return !0;
                        return !1
                    }
                    isZooming() {
                        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
                    }
                    isRotating() {
                        return !!this._eventsInProgress.rotate
                    }
                    isMoving() {
                        return !!Lo(this._eventsInProgress) || this.isZooming()
                    }
                    _blockedByActive(e, r, s) {
                        for (const c in e)
                            if (c !== s && (!r || r.indexOf(c) < 0))
                                return !0;
                        return !1
                    }
                    _getMapTouches(e) {
                        const r = [];
                        for (const s of e)
                            this._el.contains(s.target) && r.push(s);
                        return r
                    }
                    mergeHandlerResult(e, r, s, c, d) {
                        if (!s)
                            return;
                        o.e(e, s);
                        const m = {
                            handlerName: c,
                            originalEvent: s.originalEvent || d
                        };
                        s.zoomDelta !== void 0 && (r.zoom = m),
                        s.panDelta !== void 0 && (r.drag = m),
                        s.rollDelta !== void 0 && (r.roll = m),
                        s.pitchDelta !== void 0 && (r.pitch = m),
                        s.bearingDelta !== void 0 && (r.rotate = m)
                    }
                    _applyChanges() {
                        const e = {}
                          , r = {}
                          , s = {};
                        for (const [c,d,m] of this._changes)
                            c.panDelta && (e.panDelta = (e.panDelta || new o.P(0,0))._add(c.panDelta)),
                            c.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + c.zoomDelta),
                            c.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + c.bearingDelta),
                            c.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + c.pitchDelta),
                            c.rollDelta && (e.rollDelta = (e.rollDelta || 0) + c.rollDelta),
                            c.around !== void 0 && (e.around = c.around),
                            c.pinchAround !== void 0 && (e.pinchAround = c.pinchAround),
                            c.noInertia && (e.noInertia = c.noInertia),
                            o.e(r, d),
                            o.e(s, m);
                        this._updateMapTransform(e, r, s),
                        this._changes = []
                    }
                    _updateMapTransform(e, r, s) {
                        const c = this._map
                          , d = c._getTransformForUpdate()
                          , m = c.terrain;
                        if (!(Hc(e) || m && this._terrainMovement))
                            return this._fireEvents(r, s, !0);
                        c._stop(!0);
                        let {panDelta: v, zoomDelta: b, bearingDelta: P, pitchDelta: M, rollDelta: D, around: L, pinchAround: B} = e;
                        B !== void 0 && (L = B),
                        L = L || c.transform.centerPoint,
                        m && !d.isPointOnMapSurface(L) && (L = d.centerPoint);
                        const Z = {
                            panDelta: v,
                            zoomDelta: b,
                            rollDelta: D,
                            pitchDelta: M,
                            bearingDelta: P,
                            around: L
                        };
                        this._map.cameraHelper.useGlobeControls && !d.isPointOnMapSurface(L) && (L = d.centerPoint);
                        const te = L.distSqr(d.centerPoint) < .01 ? d.center : d.screenPointToLocation(v ? L.sub(v) : L);
                        m ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(Z, d),
                        this._terrainMovement || !r.drag && !r.zoom ? r.drag && this._terrainMovement ? d.setCenter(d.screenPointToLocation(d.centerPoint.sub(v))) : this._map.cameraHelper.handleMapControlsPan(Z, d, te) : (this._terrainMovement = !0,
                        this._map._elevationFreeze = !0,
                        this._map.cameraHelper.handleMapControlsPan(Z, d, te))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(Z, d),
                        this._map.cameraHelper.handleMapControlsPan(Z, d, te)),
                        c._applyUpdatedTransform(d),
                        this._map._update(),
                        e.noInertia || this._inertia.record(e),
                        this._fireEvents(r, s, !0)
                    }
                    _fireEvents(e, r, s) {
                        const c = Lo(this._eventsInProgress)
                          , d = Lo(e)
                          , m = {};
                        for (const D in e) {
                            const {originalEvent: L} = e[D];
                            this._eventsInProgress[D] || (m[`${D}start`] = L),
                            this._eventsInProgress[D] = e[D]
                        }
                        !c && d && this._fireEvent("movestart", d.originalEvent);
                        for (const D in m)
                            this._fireEvent(D, m[D]);
                        d && this._fireEvent("move", d.originalEvent);
                        for (const D in e) {
                            const {originalEvent: L} = e[D];
                            this._fireEvent(D, L)
                        }
                        const v = {};
                        let b;
                        for (const D in this._eventsInProgress) {
                            const {handlerName: L, originalEvent: B} = this._eventsInProgress[D];
                            this._handlersById[L].isActive() || (delete this._eventsInProgress[D],
                            b = r[L] || B,
                            v[`${D}end`] = b)
                        }
                        for (const D in v)
                            this._fireEvent(D, v[D]);
                        const P = Lo(this._eventsInProgress)
                          , M = (c || d) && !P;
                        if (M && this._terrainMovement) {
                            this._map._elevationFreeze = !1,
                            this._terrainMovement = !1;
                            const D = this._map._getTransformForUpdate();
                            this._map.getCenterClampedToGround() && D.recalculateZoomAndCenter(this._map.terrain),
                            this._map._applyUpdatedTransform(D)
                        }
                        if (s && M) {
                            this._updatingCamera = !0;
                            const D = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions)
                              , L = B => B !== 0 && -this._bearingSnap < B && B < this._bearingSnap;
                            !D || !D.essential && he.prefersReducedMotion ? (this._map.fire(new o.l("moveend",{
                                originalEvent: b
                            })),
                            L(this._map.getBearing()) && this._map.resetNorth()) : (L(D.bearing || this._map.getBearing()) && (D.bearing = 0),
                            D.freezeElevation = !0,
                            this._map.easeTo(D, {
                                originalEvent: b
                            })),
                            this._updatingCamera = !1
                        }
                    }
                    _fireEvent(e, r) {
                        this._map.fire(new o.l(e,r ? {
                            originalEvent: r
                        } : {}))
                    }
                    _requestFrame() {
                        return this._map.triggerRepaint(),
                        this._map._renderTaskQueue.add(e => {
                            delete this._frameId,
                            this.handleEvent(new gp("renderFrame",{
                                timeStamp: e
                            })),
                            this._applyChanges()
                        }
                        )
                    }
                    _triggerRenderFrame() {
                        this._frameId === void 0 && (this._frameId = this._requestFrame())
                    }
                }
                class Ei extends o.E {
                    constructor(e, r, s) {
                        super(),
                        this._renderFrameCallback = () => {
                            const c = Math.min((he.now() - this._easeStart) / this._easeOptions.duration, 1);
                            this._onEaseFrame(this._easeOptions.easing(c)),
                            c < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
                        }
                        ,
                        this._moving = !1,
                        this._zooming = !1,
                        this.transform = e,
                        this._bearingSnap = s.bearingSnap,
                        this.cameraHelper = r,
                        this.on("moveend", () => {
                            delete this._requestedCameraState
                        }
                        )
                    }
                    migrateProjection(e, r) {
                        e.apply(this.transform),
                        this.transform = e,
                        this.cameraHelper = r
                    }
                    getCenter() {
                        return new o.S(this.transform.center.lng,this.transform.center.lat)
                    }
                    setCenter(e, r) {
                        return this.jumpTo({
                            center: e
                        }, r)
                    }
                    getCenterElevation() {
                        return this.transform.elevation
                    }
                    setCenterElevation(e, r) {
                        return this.jumpTo({
                            elevation: e
                        }, r),
                        this
                    }
                    getCenterClampedToGround() {
                        return this._centerClampedToGround
                    }
                    setCenterClampedToGround(e) {
                        this._centerClampedToGround = e
                    }
                    panBy(e, r, s) {
                        return e = o.P.convert(e).mult(-1),
                        this.panTo(this.transform.center, o.e({
                            offset: e
                        }, r), s)
                    }
                    panTo(e, r, s) {
                        return this.easeTo(o.e({
                            center: e
                        }, r), s)
                    }
                    getZoom() {
                        return this.transform.zoom
                    }
                    setZoom(e, r) {
                        return this.jumpTo({
                            zoom: e
                        }, r),
                        this
                    }
                    zoomTo(e, r, s) {
                        return this.easeTo(o.e({
                            zoom: e
                        }, r), s)
                    }
                    zoomIn(e, r) {
                        return this.zoomTo(this.getZoom() + 1, e, r),
                        this
                    }
                    zoomOut(e, r) {
                        return this.zoomTo(this.getZoom() - 1, e, r),
                        this
                    }
                    getVerticalFieldOfView() {
                        return this.transform.fov
                    }
                    setVerticalFieldOfView(e, r) {
                        return e != this.transform.fov && (this.transform.setFov(e),
                        this.fire(new o.l("movestart",r)).fire(new o.l("move",r)).fire(new o.l("moveend",r))),
                        this
                    }
                    getBearing() {
                        return this.transform.bearing
                    }
                    setBearing(e, r) {
                        return this.jumpTo({
                            bearing: e
                        }, r),
                        this
                    }
                    getPadding() {
                        return this.transform.padding
                    }
                    setPadding(e, r) {
                        return this.jumpTo({
                            padding: e
                        }, r),
                        this
                    }
                    rotateTo(e, r, s) {
                        return this.easeTo(o.e({
                            bearing: e
                        }, r), s)
                    }
                    resetNorth(e, r) {
                        return this.rotateTo(0, o.e({
                            duration: 1e3
                        }, e), r),
                        this
                    }
                    resetNorthPitch(e, r) {
                        return this.easeTo(o.e({
                            bearing: 0,
                            pitch: 0,
                            roll: 0,
                            duration: 1e3
                        }, e), r),
                        this
                    }
                    snapToNorth(e, r) {
                        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, r) : this
                    }
                    getPitch() {
                        return this.transform.pitch
                    }
                    setPitch(e, r) {
                        return this.jumpTo({
                            pitch: e
                        }, r),
                        this
                    }
                    getRoll() {
                        return this.transform.roll
                    }
                    setRoll(e, r) {
                        return this.jumpTo({
                            roll: e
                        }, r),
                        this
                    }
                    cameraForBounds(e, r) {
                        e = Lt.convert(e).adjustAntiMeridian();
                        const s = r && r.bearing || 0;
                        return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), s, r)
                    }
                    _cameraForBoxAndBearing(e, r, s, c) {
                        const d = {
                            top: 0,
                            bottom: 0,
                            right: 0,
                            left: 0
                        };
                        if (typeof (c = o.e({
                            padding: d,
                            offset: [0, 0],
                            maxZoom: this.transform.maxZoom
                        }, c)).padding == "number") {
                            const P = c.padding;
                            c.padding = {
                                top: P,
                                bottom: P,
                                right: P,
                                left: P
                            }
                        }
                        const m = o.e(d, c.padding);
                        c.padding = m;
                        const v = this.transform
                          , b = new Lt(e,r);
                        return this.cameraHelper.cameraForBoxAndBearing(c, m, b, s, v)
                    }
                    fitBounds(e, r, s) {
                        return this._fitInternal(this.cameraForBounds(e, r), r, s)
                    }
                    fitScreenCoordinates(e, r, s, c, d) {
                        return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(o.P.convert(e)), this.transform.screenPointToLocation(o.P.convert(r)), s, c), c, d)
                    }
                    _fitInternal(e, r, s) {
                        return e ? (delete (r = o.e(e, r)).padding,
                        r.linear ? this.easeTo(r, s) : this.flyTo(r, s)) : this
                    }
                    jumpTo(e, r) {
                        this.stop();
                        const s = this._getTransformForUpdate();
                        let c = !1
                          , d = !1
                          , m = !1;
                        const v = s.zoom;
                        this.cameraHelper.handleJumpToCenterZoom(s, e);
                        const b = s.zoom !== v;
                        return "elevation"in e && s.elevation !== +e.elevation && s.setElevation(+e.elevation),
                        "bearing"in e && s.bearing !== +e.bearing && (c = !0,
                        s.setBearing(+e.bearing)),
                        "pitch"in e && s.pitch !== +e.pitch && (d = !0,
                        s.setPitch(+e.pitch)),
                        "roll"in e && s.roll !== +e.roll && (m = !0,
                        s.setRoll(+e.roll)),
                        e.padding == null || s.isPaddingEqual(e.padding) || s.setPadding(e.padding),
                        this._applyUpdatedTransform(s),
                        this.fire(new o.l("movestart",r)).fire(new o.l("move",r)),
                        b && this.fire(new o.l("zoomstart",r)).fire(new o.l("zoom",r)).fire(new o.l("zoomend",r)),
                        c && this.fire(new o.l("rotatestart",r)).fire(new o.l("rotate",r)).fire(new o.l("rotateend",r)),
                        d && this.fire(new o.l("pitchstart",r)).fire(new o.l("pitch",r)).fire(new o.l("pitchend",r)),
                        m && this.fire(new o.l("rollstart",r)).fire(new o.l("roll",r)).fire(new o.l("rollend",r)),
                        this.fire(new o.l("moveend",r))
                    }
                    calculateCameraOptionsFromTo(e, r, s, c=0) {
                        const d = o.a0.fromLngLat(e, r)
                          , m = o.a0.fromLngLat(s, c)
                          , v = m.x - d.x
                          , b = m.y - d.y
                          , P = m.z - d.z
                          , M = Math.hypot(v, b, P);
                        if (M === 0)
                            throw new Error("Can't calculate camera options with same From and To");
                        const D = Math.hypot(v, b)
                          , L = o.aj(this.transform.cameraToCenterDistance / M / this.transform.tileSize)
                          , B = 180 * Math.atan2(v, -b) / Math.PI;
                        let Z = 180 * Math.acos(D / M) / Math.PI;
                        return Z = P < 0 ? 90 - Z : 90 + Z,
                        {
                            center: m.toLngLat(),
                            elevation: c,
                            zoom: L,
                            pitch: Z,
                            bearing: B
                        }
                    }
                    calculateCameraOptionsFromCameraLngLatAltRotation(e, r, s, c, d) {
                        const m = this.transform.calculateCenterFromCameraLngLatAlt(e, r, s, c);
                        return {
                            center: m.center,
                            elevation: m.elevation,
                            zoom: m.zoom,
                            bearing: s,
                            pitch: c,
                            roll: d
                        }
                    }
                    easeTo(e, r) {
                        this._stop(!1, e.easeId),
                        ((e = o.e({
                            offset: [0, 0],
                            duration: 500,
                            easing: o.cn
                        }, e)).animate === !1 || !e.essential && he.prefersReducedMotion) && (e.duration = 0);
                        const s = this._getTransformForUpdate()
                          , c = this.getBearing()
                          , d = s.pitch
                          , m = s.roll
                          , v = "bearing"in e ? this._normalizeBearing(e.bearing, c) : c
                          , b = "pitch"in e ? +e.pitch : d
                          , P = "roll"in e ? this._normalizeBearing(e.roll, m) : m
                          , M = "padding"in e ? e.padding : s.padding
                          , D = o.P.convert(e.offset);
                        let L, B;
                        e.around && (L = o.S.convert(e.around),
                        B = s.locationToScreenPoint(L));
                        const Z = {
                            moving: this._moving,
                            zooming: this._zooming,
                            rotating: this._rotating,
                            pitching: this._pitching,
                            rolling: this._rolling
                        }
                          , te = this.cameraHelper.handleEaseTo(s, {
                            bearing: v,
                            pitch: b,
                            roll: P,
                            padding: M,
                            around: L,
                            aroundPoint: B,
                            offsetAsPoint: D,
                            offset: e.offset,
                            zoom: e.zoom,
                            center: e.center
                        });
                        return this._rotating = this._rotating || c !== v,
                        this._pitching = this._pitching || b !== d,
                        this._rolling = this._rolling || P !== m,
                        this._padding = !s.isPaddingEqual(M),
                        this._zooming = this._zooming || te.isZooming,
                        this._easeId = e.easeId,
                        this._prepareEase(r, e.noMoveStart, Z),
                        this.terrain && this._prepareElevation(te.elevationCenter),
                        this._ease(ee => {
                            te.easeFunc(ee),
                            this.terrain && !e.freezeElevation && this._updateElevation(ee),
                            this._applyUpdatedTransform(s),
                            this._fireMoveEvents(r)
                        }
                        , ee => {
                            this.terrain && e.freezeElevation && this._finalizeElevation(),
                            this._afterEase(r, ee)
                        }
                        , e),
                        this
                    }
                    _prepareEase(e, r, s={}) {
                        this._moving = !0,
                        r || s.moving || this.fire(new o.l("movestart",e)),
                        this._zooming && !s.zooming && this.fire(new o.l("zoomstart",e)),
                        this._rotating && !s.rotating && this.fire(new o.l("rotatestart",e)),
                        this._pitching && !s.pitching && this.fire(new o.l("pitchstart",e)),
                        this._rolling && !s.rolling && this.fire(new o.l("rollstart",e))
                    }
                    _prepareElevation(e) {
                        this._elevationCenter = e,
                        this._elevationStart = this.transform.elevation,
                        this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom),
                        this._elevationFreeze = !0
                    }
                    _updateElevation(e) {
                        this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
                        const r = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
                        if (e < 1 && r !== this._elevationTarget) {
                            const s = this._elevationTarget - this._elevationStart;
                            this._elevationStart += e * (s - (r - (s * e + this._elevationStart)) / (1 - e)),
                            this._elevationTarget = r
                        }
                        this.transform.setElevation(o.C.number(this._elevationStart, this._elevationTarget, e))
                    }
                    _finalizeElevation() {
                        this._elevationFreeze = !1,
                        this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain)
                    }
                    _getTransformForUpdate() {
                        return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()),
                        this._requestedCameraState) : this.transform
                    }
                    _elevateCameraIfInsideTerrain(e) {
                        if (!this.terrain && e.elevation >= 0 && e.pitch <= 90)
                            return {};
                        const r = e.getCameraLngLat()
                          , s = e.getCameraAltitude()
                          , c = this.terrain ? this.terrain.getElevationForLngLatZoom(r, e.zoom) : 0;
                        if (s < c) {
                            const d = this.calculateCameraOptionsFromTo(r, c, e.center, e.elevation);
                            return {
                                pitch: d.pitch,
                                zoom: d.zoom
                            }
                        }
                        return {}
                    }
                    _applyUpdatedTransform(e) {
                        const r = [];
                        if (r.push(c => this._elevateCameraIfInsideTerrain(c)),
                        this.transformCameraUpdate && r.push(c => this.transformCameraUpdate(c)),
                        !r.length)
                            return;
                        const s = e.clone();
                        for (const c of r) {
                            const d = s.clone()
                              , {center: m, zoom: v, roll: b, pitch: P, bearing: M, elevation: D} = c(d);
                            m && d.setCenter(m),
                            D !== void 0 && d.setElevation(D),
                            v !== void 0 && d.setZoom(v),
                            b !== void 0 && d.setRoll(b),
                            P !== void 0 && d.setPitch(P),
                            M !== void 0 && d.setBearing(M),
                            s.apply(d)
                        }
                        this.transform.apply(s)
                    }
                    _fireMoveEvents(e) {
                        this.fire(new o.l("move",e)),
                        this._zooming && this.fire(new o.l("zoom",e)),
                        this._rotating && this.fire(new o.l("rotate",e)),
                        this._pitching && this.fire(new o.l("pitch",e)),
                        this._rolling && this.fire(new o.l("roll",e))
                    }
                    _afterEase(e, r) {
                        if (this._easeId && r && this._easeId === r)
                            return;
                        delete this._easeId;
                        const s = this._zooming
                          , c = this._rotating
                          , d = this._pitching
                          , m = this._rolling;
                        this._moving = !1,
                        this._zooming = !1,
                        this._rotating = !1,
                        this._pitching = !1,
                        this._rolling = !1,
                        this._padding = !1,
                        s && this.fire(new o.l("zoomend",e)),
                        c && this.fire(new o.l("rotateend",e)),
                        d && this.fire(new o.l("pitchend",e)),
                        m && this.fire(new o.l("rollend",e)),
                        this.fire(new o.l("moveend",e))
                    }
                    flyTo(e, r) {
                        if (!e.essential && he.prefersReducedMotion) {
                            const Je = o.Q(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
                            return this.jumpTo(Je, r)
                        }
                        this.stop(),
                        e = o.e({
                            offset: [0, 0],
                            speed: 1.2,
                            curve: 1.42,
                            easing: o.cn
                        }, e);
                        const s = this._getTransformForUpdate()
                          , c = s.bearing
                          , d = s.pitch
                          , m = s.roll
                          , v = s.padding
                          , b = "bearing"in e ? this._normalizeBearing(e.bearing, c) : c
                          , P = "pitch"in e ? +e.pitch : d
                          , M = "roll"in e ? this._normalizeBearing(e.roll, m) : m
                          , D = "padding"in e ? e.padding : s.padding
                          , L = o.P.convert(e.offset);
                        let B = s.centerPoint.add(L);
                        const Z = s.screenPointToLocation(B)
                          , te = this.cameraHelper.handleFlyTo(s, {
                            bearing: b,
                            pitch: P,
                            roll: M,
                            padding: D,
                            locationAtOffset: Z,
                            offsetAsPoint: L,
                            center: e.center,
                            minZoom: e.minZoom,
                            zoom: e.zoom
                        });
                        let ee = e.curve;
                        const ne = Math.max(s.width, s.height)
                          , oe = ne / te.scaleOfZoom
                          , me = te.pixelPathLength;
                        typeof te.scaleOfMinZoom == "number" && (ee = Math.sqrt(ne / te.scaleOfMinZoom / me * 2));
                        const ce = ee * ee;
                        function Te(Je) {
                            const qt = (oe * oe - ne * ne + (Je ? -1 : 1) * ce * ce * me * me) / (2 * (Je ? oe : ne) * ce * me);
                            return Math.log(Math.sqrt(qt * qt + 1) - qt)
                        }
                        function Pe(Je) {
                            return (Math.exp(Je) - Math.exp(-Je)) / 2
                        }
                        function pe(Je) {
                            return (Math.exp(Je) + Math.exp(-Je)) / 2
                        }
                        const Fe = Te(!1);
                        let Ye = function(Je) {
                            return pe(Fe) / pe(Fe + ee * Je)
                        }
                          , $e = function(Je) {
                            return ne * ((pe(Fe) * (Pe(qt = Fe + ee * Je) / pe(qt)) - Pe(Fe)) / ce) / me;
                            var qt
                        }
                          , He = (Te(!0) - Fe) / ee;
                        if (Math.abs(me) < 2e-6 || !isFinite(He)) {
                            if (Math.abs(ne - oe) < 1e-6)
                                return this.easeTo(e, r);
                            const Je = oe < ne ? -1 : 1;
                            He = Math.abs(Math.log(oe / ne)) / ee,
                            $e = () => 0,
                            Ye = qt => Math.exp(Je * ee * qt)
                        }
                        return e.duration = "duration"in e ? +e.duration : 1e3 * He / ("screenSpeed"in e ? +e.screenSpeed / ee : +e.speed),
                        e.maxDuration && e.duration > e.maxDuration && (e.duration = 0),
                        this._zooming = !0,
                        this._rotating = c !== b,
                        this._pitching = P !== d,
                        this._rolling = M !== m,
                        this._padding = !s.isPaddingEqual(D),
                        this._prepareEase(r, !1),
                        this.terrain && this._prepareElevation(te.targetCenter),
                        this._ease(Je => {
                            const qt = Je * He
                              , Nt = 1 / Ye(qt)
                              , wt = $e(qt);
                            this._rotating && s.setBearing(o.C.number(c, b, Je)),
                            this._pitching && s.setPitch(o.C.number(d, P, Je)),
                            this._rolling && s.setRoll(o.C.number(m, M, Je)),
                            this._padding && (s.interpolatePadding(v, D, Je),
                            B = s.centerPoint.add(L)),
                            te.easeFunc(Je, Nt, wt, B),
                            this.terrain && !e.freezeElevation && this._updateElevation(Je),
                            this._applyUpdatedTransform(s),
                            this._fireMoveEvents(r)
                        }
                        , () => {
                            this.terrain && e.freezeElevation && this._finalizeElevation(),
                            this._afterEase(r)
                        }
                        , e),
                        this
                    }
                    isEasing() {
                        return !!this._easeFrameId
                    }
                    stop() {
                        return this._stop()
                    }
                    _stop(e, r) {
                        var s;
                        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId),
                        delete this._easeFrameId,
                        delete this._onEaseFrame),
                        this._onEaseEnd) {
                            const c = this._onEaseEnd;
                            delete this._onEaseEnd,
                            c.call(this, r)
                        }
                        return e || (s = this.handlers) === null || s === void 0 || s.stop(!1),
                        this
                    }
                    _ease(e, r, s) {
                        s.animate === !1 || s.duration === 0 ? (e(1),
                        r()) : (this._easeStart = he.now(),
                        this._easeOptions = s,
                        this._onEaseFrame = e,
                        this._onEaseEnd = r,
                        this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
                    }
                    _normalizeBearing(e, r) {
                        e = o.aN(e, -180, 180);
                        const s = Math.abs(e - r);
                        return Math.abs(e - 360 - r) < s && (e -= 360),
                        Math.abs(e + 360 - r) < s && (e += 360),
                        e
                    }
                    queryTerrainElevation(e) {
                        return this.terrain ? this.terrain.getElevationForLngLatZoom(o.S.convert(e), this.transform.tileZoom) : null
                    }
                }
                const Do = {
                    compact: !0,
                    customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>'
                };
                class Ml {
                    constructor(e=Do) {
                        this._toggleAttribution = () => {
                            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""),
                            this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"),
                            this._container.removeAttribute("open")))
                        }
                        ,
                        this._updateData = r => {
                            !r || r.sourceDataType !== "metadata" && r.sourceDataType !== "visibility" && r.dataType !== "style" && r.type !== "terrain" || this._updateAttributions()
                        }
                        ,
                        this._updateCompact = () => {
                            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""),
                            this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""),
                            this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"))
                        }
                        ,
                        this._updateCompactMinimize = () => {
                            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show")
                        }
                        ,
                        this.options = e
                    }
                    getDefaultPosition() {
                        return "bottom-right"
                    }
                    onAdd(e) {
                        return this._map = e,
                        this._compact = this.options.compact,
                        this._container = X.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"),
                        this._compactButton = X.create("summary", "maplibregl-ctrl-attrib-button", this._container),
                        this._compactButton.addEventListener("click", this._toggleAttribution),
                        this._setElementTitle(this._compactButton, "ToggleAttribution"),
                        this._innerContainer = X.create("div", "maplibregl-ctrl-attrib-inner", this._container),
                        this._updateAttributions(),
                        this._updateCompact(),
                        this._map.on("styledata", this._updateData),
                        this._map.on("sourcedata", this._updateData),
                        this._map.on("terrain", this._updateData),
                        this._map.on("resize", this._updateCompact),
                        this._map.on("drag", this._updateCompactMinimize),
                        this._container
                    }
                    onRemove() {
                        X.remove(this._container),
                        this._map.off("styledata", this._updateData),
                        this._map.off("sourcedata", this._updateData),
                        this._map.off("terrain", this._updateData),
                        this._map.off("resize", this._updateCompact),
                        this._map.off("drag", this._updateCompactMinimize),
                        this._map = void 0,
                        this._compact = void 0,
                        this._attribHTML = void 0
                    }
                    _setElementTitle(e, r) {
                        const s = this._map._getUIString(`AttributionControl.${r}`);
                        e.title = s,
                        e.setAttribute("aria-label", s)
                    }
                    _updateAttributions() {
                        if (!this._map.style)
                            return;
                        let e = [];
                        if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map(c => typeof c != "string" ? "" : c)) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)),
                        this._map.style.stylesheet) {
                            const c = this._map.style.stylesheet;
                            this.styleOwner = c.owner,
                            this.styleId = c.id
                        }
                        const r = this._map.style.sourceCaches;
                        for (const c in r) {
                            const d = r[c];
                            if (d.used || d.usedForTerrain) {
                                const m = d.getSource();
                                m.attribution && e.indexOf(m.attribution) < 0 && e.push(m.attribution)
                            }
                        }
                        e = e.filter(c => String(c).trim()),
                        e.sort( (c, d) => c.length - d.length),
                        e = e.filter( (c, d) => {
                            for (let m = d + 1; m < e.length; m++)
                                if (e[m].indexOf(c) >= 0)
                                    return !1;
                            return !0
                        }
                        );
                        const s = e.join(" | ");
                        s !== this._attribHTML && (this._attribHTML = s,
                        e.length ? (this._innerContainer.innerHTML = X.sanitize(s),
                        this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"),
                        this._updateCompact(),
                        this._editLink = null)
                    }
                }
                class Wc {
                    constructor(e={}) {
                        this._updateCompact = () => {
                            const r = this._container.children;
                            if (r.length) {
                                const s = r[0];
                                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && s.classList.add("maplibregl-compact") : s.classList.remove("maplibregl-compact")
                            }
                        }
                        ,
                        this.options = e
                    }
                    getDefaultPosition() {
                        return "bottom-left"
                    }
                    onAdd(e) {
                        this._map = e,
                        this._compact = this.options && this.options.compact,
                        this._container = X.create("div", "maplibregl-ctrl");
                        const r = X.create("a", "maplibregl-ctrl-logo");
                        return r.target = "_blank",
                        r.rel = "noopener nofollow",
                        r.href = "https://maplibre.org/",
                        r.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")),
                        r.setAttribute("rel", "noopener nofollow"),
                        this._container.appendChild(r),
                        this._container.style.display = "block",
                        this._map.on("resize", this._updateCompact),
                        this._updateCompact(),
                        this._container
                    }
                    onRemove() {
                        X.remove(this._container),
                        this._map.off("resize", this._updateCompact),
                        this._map = void 0,
                        this._compact = void 0
                    }
                }
                class Yh {
                    constructor() {
                        this._queue = [],
                        this._id = 0,
                        this._cleared = !1,
                        this._currentlyRunning = !1
                    }
                    add(e) {
                        const r = ++this._id;
                        return this._queue.push({
                            callback: e,
                            id: r,
                            cancelled: !1
                        }),
                        r
                    }
                    remove(e) {
                        const r = this._currentlyRunning
                          , s = r ? this._queue.concat(r) : this._queue;
                        for (const c of s)
                            if (c.id === e)
                                return void (c.cancelled = !0)
                    }
                    run(e=0) {
                        if (this._currentlyRunning)
                            throw new Error("Attempting to run(), but is already running.");
                        const r = this._currentlyRunning = this._queue;
                        this._queue = [];
                        for (const s of r)
                            if (!s.cancelled && (s.callback(e),
                            this._cleared))
                                break;
                        this._cleared = !1,
                        this._currentlyRunning = !1
                    }
                    clear() {
                        this._currentlyRunning && (this._cleared = !0),
                        this._queue = []
                    }
                }
                var Jh = o.aI([{
                    name: "a_pos3d",
                    type: "Int16",
                    components: 3
                }]);
                class vp extends o.E {
                    constructor(e) {
                        super(),
                        this._lastTilesetChange = he.now(),
                        this.sourceCache = e,
                        this._tiles = {},
                        this._renderableTilesKeys = [],
                        this._sourceTileCache = {},
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.deltaZoom = 1,
                        this.tileSize = e._source.tileSize * 2 ** this.deltaZoom,
                        e.usedForTerrain = !0,
                        e.tileSize = this.tileSize
                    }
                    destruct() {
                        this.sourceCache.usedForTerrain = !1,
                        this.sourceCache.tileSize = null
                    }
                    update(e, r) {
                        this.sourceCache.update(e, r),
                        this._renderableTilesKeys = [];
                        const s = {};
                        for (const c of Oe(e, {
                            tileSize: this.tileSize,
                            minzoom: this.minzoom,
                            maxzoom: this.maxzoom,
                            reparseOverscaled: !1,
                            terrain: r,
                            calculateTileZoom: this.sourceCache._source.calculateTileZoom
                        }))
                            s[c.key] = !0,
                            this._renderableTilesKeys.push(c.key),
                            this._tiles[c.key] || (c.terrainRttPosMatrix32f = new Float64Array(16),
                            o.bX(c.terrainRttPosMatrix32f, 0, o.$, o.$, 0, 0, 1),
                            this._tiles[c.key] = new br(c,this.tileSize),
                            this._lastTilesetChange = he.now());
                        for (const c in this._tiles)
                            s[c] || delete this._tiles[c]
                    }
                    freeRtt(e) {
                        for (const r in this._tiles) {
                            const s = this._tiles[r];
                            (!e || s.tileID.equals(e) || s.tileID.isChildOf(e) || e.isChildOf(s.tileID)) && (s.rtt = [])
                        }
                    }
                    getRenderableTiles() {
                        return this._renderableTilesKeys.map(e => this.getTileByID(e))
                    }
                    getTileByID(e) {
                        return this._tiles[e]
                    }
                    getTerrainCoords(e, r) {
                        return r ? this._getTerrainCoordsForTileRanges(e, r) : this._getTerrainCoordsForRegularTile(e)
                    }
                    _getTerrainCoordsForRegularTile(e) {
                        const r = {};
                        for (const s of this._renderableTilesKeys) {
                            const c = this._tiles[s].tileID
                              , d = e.clone()
                              , m = o.b9();
                            if (c.canonical.equals(e.canonical))
                                o.bX(m, 0, o.$, o.$, 0, 0, 1);
                            else if (c.canonical.isChildOf(e.canonical)) {
                                const v = c.canonical.z - e.canonical.z
                                  , b = c.canonical.x - (c.canonical.x >> v << v)
                                  , P = c.canonical.y - (c.canonical.y >> v << v)
                                  , M = o.$ >> v;
                                o.bX(m, 0, M, M, 0, 0, 1),
                                o.M(m, m, [-b * M, -P * M, 0])
                            } else {
                                if (!e.canonical.isChildOf(c.canonical))
                                    continue;
                                {
                                    const v = e.canonical.z - c.canonical.z
                                      , b = e.canonical.x - (e.canonical.x >> v << v)
                                      , P = e.canonical.y - (e.canonical.y >> v << v)
                                      , M = o.$ >> v;
                                    o.bX(m, 0, o.$, o.$, 0, 0, 1),
                                    o.M(m, m, [b * M, P * M, 0]),
                                    o.N(m, m, [1 / 2 ** v, 1 / 2 ** v, 0])
                                }
                            }
                            d.terrainRttPosMatrix32f = new Float32Array(m),
                            r[s] = d
                        }
                        return r
                    }
                    _getTerrainCoordsForTileRanges(e, r) {
                        const s = {};
                        for (const c of this._renderableTilesKeys) {
                            const d = this._tiles[c].tileID;
                            if (!this._isWithinTileRanges(d, r))
                                continue;
                            const m = e.clone()
                              , v = o.b9();
                            if (d.canonical.z === e.canonical.z) {
                                const b = e.canonical.x - d.canonical.x
                                  , P = e.canonical.y - d.canonical.y;
                                o.bX(v, 0, o.$, o.$, 0, 0, 1),
                                o.M(v, v, [b * o.$, P * o.$, 0])
                            } else if (d.canonical.z > e.canonical.z) {
                                const b = d.canonical.z - e.canonical.z
                                  , P = d.canonical.x - (d.canonical.x >> b << b)
                                  , M = d.canonical.y - (d.canonical.y >> b << b)
                                  , D = e.canonical.x - (d.canonical.x >> b)
                                  , L = e.canonical.y - (d.canonical.y >> b)
                                  , B = o.$ >> b;
                                o.bX(v, 0, B, B, 0, 0, 1),
                                o.M(v, v, [-P * B + D * o.$, -M * B + L * o.$, 0])
                            } else {
                                const b = e.canonical.z - d.canonical.z
                                  , P = e.canonical.x - (e.canonical.x >> b << b)
                                  , M = e.canonical.y - (e.canonical.y >> b << b)
                                  , D = (e.canonical.x >> b) - d.canonical.x
                                  , L = (e.canonical.y >> b) - d.canonical.y
                                  , B = o.$ << b;
                                o.bX(v, 0, B, B, 0, 0, 1),
                                o.M(v, v, [P * o.$ + D * B, M * o.$ + L * B, 0])
                            }
                            m.terrainRttPosMatrix32f = new Float32Array(v),
                            s[c] = m
                        }
                        return s
                    }
                    getSourceTile(e, r) {
                        const s = this.sourceCache._source;
                        let c = e.overscaledZ - this.deltaZoom;
                        if (c > s.maxzoom && (c = s.maxzoom),
                        c < s.minzoom)
                            return null;
                        this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(c).key);
                        let d = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
                        if ((!d || !d.dem) && r)
                            for (; c >= s.minzoom && (!d || !d.dem); )
                                d = this.sourceCache.getTileByID(e.scaledTo(c--).key);
                        return d
                    }
                    anyTilesAfterTime(e=Date.now()) {
                        return this._lastTilesetChange >= e
                    }
                    _isWithinTileRanges(e, r) {
                        return r[e.canonical.z] && e.canonical.x >= r[e.canonical.z].minTileX && e.canonical.x <= r[e.canonical.z].maxTileX && e.canonical.y >= r[e.canonical.z].minTileY && e.canonical.y <= r[e.canonical.z].maxTileY
                    }
                }
                class Ia {
                    constructor(e, r, s) {
                        this._meshCache = {},
                        this.painter = e,
                        this.sourceCache = new vp(r),
                        this.options = s,
                        this.exaggeration = typeof s.exaggeration == "number" ? s.exaggeration : 1,
                        this.qualityFactor = 2,
                        this.meshSize = 128,
                        this._demMatrixCache = {},
                        this.coordsIndex = [],
                        this._coordsTextureSize = 1024
                    }
                    getDEMElevation(e, r, s, c=o.$) {
                        var d;
                        if (!(r >= 0 && r < c && s >= 0 && s < c))
                            return 0;
                        const m = this.getTerrainData(e)
                          , v = (d = m.tile) === null || d === void 0 ? void 0 : d.dem;
                        if (!v)
                            return 0;
                        const b = o.cr([], [r / c * o.$, s / c * o.$], m.u_terrain_matrix)
                          , P = [b[0] * v.dim, b[1] * v.dim]
                          , M = Math.floor(P[0])
                          , D = Math.floor(P[1])
                          , L = P[0] - M
                          , B = P[1] - D;
                        return v.get(M, D) * (1 - L) * (1 - B) + v.get(M + 1, D) * L * (1 - B) + v.get(M, D + 1) * (1 - L) * B + v.get(M + 1, D + 1) * L * B
                    }
                    getElevationForLngLatZoom(e, r) {
                        if (!o.cs(r, e.wrap()))
                            return 0;
                        const {tileID: s, mercatorX: c, mercatorY: d} = this._getOverscaledTileIDFromLngLatZoom(e, r);
                        return this.getElevation(s, c % o.$, d % o.$, o.$)
                    }
                    getElevation(e, r, s, c=o.$) {
                        return this.getDEMElevation(e, r, s, c) * this.exaggeration
                    }
                    getTerrainData(e) {
                        if (!this._emptyDemTexture) {
                            const c = this.painter.context
                              , d = new o.R({
                                width: 1,
                                height: 1
                            },new Uint8Array(4));
                            this._emptyDepthTexture = new o.T(c,d,c.gl.RGBA,{
                                premultiply: !1
                            }),
                            this._emptyDemUnpack = [0, 0, 0, 0],
                            this._emptyDemTexture = new o.T(c,new o.R({
                                width: 1,
                                height: 1
                            }),c.gl.RGBA,{
                                premultiply: !1
                            }),
                            this._emptyDemTexture.bind(c.gl.NEAREST, c.gl.CLAMP_TO_EDGE),
                            this._emptyDemMatrix = o.af([])
                        }
                        const r = this.sourceCache.getSourceTile(e, !0);
                        if (r && r.dem && (!r.demTexture || r.needsTerrainPrepare)) {
                            const c = this.painter.context;
                            r.demTexture = this.painter.getTileTexture(r.dem.stride),
                            r.demTexture ? r.demTexture.update(r.dem.getPixels(), {
                                premultiply: !1
                            }) : r.demTexture = new o.T(c,r.dem.getPixels(),c.gl.RGBA,{
                                premultiply: !1
                            }),
                            r.demTexture.bind(c.gl.NEAREST, c.gl.CLAMP_TO_EDGE),
                            r.needsTerrainPrepare = !1
                        }
                        const s = r && r + r.tileID.key + e.key;
                        if (s && !this._demMatrixCache[s]) {
                            const c = this.sourceCache.sourceCache._source.maxzoom;
                            let d = e.canonical.z - r.tileID.canonical.z;
                            e.overscaledZ > e.canonical.z && (e.canonical.z >= c ? d = e.canonical.z - c : o.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
                            const m = e.canonical.x - (e.canonical.x >> d << d)
                              , v = e.canonical.y - (e.canonical.y >> d << d)
                              , b = o.ct(new Float64Array(16), [1 / (o.$ << d), 1 / (o.$ << d), 0]);
                            o.M(b, b, [m * o.$, v * o.$, 0]),
                            this._demMatrixCache[e.key] = {
                                matrix: b,
                                coord: e
                            }
                        }
                        return {
                            u_depth: 2,
                            u_terrain: 3,
                            u_terrain_dim: r && r.dem && r.dem.dim || 1,
                            u_terrain_matrix: s ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix,
                            u_terrain_unpack: r && r.dem && r.dem.getUnpackVector() || this._emptyDemUnpack,
                            u_terrain_exaggeration: this.exaggeration,
                            texture: (r && r.demTexture || this._emptyDemTexture).texture,
                            depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
                            tile: r
                        }
                    }
                    getFramebuffer(e) {
                        const r = this.painter
                          , s = r.width / devicePixelRatio
                          , c = r.height / devicePixelRatio;
                        return !this._fbo || this._fbo.width === s && this._fbo.height === c || (this._fbo.destroy(),
                        this._fboCoordsTexture.destroy(),
                        this._fboDepthTexture.destroy(),
                        delete this._fbo,
                        delete this._fboDepthTexture,
                        delete this._fboCoordsTexture),
                        this._fboCoordsTexture || (this._fboCoordsTexture = new o.T(r.context,{
                            width: s,
                            height: c,
                            data: null
                        },r.context.gl.RGBA,{
                            premultiply: !1
                        }),
                        this._fboCoordsTexture.bind(r.context.gl.NEAREST, r.context.gl.CLAMP_TO_EDGE)),
                        this._fboDepthTexture || (this._fboDepthTexture = new o.T(r.context,{
                            width: s,
                            height: c,
                            data: null
                        },r.context.gl.RGBA,{
                            premultiply: !1
                        }),
                        this._fboDepthTexture.bind(r.context.gl.NEAREST, r.context.gl.CLAMP_TO_EDGE)),
                        this._fbo || (this._fbo = r.context.createFramebuffer(s, c, !0, !1),
                        this._fbo.depthAttachment.set(r.context.createRenderbuffer(r.context.gl.DEPTH_COMPONENT16, s, c))),
                        this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture),
                        this._fbo
                    }
                    getCoordsTexture() {
                        const e = this.painter.context;
                        if (this._coordsTexture)
                            return this._coordsTexture;
                        const r = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
                        for (let d = 0, m = 0; d < this._coordsTextureSize; d++)
                            for (let v = 0; v < this._coordsTextureSize; v++,
                            m += 4)
                                r[m + 0] = 255 & v,
                                r[m + 1] = 255 & d,
                                r[m + 2] = v >> 8 << 4 | d >> 8,
                                r[m + 3] = 0;
                        const s = new o.R({
                            width: this._coordsTextureSize,
                            height: this._coordsTextureSize
                        },new Uint8Array(r.buffer))
                          , c = new o.T(e,s,e.gl.RGBA,{
                            premultiply: !1
                        });
                        return c.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE),
                        this._coordsTexture = c,
                        c
                    }
                    pointCoordinate(e) {
                        this.painter.maybeDrawDepthAndCoords(!0);
                        const r = new Uint8Array(4)
                          , s = this.painter.context
                          , c = s.gl
                          , d = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio)
                          , m = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio)
                          , v = Math.round(this.painter.height / devicePixelRatio);
                        s.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer),
                        c.readPixels(d, v - m - 1, 1, 1, c.RGBA, c.UNSIGNED_BYTE, r),
                        s.bindFramebuffer.set(null);
                        const b = r[0] + (r[2] >> 4 << 8)
                          , P = r[1] + ((15 & r[2]) << 8)
                          , M = this.coordsIndex[255 - r[3]]
                          , D = M && this.sourceCache.getTileByID(M);
                        if (!D)
                            return null;
                        const L = this._coordsTextureSize
                          , B = (1 << D.tileID.canonical.z) * L;
                        return new o.a0((D.tileID.canonical.x * L + b) / B + D.tileID.wrap,(D.tileID.canonical.y * L + P) / B,this.getElevation(D.tileID, b, P, L))
                    }
                    depthAtPoint(e) {
                        const r = new Uint8Array(4)
                          , s = this.painter.context
                          , c = s.gl;
                        return s.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer),
                        c.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, c.RGBA, c.UNSIGNED_BYTE, r),
                        s.bindFramebuffer.set(null),
                        (r[0] / 16777216 + r[1] / 65536 + r[2] / 256 + r[3]) / 256
                    }
                    getTerrainMesh(e) {
                        var r;
                        const s = ((r = this.painter.style.projection) === null || r === void 0 ? void 0 : r.transitionState) > 0
                          , c = s && e.canonical.y === 0
                          , d = s && e.canonical.y === (1 << e.canonical.z) - 1
                          , m = `m_${c ? "n" : ""}_${d ? "s" : ""}`;
                        if (this._meshCache[m])
                            return this._meshCache[m];
                        const v = this.painter.context
                          , b = new o.cu
                          , P = new o.aM
                          , M = this.meshSize
                          , D = o.$ / M
                          , L = M * M;
                        for (let pe = 0; pe <= M; pe++)
                            for (let Fe = 0; Fe <= M; Fe++)
                                b.emplaceBack(Fe * D, pe * D, 0);
                        for (let pe = 0; pe < L; pe += M + 1)
                            for (let Fe = 0; Fe < M; Fe++)
                                P.emplaceBack(Fe + pe, M + Fe + pe + 1, M + Fe + pe + 2),
                                P.emplaceBack(Fe + pe, M + Fe + pe + 2, Fe + pe + 1);
                        const B = b.length
                          , Z = B + (M + 1)
                          , te = (M + 1) * M
                          , ee = c ? o.bg : 0
                          , ne = c ? 0 : 1
                          , oe = d ? o.bh : o.$
                          , me = d ? 0 : 1;
                        for (let pe = 0; pe <= M; pe++)
                            b.emplaceBack(pe * D, ee, ne);
                        for (let pe = 0; pe <= M; pe++)
                            b.emplaceBack(pe * D, oe, me);
                        for (let pe = 0; pe < M; pe++)
                            P.emplaceBack(te + pe, Z + pe, Z + pe + 1),
                            P.emplaceBack(te + pe, Z + pe + 1, te + pe + 1),
                            P.emplaceBack(0 + pe, B + pe + 1, B + pe),
                            P.emplaceBack(0 + pe, 0 + pe + 1, B + pe + 1);
                        const ce = b.length
                          , Te = ce + 2 * (M + 1);
                        for (const pe of [0, 1])
                            for (let Fe = 0; Fe <= M; Fe++)
                                for (const Ye of [0, 1])
                                    b.emplaceBack(pe * o.$, Fe * D, Ye);
                        for (let pe = 0; pe < 2 * M; pe += 2)
                            P.emplaceBack(ce + pe, ce + pe + 1, ce + pe + 3),
                            P.emplaceBack(ce + pe, ce + pe + 3, ce + pe + 2),
                            P.emplaceBack(Te + pe, Te + pe + 3, Te + pe + 1),
                            P.emplaceBack(Te + pe, Te + pe + 2, Te + pe + 3);
                        const Pe = new Qn(v.createVertexBuffer(b, Jh.members),v.createIndexBuffer(P),o.aL.simpleSegment(0, 0, b.length, P.length));
                        return this._meshCache[m] = Pe,
                        Pe
                    }
                    getMeshFrameDelta(e) {
                        return 2 * Math.PI * o.bt / Math.pow(2, Math.max(e, 0)) / 5
                    }
                    getMinTileElevationForLngLatZoom(e, r) {
                        var s;
                        const {tileID: c} = this._getOverscaledTileIDFromLngLatZoom(e, r);
                        return (s = this.getMinMaxElevation(c).minElevation) !== null && s !== void 0 ? s : 0
                    }
                    getMinMaxElevation(e) {
                        const r = this.getTerrainData(e).tile
                          , s = {
                            minElevation: null,
                            maxElevation: null
                        };
                        return r && r.dem && (s.minElevation = r.dem.min * this.exaggeration,
                        s.maxElevation = r.dem.max * this.exaggeration),
                        s
                    }
                    _getOverscaledTileIDFromLngLatZoom(e, r) {
                        const s = o.a0.fromLngLat(e.wrap())
                          , c = (1 << r) * o.$
                          , d = s.x * c
                          , m = s.y * c
                          , v = Math.floor(d / o.$)
                          , b = Math.floor(m / o.$);
                        return {
                            tileID: new o.Z(r,0,r,v,b),
                            mercatorX: d,
                            mercatorY: m
                        }
                    }
                }
                class Al {
                    constructor(e, r, s) {
                        this._context = e,
                        this._size = r,
                        this._tileSize = s,
                        this._objects = [],
                        this._recentlyUsed = [],
                        this._stamp = 0
                    }
                    destruct() {
                        for (const e of this._objects)
                            e.texture.destroy(),
                            e.fbo.destroy()
                    }
                    _createObject(e) {
                        const r = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0)
                          , s = new o.T(this._context,{
                            width: this._tileSize,
                            height: this._tileSize,
                            data: null
                        },this._context.gl.RGBA);
                        return s.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE),
                        this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax),
                        r.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)),
                        r.colorAttachment.set(s.texture),
                        {
                            id: e,
                            fbo: r,
                            texture: s,
                            stamp: -1,
                            inUse: !1
                        }
                    }
                    getObjectForId(e) {
                        return this._objects[e]
                    }
                    useObject(e) {
                        e.inUse = !0,
                        this._recentlyUsed = this._recentlyUsed.filter(r => e.id !== r),
                        this._recentlyUsed.push(e.id)
                    }
                    stampObject(e) {
                        e.stamp = ++this._stamp
                    }
                    getOrCreateFreeObject() {
                        for (const r of this._recentlyUsed)
                            if (!this._objects[r].inUse)
                                return this._objects[r];
                        if (this._objects.length >= this._size)
                            throw new Error("No free RenderPool available, call freeAllObjects() required!");
                        const e = this._createObject(this._objects.length);
                        return this._objects.push(e),
                        e
                    }
                    freeObject(e) {
                        e.inUse = !1
                    }
                    freeAllObjects() {
                        for (const e of this._objects)
                            this.freeObject(e)
                    }
                    isFull() {
                        return !(this._objects.length < this._size) && this._objects.some(e => !e.inUse) === !1
                    }
                }
                const ar = {
                    background: !0,
                    fill: !0,
                    line: !0,
                    raster: !0,
                    hillshade: !0,
                    "color-relief": !0
                };
                class Rr {
                    constructor(e, r) {
                        this.painter = e,
                        this.terrain = r,
                        this.pool = new Al(e.context,30,r.sourceCache.tileSize * r.qualityFactor)
                    }
                    destruct() {
                        this.pool.destruct()
                    }
                    getTexture(e) {
                        return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture
                    }
                    prepareForRender(e, r) {
                        this._stacks = [],
                        this._prevType = null,
                        this._rttTiles = [],
                        this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(),
                        this._renderableLayerIds = e._order.filter(s => !e._layers[s].isHidden(r)),
                        this._coordsAscending = {};
                        for (const s in e.sourceCaches) {
                            this._coordsAscending[s] = {};
                            const c = e.sourceCaches[s].getVisibleCoordinates()
                              , d = e.sourceCaches[s].getSource()
                              , m = d instanceof tr ? d.terrainTileRanges : null;
                            for (const v of c) {
                                const b = this.terrain.sourceCache.getTerrainCoords(v, m);
                                for (const P in b)
                                    this._coordsAscending[s][P] || (this._coordsAscending[s][P] = []),
                                    this._coordsAscending[s][P].push(b[P])
                            }
                        }
                        this._coordsAscendingStr = {};
                        for (const s of e._order) {
                            const c = e._layers[s]
                              , d = c.source;
                            if (ar[c.type] && !this._coordsAscendingStr[d]) {
                                this._coordsAscendingStr[d] = {};
                                for (const m in this._coordsAscending[d])
                                    this._coordsAscendingStr[d][m] = this._coordsAscending[d][m].map(v => v.key).sort().join()
                            }
                        }
                        for (const s of this._renderableTiles)
                            for (const c in this._coordsAscendingStr) {
                                const d = this._coordsAscendingStr[c][s.tileID.key];
                                d && d !== s.rttCoords[c] && (s.rtt = [])
                            }
                    }
                    renderLayer(e, r) {
                        if (e.isHidden(this.painter.transform.zoom))
                            return !1;
                        const s = Object.assign(Object.assign({}, r), {
                            isRenderingToTexture: !0
                        })
                          , c = e.type
                          , d = this.painter
                          , m = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
                        if (ar[c] && (this._prevType && ar[this._prevType] || this._stacks.push([]),
                        this._prevType = c,
                        this._stacks[this._stacks.length - 1].push(e.id),
                        !m))
                            return !0;
                        if (ar[this._prevType] || ar[c] && m) {
                            this._prevType = c;
                            const v = this._stacks.length - 1
                              , b = this._stacks[v] || [];
                            for (const P of this._renderableTiles) {
                                if (this.pool.isFull() && (ji(this.painter, this.terrain, this._rttTiles, s),
                                this._rttTiles = [],
                                this.pool.freeAllObjects()),
                                this._rttTiles.push(P),
                                P.rtt[v]) {
                                    const D = this.pool.getObjectForId(P.rtt[v].id);
                                    if (D.stamp === P.rtt[v].stamp) {
                                        this.pool.useObject(D);
                                        continue
                                    }
                                }
                                const M = this.pool.getOrCreateFreeObject();
                                this.pool.useObject(M),
                                this.pool.stampObject(M),
                                P.rtt[v] = {
                                    id: M.id,
                                    stamp: M.stamp
                                },
                                d.context.bindFramebuffer.set(M.fbo.framebuffer),
                                d.context.clear({
                                    color: o.be.transparent,
                                    stencil: 0
                                }),
                                d.currentStencilSource = void 0;
                                for (let D = 0; D < b.length; D++) {
                                    const L = d.style._layers[b[D]]
                                      , B = L.source ? this._coordsAscending[L.source][P.tileID.key] : [P.tileID];
                                    d.context.viewport.set([0, 0, M.fbo.width, M.fbo.height]),
                                    d._renderTileClippingMasks(L, B, !0),
                                    d.renderLayer(d, d.style.sourceCaches[L.source], L, B, s),
                                    L.source && (P.rttCoords[L.source] = this._coordsAscendingStr[L.source][P.tileID.key])
                                }
                            }
                            return ji(this.painter, this.terrain, this._rttTiles, s),
                            this._rttTiles = [],
                            this.pool.freeAllObjects(),
                            ar[c]
                        }
                        return !1
                    }
                }
                const kl = {
                    "AttributionControl.ToggleAttribution": "Toggle attribution",
                    "AttributionControl.MapFeedback": "Map feedback",
                    "FullscreenControl.Enter": "Enter fullscreen",
                    "FullscreenControl.Exit": "Exit fullscreen",
                    "GeolocateControl.FindMyLocation": "Find my location",
                    "GeolocateControl.LocationNotAvailable": "Location not available",
                    "LogoControl.Title": "MapLibre logo",
                    "Map.Title": "Map",
                    "Marker.Title": "Map marker",
                    "NavigationControl.ResetBearing": "Reset bearing to north",
                    "NavigationControl.ZoomIn": "Zoom in",
                    "NavigationControl.ZoomOut": "Zoom out",
                    "Popup.Close": "Close popup",
                    "ScaleControl.Feet": "ft",
                    "ScaleControl.Meters": "m",
                    "ScaleControl.Kilometers": "km",
                    "ScaleControl.Miles": "mi",
                    "ScaleControl.NauticalMiles": "nm",
                    "GlobeControl.Enable": "Enable globe",
                    "GlobeControl.Disable": "Disable globe",
                    "TerrainControl.Enable": "Enable terrain",
                    "TerrainControl.Disable": "Disable terrain",
                    "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
                    "CooperativeGesturesHandler.MacHelpText": "Use âŒ˜ + scroll to zoom the map",
                    "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
                }
                  , Xc = W
                  , Ro = {
                    hash: !1,
                    interactive: !0,
                    bearingSnap: 7,
                    attributionControl: Do,
                    maplibreLogo: !1,
                    refreshExpiredTiles: !0,
                    canvasContextAttributes: {
                        antialias: !1,
                        preserveDrawingBuffer: !1,
                        powerPreference: "high-performance",
                        failIfMajorPerformanceCaveat: !1,
                        desynchronized: !1,
                        contextType: void 0
                    },
                    scrollZoom: !0,
                    minZoom: -2,
                    maxZoom: 22,
                    minPitch: 0,
                    maxPitch: 60,
                    boxZoom: !0,
                    dragRotate: !0,
                    dragPan: !0,
                    keyboard: !0,
                    doubleClickZoom: !0,
                    touchZoomRotate: !0,
                    touchPitch: !0,
                    cooperativeGestures: !1,
                    trackResize: !0,
                    center: [0, 0],
                    elevation: 0,
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    roll: 0,
                    renderWorldCopies: !0,
                    maxTileCacheSize: null,
                    maxTileCacheZoomLevels: o.a.MAX_TILE_CACHE_ZOOM_LEVELS,
                    transformRequest: null,
                    transformCameraUpdate: null,
                    fadeDuration: 300,
                    crossSourceCollisions: !0,
                    clickTolerance: 3,
                    localIdeographFontFamily: "sans-serif",
                    pitchWithRotate: !0,
                    rollEnabled: !1,
                    validateStyle: !0,
                    maxCanvasSize: [4096, 4096],
                    cancelPendingTileRequestsWhileZooming: !0,
                    centerClampedToGround: !0
                }
                  , Ln = {
                    showCompass: !0,
                    showZoom: !0,
                    visualizePitch: !1,
                    visualizeRoll: !0
                };
                class Qh {
                    constructor(e, r, s=!1) {
                        this.mousedown = d => {
                            this.startMove(d, X.mousePos(this.element, d)),
                            X.addEventListener(window, "mousemove", this.mousemove),
                            X.addEventListener(window, "mouseup", this.mouseup)
                        }
                        ,
                        this.mousemove = d => {
                            this.move(d, X.mousePos(this.element, d))
                        }
                        ,
                        this.mouseup = d => {
                            this._rotatePitchHanlder.dragEnd(d),
                            this.offTemp()
                        }
                        ,
                        this.touchstart = d => {
                            d.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = X.touchPos(this.element, d.targetTouches)[0],
                            this.startMove(d, this._startPos),
                            X.addEventListener(window, "touchmove", this.touchmove, {
                                passive: !1
                            }),
                            X.addEventListener(window, "touchend", this.touchend))
                        }
                        ,
                        this.touchmove = d => {
                            d.targetTouches.length !== 1 ? this.reset() : (this._lastPos = X.touchPos(this.element, d.targetTouches)[0],
                            this.move(d, this._lastPos))
                        }
                        ,
                        this.touchend = d => {
                            d.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(),
                            delete this._startPos,
                            delete this._lastPos,
                            this.offTemp()
                        }
                        ,
                        this.reset = () => {
                            this._rotatePitchHanlder.reset(),
                            delete this._startPos,
                            delete this._lastPos,
                            this.offTemp()
                        }
                        ,
                        this._clickTolerance = 10,
                        this.element = r;
                        const c = new pp;
                        this._rotatePitchHanlder = new Hs({
                            clickTolerance: 3,
                            move: (d, m) => {
                                const v = r.getBoundingClientRect()
                                  , b = new o.P((v.bottom - v.top) / 2,(v.right - v.left) / 2);
                                return {
                                    bearingDelta: o.cm(new o.P(d.x,m.y), m, b),
                                    pitchDelta: s ? -.5 * (m.y - d.y) : void 0
                                }
                            }
                            ,
                            moveStateManager: c,
                            enable: !0,
                            assignEvents: () => {}
                        }),
                        this.map = e,
                        X.addEventListener(r, "mousedown", this.mousedown),
                        X.addEventListener(r, "touchstart", this.touchstart, {
                            passive: !1
                        }),
                        X.addEventListener(r, "touchcancel", this.reset)
                    }
                    startMove(e, r) {
                        this._rotatePitchHanlder.dragStart(e, r),
                        X.disableDrag()
                    }
                    move(e, r) {
                        const s = this.map
                          , {bearingDelta: c, pitchDelta: d} = this._rotatePitchHanlder.dragMove(e, r) || {};
                        c && s.setBearing(s.getBearing() + c),
                        d && s.setPitch(s.getPitch() + d)
                    }
                    off() {
                        const e = this.element;
                        X.removeEventListener(e, "mousedown", this.mousedown),
                        X.removeEventListener(e, "touchstart", this.touchstart, {
                            passive: !1
                        }),
                        X.removeEventListener(window, "touchmove", this.touchmove, {
                            passive: !1
                        }),
                        X.removeEventListener(window, "touchend", this.touchend),
                        X.removeEventListener(e, "touchcancel", this.reset),
                        this.offTemp()
                    }
                    offTemp() {
                        X.enableDrag(),
                        X.removeEventListener(window, "mousemove", this.mousemove),
                        X.removeEventListener(window, "mouseup", this.mouseup),
                        X.removeEventListener(window, "touchmove", this.touchmove, {
                            passive: !1
                        }),
                        X.removeEventListener(window, "touchend", this.touchend)
                    }
                }
                let gn;
                function ed(h, e, r, s=!1) {
                    if (s || !r.getCoveringTilesDetailsProvider().allowWorldCopies())
                        return h == null ? void 0 : h.wrap();
                    const c = new o.S(h.lng,h.lat);
                    if (h = new o.S(h.lng,h.lat),
                    e) {
                        const d = new o.S(h.lng - 360,h.lat)
                          , m = new o.S(h.lng + 360,h.lat)
                          , v = r.locationToScreenPoint(h).distSqr(e);
                        r.locationToScreenPoint(d).distSqr(e) < v ? h = d : r.locationToScreenPoint(m).distSqr(e) < v && (h = m)
                    }
                    for (; Math.abs(h.lng - r.center.lng) > 180; ) {
                        const d = r.locationToScreenPoint(h);
                        if (d.x >= 0 && d.y >= 0 && d.x <= r.width && d.y <= r.height)
                            break;
                        h.lng > r.center.lng ? h.lng -= 360 : h.lng += 360
                    }
                    return h.lng !== c.lng && r.isPointOnMapSurface(r.locationToScreenPoint(h)) ? h : c
                }
                const ms = {
                    center: "translate(-50%,-50%)",
                    top: "translate(-50%,0)",
                    "top-left": "translate(0,0)",
                    "top-right": "translate(-100%,0)",
                    bottom: "translate(-50%,-100%)",
                    "bottom-left": "translate(0,-100%)",
                    "bottom-right": "translate(-100%,-100%)",
                    left: "translate(0,-50%)",
                    right: "translate(-100%,-50%)"
                };
                function Ri(h, e, r) {
                    const s = h.classList;
                    for (const c in ms)
                        s.remove(`maplibregl-${r}-anchor-${c}`);
                    s.add(`maplibregl-${r}-anchor-${e}`)
                }
                class qi extends o.E {
                    constructor(e) {
                        if (super(),
                        this._onKeyPress = r => {
                            const s = r.code
                              , c = r.charCode || r.keyCode;
                            s !== "Space" && s !== "Enter" && c !== 32 && c !== 13 || this.togglePopup()
                        }
                        ,
                        this._onMapClick = r => {
                            const s = r.originalEvent.target
                              , c = this._element;
                            this._popup && (s === c || c.contains(s)) && this.togglePopup()
                        }
                        ,
                        this._update = r => {
                            if (!this._map)
                                return;
                            const s = this._map.loaded() && !this._map.isMoving();
                            ((r == null ? void 0 : r.type) === "terrain" || (r == null ? void 0 : r.type) === "render" && !s) && this._map.once("render", this._update),
                            this._lngLat = ed(this._lngLat, this._flatPos, this._map.transform),
                            this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset),
                            this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                            let c = "";
                            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? c = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (c = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
                            let d = "";
                            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? d = "rotateX(0deg)" : this._pitchAlignment === "map" && (d = `rotateX(${this._map.getPitch()}deg)`),
                            this._subpixelPositioning || r && r.type !== "moveend" || (this._pos = this._pos.round()),
                            X.setTransform(this._element, `${ms[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${d} ${c}`),
                            he.frameAsync(new AbortController).then( () => {
                                this._updateOpacity(r && r.type === "moveend")
                            }
                            ).catch( () => {}
                            )
                        }
                        ,
                        this._onMove = r => {
                            if (!this._isDragging) {
                                const s = this._clickTolerance || this._map._clickTolerance;
                                this._isDragging = r.point.dist(this._pointerdownPos) >= s
                            }
                            this._isDragging && (this._pos = r.point.sub(this._positionDelta),
                            this._lngLat = this._map.unproject(this._pos),
                            this.setLngLat(this._lngLat),
                            this._element.style.pointerEvents = "none",
                            this._state === "pending" && (this._state = "active",
                            this.fire(new o.l("dragstart"))),
                            this.fire(new o.l("drag")))
                        }
                        ,
                        this._onUp = () => {
                            this._element.style.pointerEvents = "auto",
                            this._positionDelta = null,
                            this._pointerdownPos = null,
                            this._isDragging = !1,
                            this._map.off("mousemove", this._onMove),
                            this._map.off("touchmove", this._onMove),
                            this._state === "active" && this.fire(new o.l("dragend")),
                            this._state = "inactive"
                        }
                        ,
                        this._addDragHandler = r => {
                            this._element.contains(r.originalEvent.target) && (r.preventDefault(),
                            this._positionDelta = r.point.sub(this._pos).add(this._offset),
                            this._pointerdownPos = r.point,
                            this._state = "pending",
                            this._map.on("mousemove", this._onMove),
                            this._map.on("touchmove", this._onMove),
                            this._map.once("mouseup", this._onUp),
                            this._map.once("touchend", this._onUp))
                        }
                        ,
                        this._anchor = e && e.anchor || "center",
                        this._color = e && e.color || "#3FB1CE",
                        this._scale = e && e.scale || 1,
                        this._draggable = e && e.draggable || !1,
                        this._clickTolerance = e && e.clickTolerance || 0,
                        this._subpixelPositioning = e && e.subpixelPositioning || !1,
                        this._isDragging = !1,
                        this._state = "inactive",
                        this._rotation = e && e.rotation || 0,
                        this._rotationAlignment = e && e.rotationAlignment || "auto",
                        this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment,
                        this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered),
                        e && e.element)
                            this._element = e.element,
                            this._offset = o.P.convert(e && e.offset || [0, 0]);
                        else {
                            this._defaultMarker = !0,
                            this._element = X.create("div");
                            const r = X.createNS("http://www.w3.org/2000/svg", "svg")
                              , s = 41
                              , c = 27;
                            r.setAttributeNS(null, "display", "block"),
                            r.setAttributeNS(null, "height", `${s}px`),
                            r.setAttributeNS(null, "width", `${c}px`),
                            r.setAttributeNS(null, "viewBox", `0 0 ${c} ${s}`);
                            const d = X.createNS("http://www.w3.org/2000/svg", "g");
                            d.setAttributeNS(null, "stroke", "none"),
                            d.setAttributeNS(null, "stroke-width", "1"),
                            d.setAttributeNS(null, "fill", "none"),
                            d.setAttributeNS(null, "fill-rule", "evenodd");
                            const m = X.createNS("http://www.w3.org/2000/svg", "g");
                            m.setAttributeNS(null, "fill-rule", "nonzero");
                            const v = X.createNS("http://www.w3.org/2000/svg", "g");
                            v.setAttributeNS(null, "transform", "translate(3.0, 29.0)"),
                            v.setAttributeNS(null, "fill", "#000000");
                            const b = [{
                                rx: "10.5",
                                ry: "5.25002273"
                            }, {
                                rx: "10.5",
                                ry: "5.25002273"
                            }, {
                                rx: "9.5",
                                ry: "4.77275007"
                            }, {
                                rx: "8.5",
                                ry: "4.29549936"
                            }, {
                                rx: "7.5",
                                ry: "3.81822308"
                            }, {
                                rx: "6.5",
                                ry: "3.34094679"
                            }, {
                                rx: "5.5",
                                ry: "2.86367051"
                            }, {
                                rx: "4.5",
                                ry: "2.38636864"
                            }];
                            for (const ne of b) {
                                const oe = X.createNS("http://www.w3.org/2000/svg", "ellipse");
                                oe.setAttributeNS(null, "opacity", "0.04"),
                                oe.setAttributeNS(null, "cx", "10.5"),
                                oe.setAttributeNS(null, "cy", "5.80029008"),
                                oe.setAttributeNS(null, "rx", ne.rx),
                                oe.setAttributeNS(null, "ry", ne.ry),
                                v.appendChild(oe)
                            }
                            const P = X.createNS("http://www.w3.org/2000/svg", "g");
                            P.setAttributeNS(null, "fill", this._color);
                            const M = X.createNS("http://www.w3.org/2000/svg", "path");
                            M.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"),
                            P.appendChild(M);
                            const D = X.createNS("http://www.w3.org/2000/svg", "g");
                            D.setAttributeNS(null, "opacity", "0.25"),
                            D.setAttributeNS(null, "fill", "#000000");
                            const L = X.createNS("http://www.w3.org/2000/svg", "path");
                            L.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"),
                            D.appendChild(L);
                            const B = X.createNS("http://www.w3.org/2000/svg", "g");
                            B.setAttributeNS(null, "transform", "translate(6.0, 7.0)"),
                            B.setAttributeNS(null, "fill", "#FFFFFF");
                            const Z = X.createNS("http://www.w3.org/2000/svg", "g");
                            Z.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
                            const te = X.createNS("http://www.w3.org/2000/svg", "circle");
                            te.setAttributeNS(null, "fill", "#000000"),
                            te.setAttributeNS(null, "opacity", "0.25"),
                            te.setAttributeNS(null, "cx", "5.5"),
                            te.setAttributeNS(null, "cy", "5.5"),
                            te.setAttributeNS(null, "r", "5.4999962");
                            const ee = X.createNS("http://www.w3.org/2000/svg", "circle");
                            ee.setAttributeNS(null, "fill", "#FFFFFF"),
                            ee.setAttributeNS(null, "cx", "5.5"),
                            ee.setAttributeNS(null, "cy", "5.5"),
                            ee.setAttributeNS(null, "r", "5.4999962"),
                            Z.appendChild(te),
                            Z.appendChild(ee),
                            m.appendChild(v),
                            m.appendChild(P),
                            m.appendChild(D),
                            m.appendChild(B),
                            m.appendChild(Z),
                            r.appendChild(m),
                            r.setAttributeNS(null, "height", s * this._scale + "px"),
                            r.setAttributeNS(null, "width", c * this._scale + "px"),
                            this._element.appendChild(r),
                            this._offset = o.P.convert(e && e.offset || [0, -14])
                        }
                        if (this._element.classList.add("maplibregl-marker"),
                        this._element.addEventListener("dragstart", r => {
                            r.preventDefault()
                        }
                        ),
                        this._element.addEventListener("mousedown", r => {
                            r.preventDefault()
                        }
                        ),
                        Ri(this._element, this._anchor, "marker"),
                        e && e.className)
                            for (const r of e.className.split(" "))
                                this._element.classList.add(r);
                        this._popup = null
                    }
                    addTo(e) {
                        return this.remove(),
                        this._map = e,
                        this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")),
                        e.getCanvasContainer().appendChild(this._element),
                        e.on("move", this._update),
                        e.on("moveend", this._update),
                        e.on("terrain", this._update),
                        e.on("projectiontransition", this._update),
                        this.setDraggable(this._draggable),
                        this._update(),
                        this._map.on("click", this._onMapClick),
                        this
                    }
                    remove() {
                        return this._opacityTimeout && (clearTimeout(this._opacityTimeout),
                        delete this._opacityTimeout),
                        this._map && (this._map.off("click", this._onMapClick),
                        this._map.off("move", this._update),
                        this._map.off("moveend", this._update),
                        this._map.off("terrain", this._update),
                        this._map.off("projectiontransition", this._update),
                        this._map.off("mousedown", this._addDragHandler),
                        this._map.off("touchstart", this._addDragHandler),
                        this._map.off("mouseup", this._onUp),
                        this._map.off("touchend", this._onUp),
                        this._map.off("mousemove", this._onMove),
                        this._map.off("touchmove", this._onMove),
                        delete this._map),
                        X.remove(this._element),
                        this._popup && this._popup.remove(),
                        this
                    }
                    getLngLat() {
                        return this._lngLat
                    }
                    setLngLat(e) {
                        return this._lngLat = o.S.convert(e),
                        this._pos = null,
                        this._popup && this._popup.setLngLat(this._lngLat),
                        this._update(),
                        this
                    }
                    getElement() {
                        return this._element
                    }
                    setPopup(e) {
                        if (this._popup && (this._popup.remove(),
                        this._popup = null,
                        this._element.removeEventListener("keypress", this._onKeyPress),
                        this._originalTabIndex || this._element.removeAttribute("tabindex")),
                        e) {
                            if (!("offset"in e.options)) {
                                const c = Math.abs(13.5) / Math.SQRT2;
                                e.options.offset = this._defaultMarker ? {
                                    top: [0, 0],
                                    "top-left": [0, 0],
                                    "top-right": [0, 0],
                                    bottom: [0, -38.1],
                                    "bottom-left": [c, -1 * (38.1 - 13.5 + c)],
                                    "bottom-right": [-c, -1 * (38.1 - 13.5 + c)],
                                    left: [13.5, -1 * (38.1 - 13.5)],
                                    right: [-13.5, -1 * (38.1 - 13.5)]
                                } : this._offset
                            }
                            this._popup = e,
                            this._originalTabIndex = this._element.getAttribute("tabindex"),
                            this._originalTabIndex || this._element.setAttribute("tabindex", "0"),
                            this._element.addEventListener("keypress", this._onKeyPress)
                        }
                        return this
                    }
                    setSubpixelPositioning(e) {
                        return this._subpixelPositioning = e,
                        this
                    }
                    getPopup() {
                        return this._popup
                    }
                    togglePopup() {
                        const e = this._popup;
                        return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat),
                        e.addTo(this._map)),
                        this) : this
                    }
                    _updateOpacity(e=!1) {
                        var r, s;
                        const c = (r = this._map) === null || r === void 0 ? void 0 : r.terrain
                          , d = this._map.transform.isLocationOccluded(this._lngLat);
                        if (!c || d) {
                            const B = d ? this._opacityWhenCovered : this._opacity;
                            return void (this._element.style.opacity !== B && (this._element.style.opacity = B))
                        }
                        if (e)
                            this._opacityTimeout = null;
                        else {
                            if (this._opacityTimeout)
                                return;
                            this._opacityTimeout = setTimeout( () => {
                                this._opacityTimeout = null
                            }
                            , 100)
                        }
                        const m = this._map
                          , v = m.terrain.depthAtPoint(this._pos)
                          , b = m.terrain.getElevationForLngLatZoom(this._lngLat, m.transform.tileZoom);
                        if (m.transform.lngLatToCameraDepth(this._lngLat, b) - v < .006)
                            return void (this._element.style.opacity = this._opacity);
                        const P = -this._offset.y / m.transform.pixelsPerMeter
                          , M = Math.sin(m.getPitch() * Math.PI / 180) * P
                          , D = m.terrain.depthAtPoint(new o.P(this._pos.x,this._pos.y - this._offset.y))
                          , L = m.transform.lngLatToCameraDepth(this._lngLat, b + M) - D > .006;
                        !((s = this._popup) === null || s === void 0) && s.isOpen() && L && this._popup.remove(),
                        this._element.style.opacity = L ? this._opacityWhenCovered : this._opacity
                    }
                    getOffset() {
                        return this._offset
                    }
                    setOffset(e) {
                        return this._offset = o.P.convert(e),
                        this._update(),
                        this
                    }
                    addClassName(e) {
                        this._element.classList.add(e)
                    }
                    removeClassName(e) {
                        this._element.classList.remove(e)
                    }
                    toggleClassName(e) {
                        return this._element.classList.toggle(e)
                    }
                    setDraggable(e) {
                        return this._draggable = !!e,
                        this._map && (e ? (this._map.on("mousedown", this._addDragHandler),
                        this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler),
                        this._map.off("touchstart", this._addDragHandler))),
                        this
                    }
                    isDraggable() {
                        return this._draggable
                    }
                    setRotation(e) {
                        return this._rotation = e || 0,
                        this._update(),
                        this
                    }
                    getRotation() {
                        return this._rotation
                    }
                    setRotationAlignment(e) {
                        return this._rotationAlignment = e || "auto",
                        this._update(),
                        this
                    }
                    getRotationAlignment() {
                        return this._rotationAlignment
                    }
                    setPitchAlignment(e) {
                        return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment,
                        this._update(),
                        this
                    }
                    getPitchAlignment() {
                        return this._pitchAlignment
                    }
                    setOpacity(e, r) {
                        return (this._opacity === void 0 || e === void 0 && r === void 0) && (this._opacity = "1",
                        this._opacityWhenCovered = "0.2"),
                        e !== void 0 && (this._opacity = e),
                        r !== void 0 && (this._opacityWhenCovered = r),
                        this._map && this._updateOpacity(!0),
                        this
                    }
                }
                const td = {
                    positionOptions: {
                        enableHighAccuracy: !1,
                        maximumAge: 0,
                        timeout: 6e3
                    },
                    fitBoundsOptions: {
                        maxZoom: 15
                    },
                    trackUserLocation: !1,
                    showAccuracyCircle: !0,
                    showUserLocation: !0
                };
                let Ka = 0
                  , Ya = !1;
                const Kc = {
                    maxWidth: 100,
                    unit: "metric"
                };
                function El(h, e, r) {
                    const s = r && r.maxWidth || 100
                      , c = h._container.clientHeight / 2
                      , d = h._container.clientWidth / 2
                      , m = h.unproject([d - s / 2, c])
                      , v = h.unproject([d + s / 2, c])
                      , b = Math.round(h.project(v).x - h.project(m).x)
                      , P = Math.min(s, b, h._container.clientWidth)
                      , M = m.distanceTo(v);
                    if (r && r.unit === "imperial") {
                        const D = 3.2808 * M;
                        D > 5280 ? _s(e, P, D / 5280, h._getUIString("ScaleControl.Miles")) : _s(e, P, D, h._getUIString("ScaleControl.Feet"))
                    } else
                        r && r.unit === "nautical" ? _s(e, P, M / 1852, h._getUIString("ScaleControl.NauticalMiles")) : M >= 1e3 ? _s(e, P, M / 1e3, h._getUIString("ScaleControl.Kilometers")) : _s(e, P, M, h._getUIString("ScaleControl.Meters"))
                }
                function _s(h, e, r, s) {
                    const c = function(d) {
                        const m = Math.pow(10, `${Math.floor(d)}`.length - 1);
                        let v = d / m;
                        return v = v >= 10 ? 10 : v >= 5 ? 5 : v >= 3 ? 3 : v >= 2 ? 2 : v >= 1 ? 1 : function(b) {
                            const P = Math.pow(10, Math.ceil(-Math.log(b) / Math.LN10));
                            return Math.round(b * P) / P
                        }(v),
                        m * v
                    }(r);
                    h.style.width = e * (c / r) + "px",
                    h.innerHTML = `${c}&nbsp;${s}`
                }
                const Bo = {
                    closeButton: !0,
                    closeOnClick: !0,
                    focusAfterOpen: !0,
                    className: "",
                    maxWidth: "240px",
                    subpixelPositioning: !1,
                    locationOccludedOpacity: void 0
                }
                  , Yc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
                function zl(h) {
                    if (h) {
                        if (typeof h == "number") {
                            const e = Math.round(Math.abs(h) / Math.SQRT2);
                            return {
                                center: new o.P(0,0),
                                top: new o.P(0,h),
                                "top-left": new o.P(e,e),
                                "top-right": new o.P(-e,e),
                                bottom: new o.P(0,-h),
                                "bottom-left": new o.P(e,-e),
                                "bottom-right": new o.P(-e,-e),
                                left: new o.P(h,0),
                                right: new o.P(-h,0)
                            }
                        }
                        if (h instanceof o.P || Array.isArray(h)) {
                            const e = o.P.convert(h);
                            return {
                                center: e,
                                top: e,
                                "top-left": e,
                                "top-right": e,
                                bottom: e,
                                "bottom-left": e,
                                "bottom-right": e,
                                left: e,
                                right: e
                            }
                        }
                        return {
                            center: o.P.convert(h.center || [0, 0]),
                            top: o.P.convert(h.top || [0, 0]),
                            "top-left": o.P.convert(h["top-left"] || [0, 0]),
                            "top-right": o.P.convert(h["top-right"] || [0, 0]),
                            bottom: o.P.convert(h.bottom || [0, 0]),
                            "bottom-left": o.P.convert(h["bottom-left"] || [0, 0]),
                            "bottom-right": o.P.convert(h["bottom-right"] || [0, 0]),
                            left: o.P.convert(h.left || [0, 0]),
                            right: o.P.convert(h.right || [0, 0])
                        }
                    }
                    return zl(new o.P(0,0))
                }
                const Jc = W;
                C.AJAXError = o.cy,
                C.Event = o.l,
                C.Evented = o.E,
                C.LngLat = o.S,
                C.MercatorCoordinate = o.a0,
                C.Point = o.P,
                C.addProtocol = o.cz,
                C.config = o.a,
                C.removeProtocol = o.cA,
                C.AttributionControl = Ml,
                C.BoxZoomHandler = Nc,
                C.CanvasSource = zr,
                C.CooperativeGesturesHandler = Kh,
                C.DoubleClickZoomHandler = Pl,
                C.DragPanHandler = Uc,
                C.DragRotateHandler = Il,
                C.EdgeInsets = jn,
                C.FullscreenControl = class extends o.E {
                    constructor(h={}) {
                        super(),
                        this._onFullscreenChange = () => {
                            var e;
                            let r = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
                            for (; !((e = r == null ? void 0 : r.shadowRoot) === null || e === void 0) && e.fullscreenElement; )
                                r = r.shadowRoot.fullscreenElement;
                            r === this._container !== this._fullscreen && this._handleFullscreenChange()
                        }
                        ,
                        this._onClickFullscreen = () => {
                            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen()
                        }
                        ,
                        this._fullscreen = !1,
                        h && h.container && (h.container instanceof HTMLElement ? this._container = h.container : o.w("Full screen control 'container' must be a DOM element.")),
                        "onfullscreenchange"in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange"in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange"in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange"in document && (this._fullscreenchange = "MSFullscreenChange")
                    }
                    onAdd(h) {
                        return this._map = h,
                        this._container || (this._container = this._map.getContainer()),
                        this._controlContainer = X.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._setupUI(),
                        this._controlContainer
                    }
                    onRemove() {
                        X.remove(this._controlContainer),
                        this._map = null,
                        window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange)
                    }
                    _setupUI() {
                        const h = this._fullscreenButton = X.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
                        X.create("span", "maplibregl-ctrl-icon", h).setAttribute("aria-hidden", "true"),
                        h.type = "button",
                        this._updateTitle(),
                        this._fullscreenButton.addEventListener("click", this._onClickFullscreen),
                        window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange)
                    }
                    _updateTitle() {
                        const h = this._getTitle();
                        this._fullscreenButton.setAttribute("aria-label", h),
                        this._fullscreenButton.title = h
                    }
                    _getTitle() {
                        return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
                    }
                    _isFullscreen() {
                        return this._fullscreen
                    }
                    _handleFullscreenChange() {
                        this._fullscreen = !this._fullscreen,
                        this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"),
                        this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"),
                        this._updateTitle(),
                        this._fullscreen ? (this.fire(new o.l("fullscreenstart")),
                        this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(),
                        this._map.cooperativeGestures.disable()) : (this.fire(new o.l("fullscreenend")),
                        this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable())
                    }
                    _exitFullscreen() {
                        window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen()
                    }
                    _requestFullscreen() {
                        this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen()
                    }
                    _togglePseudoFullScreen() {
                        this._container.classList.toggle("maplibregl-pseudo-fullscreen"),
                        this._handleFullscreenChange(),
                        this._map.resize()
                    }
                }
                ,
                C.GeoJSONSource = $t,
                C.GeolocateControl = class extends o.E {
                    constructor(h) {
                        super(),
                        this._onSuccess = e => {
                            if (this._map) {
                                if (this._isOutOfMapMaxBounds(e))
                                    return this._setErrorState(),
                                    this.fire(new o.l("outofmaxbounds",e)),
                                    this._updateMarker(),
                                    void this._finish();
                                if (this.options.trackUserLocation)
                                    switch (this._lastKnownPosition = e,
                                    this._watchState) {
                                    case "WAITING_ACTIVE":
                                    case "ACTIVE_LOCK":
                                    case "ACTIVE_ERROR":
                                        this._watchState = "ACTIVE_LOCK",
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"),
                                        this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                        break;
                                    case "BACKGROUND":
                                    case "BACKGROUND_ERROR":
                                        this._watchState = "BACKGROUND",
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"),
                                        this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                                        break;
                                    default:
                                        throw new Error(`Unexpected watchState ${this._watchState}`)
                                    }
                                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e),
                                this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e),
                                this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"),
                                this.fire(new o.l("geolocate",e)),
                                this._finish()
                            }
                        }
                        ,
                        this._updateCamera = e => {
                            const r = new o.S(e.coords.longitude,e.coords.latitude)
                              , s = e.coords.accuracy
                              , c = this._map.getBearing()
                              , d = o.e({
                                bearing: c
                            }, this.options.fitBoundsOptions)
                              , m = Lt.fromLngLat(r, s);
                            this._map.fitBounds(m, d, {
                                geolocateSource: !0
                            })
                        }
                        ,
                        this._updateMarker = e => {
                            if (e) {
                                const r = new o.S(e.coords.longitude,e.coords.latitude);
                                this._accuracyCircleMarker.setLngLat(r).addTo(this._map),
                                this._userLocationDotMarker.setLngLat(r).addTo(this._map),
                                this._accuracy = e.coords.accuracy,
                                this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                            } else
                                this._userLocationDotMarker.remove(),
                                this._accuracyCircleMarker.remove()
                        }
                        ,
                        this._onZoom = () => {
                            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                        }
                        ,
                        this._onError = e => {
                            if (this._map) {
                                if (e.code === 1) {
                                    this._watchState = "OFF",
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"),
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"),
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"),
                                    this._geolocateButton.disabled = !0;
                                    const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                    this._geolocateButton.title = r,
                                    this._geolocateButton.setAttribute("aria-label", r),
                                    this._geolocationWatchID !== void 0 && this._clearWatch()
                                } else {
                                    if (e.code === 3 && Ya)
                                        return;
                                    this.options.trackUserLocation && this._setErrorState()
                                }
                                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"),
                                this.fire(new o.l("error",e)),
                                this._finish()
                            }
                        }
                        ,
                        this._finish = () => {
                            this._timeoutId && clearTimeout(this._timeoutId),
                            this._timeoutId = void 0
                        }
                        ,
                        this._setupUI = () => {
                            this._map && (this._container.addEventListener("contextmenu", e => e.preventDefault()),
                            this._geolocateButton = X.create("button", "maplibregl-ctrl-geolocate", this._container),
                            X.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"),
                            this._geolocateButton.type = "button",
                            this._geolocateButton.disabled = !0)
                        }
                        ,
                        this._finishSetupUI = e => {
                            if (this._map) {
                                if (e === !1) {
                                    o.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                                    const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                    this._geolocateButton.disabled = !0,
                                    this._geolocateButton.title = r,
                                    this._geolocateButton.setAttribute("aria-label", r)
                                } else {
                                    const r = this._map._getUIString("GeolocateControl.FindMyLocation");
                                    this._geolocateButton.disabled = !1,
                                    this._geolocateButton.title = r,
                                    this._geolocateButton.setAttribute("aria-label", r)
                                }
                                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"),
                                this._watchState = "OFF"),
                                this.options.showUserLocation && (this._dotElement = X.create("div", "maplibregl-user-location-dot"),
                                this._userLocationDotMarker = new qi({
                                    element: this._dotElement
                                }),
                                this._circleElement = X.create("div", "maplibregl-user-location-accuracy-circle"),
                                this._accuracyCircleMarker = new qi({
                                    element: this._circleElement,
                                    pitchAlignment: "map"
                                }),
                                this.options.trackUserLocation && (this._watchState = "OFF"),
                                this._map.on("zoom", this._onZoom)),
                                this._geolocateButton.addEventListener("click", () => this.trigger()),
                                this._setup = !0,
                                this.options.trackUserLocation && this._map.on("movestart", r => {
                                    r.geolocateSource || this._watchState !== "ACTIVE_LOCK" || r.originalEvent && r.originalEvent.type === "resize" || (this._watchState = "BACKGROUND",
                                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"),
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                                    this.fire(new o.l("trackuserlocationend")),
                                    this.fire(new o.l("userlocationlostfocus")))
                                }
                                )
                            }
                        }
                        ,
                        this.options = o.e({}, td, h)
                    }
                    onAdd(h) {
                        return this._map = h,
                        this._container = X.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._setupUI(),
                        function() {
                            return o._(this, arguments, void 0, function*(e=!1) {
                                if (gn !== void 0 && !e)
                                    return gn;
                                if (window.navigator.permissions === void 0)
                                    return gn = !!window.navigator.geolocation,
                                    gn;
                                try {
                                    gn = (yield window.navigator.permissions.query({
                                        name: "geolocation"
                                    })).state !== "denied"
                                } catch {
                                    gn = !!window.navigator.geolocation
                                }
                                return gn
                            })
                        }().then(e => this._finishSetupUI(e)),
                        this._container
                    }
                    onRemove() {
                        this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID),
                        this._geolocationWatchID = void 0),
                        this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(),
                        this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(),
                        X.remove(this._container),
                        this._map.off("zoom", this._onZoom),
                        this._map = void 0,
                        Ka = 0,
                        Ya = !1
                    }
                    _isOutOfMapMaxBounds(h) {
                        const e = this._map.getMaxBounds()
                          , r = h.coords;
                        return e && (r.longitude < e.getWest() || r.longitude > e.getEast() || r.latitude < e.getSouth() || r.latitude > e.getNorth())
                    }
                    _setErrorState() {
                        switch (this._watchState) {
                        case "WAITING_ACTIVE":
                            this._watchState = "ACTIVE_ERROR",
                            this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                            break;
                        case "ACTIVE_LOCK":
                            this._watchState = "ACTIVE_ERROR",
                            this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                            break;
                        case "BACKGROUND":
                            this._watchState = "BACKGROUND_ERROR",
                            this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                            break;
                        case "ACTIVE_ERROR":
                            break;
                        default:
                            throw new Error(`Unexpected watchState ${this._watchState}`)
                        }
                    }
                    _updateCircleRadius() {
                        const h = this._map.getBounds()
                          , e = h.getSouthEast()
                          , r = h.getNorthEast()
                          , s = e.distanceTo(r)
                          , c = Math.ceil(this._accuracy / (s / this._map._container.clientHeight) * 2);
                        this._circleElement.style.width = `${c}px`,
                        this._circleElement.style.height = `${c}px`
                    }
                    trigger() {
                        if (!this._setup)
                            return o.w("Geolocate control triggered before added to a map"),
                            !1;
                        if (this.options.trackUserLocation) {
                            switch (this._watchState) {
                            case "OFF":
                                this._watchState = "WAITING_ACTIVE",
                                this.fire(new o.l("trackuserlocationstart"));
                                break;
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                            case "BACKGROUND_ERROR":
                                Ka--,
                                Ya = !1,
                                this._watchState = "OFF",
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"),
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"),
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"),
                                this.fire(new o.l("trackuserlocationend"));
                                break;
                            case "BACKGROUND":
                                this._watchState = "ACTIVE_LOCK",
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"),
                                this._lastKnownPosition && this._updateCamera(this._lastKnownPosition),
                                this.fire(new o.l("trackuserlocationstart")),
                                this.fire(new o.l("userlocationfocus"));
                                break;
                            default:
                                throw new Error(`Unexpected watchState ${this._watchState}`)
                            }
                            switch (this._watchState) {
                            case "WAITING_ACTIVE":
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"),
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_LOCK":
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                break;
                            case "OFF":
                                break;
                            default:
                                throw new Error(`Unexpected watchState ${this._watchState}`)
                            }
                            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
                                this._clearWatch();
                            else if (this._geolocationWatchID === void 0) {
                                let h;
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"),
                                this._geolocateButton.setAttribute("aria-pressed", "true"),
                                Ka++,
                                Ka > 1 ? (h = {
                                    maximumAge: 6e5,
                                    timeout: 0
                                },
                                Ya = !0) : (h = this.options.positionOptions,
                                Ya = !1),
                                this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, h)
                            }
                        } else
                            window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions),
                            this._timeoutId = setTimeout(this._finish, 1e4);
                        return !0
                    }
                    _clearWatch() {
                        window.navigator.geolocation.clearWatch(this._geolocationWatchID),
                        this._geolocationWatchID = void 0,
                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                        this._geolocateButton.setAttribute("aria-pressed", "false"),
                        this.options.showUserLocation && this._updateMarker(null)
                    }
                }
                ,
                C.GlobeControl = class {
                    constructor() {
                        this._toggleProjection = () => {
                            var h;
                            const e = (h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type;
                            this._map.setProjection(e !== "mercator" && e ? {
                                type: "mercator"
                            } : {
                                type: "globe"
                            }),
                            this._updateGlobeIcon()
                        }
                        ,
                        this._updateGlobeIcon = () => {
                            var h;
                            this._globeButton.classList.remove("maplibregl-ctrl-globe"),
                            this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"),
                            ((h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"),
                            this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"),
                            this._globeButton.title = this._map._getUIString("GlobeControl.Enable"))
                        }
                    }
                    onAdd(h) {
                        return this._map = h,
                        this._container = X.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._globeButton = X.create("button", "maplibregl-ctrl-globe", this._container),
                        X.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"),
                        this._globeButton.type = "button",
                        this._globeButton.addEventListener("click", this._toggleProjection),
                        this._updateGlobeIcon(),
                        this._map.on("styledata", this._updateGlobeIcon),
                        this._container
                    }
                    onRemove() {
                        X.remove(this._container),
                        this._map.off("styledata", this._updateGlobeIcon),
                        this._globeButton.removeEventListener("click", this._toggleProjection),
                        this._map = void 0
                    }
                }
                ,
                C.Hash = Mo,
                C.ImageSource = tr,
                C.KeyboardHandler = Ks,
                C.LngLatBounds = Lt,
                C.LogoControl = Wc,
                C.Map = class extends Ei {
                    constructor(h) {
                        var e, r;
                        o.cv.mark(o.cw.create);
                        const s = Object.assign(Object.assign(Object.assign({}, Ro), h), {
                            canvasContextAttributes: Object.assign(Object.assign({}, Ro.canvasContextAttributes), h.canvasContextAttributes)
                        });
                        if (s.minZoom != null && s.maxZoom != null && s.minZoom > s.maxZoom)
                            throw new Error("maxZoom must be greater than or equal to minZoom");
                        if (s.minPitch != null && s.maxPitch != null && s.minPitch > s.maxPitch)
                            throw new Error("maxPitch must be greater than or equal to minPitch");
                        if (s.minPitch != null && s.minPitch < 0)
                            throw new Error("minPitch must be greater than or equal to 0");
                        if (s.maxPitch != null && s.maxPitch > 180)
                            throw new Error("maxPitch must be less than or equal to 180");
                        const c = new Li
                          , d = new tl;
                        if (s.minZoom !== void 0 && c.setMinZoom(s.minZoom),
                        s.maxZoom !== void 0 && c.setMaxZoom(s.maxZoom),
                        s.minPitch !== void 0 && c.setMinPitch(s.minPitch),
                        s.maxPitch !== void 0 && c.setMaxPitch(s.maxPitch),
                        s.renderWorldCopies !== void 0 && c.setRenderWorldCopies(s.renderWorldCopies),
                        super(c, d, {
                            bearingSnap: s.bearingSnap
                        }),
                        this._idleTriggered = !1,
                        this._crossFadingFactor = 1,
                        this._renderTaskQueue = new Yh,
                        this._controls = [],
                        this._mapId = o.a6(),
                        this._contextLost = v => {
                            v.preventDefault(),
                            this._frameRequest && (this._frameRequest.abort(),
                            this._frameRequest = null),
                            this.fire(new o.l("webglcontextlost",{
                                originalEvent: v
                            }))
                        }
                        ,
                        this._contextRestored = v => {
                            this._setupPainter(),
                            this.resize(),
                            this._update(),
                            this.fire(new o.l("webglcontextrestored",{
                                originalEvent: v
                            }))
                        }
                        ,
                        this._onMapScroll = v => {
                            if (v.target === this._container)
                                return this._container.scrollTop = 0,
                                this._container.scrollLeft = 0,
                                !1
                        }
                        ,
                        this._onWindowOnline = () => {
                            this._update()
                        }
                        ,
                        this._interactive = s.interactive,
                        this._maxTileCacheSize = s.maxTileCacheSize,
                        this._maxTileCacheZoomLevels = s.maxTileCacheZoomLevels,
                        this._canvasContextAttributes = Object.assign({}, s.canvasContextAttributes),
                        this._trackResize = s.trackResize === !0,
                        this._bearingSnap = s.bearingSnap,
                        this._centerClampedToGround = s.centerClampedToGround,
                        this._refreshExpiredTiles = s.refreshExpiredTiles === !0,
                        this._fadeDuration = s.fadeDuration,
                        this._crossSourceCollisions = s.crossSourceCollisions === !0,
                        this._collectResourceTiming = s.collectResourceTiming === !0,
                        this._locale = Object.assign(Object.assign({}, kl), s.locale),
                        this._clickTolerance = s.clickTolerance,
                        this._overridePixelRatio = s.pixelRatio,
                        this._maxCanvasSize = s.maxCanvasSize,
                        this.transformCameraUpdate = s.transformCameraUpdate,
                        this.cancelPendingTileRequestsWhileZooming = s.cancelPendingTileRequestsWhileZooming === !0,
                        this._imageQueueHandle = Ze.addThrottleControl( () => this.isMoving()),
                        this._requestManager = new ut(s.transformRequest),
                        typeof s.container == "string") {
                            if (this._container = document.getElementById(s.container),
                            !this._container)
                                throw new Error(`Container '${s.container}' not found.`)
                        } else {
                            if (!(s.container instanceof HTMLElement))
                                throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                            this._container = s.container
                        }
                        if (s.maxBounds && this.setMaxBounds(s.maxBounds),
                        this._setupContainer(),
                        this._setupPainter(),
                        this.on("move", () => this._update(!1)),
                        this.on("moveend", () => this._update(!1)),
                        this.on("zoom", () => this._update(!0)),
                        this.on("terrain", () => {
                            this.painter.terrainFacilitator.dirty = !0,
                            this._update(!0)
                        }
                        ),
                        this.once("idle", () => {
                            this._idleTriggered = !0
                        }
                        ),
                        typeof window < "u") {
                            addEventListener("online", this._onWindowOnline, !1);
                            let v = !1;
                            const b = bl(P => {
                                this._trackResize && !this._removed && (this.resize(P),
                                this.redraw())
                            }
                            , 50);
                            this._resizeObserver = new ResizeObserver(P => {
                                v ? b(P) : v = !0
                            }
                            ),
                            this._resizeObserver.observe(this._container)
                        }
                        this.handlers = new Xa(this,s),
                        this._hash = s.hash && new Mo(typeof s.hash == "string" && s.hash || void 0).addTo(this),
                        this._hash && this._hash._onHashChange() || (this.jumpTo({
                            center: s.center,
                            elevation: s.elevation,
                            zoom: s.zoom,
                            bearing: s.bearing,
                            pitch: s.pitch,
                            roll: s.roll
                        }),
                        s.bounds && (this.resize(),
                        this.fitBounds(s.bounds, o.e({}, s.fitBoundsOptions, {
                            duration: 0
                        }))));
                        const m = typeof s.style == "string" || ((r = (e = s.style) === null || e === void 0 ? void 0 : e.projection) === null || r === void 0 ? void 0 : r.type) !== "globe";
                        this.resize(null, m),
                        this._localIdeographFontFamily = s.localIdeographFontFamily,
                        this._validateStyle = s.validateStyle,
                        s.style && this.setStyle(s.style, {
                            localIdeographFontFamily: s.localIdeographFontFamily
                        }),
                        s.attributionControl && this.addControl(new Ml(typeof s.attributionControl == "boolean" ? void 0 : s.attributionControl)),
                        s.maplibreLogo && this.addControl(new Wc, s.logoPosition),
                        this.on("style.load", () => {
                            if (m || this._resizeTransform(),
                            this.transform.unmodified) {
                                const v = o.Q(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                                this.jumpTo(v)
                            }
                        }
                        ),
                        this.on("data", v => {
                            this._update(v.dataType === "style"),
                            this.fire(new o.l(`${v.dataType}data`,v))
                        }
                        ),
                        this.on("dataloading", v => {
                            this.fire(new o.l(`${v.dataType}dataloading`,v))
                        }
                        ),
                        this.on("dataabort", v => {
                            this.fire(new o.l("sourcedataabort",v))
                        }
                        )
                    }
                    _getMapId() {
                        return this._mapId
                    }
                    setGlobalStateProperty(h, e) {
                        return this.style.setGlobalStateProperty(h, e),
                        this._update(!0)
                    }
                    getGlobalState() {
                        return this.style.getGlobalState()
                    }
                    addControl(h, e) {
                        if (e === void 0 && (e = h.getDefaultPosition ? h.getDefaultPosition() : "top-right"),
                        !h || !h.onAdd)
                            return this.fire(new o.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                        const r = h.onAdd(this);
                        this._controls.push(h);
                        const s = this._controlPositions[e];
                        return e.indexOf("bottom") !== -1 ? s.insertBefore(r, s.firstChild) : s.appendChild(r),
                        this
                    }
                    removeControl(h) {
                        if (!h || !h.onRemove)
                            return this.fire(new o.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                        const e = this._controls.indexOf(h);
                        return e > -1 && this._controls.splice(e, 1),
                        h.onRemove(this),
                        this
                    }
                    hasControl(h) {
                        return this._controls.indexOf(h) > -1
                    }
                    calculateCameraOptionsFromTo(h, e, r, s) {
                        return s == null && this.terrain && (s = this.terrain.getElevationForLngLatZoom(r, this.transform.tileZoom)),
                        super.calculateCameraOptionsFromTo(h, e, r, s)
                    }
                    resize(h, e=!0) {
                        const [r,s] = this._containerDimensions()
                          , c = this._getClampedPixelRatio(r, s);
                        if (this._resizeCanvas(r, s, c),
                        this.painter.resize(r, s, c),
                        this.painter.overLimit()) {
                            const m = this.painter.context.gl;
                            this._maxCanvasSize = [m.drawingBufferWidth, m.drawingBufferHeight];
                            const v = this._getClampedPixelRatio(r, s);
                            this._resizeCanvas(r, s, v),
                            this.painter.resize(r, s, v)
                        }
                        this._resizeTransform(e);
                        const d = !this._moving;
                        return d && (this.stop(),
                        this.fire(new o.l("movestart",h)).fire(new o.l("move",h))),
                        this.fire(new o.l("resize",h)),
                        d && this.fire(new o.l("moveend",h)),
                        this
                    }
                    _resizeTransform(h=!0) {
                        var e;
                        const [r,s] = this._containerDimensions();
                        this.transform.resize(r, s, h),
                        (e = this._requestedCameraState) === null || e === void 0 || e.resize(r, s, h)
                    }
                    _getClampedPixelRatio(h, e) {
                        const {0: r, 1: s} = this._maxCanvasSize
                          , c = this.getPixelRatio()
                          , d = h * c
                          , m = e * c;
                        return Math.min(d > r ? r / d : 1, m > s ? s / m : 1) * c
                    }
                    getPixelRatio() {
                        var h;
                        return (h = this._overridePixelRatio) !== null && h !== void 0 ? h : devicePixelRatio
                    }
                    setPixelRatio(h) {
                        this._overridePixelRatio = h,
                        this.resize()
                    }
                    getBounds() {
                        return this.transform.getBounds()
                    }
                    getMaxBounds() {
                        return this.transform.getMaxBounds()
                    }
                    setMaxBounds(h) {
                        return this.transform.setMaxBounds(Lt.convert(h)),
                        this._update()
                    }
                    setMinZoom(h) {
                        if ((h = h ?? -2) >= -2 && h <= this.transform.maxZoom)
                            return this.transform.setMinZoom(h),
                            this._update(),
                            this.getZoom() < h && this.setZoom(h),
                            this;
                        throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
                    }
                    getMinZoom() {
                        return this.transform.minZoom
                    }
                    setMaxZoom(h) {
                        if ((h = h ?? 22) >= this.transform.minZoom)
                            return this.transform.setMaxZoom(h),
                            this._update(),
                            this.getZoom() > h && this.setZoom(h),
                            this;
                        throw new Error("maxZoom must be greater than the current minZoom")
                    }
                    getMaxZoom() {
                        return this.transform.maxZoom
                    }
                    setMinPitch(h) {
                        if ((h = h ?? 0) < 0)
                            throw new Error("minPitch must be greater than or equal to 0");
                        if (h >= 0 && h <= this.transform.maxPitch)
                            return this.transform.setMinPitch(h),
                            this._update(),
                            this.getPitch() < h && this.setPitch(h),
                            this;
                        throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
                    }
                    getMinPitch() {
                        return this.transform.minPitch
                    }
                    setMaxPitch(h) {
                        if ((h = h ?? 60) > 180)
                            throw new Error("maxPitch must be less than or equal to 180");
                        if (h >= this.transform.minPitch)
                            return this.transform.setMaxPitch(h),
                            this._update(),
                            this.getPitch() > h && this.setPitch(h),
                            this;
                        throw new Error("maxPitch must be greater than the current minPitch")
                    }
                    getMaxPitch() {
                        return this.transform.maxPitch
                    }
                    getRenderWorldCopies() {
                        return this.transform.renderWorldCopies
                    }
                    setRenderWorldCopies(h) {
                        return this.transform.setRenderWorldCopies(h),
                        this._update()
                    }
                    project(h) {
                        return this.transform.locationToScreenPoint(o.S.convert(h), this.style && this.terrain)
                    }
                    unproject(h) {
                        return this.transform.screenPointToLocation(o.P.convert(h), this.terrain)
                    }
                    isMoving() {
                        var h;
                        return this._moving || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isMoving())
                    }
                    isZooming() {
                        var h;
                        return this._zooming || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isZooming())
                    }
                    isRotating() {
                        var h;
                        return this._rotating || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isRotating())
                    }
                    _createDelegatedListener(h, e, r) {
                        if (h === "mouseenter" || h === "mouseover") {
                            let s = !1;
                            return {
                                layers: e,
                                listener: r,
                                delegates: {
                                    mousemove: d => {
                                        const m = e.filter(b => this.getLayer(b))
                                          , v = m.length !== 0 ? this.queryRenderedFeatures(d.point, {
                                            layers: m
                                        }) : [];
                                        v.length ? s || (s = !0,
                                        r.call(this, new $n(h,this,d.originalEvent,{
                                            features: v
                                        }))) : s = !1
                                    }
                                    ,
                                    mouseout: () => {
                                        s = !1
                                    }
                                }
                            }
                        }
                        if (h === "mouseleave" || h === "mouseout") {
                            let s = !1;
                            return {
                                layers: e,
                                listener: r,
                                delegates: {
                                    mousemove: m => {
                                        const v = e.filter(b => this.getLayer(b));
                                        (v.length !== 0 ? this.queryRenderedFeatures(m.point, {
                                            layers: v
                                        }) : []).length ? s = !0 : s && (s = !1,
                                        r.call(this, new $n(h,this,m.originalEvent)))
                                    }
                                    ,
                                    mouseout: m => {
                                        s && (s = !1,
                                        r.call(this, new $n(h,this,m.originalEvent)))
                                    }
                                }
                            }
                        }
                        {
                            const s = c => {
                                const d = e.filter(v => this.getLayer(v))
                                  , m = d.length !== 0 ? this.queryRenderedFeatures(c.point, {
                                    layers: d
                                }) : [];
                                m.length && (c.features = m,
                                r.call(this, c),
                                delete c.features)
                            }
                            ;
                            return {
                                layers: e,
                                listener: r,
                                delegates: {
                                    [h]: s
                                }
                            }
                        }
                    }
                    _saveDelegatedListener(h, e) {
                        this._delegatedListeners = this._delegatedListeners || {},
                        this._delegatedListeners[h] = this._delegatedListeners[h] || [],
                        this._delegatedListeners[h].push(e)
                    }
                    _removeDelegatedListener(h, e, r) {
                        if (!this._delegatedListeners || !this._delegatedListeners[h])
                            return;
                        const s = this._delegatedListeners[h];
                        for (let c = 0; c < s.length; c++) {
                            const d = s[c];
                            if (d.listener === r && d.layers.length === e.length && d.layers.every(m => e.includes(m))) {
                                for (const m in d.delegates)
                                    this.off(m, d.delegates[m]);
                                return void s.splice(c, 1)
                            }
                        }
                    }
                    on(h, e, r) {
                        if (r === void 0)
                            return super.on(h, e);
                        const s = typeof e == "string" ? [e] : e
                          , c = this._createDelegatedListener(h, s, r);
                        this._saveDelegatedListener(h, c);
                        for (const d in c.delegates)
                            this.on(d, c.delegates[d]);
                        return {
                            unsubscribe: () => {
                                this._removeDelegatedListener(h, s, r)
                            }
                        }
                    }
                    once(h, e, r) {
                        if (r === void 0)
                            return super.once(h, e);
                        const s = typeof e == "string" ? [e] : e
                          , c = this._createDelegatedListener(h, s, r);
                        for (const d in c.delegates) {
                            const m = c.delegates[d];
                            c.delegates[d] = (...v) => {
                                this._removeDelegatedListener(h, s, r),
                                m(...v)
                            }
                        }
                        this._saveDelegatedListener(h, c);
                        for (const d in c.delegates)
                            this.once(d, c.delegates[d]);
                        return this
                    }
                    off(h, e, r) {
                        return r === void 0 ? super.off(h, e) : (this._removeDelegatedListener(h, typeof e == "string" ? [e] : e, r),
                        this)
                    }
                    queryRenderedFeatures(h, e) {
                        if (!this.style)
                            return [];
                        let r;
                        const s = h instanceof o.P || Array.isArray(h)
                          , c = s ? h : [[0, 0], [this.transform.width, this.transform.height]];
                        if (e = e || (s ? {} : h) || {},
                        c instanceof o.P || typeof c[0] == "number")
                            r = [o.P.convert(c)];
                        else {
                            const d = o.P.convert(c[0])
                              , m = o.P.convert(c[1]);
                            r = [d, new o.P(m.x,d.y), m, new o.P(d.x,m.y), d]
                        }
                        return this.style.queryRenderedFeatures(r, e, this.transform)
                    }
                    querySourceFeatures(h, e) {
                        return this.style.querySourceFeatures(h, e)
                    }
                    setStyle(h, e) {
                        return (e = o.e({}, {
                            localIdeographFontFamily: this._localIdeographFontFamily,
                            validate: this._validateStyle
                        }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && h ? (this._diffStyle(h, e),
                        this) : (this._localIdeographFontFamily = e.localIdeographFontFamily,
                        this._updateStyle(h, e))
                    }
                    setTransformRequest(h) {
                        return this._requestManager.setTransformRequest(h),
                        this
                    }
                    _getUIString(h) {
                        const e = this._locale[h];
                        if (e == null)
                            throw new Error(`Missing UI string '${h}'`);
                        return e
                    }
                    _updateStyle(h, e) {
                        var r, s;
                        if (e.transformStyle && this.style && !this.style._loaded)
                            return void this.style.once("style.load", () => this._updateStyle(h, e));
                        const c = this.style && e.transformStyle ? this.style.serialize() : void 0;
                        return this.style && (this.style.setEventedParent(null),
                        this.style._remove(!h)),
                        h ? (this.style = new _c(this,e || {}),
                        this.style.setEventedParent(this, {
                            style: this.style
                        }),
                        typeof h == "string" ? this.style.loadURL(h, e, c) : this.style.loadJSON(h, e, c),
                        this) : ((s = (r = this.style) === null || r === void 0 ? void 0 : r.projection) === null || s === void 0 || s.destroy(),
                        delete this.style,
                        this)
                    }
                    _lazyInitEmptyStyle() {
                        this.style || (this.style = new _c(this,{}),
                        this.style.setEventedParent(this, {
                            style: this.style
                        }),
                        this.style.loadEmpty())
                    }
                    _diffStyle(h, e) {
                        if (typeof h == "string") {
                            const r = this._requestManager.transformRequest(h, "Style");
                            o.j(r, new AbortController).then(s => {
                                this._updateDiff(s.data, e)
                            }
                            ).catch(s => {
                                s && this.fire(new o.k(s))
                            }
                            )
                        } else
                            typeof h == "object" && this._updateDiff(h, e)
                    }
                    _updateDiff(h, e) {
                        try {
                            this.style.setState(h, e) && this._update(!0)
                        } catch (r) {
                            o.w(`Unable to perform style diff: ${r.message || r.error || r}.  Rebuilding the style from scratch.`),
                            this._updateStyle(h, e)
                        }
                    }
                    getStyle() {
                        if (this.style)
                            return this.style.serialize()
                    }
                    isStyleLoaded() {
                        return this.style ? this.style.loaded() : o.w("There is no style added to the map.")
                    }
                    addSource(h, e) {
                        return this._lazyInitEmptyStyle(),
                        this.style.addSource(h, e),
                        this._update(!0)
                    }
                    isSourceLoaded(h) {
                        const e = this.style && this.style.sourceCaches[h];
                        if (e !== void 0)
                            return e.loaded();
                        this.fire(new o.k(new Error(`There is no source with ID '${h}'`)))
                    }
                    setTerrain(h) {
                        if (this.style._checkLoaded(),
                        this._terrainDataCallback && this.style.off("data", this._terrainDataCallback),
                        h) {
                            const e = this.style.sourceCaches[h.source];
                            if (!e)
                                throw new Error(`cannot load terrain, because there exists no source with ID: ${h.source}`);
                            this.terrain === null && e.reload();
                            for (const r in this.style._layers) {
                                const s = this.style._layers[r];
                                s.type === "hillshade" && s.source === h.source && o.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."),
                                s.type === "color-relief" && s.source === h.source && o.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.")
                            }
                            this.terrain = new Ia(this.painter,e,h),
                            this.painter.renderToTexture = new Rr(this.painter,this.terrain),
                            this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)),
                            this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)),
                            this._terrainDataCallback = r => {
                                var s;
                                r.dataType === "style" ? this.terrain.sourceCache.freeRtt() : r.dataType === "source" && r.tile && (r.sourceId !== h.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)),
                                this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))),
                                ((s = r.source) === null || s === void 0 ? void 0 : s.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(r.tile.tileID))
                            }
                            ,
                            this.style.on("data", this._terrainDataCallback)
                        } else
                            this.terrain && this.terrain.sourceCache.destruct(),
                            this.terrain = null,
                            this.painter.renderToTexture && this.painter.renderToTexture.destruct(),
                            this.painter.renderToTexture = null,
                            this.transform.setMinElevationForCurrentTile(0),
                            this._centerClampedToGround && this.transform.setElevation(0);
                        return this.fire(new o.l("terrain",{
                            terrain: h
                        })),
                        this
                    }
                    getTerrain() {
                        var h, e;
                        return (e = (h = this.terrain) === null || h === void 0 ? void 0 : h.options) !== null && e !== void 0 ? e : null
                    }
                    areTilesLoaded() {
                        const h = this.style && this.style.sourceCaches;
                        for (const e in h) {
                            const r = h[e]._tiles;
                            for (const s in r) {
                                const c = r[s];
                                if (c.state !== "loaded" && c.state !== "errored")
                                    return !1
                            }
                        }
                        return !0
                    }
                    removeSource(h) {
                        return this.style.removeSource(h),
                        this._update(!0)
                    }
                    getSource(h) {
                        return this.style.getSource(h)
                    }
                    setSourceTileLodParams(h, e, r) {
                        if (r) {
                            const s = this.getSource(r);
                            if (!s)
                                throw new Error(`There is no source with ID "${r}", cannot set LOD parameters`);
                            s.calculateTileZoom = ke(Math.max(1, h), Math.max(1, e))
                        } else
                            for (const s in this.style.sourceCaches)
                                this.style.sourceCaches[s].getSource().calculateTileZoom = ke(Math.max(1, h), Math.max(1, e));
                        return this._update(!0),
                        this
                    }
                    refreshTiles(h, e) {
                        const r = this.style.sourceCaches[h];
                        if (!r)
                            throw new Error(`There is no source cache with ID "${h}", cannot refresh tile`);
                        e === void 0 ? r.reload(!0) : r.refreshTiles(e.map(s => new o.a3(s.z,s.x,s.y)))
                    }
                    addImage(h, e, r={}) {
                        const {pixelRatio: s=1, sdf: c=!1, stretchX: d, stretchY: m, content: v, textFitWidth: b, textFitHeight: P} = r;
                        if (this._lazyInitEmptyStyle(),
                        !(e instanceof HTMLImageElement || o.b(e))) {
                            if (e.width === void 0 || e.height === void 0)
                                return this.fire(new o.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                            {
                                const {width: M, height: D, data: L} = e
                                  , B = e;
                                return this.style.addImage(h, {
                                    data: new o.R({
                                        width: M,
                                        height: D
                                    },new Uint8Array(L)),
                                    pixelRatio: s,
                                    stretchX: d,
                                    stretchY: m,
                                    content: v,
                                    textFitWidth: b,
                                    textFitHeight: P,
                                    sdf: c,
                                    version: 0,
                                    userImage: B
                                }),
                                B.onAdd && B.onAdd(this, h),
                                this
                            }
                        }
                        {
                            const {width: M, height: D, data: L} = he.getImageData(e);
                            this.style.addImage(h, {
                                data: new o.R({
                                    width: M,
                                    height: D
                                },L),
                                pixelRatio: s,
                                stretchX: d,
                                stretchY: m,
                                content: v,
                                textFitWidth: b,
                                textFitHeight: P,
                                sdf: c,
                                version: 0
                            })
                        }
                    }
                    updateImage(h, e) {
                        const r = this.style.getImage(h);
                        if (!r)
                            return this.fire(new o.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                        const s = e instanceof HTMLImageElement || o.b(e) ? he.getImageData(e) : e
                          , {width: c, height: d, data: m} = s;
                        if (c === void 0 || d === void 0)
                            return this.fire(new o.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                        if (c !== r.data.width || d !== r.data.height)
                            return this.fire(new o.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
                        const v = !(e instanceof HTMLImageElement || o.b(e));
                        return r.data.replace(m, v),
                        this.style.updateImage(h, r),
                        this
                    }
                    getImage(h) {
                        return this.style.getImage(h)
                    }
                    hasImage(h) {
                        return h ? !!this.style.getImage(h) : (this.fire(new o.k(new Error("Missing required image id"))),
                        !1)
                    }
                    removeImage(h) {
                        this.style.removeImage(h)
                    }
                    loadImage(h) {
                        return Ze.getImage(this._requestManager.transformRequest(h, "Image"), new AbortController)
                    }
                    listImages() {
                        return this.style.listImages()
                    }
                    addLayer(h, e) {
                        return this._lazyInitEmptyStyle(),
                        this.style.addLayer(h, e),
                        this._update(!0)
                    }
                    moveLayer(h, e) {
                        return this.style.moveLayer(h, e),
                        this._update(!0)
                    }
                    removeLayer(h) {
                        return this.style.removeLayer(h),
                        this._update(!0)
                    }
                    getLayer(h) {
                        return this.style.getLayer(h)
                    }
                    getLayersOrder() {
                        return this.style.getLayersOrder()
                    }
                    setLayerZoomRange(h, e, r) {
                        return this.style.setLayerZoomRange(h, e, r),
                        this._update(!0)
                    }
                    setFilter(h, e, r={}) {
                        return this.style.setFilter(h, e, r),
                        this._update(!0)
                    }
                    getFilter(h) {
                        return this.style.getFilter(h)
                    }
                    setPaintProperty(h, e, r, s={}) {
                        return this.style.setPaintProperty(h, e, r, s),
                        this._update(!0)
                    }
                    getPaintProperty(h, e) {
                        return this.style.getPaintProperty(h, e)
                    }
                    setLayoutProperty(h, e, r, s={}) {
                        return this.style.setLayoutProperty(h, e, r, s),
                        this._update(!0)
                    }
                    getLayoutProperty(h, e) {
                        return this.style.getLayoutProperty(h, e)
                    }
                    setGlyphs(h, e={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setGlyphs(h, e),
                        this._update(!0)
                    }
                    getGlyphs() {
                        return this.style.getGlyphsUrl()
                    }
                    addSprite(h, e, r={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.addSprite(h, e, r, s => {
                            s || this._update(!0)
                        }
                        ),
                        this
                    }
                    removeSprite(h) {
                        return this._lazyInitEmptyStyle(),
                        this.style.removeSprite(h),
                        this._update(!0)
                    }
                    getSprite() {
                        return this.style.getSprite()
                    }
                    setSprite(h, e={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setSprite(h, e, r => {
                            r || this._update(!0)
                        }
                        ),
                        this
                    }
                    setLight(h, e={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setLight(h, e),
                        this._update(!0)
                    }
                    getLight() {
                        return this.style.getLight()
                    }
                    setSky(h, e={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setSky(h, e),
                        this._update(!0)
                    }
                    getSky() {
                        return this.style.getSky()
                    }
                    setFeatureState(h, e) {
                        return this.style.setFeatureState(h, e),
                        this._update()
                    }
                    removeFeatureState(h, e) {
                        return this.style.removeFeatureState(h, e),
                        this._update()
                    }
                    getFeatureState(h) {
                        return this.style.getFeatureState(h)
                    }
                    getContainer() {
                        return this._container
                    }
                    getCanvasContainer() {
                        return this._canvasContainer
                    }
                    getCanvas() {
                        return this._canvas
                    }
                    _containerDimensions() {
                        let h = 0
                          , e = 0;
                        return this._container && (h = this._container.clientWidth || 400,
                        e = this._container.clientHeight || 300),
                        [h, e]
                    }
                    _setupContainer() {
                        const h = this._container;
                        h.classList.add("maplibregl-map");
                        const e = this._canvasContainer = X.create("div", "maplibregl-canvas-container", h);
                        this._interactive && e.classList.add("maplibregl-interactive"),
                        this._canvas = X.create("canvas", "maplibregl-canvas", e),
                        this._canvas.addEventListener("webglcontextlost", this._contextLost, !1),
                        this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1),
                        this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"),
                        this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")),
                        this._canvas.setAttribute("role", "region");
                        const r = this._containerDimensions()
                          , s = this._getClampedPixelRatio(r[0], r[1]);
                        this._resizeCanvas(r[0], r[1], s);
                        const c = this._controlContainer = X.create("div", "maplibregl-control-container", h)
                          , d = this._controlPositions = {};
                        ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(m => {
                            d[m] = X.create("div", `maplibregl-ctrl-${m} `, c)
                        }
                        ),
                        this._container.addEventListener("scroll", this._onMapScroll, !1)
                    }
                    _resizeCanvas(h, e, r) {
                        this._canvas.width = Math.floor(r * h),
                        this._canvas.height = Math.floor(r * e),
                        this._canvas.style.width = `${h}px`,
                        this._canvas.style.height = `${e}px`
                    }
                    _setupPainter() {
                        const h = Object.assign(Object.assign({}, this._canvasContextAttributes), {
                            alpha: !0,
                            depth: !0,
                            stencil: !0,
                            premultipliedAlpha: !0
                        });
                        let e = null;
                        this._canvas.addEventListener("webglcontextcreationerror", s => {
                            e = {
                                requestedAttributes: h
                            },
                            s && (e.statusMessage = s.statusMessage,
                            e.type = s.type)
                        }
                        , {
                            once: !0
                        });
                        let r = null;
                        if (r = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, h) : this._canvas.getContext("webgl2", h) || this._canvas.getContext("webgl", h),
                        !r) {
                            const s = "Failed to initialize WebGL";
                            throw e ? (e.message = s,
                            new Error(JSON.stringify(e))) : new Error(s)
                        }
                        this.painter = new la(r,this.transform),
                        le.testSupport(r)
                    }
                    migrateProjection(h, e) {
                        super.migrateProjection(h, e),
                        this.painter.transform = h,
                        this.fire(new o.l("projectiontransition",{
                            newProjection: this.style.projection.name
                        }))
                    }
                    loaded() {
                        return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
                    }
                    _update(h) {
                        return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || h,
                        this._sourcesDirty = !0,
                        this.triggerRepaint(),
                        this) : this
                    }
                    _requestRenderFrame(h) {
                        return this._update(),
                        this._renderTaskQueue.add(h)
                    }
                    _cancelRenderFrame(h) {
                        this._renderTaskQueue.remove(h)
                    }
                    _render(h) {
                        var e, r, s, c, d;
                        const m = this._idleTriggered ? this._fadeDuration : 0
                          , v = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
                        if (this.painter.context.setDirty(),
                        this.painter.setBaseState(),
                        this._renderTaskQueue.run(h),
                        this._removed)
                            return;
                        let b = !1;
                        if (this.style && this._styleDirty) {
                            this._styleDirty = !1;
                            const D = this.transform.zoom
                              , L = he.now();
                            this.style.zoomHistory.update(D, L);
                            const B = new o.F(D,{
                                now: L,
                                fadeDuration: m,
                                zoomHistory: this.style.zoomHistory,
                                transition: this.style.getTransition(),
                                globalState: this.style.getGlobalState()
                            })
                              , Z = B.crossFadingFactor();
                            Z === 1 && Z === this._crossFadingFactor || (b = !0,
                            this._crossFadingFactor = Z),
                            this.style.update(B)
                        }
                        const P = ((r = this.style.projection) === null || r === void 0 ? void 0 : r.transitionState) > 0 !== v;
                        (s = this.style.projection) === null || s === void 0 || s.setErrorQueryLatitudeDegrees(this.transform.center.lat),
                        this.transform.setTransitionState((c = this.style.projection) === null || c === void 0 ? void 0 : c.transitionState, (d = this.style.projection) === null || d === void 0 ? void 0 : d.latitudeErrorCorrectionRadians),
                        this.style && (this._sourcesDirty || P) && (this._sourcesDirty = !1,
                        this.style._updateSources(this.transform)),
                        this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain),
                        this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)),
                        !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0),
                        this._centerClampedToGround && this.transform.setElevation(0)),
                        this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, m, this._crossSourceCollisions, P),
                        this.painter.render(this.style, {
                            showTileBoundaries: this.showTileBoundaries,
                            showOverdrawInspector: this._showOverdrawInspector,
                            rotating: this.isRotating(),
                            zooming: this.isZooming(),
                            moving: this.isMoving(),
                            fadeDuration: m,
                            showPadding: this.showPadding
                        }),
                        this.fire(new o.l("render")),
                        this.loaded() && !this._loaded && (this._loaded = !0,
                        o.cv.mark(o.cw.load),
                        this.fire(new o.l("load"))),
                        this.style && (this.style.hasTransitions() || b) && (this._styleDirty = !0),
                        this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
                        const M = this._sourcesDirty || this._styleDirty || this._placementDirty;
                        return M || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new o.l("idle")),
                        !this._loaded || this._fullyLoaded || M || (this._fullyLoaded = !0,
                        o.cv.mark(o.cw.fullLoad)),
                        this
                    }
                    redraw() {
                        return this.style && (this._frameRequest && (this._frameRequest.abort(),
                        this._frameRequest = null),
                        this._render(0)),
                        this
                    }
                    remove() {
                        var h;
                        this._hash && this._hash.remove();
                        for (const r of this._controls)
                            r.onRemove(this);
                        this._controls = [],
                        this._frameRequest && (this._frameRequest.abort(),
                        this._frameRequest = null),
                        this._renderTaskQueue.clear(),
                        this.painter.destroy(),
                        this.handlers.destroy(),
                        delete this.handlers,
                        this.setStyle(null),
                        typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1),
                        Ze.removeThrottleControl(this._imageQueueHandle),
                        (h = this._resizeObserver) === null || h === void 0 || h.disconnect();
                        const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
                        e != null && e.loseContext && e.loseContext(),
                        this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1),
                        this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1),
                        X.remove(this._canvasContainer),
                        X.remove(this._controlContainer),
                        this._container.removeEventListener("scroll", this._onMapScroll, !1),
                        this._container.classList.remove("maplibregl-map"),
                        o.cv.clearMetrics(),
                        this._removed = !0,
                        this.fire(new o.l("remove"))
                    }
                    triggerRepaint() {
                        this.style && !this._frameRequest && (this._frameRequest = new AbortController,
                        he.frame(this._frameRequest, h => {
                            o.cv.frame(h),
                            this._frameRequest = null;
                            try {
                                this._render(h)
                            } catch (e) {
                                if (!o.cx(e) && !function(r) {
                                    return r.message === Ec
                                }(e))
                                    throw e
                            }
                        }
                        , () => {}
                        ))
                    }
                    get showTileBoundaries() {
                        return !!this._showTileBoundaries
                    }
                    set showTileBoundaries(h) {
                        this._showTileBoundaries !== h && (this._showTileBoundaries = h,
                        this._update())
                    }
                    get showPadding() {
                        return !!this._showPadding
                    }
                    set showPadding(h) {
                        this._showPadding !== h && (this._showPadding = h,
                        this._update())
                    }
                    get showCollisionBoxes() {
                        return !!this._showCollisionBoxes
                    }
                    set showCollisionBoxes(h) {
                        this._showCollisionBoxes !== h && (this._showCollisionBoxes = h,
                        h ? this.style._generateCollisionBoxes() : this._update())
                    }
                    get showOverdrawInspector() {
                        return !!this._showOverdrawInspector
                    }
                    set showOverdrawInspector(h) {
                        this._showOverdrawInspector !== h && (this._showOverdrawInspector = h,
                        this._update())
                    }
                    get repaint() {
                        return !!this._repaint
                    }
                    set repaint(h) {
                        this._repaint !== h && (this._repaint = h,
                        this.triggerRepaint())
                    }
                    get vertices() {
                        return !!this._vertices
                    }
                    set vertices(h) {
                        this._vertices = h,
                        this._update()
                    }
                    get version() {
                        return Xc
                    }
                    getCameraTargetElevation() {
                        return this.transform.elevation
                    }
                    getProjection() {
                        return this.style.getProjection()
                    }
                    setProjection(h) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setProjection(h),
                        this._update(!0)
                    }
                }
                ,
                C.MapMouseEvent = $n,
                C.MapTouchEvent = fa,
                C.MapWheelEvent = Oc,
                C.Marker = qi,
                C.NavigationControl = class {
                    constructor(h) {
                        this._updateZoomButtons = () => {
                            const e = this._map.getZoom()
                              , r = e === this._map.getMaxZoom()
                              , s = e === this._map.getMinZoom();
                            this._zoomInButton.disabled = r,
                            this._zoomOutButton.disabled = s,
                            this._zoomInButton.setAttribute("aria-disabled", r.toString()),
                            this._zoomOutButton.setAttribute("aria-disabled", s.toString())
                        }
                        ,
                        this._rotateCompassArrow = () => {
                            this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`
                        }
                        ,
                        this._setButtonTitle = (e, r) => {
                            const s = this._map._getUIString(`NavigationControl.${r}`);
                            e.title = s,
                            e.setAttribute("aria-label", s)
                        }
                        ,
                        this.options = o.e({}, Ln, h),
                        this._container = X.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._container.addEventListener("contextmenu", e => e.preventDefault()),
                        this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", e => this._map.zoomIn({}, {
                            originalEvent: e
                        })),
                        X.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"),
                        this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", e => this._map.zoomOut({}, {
                            originalEvent: e
                        })),
                        X.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")),
                        this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", e => {
                            this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                                originalEvent: e
                            }) : this._map.resetNorth({}, {
                                originalEvent: e
                            })
                        }
                        ),
                        this._compassIcon = X.create("span", "maplibregl-ctrl-icon", this._compass),
                        this._compassIcon.setAttribute("aria-hidden", "true"))
                    }
                    onAdd(h) {
                        return this._map = h,
                        this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"),
                        this._setButtonTitle(this._zoomOutButton, "ZoomOut"),
                        this._map.on("zoom", this._updateZoomButtons),
                        this._updateZoomButtons()),
                        this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"),
                        this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow),
                        this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow),
                        this._map.on("rotate", this._rotateCompassArrow),
                        this._rotateCompassArrow(),
                        this._handler = new Qh(this._map,this._compass,this.options.visualizePitch)),
                        this._container
                    }
                    onRemove() {
                        X.remove(this._container),
                        this.options.showZoom && this._map.off("zoom", this._updateZoomButtons),
                        this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow),
                        this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow),
                        this._map.off("rotate", this._rotateCompassArrow),
                        this._handler.off(),
                        delete this._handler),
                        delete this._map
                    }
                    _createButton(h, e) {
                        const r = X.create("button", h, this._container);
                        return r.type = "button",
                        r.addEventListener("click", e),
                        r
                    }
                }
                ,
                C.Popup = class extends o.E {
                    constructor(h) {
                        super(),
                        this._updateOpacity = () => {
                            this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "")
                        }
                        ,
                        this.remove = () => (this._content && X.remove(this._content),
                        this._container && (X.remove(this._container),
                        delete this._container),
                        this._map && (this._map.off("move", this._update),
                        this._map.off("move", this._onClose),
                        this._map.off("click", this._onClose),
                        this._map.off("remove", this.remove),
                        this._map.off("mousemove", this._onMouseMove),
                        this._map.off("mouseup", this._onMouseUp),
                        this._map.off("drag", this._onDrag),
                        this._map._canvasContainer.classList.remove("maplibregl-track-pointer"),
                        delete this._map,
                        this.fire(new o.l("close"))),
                        this),
                        this._onMouseUp = e => {
                            this._update(e.point)
                        }
                        ,
                        this._onMouseMove = e => {
                            this._update(e.point)
                        }
                        ,
                        this._onDrag = e => {
                            this._update(e.point)
                        }
                        ,
                        this._update = e => {
                            if (!this._map || !this._lngLat && !this._trackPointer || !this._content)
                                return;
                            if (!this._container) {
                                if (this._container = X.create("div", "maplibregl-popup", this._map.getContainer()),
                                this._tip = X.create("div", "maplibregl-popup-tip", this._container),
                                this._container.appendChild(this._content),
                                this.options.className)
                                    for (const m of this.options.className.split(" "))
                                        this._container.classList.add(m);
                                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")),
                                this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer")
                            }
                            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth),
                            this._lngLat = ed(this._lngLat, this._flatPos, this._map.transform, this._trackPointer),
                            this._trackPointer && !e)
                                return;
                            const r = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
                            this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
                            let s = this.options.anchor;
                            const c = zl(this.options.offset);
                            if (!s) {
                                const m = this._container.offsetWidth
                                  , v = this._container.offsetHeight;
                                let b;
                                b = r.y + c.bottom.y < v ? ["top"] : r.y > this._map.transform.height - v ? ["bottom"] : [],
                                r.x < m / 2 ? b.push("left") : r.x > this._map.transform.width - m / 2 && b.push("right"),
                                s = b.length === 0 ? "bottom" : b.join("-")
                            }
                            let d = r.add(c[s]);
                            this.options.subpixelPositioning || (d = d.round()),
                            X.setTransform(this._container, `${ms[s]} translate(${d.x}px,${d.y}px)`),
                            Ri(this._container, s, "popup"),
                            this._updateOpacity()
                        }
                        ,
                        this._onClose = () => {
                            this.remove()
                        }
                        ,
                        this.options = o.e(Object.create(Bo), h)
                    }
                    addTo(h) {
                        return this._map && this.remove(),
                        this._map = h,
                        this.options.closeOnClick && this._map.on("click", this._onClose),
                        this.options.closeOnMove && this._map.on("move", this._onClose),
                        this._map.on("remove", this.remove),
                        this._update(),
                        this._focusFirstElement(),
                        this._trackPointer ? (this._map.on("mousemove", this._onMouseMove),
                        this._map.on("mouseup", this._onMouseUp),
                        this._container && this._container.classList.add("maplibregl-popup-track-pointer"),
                        this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update),
                        this.fire(new o.l("open")),
                        this
                    }
                    isOpen() {
                        return !!this._map
                    }
                    getLngLat() {
                        return this._lngLat
                    }
                    setLngLat(h) {
                        return this._lngLat = o.S.convert(h),
                        this._pos = null,
                        this._flatPos = null,
                        this._trackPointer = !1,
                        this._update(),
                        this._map && (this._map.on("move", this._update),
                        this._map.off("mousemove", this._onMouseMove),
                        this._container && this._container.classList.remove("maplibregl-popup-track-pointer"),
                        this._map._canvasContainer.classList.remove("maplibregl-track-pointer")),
                        this
                    }
                    trackPointer() {
                        return this._trackPointer = !0,
                        this._pos = null,
                        this._flatPos = null,
                        this._update(),
                        this._map && (this._map.off("move", this._update),
                        this._map.on("mousemove", this._onMouseMove),
                        this._map.on("drag", this._onDrag),
                        this._container && this._container.classList.add("maplibregl-popup-track-pointer"),
                        this._map._canvasContainer.classList.add("maplibregl-track-pointer")),
                        this
                    }
                    getElement() {
                        return this._container
                    }
                    setText(h) {
                        return this.setDOMContent(document.createTextNode(h))
                    }
                    setHTML(h) {
                        const e = document.createDocumentFragment()
                          , r = document.createElement("body");
                        let s;
                        for (r.innerHTML = h; s = r.firstChild,
                        s; )
                            e.appendChild(s);
                        return this.setDOMContent(e)
                    }
                    getMaxWidth() {
                        var h;
                        return (h = this._container) === null || h === void 0 ? void 0 : h.style.maxWidth
                    }
                    setMaxWidth(h) {
                        return this.options.maxWidth = h,
                        this._update(),
                        this
                    }
                    setDOMContent(h) {
                        if (this._content)
                            for (; this._content.hasChildNodes(); )
                                this._content.firstChild && this._content.removeChild(this._content.firstChild);
                        else
                            this._content = X.create("div", "maplibregl-popup-content", this._container);
                        return this._content.appendChild(h),
                        this._createCloseButton(),
                        this._update(),
                        this._focusFirstElement(),
                        this
                    }
                    addClassName(h) {
                        return this._container && this._container.classList.add(h),
                        this
                    }
                    removeClassName(h) {
                        return this._container && this._container.classList.remove(h),
                        this
                    }
                    setOffset(h) {
                        return this.options.offset = h,
                        this._update(),
                        this
                    }
                    toggleClassName(h) {
                        if (this._container)
                            return this._container.classList.toggle(h)
                    }
                    setSubpixelPositioning(h) {
                        this.options.subpixelPositioning = h
                    }
                    _createCloseButton() {
                        this.options.closeButton && (this._closeButton = X.create("button", "maplibregl-popup-close-button", this._content),
                        this._closeButton.type = "button",
                        this._closeButton.innerHTML = "&#215;",
                        this._closeButton.addEventListener("click", this._onClose))
                    }
                    _focusFirstElement() {
                        if (!this.options.focusAfterOpen || !this._container)
                            return;
                        const h = this._container.querySelector(Yc);
                        h && h.focus()
                    }
                }
                ,
                C.RasterDEMTileSource = Qt,
                C.RasterTileSource = er,
                C.ScaleControl = class {
                    constructor(h) {
                        this._onMove = () => {
                            El(this._map, this._container, this.options)
                        }
                        ,
                        this.setUnit = e => {
                            this.options.unit = e,
                            El(this._map, this._container, this.options)
                        }
                        ,
                        this.options = Object.assign(Object.assign({}, Kc), h)
                    }
                    getDefaultPosition() {
                        return "bottom-left"
                    }
                    onAdd(h) {
                        return this._map = h,
                        this._container = X.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", h.getContainer()),
                        this._map.on("move", this._onMove),
                        this._onMove(),
                        this._container
                    }
                    onRemove() {
                        X.remove(this._container),
                        this._map.off("move", this._onMove),
                        this._map = void 0
                    }
                }
                ,
                C.ScrollZoomHandler = Xh,
                C.Style = _c,
                C.TerrainControl = class {
                    constructor(h) {
                        this._toggleTerrain = () => {
                            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options),
                            this._updateTerrainIcon()
                        }
                        ,
                        this._updateTerrainIcon = () => {
                            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"),
                            this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"),
                            this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"),
                            this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"),
                            this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"))
                        }
                        ,
                        this.options = h
                    }
                    onAdd(h) {
                        return this._map = h,
                        this._container = X.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._terrainButton = X.create("button", "maplibregl-ctrl-terrain", this._container),
                        X.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"),
                        this._terrainButton.type = "button",
                        this._terrainButton.addEventListener("click", this._toggleTerrain),
                        this._updateTerrainIcon(),
                        this._map.on("terrain", this._updateTerrainIcon),
                        this._container
                    }
                    onRemove() {
                        X.remove(this._container),
                        this._map.off("terrain", this._updateTerrainIcon),
                        this._map = void 0
                    }
                }
                ,
                C.TwoFingersTouchPitchHandler = Vc,
                C.TwoFingersTouchRotateHandler = qc,
                C.TwoFingersTouchZoomHandler = Pa,
                C.TwoFingersTouchZoomRotateHandler = Gc,
                C.VectorTileSource = xr,
                C.VideoSource = $r,
                C.addSourceType = (h, e) => o._(void 0, void 0, void 0, function*() {
                    if (sr(h))
                        throw new Error(`A source type called "${h}" already exists.`);
                    ( (r, s) => {
                        Mr[r] = s
                    }
                    )(h, e)
                }),
                C.clearPrewarmedResources = function() {
                    const h = it;
                    h && (h.isPreloaded() && h.numActive() === 1 ? (h.release(Le),
                    it = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
                }
                ,
                C.createTileMesh = pc,
                C.getMaxParallelImageRequests = function() {
                    return o.a.MAX_PARALLEL_IMAGE_REQUESTS
                }
                ,
                C.getRTLTextPluginStatus = function() {
                    return vr().getRTLTextPluginStatus()
                }
                ,
                C.getVersion = function() {
                    return Jc
                }
                ,
                C.getWorkerCount = function() {
                    return Re.workerCount
                }
                ,
                C.getWorkerUrl = function() {
                    return o.a.WORKER_URL
                }
                ,
                C.importScriptInWorkers = function(h) {
                    return zt().broadcast("IS", h)
                }
                ,
                C.prewarm = function() {
                    ht().acquire(Le)
                }
                ,
                C.setMaxParallelImageRequests = function(h) {
                    o.a.MAX_PARALLEL_IMAGE_REQUESTS = h
                }
                ,
                C.setRTLTextPlugin = function(h, e) {
                    return vr().setRTLTextPlugin(h, e)
                }
                ,
                C.setWorkerCount = function(h) {
                    Re.workerCount = h
                }
                ,
                C.setWorkerUrl = function(h) {
                    o.a.WORKER_URL = h
                }
            });
            var F = _;
            return F
        })
    }(Sd)),
    Sd.exports
}
var rP = tP();
const bd = um(rP);
class Mg {
    constructor(l) {
        hr(this, "gm");
        hr(this, "markers", new Map);
        hr(this, "canvases", new Map);
        hr(this, "canvasSize");
        hr(this, "canvasOpacity", .8);
        this.input = l,
        this.gm = new cc(this.input.tileSize);
        const _ = dv(l.img);
        this.canvasSize = Math.ceil(2e3 / _)
    }
    place([l,_]) {
        const T = this.gm.latLonToPixelsFloor(l, _, this.input.zoom)
          , E = this.getMarkerId(T)
          , F = this.gm.latLonToPixelBoundsLatLon(l, _, this.input.zoom)
          , C = this.input.map;
        if (this.input.markerFn && !this.markers.has(E)) {
            const de = this.input.markerFn();
            de.setLngLat({
                lat: F.min[0],
                lng: (F.max[1] + F.min[1]) / 2
            }).addTo(C),
            this.markers.set(E, de)
        }
        const {key: o, pos: W, innerPos: G} = this.getCanvasPos(T);
        let re = this.canvases.get(o);
        if (!re) {
            const de = this.canvasSize
              , he = W.x * de
              , X = W.y * de
              , le = he + de - 1
              , Se = X + de - 1
              , Ie = this.gm.pixelsToLatLon(he, Se + 1, this.input.zoom)
              , De = this.gm.pixelsToLatLon(le + 1, X, this.input.zoom);
            re = new iP({
                id: `${this.input.id}-${o}`,
                img: this.input.img,
                canvasSize: this.canvasSize,
                coordinates: lm({
                    min: Ie,
                    max: De
                }),
                layerPaint: {
                    "raster-resampling": "nearest",
                    "raster-opacity": this.canvasOpacity
                }
            }),
            re.addTo(this.input.map),
            this.canvases.set(o, re)
        }
        re.place(G.x, G.y)
    }
    clear() {
        const l = this.input.map;
        for (const _ of this.canvases.values())
            _.removeFrom(l),
            _.removeDOM();
        this.canvases.clear();
        for (const _ of this.markers.values())
            _.remove();
        this.markers.clear()
    }
    clearAndPlace(l) {
        this.clear(),
        this.place(l)
    }
    remove([l,_]) {
        let T = !1;
        const E = this.gm.latLonToPixelsFloor(l, _, this.input.zoom)
          , {key: F, innerPos: C} = this.getCanvasPos(E)
          , o = this.canvases.get(F);
        o && (T = o.remove(C.x, C.y),
        o.annotationsCount() === 0 && (this.canvases.delete(F),
        o.removeFrom(this.input.map),
        o.removeDOM()));
        const W = this.getMarkerId(E)
          , G = this.markers.get(W);
        return G == null || G.remove(),
        this.markers.delete(W),
        T
    }
    setCanvasOpacity(l) {
        this.canvasOpacity = l;
        for (const _ of this.canvases.values())
            _.setOpacity(l)
    }
    getMarkerId([l,_]) {
        return `${this.input.id}:${l},${_}`
    }
    getCanvasPos([l,_]) {
        const T = {
            x: Math.floor(l / this.canvasSize),
            y: Math.floor(_ / this.canvasSize)
        }
          , E = {
            x: l % this.canvasSize,
            y: _ % this.canvasSize
        }
          , F = `${T.x},${T.y}`;
        return {
            pos: T,
            innerPos: E,
            key: F
        }
    }
}
class iP {
    constructor(l) {
        hr(this, "annotations", new Set);
        hr(this, "canvas");
        hr(this, "imgSize");
        hr(this, "maps", new Set);
        this.input = l,
        this.imgSize = dv(l.img),
        this.canvas = document.createElement("canvas"),
        this.canvas.width = this.input.canvasSize * this.imgSize,
        this.canvas.height = this.input.canvasSize * this.imgSize
    }
    place(l, _) {
        const T = this.getPixelKey(l, _);
        if (this.annotations.has(T))
            return !1;
        const E = this.canvas.getContext("2d");
        if (E) {
            const F = l * this.imgSize
              , C = _ * this.imgSize;
            E.drawImage(this.input.img, F, C)
        }
        return this.annotations.add(T),
        !0
    }
    remove(l, _) {
        const T = this.getPixelKey(l, _);
        if (!this.annotations.has(T))
            return !1;
        const E = this.canvas.getContext("2d");
        if (E) {
            const F = l * this.imgSize
              , C = _ * this.imgSize;
            E.clearRect(F, C, this.imgSize, this.imgSize)
        }
        return this.annotations.delete(T),
        !0
    }
    addTo(l) {
        const _ = this.input.id;
        l.getSource(_) || l.addSource(_, {
            type: "canvas",
            canvas: this.canvas,
            coordinates: this.input.coordinates
        }),
        l.getLayer(_) || l.addLayer({
            id: _,
            type: "raster",
            source: _,
            paint: this.input.layerPaint
        }),
        this.maps.add(l)
    }
    removeFrom(l) {
        const {id: _} = this.input;
        l.getLayer(_) && l.removeLayer(_),
        l.getSource(_) && l.removeSource(_),
        this.maps.delete(l)
    }
    removeDOM() {
        this.canvas.remove()
    }
    annotationsCount() {
        return this.annotations.size
    }
    setOpacity(l) {
        for (const _ of this.maps.values())
            _.setPaintProperty(this.input.id, "raster-opacity", l)
    }
    getPixelKey(l, _) {
        return `${l},${_}`
    }
}
function dv(x) {
    return Math.max(x.naturalWidth, x.naturalHeight)
}
function nP() {
    return window.matchMedia("(display-mode: standalone)").matches || "standalone"in window.navigator && window.navigator.standalone === !0
}
function aP(x) {
    const l = {
        opaque: !0
    }
      , _ = x.searchParams.get("lat")
      , T = x.searchParams.get("lng");
    _ && T && (l.pos = {
        lat: parseFloat(_),
        lng: parseFloat(T)
    });
    const E = x.searchParams.get("zoom");
    E && (l.zoom = parseFloat(E));
    const F = x.searchParams.get("season");
    F && (l.season = parseInt(F));
    const C = x.searchParams.get("opaque");
    return C && (l.opaque = C !== "0"),
    x.searchParams.get("select") && (l.select = !0),
    l.newUser = !!x.searchParams.get("new-user"),
    l.alliance = !!x.searchParams.get("alliance"),
    l
}
function sP(x, l) {
    return x = new URL(x),
    l.pos !== void 0 && (x.searchParams.set("lat", l.pos.lat.toString()),
    x.searchParams.set("lng", l.pos.lng.toString())),
    l.zoom !== void 0 && x.searchParams.set("zoom", l.zoom.toString()),
    l.season !== void 0 && x.searchParams.set("season", l.season.toString()),
    l.opaque !== void 0 && x.searchParams.set("opaque", l.opaque ? "1" : "0"),
    l.newUser !== void 0 && x.searchParams.set("new-user", l.newUser ? "1" : "0"),
    l.alliance !== void 0 && x.searchParams.set("alliance", l.alliance ? "1" : "0"),
    l.select && x.searchParams.set("alliance", "1"),
    x
}
const Pd = Mn({
    shouldReload: !0
});
var oP = Be('<legend class="fieldset-legend"> </legend>')
  , lP = Be('<span class="text-base-content/80"> </span>')
  , cP = Be('<fieldset class="fieldset"><!> <textarea></textarea> <div class="flex items-center justify-between text-xs"><span class="text-error"> </span> <!></div></fieldset>');
function uP(x, l) {
    Lr(l, !0);
    let _ = At(l, "value", 15)
      , T = At(l, "validate", 15)
      , E = mt("");
    const F = _t( () => {
        var Ie;
        return ((Ie = _()) == null ? void 0 : Ie.length) ?? 0
    }
    );
    T(C);
    function C() {
        return l.min !== void 0 && w(F) < l.min ? (fe(E, w(F) === 0 ? "Required" : `Min. characters: ${l.min}`, !0),
        !1) : l.max !== void 0 && w(F) > l.max ? (fe(E, `Max. characters: ${l.max}`),
        !1) : !0
    }
    Gr( () => {
        var Ie;
        l.max !== void 0 && w(F) > l.max && _((Ie = _()) == null ? void 0 : Ie.substring(0, l.max))
    }
    );
    var o = cP()
      , W = z(o);
    {
        var G = Ie => {
            var De = oP()
              , qe = z(De, !0);
            k(De),
            st( () => Ce(qe, l.label)),
            H(Ie, De)
        }
        ;
        tt(W, Ie => {
            l.label && Ie(G)
        }
        )
    }
    var re = U(W, 2);
    ax(re);
    var de = U(re, 2)
      , he = z(de)
      , X = z(he, !0);
    k(he);
    var le = U(he, 2);
    {
        var Se = Ie => {
            var De = lP()
              , qe = z(De, !0);
            k(De),
            st( () => Ce(qe, l.max - w(F))),
            H(Ie, De)
        }
        ;
        tt(le, Ie => {
            l.max !== void 0 && Ie(Se)
        }
        )
    }
    k(de),
    k(o),
    st( () => {
        Vr(re, 1, `textarea w-full ${l.class ?? ""}`),
        jr(re, "placeholder", l.placeholder),
        Ce(X, w(E))
    }
    ),
    jd(re, _),
    H(x, o),
    Dr()
}
var hP = (x, l) => {
    var _;
    (_ = l()) == null || _.close()
}
  , dP = Be('<dialog class="modal"><div class="modal-box max-w-2xl"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="mb-4 mt-2"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function pP(x, l) {
    Lr(l, !0);
    let _ = At(l, "ref", 15)
      , T = mt(!1)
      , E = mt(Mn(l.description))
      , F = mt(void 0);
    wi( () => {
        const qe = Ne => {
            var Ze;
            Ne.key === "Escape" && ((Ze = _()) == null || Ze.close())
        }
        ;
        return document.addEventListener("keydown", qe),
        () => document.removeEventListener("keydown", qe)
    }
    );
    var C = dP()
      , o = z(C)
      , W = z(o)
      , G = z(W, !0);
    k(W);
    var re = U(W, 2)
      , de = z(re)
      , he = z(de);
    {
        let qe = _t( () => sv());
        uP(he, {
            class: "h-24 rounded-lg",
            get placeholder() {
                return w(qe)
            },
            max: 512,
            get value() {
                return w(E)
            },
            set value(Ne) {
                fe(E, Ne, !0)
            },
            get validate() {
                return w(F)
            },
            set validate(Ne) {
                fe(F, Ne, !0)
            }
        })
    }
    k(de);
    var X = U(de, 2)
      , le = z(X);
    le.__click = [hP, _];
    var Se = z(le, !0);
    k(le);
    var Ie = U(le, 2)
      , De = z(Ie, !0);
    k(Ie),
    k(X),
    k(re),
    k(o),
    di(2),
    k(C),
    Ss(C, qe => _(qe), () => _()),
    st( (qe, Ne, Ze) => {
        Ce(G, qe),
        le.disabled = w(T),
        Ce(Se, Ne),
        Ie.disabled = w(T),
        Ce(De, Ze)
    }
    , [ () => QT(), () => Qf(), () => r3()]),
    _n("submit", re, async () => {
        var qe, Ne, Ze;
        try {
            if (!((qe = w(F)) != null && qe()))
                return;
            fe(T, !0),
            l.description !== w(E) && await ri.updateAllianceDescription(w(E)),
            await ((Ne = l.onsuccess) == null ? void 0 : Ne.call(l, w(E))),
            (Ze = _()) == null || Ze.close()
        } catch (ut) {
            Zr.error(ut.message)
        } finally {
            fe(T, !1)
        }
    }
    ),
    H(x, C),
    Dr()
}
Xi(["click"]);
var fP = (x, l, _) => {
    navigator.clipboard.writeText(w(l).toString()),
    fe(_, !0),
    setTimeout( () => {
        fe(_, !1)
    }
    , 1e3)
}
  , mP = Be('<span class="loading loading-spinner loading-md center-absolute absolute"></span>')
  , _P = Be('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <span class="text-base-content/80 text-sm"> </span> <div class="relative mt-4"><div><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function gP(x, l) {
    Lr(l, !0);
    let _ = At(l, "open", 15)
      , T = mt("")
      , E = mt(!1);
    const F = _t( () => Za.url.origin + `/join?id=${w(T)}`);
    Gr( () => {
        _() && ri.getAllianceInvites().then(rt => {
            fe(T, rt[0], !0)
        }
        ).catch(rt => {
            Zr.error(rt.message)
        }
        )
    }
    ),
    wi( () => {
        const rt = Ue => {
            Ue.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", rt),
        () => document.removeEventListener("keydown", rt)
    }
    );
    var C = _P()
      , o = z(C)
      , W = U(z(o), 2)
      , G = z(W, !0);
    k(W);
    var re = U(W, 2)
      , de = z(re, !0);
    k(re);
    var he = U(re, 2)
      , X = z(he);
    let le;
    var Se = z(X);
    Ea(Se);
    var Ie = U(Se, 2)
      , De = z(Ie);
    let qe;
    De.__click = [fP, F, E];
    var Ne = z(De, !0);
    k(De),
    k(Ie),
    k(X);
    var Ze = U(X, 2);
    {
        var ut = rt => {
            var Ue = mP();
            H(rt, Ue)
        }
        ;
        tt(Ze, rt => {
            w(T) || rt(ut)
        }
        )
    }
    k(he),
    k(o),
    di(2),
    k(C),
    Fn(C, () => rt => {
        Gr( () => {
            _() ? rt.show() : rt.close()
        }
        )
    }
    ),
    st( (rt, Ue, lt, et, Ve, gt) => {
        Ce(G, rt),
        Ce(de, Ue),
        le = Vr(X, 1, "border-base-content/20 rounded-field relative flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5", null, le, lt),
        Yf(Se, et),
        qe = Vr(De, 1, "btn btn-primary", null, qe, Ve),
        Ce(Ne, gt)
    }
    , [ () => H5(), () => K5(), () => ({
        invisible: !w(T)
    }), () => w(F).toString(), () => ({
        "btn-success": w(E)
    }), () => w(E) ? av() : Tf()]),
    _n("close", C, () => _(!1)),
    H(x, C),
    Dr()
}
Xi(["click"]);
var vP = Pr('<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z" fill="#5865F2"></path></svg>');
function pv(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = vP();
    Yt(T, () => ({
        viewBox: "0 0 256 199",
        width: "256",
        height: "199",
        xmlns: "http://www.w3.org/2000/svg",
        preserveAspectRatio: "xMidYMid",
        ..._
    })),
    H(x, T)
}
var yP = async (x, l) => {
    await navigator.clipboard.writeText(l.username),
    Zr.info(pC())
}
  , xP = Be('<span class="tooltip h-4"><button><!></button></span>');
function fh(x, l) {
    Lr(l, !0);
    var _ = xP()
      , T = z(_);
    T.__click = [yP, l];
    var E = z(T);
    pv(E, {
        class: "size-4 opacity-70"
    }),
    k(T),
    k(_),
    st( () => jr(_, "data-tip", `Discord: ${l.username}`)),
    H(x, _),
    Dr()
}
Xi(["click"]);
var bP = Be('<input type="radio" class="tab max-[380px]:px-3"/>')
  , wP = Be('<div class="tabs tabs-border w-max font-medium"></div>');
function hm(x, l) {
    Lr(l, !0);
    const _ = [];
    let T = At(l, "value", 15, "today")
      , E = [{
        value: "today",
        label: Ud()
    }, {
        value: "week",
        label: dT()
    }, {
        value: "month",
        label: mT()
    }, {
        value: "all-time",
        label: vT()
    }];
    var F = wP();
    mn(F, 21, () => E, C => C.value, (C, o) => {
        var W = bP();
        Ea(W);
        var G;
        st( () => {
            jr(W, "aria-label", w(o).label),
            G !== (G = w(o).value) && (W.value = (W.__value = w(o).value) ?? "")
        }
        ),
        em(_, [], W, () => (w(o).value,
        T()), T),
        H(C, W)
    }
    ),
    k(F),
    H(x, F),
    Dr()
}
var TP = Pr('<svg><path d="M480-480q33 0 56.5-23.5T560-560q0-33-23.5-56.5T480-640q-33 0-56.5 23.5T400-560q0 33 23.5 56.5T480-480Zm0 400Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"></path></svg>');
function dm(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = TP();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
const CP = typeof window < "u" ? window : void 0;
function SP(x) {
    let l = x.activeElement;
    for (; l != null && l.shadowRoot; ) {
        const _ = l.shadowRoot.activeElement;
        if (_ === l)
            break;
        l = _
    }
    return l
}
var ec, Lu, jg;
let PP = (jg = class {
    constructor(l={}) {
        Sr(this, ec);
        Sr(this, Lu);
        const {window: _=CP, document: T=_ == null ? void 0 : _.document} = l;
        _ !== void 0 && (Hn(this, ec, T),
        Hn(this, Lu, $g(E => {
            const F = Pu(_, "focusin", E)
              , C = Pu(_, "focusout", E);
            return () => {
                F(),
                C()
            }
        }
        )))
    }
    get current() {
        var l;
        return (l = nt(this, Lu)) == null || l.call(this),
        nt(this, ec) ? SP(nt(this, ec)) : null
    }
}
,
ec = new WeakMap,
Lu = new WeakMap,
jg);
new PP;
function IP(x, l) {
    switch (x) {
    case "post":
        Gr(l);
        break;
    case "pre":
        Kf(l);
        break
    }
}
function fv(x, l, _, T={}) {
    const {lazy: E=!1} = T;
    let F = !E
      , C = Array.isArray(x) ? [] : void 0;
    IP(l, () => {
        const o = Array.isArray(x) ? x.map(G => G()) : x();
        if (!F) {
            F = !0,
            C = o;
            return
        }
        const W = so( () => _(o, C));
        return C = o,
        W
    }
    )
}
function uc(x, l, _) {
    fv(x, "post", l, _)
}
function MP(x, l, _) {
    fv(x, "pre", l, _)
}
uc.pre = MP;
function AP(x) {
    const l = x - 1;
    return l * l * l + 1
}
function Yo(x, {from: l, to: _}, T={}) {
    var {delay: E=0, duration: F=rt => Math.sqrt(rt) * 120, easing: C=AP} = T
      , o = getComputedStyle(x)
      , W = o.transform === "none" ? "" : o.transform
      , [G,re] = o.transformOrigin.split(" ").map(parseFloat);
    G /= x.clientWidth,
    re /= x.clientHeight;
    var de = kP(x)
      , he = x.clientWidth / _.width / de
      , X = x.clientHeight / _.height / de
      , le = l.left + l.width * G
      , Se = l.top + l.height * re
      , Ie = _.left + _.width * G
      , De = _.top + _.height * re
      , qe = (le - Ie) * he
      , Ne = (Se - De) * X
      , Ze = l.width / _.width
      , ut = l.height / _.height;
    return {
        delay: E,
        duration: typeof F == "function" ? F(Math.sqrt(qe * qe + Ne * Ne)) : F,
        easing: C,
        css: (rt, Ue) => {
            var lt = Ue * qe
              , et = Ue * Ne
              , Ve = rt + Ue * Ze
              , gt = rt + Ue * ut;
            return `transform: ${W} translate(${lt}px, ${et}px) scale(${Ve}, ${gt});`
        }
    }
}
function kP(x) {
    if ("currentCSSZoom"in x)
        return x.currentCSSZoom;
    for (var l = x, _ = 1; l !== null; )
        _ *= +getComputedStyle(l).zoom,
        l = l.parentElement;
    return _
}
var EP = Be('<span class="loading loading-spinner loading-lg mt-18 mx-auto flex items-center"></span>')
  , zP = Be('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>')
  , LP = Be('<span class="font-flag tooltip ml-0.5"> </span>')
  , DP = (x, l, _) => {
    l.onlastpixelclick({
        lat: w(_).lastLatitude ?? 0,
        lng: w(_).lastLongitude ?? 0
    })
}
  , RP = Be("<button><!></button>")
  , BP = Be('<tr><td class="text-base-content/80 font-medium max-[400px]:hidden"> </td><td><div class="flex items-center gap-2"><!> <span> <span class="ml-0.5"> </span></span> <!> <!></div></td><td class="text-base-content/80 relative text-center font-medium"> <!></td></tr>')
  , FP = Be('<table class="table"><thead class="text-base-content/80"><tr><th class="max-[400px]:hidden"></th><th> </th><th class="text-center max-sm:px-1"> </th></tr></thead><tbody></tbody></table>')
  , OP = Be('<div><!> <div class="mt-4"><!></div></div>');
function NP(x, l) {
    Lr(l, !0);
    let _ = At(l, "reload", 15)
      , T = mt(!0)
      , E = mt([])
      , F = mt(0)
      , C = mt("today")
      , o = {};
    _(W);
    function W() {
        const Se = w(C);
        ri.allianceLeaderboard(l.allianceId, Se).then(Ie => {
            fe(E, Ie),
            o = {
                [Se]: Ie
            },
            fe(T, !1)
        }
        ).catch(Ie => {
            Zr.error(Ie.message)
        }
        )
    }
    uc( () => [w(C)], () => {
        const Se = w(C)
          , Ie = o[Se];
        if (Ie) {
            fe(E, Ie),
            fe(T, !1);
            return
        }
        fe(T, !0),
        ri.allianceLeaderboard(l.allianceId, Se).then(De => {
            fe(E, De),
            o[Se] = De,
            fe(T, !1)
        }
        ).catch(De => {
            Zr.error(De.message)
        }
        )
    }
    );
    var G = OP()
      , re = z(G);
    hm(re, {
        get value() {
            return w(C)
        },
        set value(Se) {
            fe(C, Se, !0)
        }
    });
    var de = U(re, 2)
      , he = z(de);
    {
        var X = Se => {
            var Ie = EP();
            H(Se, Ie)
        }
          , le = Se => {
            var Ie = cr()
              , De = Rt(Ie);
            {
                var qe = Ze => {
                    var ut = zP()
                      , rt = z(ut)
                      , Ue = U(rt);
                    {
                        var lt = Ve => {
                            var gt = wa();
                            st(dt => Ce(gt, dt), [ () => Ud().toLowerCase()]),
                            H(Ve, gt)
                        }
                          , et = Ve => {
                            var gt = cr()
                              , dt = Rt(gt);
                            {
                                var ct = vt => {
                                    var Q = wa();
                                    st(ie => Ce(Q, ie), [ () => am()]),
                                    H(vt, Q)
                                }
                                  , ze = vt => {
                                    var Q = cr()
                                      , ie = Rt(Q);
                                    {
                                        var xe = ue => {
                                            var Le = wa();
                                            st(Re => Ce(Le, Re), [ () => sm()]),
                                            H(ue, Le)
                                        }
                                        ;
                                        tt(ie, ue => {
                                            w(C) === "month" && ue(xe)
                                        }
                                        , !0)
                                    }
                                    H(vt, Q)
                                }
                                ;
                                tt(dt, vt => {
                                    w(C) === "week" ? vt(ct) : vt(ze, !1)
                                }
                                , !0)
                            }
                            H(Ve, gt)
                        }
                        ;
                        tt(Ue, Ve => {
                            w(C) === "today" ? Ve(lt) : Ve(et, !1)
                        }
                        )
                    }
                    k(ut),
                    st(Ve => Ce(rt, `${Ve ?? ""} `), [ () => nm()]),
                    H(Ze, ut)
                }
                  , Ne = Ze => {
                    var ut = FP()
                      , rt = z(ut)
                      , Ue = z(rt)
                      , lt = U(z(Ue))
                      , et = z(lt, !0);
                    k(lt);
                    var Ve = U(lt)
                      , gt = z(Ve, !0);
                    k(Ve),
                    k(Ue),
                    k(rt);
                    var dt = U(rt);
                    mn(dt, 31, () => w(E), ct => ct.userId, (ct, ze, vt) => {
                        const Q = _t( () => {
                            var er;
                            return ((er = Vt.data) == null ? void 0 : er.id) === w(ze).userId
                        }
                        );
                        var ie = BP();
                        let xe;
                        var ue = z(ie)
                          , Le = z(ue, !0);
                        k(ue);
                        var Re = U(ue)
                          , We = z(Re)
                          , it = z(We);
                        ss(it, {
                            class: "size-10 border",
                            get userId() {
                                return w(ze).userId
                            },
                            get pictureUrl() {
                                return w(ze).picture
                            }
                        });
                        var at = U(it, 2)
                          , ht = z(at)
                          , Ft = U(ht)
                          , zt = z(Ft);
                        k(Ft),
                        k(at);
                        var lr = U(at, 2);
                        {
                            var kt = er => {
                                const Qt = _t( () => as(w(ze).equippedFlag));
                                var $t = LP()
                                  , tr = z($t, !0);
                                k($t),
                                st( () => {
                                    jr($t, "data-tip", w(Qt).name),
                                    Ce(tr, w(Qt).flag)
                                }
                                ),
                                H(er, $t)
                            }
                            ;
                            tt(lr, er => {
                                w(ze).equippedFlag && er(kt)
                            }
                            )
                        }
                        var xt = U(lr, 2);
                        {
                            var Pt = er => {
                                fh(er, {
                                    get username() {
                                        return w(ze).discord
                                    }
                                })
                            }
                            ;
                            tt(xt, er => {
                                w(ze).discord && er(Pt)
                            }
                            )
                        }
                        k(We),
                        k(Re);
                        var jt = U(Re)
                          , Lt = z(jt)
                          , nr = U(Lt);
                        {
                            var xr = er => {
                                var Qt = RP();
                                let $t;
                                Qt.__click = [DP, l, ze];
                                var tr = z(Qt);
                                dm(tr, {
                                    class: "size-4"
                                }),
                                k(Qt),
                                st( ($r, zr) => {
                                    $t = Vr(Qt, 1, "btn btn-sm btn-ghost absolute -right-2 top-1/2 !-translate-y-1/2 sm:right-4", null, $t, $r),
                                    jr(Qt, "data-tip", zr)
                                }
                                , [ () => ({
                                    tooltip: w(F) > 640
                                }), () => IT()]),
                                H(er, Qt)
                            }
                            ;
                            tt(nr, er => {
                                w(ze).lastLatitude && w(ze).lastLongitude && er(xr)
                            }
                            )
                        }
                        k(jt),
                        k(ie),
                        st( (er, Qt, $t) => {
                            var tr;
                            xe = Vr(ie, 1, "", null, xe, er),
                            Ce(Le, w(vt) + 1),
                            Vr(at, 1, `font-semibold ${Qt ?? ""}`),
                            Ce(ht, `${(w(Q) ? ((tr = Vt.data) == null ? void 0 : tr.name) ?? w(ze).name : w(ze).name) ?? ""} `),
                            Ce(zt, `#${w(ze).userId ?? ""}`),
                            Ce(Lt, `${$t ?? ""} `)
                        }
                        , [ () => ({
                            "bg-base-200": w(Q)
                        }), () => Xn(w(ze).userId), () => w(ze).pixelsPainted.toLocaleString("en-US")]),
                        Ko(ie, () => Yo, () => ({
                            duration: 200
                        })),
                        H(ct, ie)
                    }
                    ),
                    k(dt),
                    k(ut),
                    st( (ct, ze) => {
                        Ce(et, ct),
                        Ce(gt, ze)
                    }
                    , [ () => om(), () => im()]),
                    H(Ze, ut)
                }
                ;
                tt(De, Ze => {
                    w(E).length === 0 ? Ze(qe) : Ze(Ne, !1)
                }
                , !0)
            }
            H(Se, Ie)
        }
        ;
        tt(he, Se => {
            w(T) ? Se(X) : Se(le, !1)
        }
        )
    }
    k(de),
    k(G),
    Vd("innerWidth", Se => fe(F, Se, !0)),
    H(x, G),
    Dr()
}
Xi(["click"]);
var jP = Pr('<svg><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"></path></svg>');
function pm(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = jP();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var qP = (x, l) => l.onclickback()
  , VP = Be('<div class="badge badge-primary badge-sm badge-soft">ADMIN</div>')
  , ZP = async (x, l) => {
    try {
        w(l).loading = !0,
        await ri.giveAllianceAdmin(w(l).id),
        w(l).role = "admin"
    } catch {
        Zr.error(FC())
    } finally {
        w(l).loading = !1
    }
}
  , $P = async (x, l, _) => {
    try {
        w(l).loading = !0,
        await ri.banAllianceUser(w(l).id),
        _.data = _.data.filter(T => T.id !== w(l).id)
    } catch {
        Zr.error(a3())
    } finally {
        w(l).loading = !1
    }
}
  , UP = Be('<li><button class="btn btn-ghost"> </button></li> <li><button class="btn btn-ghost btn-error not-hover:text-error"> </button></li>', 1)
  , GP = Be('<li><button class="btn btn-ghost text-base-content/80"> </button></li>')
  , HP = Be('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span> <!></div></td><td class="px-0"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 gap-1 border p-2 shadow-sm"><!></ul></div></td></tr>')
  , WP = Be('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>')
  , XP = (x, l, _) => {
    ri.unbanAllianceUser(w(l).id).then( () => {
        _.data = _.data.filter(T => T.id !== w(l).id)
    }
    ).catch(T => Zr.error(T.message)).finally( () => {
        w(l).loading = !1
    }
    )
}
  , KP = Be('<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span></div></td><td class="px-0"><button class="btn btn-error"> </button></td></tr>')
  , YP = Be('<div class="text-base-content/80 mt-4 flex justify-center"> </div>')
  , JP = Be('<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>')
  , QP = Be('<div><section class="mt-2 flex items-center gap-1"><button class="btn btn-ghost btn-circle"><!></button> <h2 class="text-xl font-semibold"> </h2></section> <div class="tabs tabs-border mt-2"><input type="radio" name="members_tabs" class="tab" checked/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!></div> <input type="radio" name="members_tabs" class="tab"/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!> <!></div></div></div>');
function eI(x, l) {
    Lr(l, !0);
    let _ = Mn({
        data: [],
        page: 0,
        hasNextPage: !0,
        loading: !1
    })
      , T = Mn({
        data: [],
        page: 0,
        hasNextPage: !0,
        loading: !1
    });
    var E = QP()
      , F = z(E)
      , C = z(F);
    C.__click = [qP, l];
    var o = z(C);
    xx(o, {
        class: "size-5"
    }),
    k(C);
    var W = U(C, 2)
      , G = z(W, !0);
    k(W),
    k(F);
    var re = U(F, 2)
      , de = z(re);
    Ea(de);
    var he = U(de, 2)
      , X = z(he)
      , le = z(X);
    mn(le, 21, () => _.data, et => et.id, (et, Ve, gt) => {
        const dt = _t( () => {
            var kt;
            return ((kt = Vt.data) == null ? void 0 : kt.id) === w(Ve).id
        }
        );
        var ct = HP()
          , ze = z(ct)
          , vt = z(ze)
          , Q = z(vt);
        ss(Q, {
            class: "size-10 border",
            get userId() {
                return w(Ve).id
            },
            get pictureUrl() {
                return w(Ve).picture
            }
        });
        var ie = U(Q, 2)
          , xe = z(ie);
        k(ie);
        var ue = U(ie, 2);
        {
            var Le = kt => {
                var xt = VP();
                H(kt, xt)
            }
            ;
            tt(ue, kt => {
                w(Ve).role === "admin" && kt(Le)
            }
            )
        }
        k(vt),
        k(ze);
        var Re = U(ze)
          , We = z(Re)
          , it = z(We)
          , at = z(it);
        pm(at, {
            class: "size-4"
        }),
        k(it);
        var ht = U(it, 2)
          , Ft = z(ht);
        {
            var zt = kt => {
                var xt = UP()
                  , Pt = Rt(xt)
                  , jt = z(Pt);
                jt.__click = [ZP, Ve];
                var Lt = z(jt, !0);
                k(jt),
                k(Pt);
                var nr = U(Pt, 2)
                  , xr = z(nr);
                xr.__click = [$P, Ve, _];
                var er = z(xr, !0);
                k(xr),
                k(nr),
                st( (Qt, $t) => {
                    jt.disabled = w(Ve).loading,
                    Ce(Lt, Qt),
                    xr.disabled = w(Ve).loading,
                    Ce(er, $t)
                }
                , [ () => NT(), () => ov()]),
                H(kt, xt)
            }
              , lr = kt => {
                var xt = GP()
                  , Pt = z(xt);
                Pt.disabled = !0;
                var jt = z(Pt, !0);
                k(Pt),
                k(xt),
                st(Lt => Ce(jt, Lt), [ () => $T()]),
                H(kt, xt)
            }
            ;
            tt(Ft, kt => {
                w(Ve).role === "member" ? kt(zt) : kt(lr, !1)
            }
            )
        }
        k(ht),
        k(We),
        k(Re),
        k(ct),
        st(kt => {
            var xt;
            Vr(ie, 1, `font-semibold ${kt ?? ""}`),
            Ce(xe, `${(w(dt) ? ((xt = Vt.data) == null ? void 0 : xt.name) ?? w(Ve).name : w(Ve).name) ?? ""} #${w(Ve).id ?? ""}`)
        }
        , [ () => Xn(w(Ve).id)]),
        H(et, ct)
    }
    ),
    k(le),
    k(X);
    var Se = U(X, 2);
    {
        var Ie = et => {
            var Ve = cr()
              , gt = Rt(Ve);
            Iu(gt, () => _.page, dt => {
                var ct = WP();
                Fn(ct, () => ze => {
                    const vt = new IntersectionObserver(Q => {
                        Q[0].isIntersecting && !_.loading && (_.loading = !0,
                        ri.getAllianceMembers(_.page).then(ie => {
                            _.data = [..._.data, ...ie.data],
                            _.hasNextPage = ie.hasNext,
                            _.page++
                        }
                        ).catch(ie => {
                            Zr.error(ie.message)
                        }
                        ).finally( () => {
                            _.loading = !1
                        }
                        ))
                    }
                    );
                    return vt.observe(ze),
                    () => {
                        vt.disconnect()
                    }
                }
                ),
                H(dt, ct)
            }
            ),
            H(et, Ve)
        }
        ;
        tt(Se, et => {
            _.hasNextPage && et(Ie)
        }
        )
    }
    k(he);
    var De = U(he, 2)
      , qe = U(De, 2)
      , Ne = z(qe)
      , Ze = z(Ne);
    mn(Ze, 21, () => T.data, et => et.id, (et, Ve, gt) => {
        var dt = KP()
          , ct = z(dt)
          , ze = z(ct)
          , vt = z(ze);
        ss(vt, {
            class: "size-10 border",
            get userId() {
                return w(Ve).id
            },
            get pictureUrl() {
                return w(Ve).picture
            }
        });
        var Q = U(vt, 2)
          , ie = z(Q);
        k(Q),
        k(ze),
        k(ct);
        var xe = U(ct)
          , ue = z(xe);
        ue.__click = [XP, Ve, T];
        var Le = z(ue, !0);
        k(ue),
        k(xe),
        k(dt),
        st( (Re, We) => {
            Vr(Q, 1, `font-semibold ${Re ?? ""}`),
            Ce(ie, `${w(Ve).name ?? ""} #${w(Ve).id ?? ""}`),
            ue.disabled = w(Ve).loading,
            Ce(Le, We)
        }
        , [ () => Xn(w(Ve).id), () => HT()]),
        H(et, dt)
    }
    ),
    k(Ze),
    k(Ne);
    var ut = U(Ne, 2);
    {
        var rt = et => {
            var Ve = YP()
              , gt = z(Ve, !0);
            k(Ve),
            st(dt => Ce(gt, dt), [ () => KT()]),
            H(et, Ve)
        }
        ;
        tt(ut, et => {
            !T.hasNextPage && T.data.length === 0 && et(rt)
        }
        )
    }
    var Ue = U(ut, 2);
    {
        var lt = et => {
            var Ve = cr()
              , gt = Rt(Ve);
            Iu(gt, () => T.page, dt => {
                var ct = JP();
                Fn(ct, () => ze => {
                    const vt = new IntersectionObserver(Q => {
                        Q[0].isIntersecting && !T.loading && (T.loading = !0,
                        ri.getAllianceBannedMembers(T.page).then(ie => {
                            T.data = [...T.data, ...ie.data],
                            T.hasNextPage = ie.hasNext,
                            T.page++
                        }
                        ).catch(ie => {
                            Zr.error(ie.message)
                        }
                        ).finally( () => {
                            T.loading = !1
                        }
                        ))
                    }
                    );
                    return vt.observe(ze),
                    () => {
                        vt.disconnect()
                    }
                }
                ),
                H(dt, ct)
            }
            ),
            H(et, Ve)
        }
        ;
        tt(Ue, et => {
            T.hasNextPage && et(lt)
        }
        )
    }
    k(qe),
    k(re),
    k(E),
    st( (et, Ve, gt) => {
        Ce(G, et),
        jr(de, "aria-label", Ve),
        jr(De, "aria-label", gt)
    }
    , [ () => nv(), () => l3(), () => h3()]),
    H(x, E),
    Dr()
}
Xi(["click"]);
var tI = Be('<span class="label"> </span>')
  , rI = Be('<span class="hidden px-1 text-[10px] peer-focus:block"> </span>')
  , iI = Be('<p class="text-error ml-3 text-sm"> </p>')
  , nI = Be('<div><label><!> <input class="peer" type="text"/> <!></label> <!></div>');
function Sf(x, l) {
    Lr(l, !0);
    let _ = At(l, "value", 15)
      , T = At(l, "validate", 15)
      , E = mt("");
    const F = _t( () => {
        var De;
        return ((De = _()) == null ? void 0 : De.length) ?? 0
    }
    );
    T(C);
    function C() {
        return l.min !== void 0 && w(F) < l.min ? (fe(E, w(F) === 0 ? "Required" : `Min. characters: ${l.min}`, !0),
        !1) : l.max !== void 0 && w(F) > l.max ? (fe(E, `Max. characters: ${l.max}`),
        !1) : !0
    }
    Gr( () => {
        var De;
        l.max !== void 0 && w(F) > l.max && _((De = _()) == null ? void 0 : De.substring(0, l.max))
    }
    );
    var o = nI()
      , W = z(o);
    let G;
    var re = z(W);
    {
        var de = De => {
            var qe = tI()
              , Ne = z(qe, !0);
            k(qe),
            st( () => Ce(Ne, l.label)),
            H(De, qe)
        }
        ;
        tt(re, De => {
            l.label && De(de)
        }
        )
    }
    var he = U(re, 2);
    Ea(he);
    var X = U(he, 2);
    {
        var le = De => {
            var qe = rI()
              , Ne = z(qe, !0);
            k(qe),
            st( () => Ce(Ne, l.max - w(F))),
            H(De, qe)
        }
        ;
        tt(X, De => {
            l.max !== void 0 && De(le)
        }
        )
    }
    k(W);
    var Se = U(W, 2);
    {
        var Ie = De => {
            var qe = iI()
              , Ne = z(qe, !0);
            k(qe),
            st( () => Ce(Ne, w(E))),
            H(De, qe)
        }
        ;
        tt(Se, De => {
            w(E) && De(Ie)
        }
        )
    }
    k(o),
    st(De => {
        G = Vr(W, 1, "input w-full", null, G, De),
        jr(he, "placeholder", l.placeholder),
        jr(he, "maxlength", l.max)
    }
    , [ () => ({
        "input-error": !!w(E)
    })]),
    jd(he, _),
    H(x, o),
    Dr()
}
var aI = (x, l) => {
    var _;
    (_ = l()) == null || _.close()
}
  , sI = Be('<dialog class="modal"><div class="modal-box"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="my-4"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function oI(x, l) {
    Lr(l, !0);
    let _ = At(l, "ref", 15)
      , T = mt(!1)
      , E = mt("")
      , F = mt(void 0);
    wi( () => {
        const qe = Ne => {
            var Ze;
            Ne.key === "Escape" && ((Ze = _()) == null || Ze.close())
        }
        ;
        return document.addEventListener("keydown", qe),
        () => document.removeEventListener("keydown", qe)
    }
    );
    var C = sI()
      , o = z(C)
      , W = z(o)
      , G = z(W, !0);
    k(W);
    var re = U(W, 2)
      , de = z(re)
      , he = z(de);
    {
        let qe = _t( () => wf())
          , Ne = _t( () => LT());
        Sf(he, {
            get label() {
                return w(qe)
            },
            get placeholder() {
                return w(Ne)
            },
            min: 1,
            max: 16,
            get value() {
                return w(E)
            },
            set value(Ze) {
                fe(E, Ze, !0)
            },
            get validate() {
                return w(F)
            },
            set validate(Ze) {
                fe(F, Ze, !0)
            }
        })
    }
    k(de);
    var X = U(de, 2)
      , le = z(X);
    le.__click = [aI, _];
    var Se = z(le, !0);
    k(le);
    var Ie = U(le, 2)
      , De = z(Ie, !0);
    k(Ie),
    k(X),
    k(re),
    k(o),
    di(2),
    k(C),
    Ss(C, qe => _(qe), () => _()),
    st( (qe, Ne, Ze) => {
        Ce(G, qe),
        le.disabled = w(T),
        Ce(Se, Ne),
        Ie.disabled = w(T),
        Ce(De, Ze)
    }
    , [ () => kT(), () => Qf(), () => BT()]),
    _n("submit", re, async () => {
        var qe, Ne;
        try {
            if (!((qe = w(F)) != null && qe()))
                return;
            fe(T, !0);
            const {id: Ze} = await ri.createAlliance(w(E));
            await l.onsuccess(Ze),
            (Ne = _()) == null || Ne.close()
        } catch (Ze) {
            Zr.error(Ze.message)
        } finally {
            fe(T, !1)
        }
    }
    ),
    H(x, C),
    Dr()
}
Xi(["click"]);
var lI = Pr('<svg><path d="M240-120q-45 0-89-22t-71-58q26 0 53-20.5t27-59.5q0-50 35-85t85-35q50 0 85 35t35 85q0 66-47 113t-113 47Zm230-240L360-470l358-358q11-11 27.5-11.5T774-828l54 54q12 12 12 28t-12 28L470-360Z"></path></svg>');
function mh(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = lI();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var cI = Pr('<svg><path d="M160-160v-100.77l527.23-527.77q6.15-5.48 13.57-8.47 7.43-2.99 15.49-2.99t15.62 2.54q7.55 2.54 13.94 9.15l42.69 42.93q6.61 6.38 9.04 14 2.42 7.63 2.42 15.25 0 8.13-2.74 15.56-2.74 7.42-8.72 13.57L260.77-160H160Zm540.15-496.46L760-715.54 715.54-760l-59.08 59.85 43.69 43.69Z"></path></svg>')
  , uI = Pr('<svg><path d="M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z"></path></svg>');
function Pf(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
    var T = cr()
      , E = Rt(T);
    {
        var F = o => {
            var W = cI();
            Yt(W, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, W)
        }
          , C = o => {
            var W = uI();
            Yt(W, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, W)
        }
        ;
        tt(E, o => {
            l.filled ? o(F) : o(C, !1)
        }
        )
    }
    H(x, T)
}
var hI = Pr('<svg><path d="M360-440h80v-110h80v110h80v-190l-120-80-120 80v190ZM480-80Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"></path></svg>');
function dI(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = hI();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var pI = Pr('<svg><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h640q33 0 56.5 23.5T880-720v480q0 33-23.5 56.5T800-160H160Zm320-280L160-640v400h640v-400L480-440Zm0-80 320-200H160l320 200ZM160-640v-80 480-400Z"></path></svg>');
function fI(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = pI();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var mI = Pr('<svg><path d="M720-400v-120H600v-80h120v-120h80v120h120v80H800v120h-80Zm-360-80q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM40-160v-112q0-34 17.5-62.5T104-378q62-31 126-46.5T360-440q66 0 130 15.5T616-378q29 15 46.5 43.5T680-272v112H40Z"></path></svg>');
function _I(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = mI();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var gI = Pr('<svg><path d="M480-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM160-160v-112q0-34 17.5-62.5T224-378q62-31 126-46.5T480-440q66 0 130 15.5T736-378q29 15 46.5 43.5T800-272v112H160Z"></path></svg>');
function Gd(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = gI();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
function vI(x, l="_blank") {
    return x.replaceAll(/https?:\/\/[^\s]+/g, _ => `<a href="${_}"${l ? ` target="${l}"` : ""}>${_}</a>`)
}
var yI = Be('<div class="flex h-full items-center justify-center"><span class="loading loading-spinner loading-xl"></span></div>')
  , xI = async (x, l, _, T) => {
    try {
        fe(l, !0),
        await ri.leaveAlliance(),
        fe(_, !0),
        await T()
    } catch (E) {
        Zr.error(E.message)
    } finally {
        fe(l, !1)
    }
}
  , bI = (x, l) => {
    fe(l, !0)
}
  , wI = Be('<div class="tooltip"><button class="btn"><!></button></div>')
  , TI = (x, l) => {
    var _;
    (_ = w(l)) == null || _.show()
}
  , CI = Be('<button class="text-base-content/50 translate-y-0.5 p-1"><!></button>')
  , SI = Be('<section class="text-base-content/80 highlight-link"><!> <!></section>')
  , PI = Be('<span class="font-semibold"> </span>')
  , II = (x, l) => fe(l, !0)
  , MI = Be('<button class="text-primary font-semibold underline"> </button>')
  , AI = (x, l, _) => {
    var T;
    (T = w(l)) != null && T.hq ? _.onhqclick({
        lat: w(l).hq.latitude,
        lng: w(l).hq.longitude
    }) : _.onhqchange()
}
  , kI = Be('<span class="text-primary underline"> </span>')
  , EI = Be('<span class="text-primary underline"> </span>')
  , zI = Be('<button class="text-base-content/80 p-1"><!></button>')
  , LI = Be('<div class="flex items-center gap-1"><!> <span> <button class="font-semibold"><!></button></span> <!></div>')
  , DI = Be('<section class="flex items-center justify-between"><h2 class="text-xl font-semibold sm:text-3xl"> </h2> <div class="flex items-center gap-1"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 border p-2 shadow-sm"><li><button class="btn btn-soft btn-error"> </button></li></ul></div> <!></div></section> <!> <section class="mt-3"><div class="flex items-center gap-1"><!> <span> <span class="font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span> <!></span></div> <!></section> <section class="mt-6"><h3 class="text-lg font-semibold"> </h3> <div class="mt-1 pb-2"><!></div></section> <!> <!>', 1)
  , RI = (x, l) => {
    var _;
    (_ = w(l)) == null || _.show()
}
  , BI = Be('<div class="flex h-[90%] flex-col items-center justify-center gap-3"><span class="text-base-content/80"> </span> <span class="mt-8 flex items-center gap-2 text-xl font-semibold"><!> </span> <div class="flex w-full justify-center"><div class="divider w-full max-w-sm"> </div></div> <button class="btn btn-xl btn-soft mb-6"><!> </button></div> <!>', 1)
  , FI = Be('<div class="h-full"><!></div>');
function OI(x, l) {
    Lr(l, !0);
    let _ = mt(void 0)
      , T = mt(!0)
      , E = mt(void 0)
      , F = mt(!1)
      , C = mt(void 0)
      , o = mt(!1)
      , W = mt(!1)
      , G = mt( () => {}
    );
    uc( () => l.open, () => {
        l.open && Pd.shouldReload && re()
    }
    ),
    wi( () => {
        const Se = setInterval( () => {
            Pd.shouldReload = !0
        }
        , 1e4);
        return () => {
            clearTimeout(Se)
        }
    }
    );
    async function re() {
        try {
            fe(_, await ri.getAlliance(), !0),
            w(_) && w(G)(),
            fe(T, !1),
            Pd.shouldReload = !1
        } catch (Se) {
            Zr.error(Se.message)
        }
    }
    var de = FI()
      , he = z(de);
    {
        var X = Se => {
            var Ie = yI();
            H(Se, Ie)
        }
          , le = Se => {
            var Ie = cr()
              , De = Rt(Ie);
            {
                var qe = Ze => {
                    eI(Ze, {
                        onclickback: () => fe(W, !1)
                    })
                }
                  , Ne = Ze => {
                    var ut = cr()
                      , rt = Rt(ut);
                    {
                        var Ue = et => {
                            var Ve = DI()
                              , gt = Rt(Ve)
                              , dt = z(gt)
                              , ct = z(dt, !0);
                            k(dt);
                            var ze = U(dt, 2)
                              , vt = z(ze)
                              , Q = z(vt)
                              , ie = z(Q);
                            pm(ie, {
                                class: "size-4"
                            }),
                            k(Q);
                            var xe = U(Q, 2)
                              , ue = z(xe)
                              , Le = z(ue);
                            Le.__click = [xI, F, T, re];
                            var Re = z(Le, !0);
                            k(Le),
                            k(ue),
                            k(xe),
                            k(vt);
                            var We = U(vt, 2);
                            {
                                var it = _r => {
                                    var Ar = wI()
                                      , Tr = z(Ar);
                                    Tr.__click = [bI, o];
                                    var be = z(Tr);
                                    _I(be, {
                                        class: "size-4"
                                    }),
                                    k(Tr),
                                    k(Ar),
                                    st(q => jr(Ar, "data-tip", q), [ () => aT()]),
                                    H(_r, Ar)
                                }
                                ;
                                tt(We, _r => {
                                    w(_).role == "admin" && _r(it)
                                }
                                )
                            }
                            k(ze),
                            k(gt);
                            var at = U(gt, 2);
                            {
                                var ht = _r => {
                                    var Ar = SI()
                                      , Tr = z(Ar);
                                    yx(Tr, () => vI(w(_).description || sv()));
                                    var be = U(Tr, 2);
                                    {
                                        var q = V => {
                                            var K = CI();
                                            K.__click = [TI, C];
                                            var ae = z(K);
                                            Pf(ae, {
                                                class: "size-4"
                                            }),
                                            k(K),
                                            H(V, K)
                                        }
                                        ;
                                        tt(be, V => {
                                            w(_).role === "admin" && V(q)
                                        }
                                        )
                                    }
                                    k(Ar),
                                    H(_r, Ar)
                                }
                                ;
                                tt(at, _r => {
                                    (w(_).description || w(_).role === "admin") && _r(ht)
                                }
                                )
                            }
                            var Ft = U(at, 2)
                              , zt = z(Ft)
                              , lr = z(zt);
                            mh(lr, {
                                class: "inline size-4"
                            });
                            var kt = U(lr, 2)
                              , xt = z(kt)
                              , Pt = U(xt)
                              , jt = z(Pt, !0);
                            k(Pt),
                            k(kt),
                            k(zt);
                            var Lt = U(zt, 2)
                              , nr = z(Lt);
                            Gd(nr, {
                                class: "inline size-4"
                            });
                            var xr = U(nr, 2)
                              , er = z(xr)
                              , Qt = U(er);
                            {
                                var $t = _r => {
                                    var Ar = PI()
                                      , Tr = z(Ar, !0);
                                    k(Ar),
                                    st(be => Ce(Tr, be), [ () => w(_).members.toLocaleString("en-US")]),
                                    H(_r, Ar)
                                }
                                  , tr = _r => {
                                    var Ar = MI();
                                    Ar.__click = [II, W];
                                    var Tr = z(Ar, !0);
                                    k(Ar),
                                    st(be => Ce(Tr, be), [ () => w(_).members.toLocaleString("en-US")]),
                                    H(_r, Ar)
                                }
                                ;
                                tt(Qt, _r => {
                                    w(_).role === "member" ? _r($t) : _r(tr, !1)
                                }
                                )
                            }
                            k(xr),
                            k(Lt);
                            var $r = U(Lt, 2);
                            {
                                var zr = _r => {
                                    var Ar = LI()
                                      , Tr = z(Ar);
                                    dI(Tr, {
                                        class: "inline size-4"
                                    });
                                    var be = U(Tr, 2)
                                      , q = z(be)
                                      , V = U(q);
                                    V.__click = [AI, _, l];
                                    var K = z(V);
                                    {
                                        var ae = ge => {
                                            var je = kI()
                                              , Oe = z(je);
                                            k(je),
                                            st( (Ee, Ke) => Ce(Oe, `${Ee ?? ""}, ${Ke ?? ""}`), [ () => w(_).hq.latitude.toFixed(3), () => w(_).hq.longitude.toFixed(3)]),
                                            H(ge, je)
                                        }
                                          , we = ge => {
                                            var je = EI()
                                              , Oe = z(je, !0);
                                            k(je),
                                            st(Ee => Ce(Oe, Ee), [ () => z5()]),
                                            H(ge, je)
                                        }
                                        ;
                                        tt(K, ge => {
                                            w(_).hq ? ge(ae) : ge(we, !1)
                                        }
                                        )
                                    }
                                    k(V),
                                    k(be);
                                    var Me = U(be, 2);
                                    {
                                        var ke = ge => {
                                            var je = zI();
                                            je.__click = function(...Ee) {
                                                var Ke;
                                                (Ke = l.onhqchange) == null || Ke.apply(this, Ee)
                                            }
                                            ;
                                            var Oe = z(je);
                                            Pf(Oe, {
                                                class: "text-base-content/50 size-4"
                                            }),
                                            k(je),
                                            H(ge, je)
                                        }
                                        ;
                                        tt(Me, ge => {
                                            w(_).role === "admin" && ge(ke)
                                        }
                                        )
                                    }
                                    k(Ar),
                                    st(ge => Ce(q, `${ge ?? ""}: `), [ () => A5()]),
                                    H(_r, Ar)
                                }
                                ;
                                tt($r, _r => {
                                    (w(_).hq || w(_).role === "admin") && _r(zr)
                                }
                                )
                            }
                            k(Ft);
                            var Mr = U(Ft, 2)
                              , sr = z(Mr)
                              , Xt = z(sr, !0);
                            k(sr);
                            var Ir = U(sr, 2)
                              , mr = z(Ir);
                            NP(mr, {
                                get allianceId() {
                                    return w(_).id
                                },
                                get onlastpixelclick() {
                                    return l.onlastpixelclick
                                },
                                get reload() {
                                    return w(G)
                                },
                                set reload(_r) {
                                    fe(G, _r, !0)
                                }
                            }),
                            k(Ir),
                            k(Mr);
                            var vr = U(Mr, 2);
                            pP(vr, {
                                get description() {
                                    return w(_).description
                                },
                                onsuccess: async _r => {
                                    w(_) && (w(_).description = _r)
                                }
                                ,
                                get ref() {
                                    return w(C)
                                },
                                set ref(_r) {
                                    fe(C, _r, !0)
                                }
                            });
                            var br = U(vr, 2);
                            gP(br, {
                                get open() {
                                    return w(o)
                                },
                                set open(_r) {
                                    fe(o, _r, !0)
                                }
                            }),
                            st( (_r, Ar, Tr, be, q) => {
                                Ce(ct, w(_).name),
                                Le.disabled = w(F),
                                Ce(Re, _r),
                                Ce(xt, `${Ar ?? ""}: `),
                                Ce(jt, Tr),
                                Ce(er, `${be ?? ""}: `),
                                Ce(Xt, q)
                            }
                            , [ () => C5(), () => im(), () => w(_).pixelsPainted.toLocaleString("en-US"), () => nv(), () => rm()]),
                            H(et, Ve)
                        }
                          , lt = et => {
                            var Ve = BI()
                              , gt = Rt(Ve)
                              , dt = z(gt)
                              , ct = z(dt);
                            k(dt);
                            var ze = U(dt, 2)
                              , vt = z(ze);
                            fI(vt, {
                                class: "size-5"
                            });
                            var Q = U(vt, 1, !0);
                            k(ze);
                            var ie = U(ze, 2)
                              , xe = z(ie)
                              , ue = z(xe, !0);
                            k(xe),
                            k(ie);
                            var Le = U(ie, 2);
                            Le.__click = [RI, E];
                            var Re = z(Le);
                            Gg(Re, {
                                class: "size-6"
                            });
                            var We = U(Re);
                            k(Le),
                            k(gt);
                            var it = U(gt, 2);
                            oI(it, {
                                onsuccess: re,
                                get ref() {
                                    return w(E)
                                },
                                set ref(at) {
                                    fe(E, at, !0)
                                }
                            }),
                            st( (at, ht, Ft, zt) => {
                                Ce(ct, `${at ?? ""}:`),
                                Ce(Q, ht),
                                Ce(ue, Ft),
                                Ce(We, ` ${zt ?? ""}`)
                            }
                            , [ () => R5(), () => O5(), () => q5(), () => $5()]),
                            H(et, Ve)
                        }
                        ;
                        tt(rt, et => {
                            w(_) ? et(Ue) : et(lt, !1)
                        }
                        , !0)
                    }
                    H(Ze, ut)
                }
                ;
                tt(De, Ze => {
                    w(W) ? Ze(qe) : Ze(Ne, !1)
                }
                , !0)
            }
            H(Se, Ie)
        }
        ;
        tt(he, Se => {
            w(T) ? Se(X) : Se(le, !1)
        }
        )
    }
    k(de),
    H(x, de),
    Dr()
}
Xi(["click"]);
var NI = Pr('<svg><path d="M40-160v-160q0-34 23.5-57t56.5-23h131q20 0 38 10t29 27q29 39 71.5 61t90.5 22q49 0 91.5-22t70.5-61q13-17 30.5-27t36.5-10h131q34 0 57 23t23 57v160H640v-91q-35 25-75.5 38T480-200q-43 0-84-13.5T320-252v92H40Zm440-160q-38 0-72-17.5T351-386q-17-25-42.5-39.5T253-440q22-37 93-58.5T480-520q63 0 134 21.5t93 58.5q-29 0-55 14.5T609-386q-22 32-56 49t-73 17ZM160-440q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T280-560q0 50-34.5 85T160-440Zm640 0q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T920-560q0 50-34.5 85T800-440ZM480-560q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T600-680q0 50-34.5 85T480-560Z"></path></svg>');
function Hd(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = NI();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
const jI = x => x;
function qI(x) {
    const l = x - 1;
    return l * l * l + 1
}
function Wn(x, {delay: l=0, duration: _=400, easing: T=jI}={}) {
    const E = +getComputedStyle(x).opacity;
    return {
        delay: l,
        duration: _,
        easing: T,
        css: F => `opacity: ${F * E}`
    }
}
function df(x, {delay: l=0, duration: _=400, easing: T=qI, axis: E="y"}={}) {
    const F = getComputedStyle(x)
      , C = +F.opacity
      , o = E === "y" ? "height" : "width"
      , W = parseFloat(F[o])
      , G = E === "y" ? ["top", "bottom"] : ["left", "right"]
      , re = G.map(De => `${De[0].toUpperCase()}${De.slice(1)}`)
      , de = parseFloat(F[`padding${re[0]}`])
      , he = parseFloat(F[`padding${re[1]}`])
      , X = parseFloat(F[`margin${re[0]}`])
      , le = parseFloat(F[`margin${re[1]}`])
      , Se = parseFloat(F[`border${re[0]}Width`])
      , Ie = parseFloat(F[`border${re[1]}Width`]);
    return {
        delay: l,
        duration: _,
        easing: T,
        css: De => `overflow: hidden;opacity: ${Math.min(De * 20, 1) * C};${o}: ${De * W}px;padding-${G[0]}: ${De * de}px;padding-${G[1]}: ${De * he}px;margin-${G[0]}: ${De * X}px;margin-${G[1]}: ${De * le}px;border-${G[0]}-width: ${De * Se}px;border-${G[1]}-width: ${De * Ie}px;min-${o}: 0`
    }
}
var VI = Be('<dialog class="modal"><div class="modal-box sm:h-11/12 flex max-w-3xl flex-col max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <div class="flex items-center gap-1.5"><!> <h3 class="text-lg font-bold max-sm:text-xl"> </h3></div> <div class="mt-1 grow"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function ZI(x, l) {
    Lr(l, !0);
    let _ = At(l, "open", 15);
    wi( () => {
        const de = he => {
            he.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", de),
        () => document.removeEventListener("keydown", de)
    }
    );
    var T = VI()
      , E = z(T)
      , F = U(z(E), 2)
      , C = z(F);
    Hd(C, {
        class: "size-5 max-sm:size-6"
    });
    var o = U(C, 2)
      , W = z(o, !0);
    k(o),
    k(F);
    var G = U(F, 2)
      , re = z(G);
    OI(re, {
        get open() {
            return _()
        },
        get onhqchange() {
            return l.onhqchange
        },
        get onhqclick() {
            return l.onhqclick
        },
        get onlastpixelclick() {
            return l.onlastpixelclick
        }
    }),
    k(G),
    k(E),
    di(2),
    k(T),
    Fn(T, () => de => {
        Gr( () => {
            _() ? (de.show(),
            Za.url.searchParams.get("alliance") && (Za.url.searchParams.delete("alliance"),
            Ug(Za.url.toString()))) : de.close()
        }
        )
    }
    ),
    st(de => Ce(W, de), [ () => Zd()]),
    _n("close", T, () => _(!1)),
    Cn(2, G, () => Wn, () => ({
        duration: 300
    })),
    H(x, T),
    Dr()
}
var $I = Pr('<svg><path d="M360-240q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240H360ZM200-80q-33 0-56.5-23.5T120-160v-560h80v560h440v80H200Z"></path></svg>')
  , UI = Pr('<svg><path d="M360-240q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240H360Zm0-80h360v-480H360v480ZM200-80q-33 0-56.5-23.5T120-160v-560h80v560h440v80H200Zm160-240v-480 480Z"></path></svg>');
function GI(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
    var T = cr()
      , E = Rt(T);
    {
        var F = o => {
            var W = $I();
            Yt(W, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, W)
        }
          , C = o => {
            var W = UI();
            Yt(W, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, W)
        }
        ;
        tt(E, o => {
            l.filled ? o(F) : o(C, !1)
        }
        )
    }
    H(x, T)
}
var HI = Pr('<svg><path d="M480-320 280-520l56-58 104 104v-326h80v326l104-104 56 58-200 200ZM240-160q-33 0-56.5-23.5T160-240v-120h80v120h480v-120h80v120q0 33-23.5 56.5T720-160H240Z"></path></svg>');
function mv(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = HI();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var WI = Pr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm40-80h480L570-480 450-320l-90-120-120 160Zm-40 80v-560 560Z"></path></svg>');
function XI(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = WI();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        height: "24px",
        viewBox: "0 -960 960 960",
        width: "24px",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var KI = Pr('<svg><path d="M680-80q-50 0-85-35t-35-85q0-6 3-28L282-392q-16 15-37 23.5t-45 8.5q-50 0-85-35t-35-85q0-50 35-85t85-35q24 0 45 8.5t37 23.5l281-164q-2-7-2.5-13.5T560-760q0-50 35-85t85-35q50 0 85 35t35 85q0 50-35 85t-85 35q-24 0-45-8.5T598-672L317-508q2 7 2.5 13.5t.5 14.5q0 8-.5 14.5T317-452l281 164q16-15 37-23.5t45-8.5q50 0 85 35t35 85q0 50-35 85t-85 35Z"></path></svg>');
function _v(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = KI();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
const Xl = {
    hour: 3600 * 1e3,
    min: 60 * 1e3,
    sec: 1e3
};
function zd(x) {
    const l = Math.floor(x / Xl.hour);
    x -= l * Xl.hour;
    const _ = Math.floor(x / Xl.min);
    x -= _ * Xl.min;
    const E = Math.floor(x / Xl.sec).toString().padStart(2, "0");
    return l > 0 ? `${l}:${_.toString().padStart(2, "0")}:${E}` : `${_}:${E}`
}
function YI(x) {
    const l = new Date
      , _ = l.getFullYear()
      , T = String(l.getMonth() + 1).padStart(2, "0")
      , E = String(l.getDate()).padStart(2, "0")
      , F = String(l.getHours()).padStart(2, "0")
      , C = String(l.getMinutes()).padStart(2, "0")
      , o = String(l.getSeconds()).padStart(2, "0");
    return `${_}-${T}-${E} ${F}:${C}:${o}`
}
var JI = (x, l, _) => {
    navigator.clipboard.writeText(l.url.toString()),
    fe(_, !0),
    setTimeout( () => {
        fe(_, !1)
    }
    , 1e3)
}
  , QI = Be('<img class="border-base-content/20 border" alt="Screenshot"/>')
  , eM = Be('<div class="flex w-full items-center justify-center"><span class="loading loading-spinner"></span></div>')
  , tM = async (x, l) => {
    w(l) && (await navigator.clipboard.write([new ClipboardItem({
        "image/png": w(l)
    })]),
    Zr.info(ES()))
}
  , rM = Be('<div><h3 class="mb-1 mt-5 flex items-center gap-1 text-xl font-semibold"><!> </h3> <!> <div class="mt-3 flex items-end justify-end gap-2"><button class="btn"><!> </button> <a class="btn btn-primary"><!> </a></div></div>')
  , iM = Be('<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-xl font-bold"><!> </h3> <div class="border-base-content/20 rounded-field mt-3 flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5"><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function nM(x, l) {
    Lr(l, !0);
    let _ = At(l, "open", 15)
      , T = mt(!1);
    wi( () => {
        const Ne = Ze => {
            Ze.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", Ne),
        () => document.removeEventListener("keydown", Ne)
    }
    );
    let E = mt(null)
      , F = mt("");
    Gr( () => {
        _() ? (l.hideHover(),
        setTimeout( () => {
            l.map.once("render", () => {
                try {
                    l.map.getCanvas().toBlob(Ne => {
                        Ne && (fe(E, Ne, !0),
                        fe(F, URL.createObjectURL(w(E)), !0))
                    }
                    , "image/png")
                } finally {
                    l.showHover()
                }
            }
            )
        }
        , 500)) : w(F) && (URL.revokeObjectURL(w(F)),
        fe(E, null),
        fe(F, ""))
    }
    );
    var C = iM()
      , o = z(C)
      , W = U(z(o), 2)
      , G = z(W);
    _v(G, {
        class: "size-5"
    });
    var re = U(G);
    k(W);
    var de = U(W, 2)
      , he = z(de);
    Ea(he);
    var X = U(he, 2)
      , le = z(X);
    let Se;
    le.__click = [JI, l, T];
    var Ie = z(le, !0);
    k(le),
    k(X),
    k(de);
    var De = U(de, 2);
    {
        var qe = Ne => {
            const Ze = _t( () => {
                var ue;
                return (ue = l.map) == null ? void 0 : ue.getCanvas()
            }
            );
            var ut = rM()
              , rt = z(ut)
              , Ue = z(rt);
            XI(Ue, {
                class: "inline size-5"
            });
            var lt = U(Ue);
            k(rt);
            var et = U(rt, 2);
            {
                var Ve = ue => {
                    var Le = QI();
                    st( () => {
                        jr(Le, "src", w(F)),
                        jr(Le, "width", w(Ze).width),
                        jr(Le, "height", w(Ze).height)
                    }
                    ),
                    H(ue, Le)
                }
                  , gt = ue => {
                    var Le = eM();
                    st( () => lc(Le, `aspect-ratio: ${w(Ze).width / w(Ze).height}`)),
                    H(ue, Le)
                }
                ;
                tt(et, ue => {
                    w(F) ? ue(Ve) : ue(gt, !1)
                }
                )
            }
            var dt = U(et, 2)
              , ct = z(dt);
            ct.__click = [tM, E];
            var ze = z(ct);
            GI(ze, {
                class: "size-5"
            });
            var vt = U(ze);
            k(ct);
            var Q = U(ct, 2)
              , ie = z(Q);
            mv(ie, {
                class: "size-5"
            });
            var xe = U(ie);
            k(Q),
            k(dt),
            k(ut),
            st( (ue, Le, Re, We) => {
                Ce(lt, ` ${ue ?? ""}`),
                Ce(vt, ` ${Le ?? ""}`),
                jr(Q, "href", w(F)),
                jr(Q, "download", `wplace_${Re ?? ""}.png`),
                Ce(xe, ` ${We ?? ""}`)
            }
            , [ () => SS(), () => Tf(), () => YI().replaceAll(" ", "_").replaceAll(":", "-"), () => MS()]),
            Cn(2, ut, () => Wn, () => ({
                duration: 300
            })),
            H(Ne, ut)
        }
        ;
        tt(De, Ne => {
            _() && Ne(qe)
        }
        )
    }
    k(o),
    di(2),
    k(C),
    Fn(C, () => Ne => {
        Gr( () => {
            _() ? Ne.show() : Ne.close()
        }
        )
    }
    ),
    st( (Ne, Ze, ut, rt) => {
        Ce(re, ` ${Ne ?? ""}`),
        Yf(he, Ze),
        Se = Vr(le, 1, "btn btn-primary", null, Se, ut),
        Ce(Ie, rt)
    }
    , [ () => J3(), () => l.url.toString(), () => ({
        "btn-success": w(T)
    }), () => w(T) ? av() : Tf()]),
    _n("close", C, () => _(!1)),
    H(x, C),
    Dr()
}
Xi(["click"]);
var aM = Pr('<svg><path d="m576-160-56-56 104-104-104-104 56-56 104 104 104-104 56 56-104 104 104 104-56 56-104-104-104 104Zm79-360L513-662l56-56 85 85 170-170 56 57-225 226ZM80-280v-80h360v80H80Zm0-320v-80h360v80H80Z"></path></svg>');
function sM(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = aM();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var oM = Be('<li class="bg-base-200 border-base-content/10 rounded-xl border-2 p-3"> </li>')
  , lM = Be('<div><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> <span class="badge badge-sm badge-error badge-soft ml-1"> </span></h3></div> <div class="text-sm sm:text-base"><ul class="my-3 flex flex-col gap-2 font-medium"></ul> <p class="text-base-content/80 mt-2 text-sm"> </p></div></div>');
function fm(x, l) {
    Lr(l, !1);
    const _ = [J2(), tw(), nw(), ow(), uw(), yw(), pw(), _w()];
    Kg();
    var T = lM()
      , E = z(T)
      , F = z(E);
    sM(F, {
        class: "size-5"
    });
    var C = U(F, 2)
      , o = z(C)
      , W = U(o)
      , G = z(W, !0);
    k(W),
    k(C),
    k(E);
    var re = U(E, 2)
      , de = z(re);
    mn(de, 5, () => _, Jf, (le, Se) => {
        var Ie = oM()
          , De = z(Ie, !0);
        k(Ie),
        st( () => Ce(De, w(Se))),
        H(le, Ie)
    }
    ),
    k(de);
    var he = U(de, 2)
      , X = z(he, !0);
    k(he),
    k(re),
    k(T),
    st( (le, Se, Ie) => {
        Ce(o, `${le ?? ""} `),
        Ce(G, Se),
        Ce(X, Ie)
    }
    , [ () => G2(), () => X2(), () => ww()]),
    H(x, T),
    Dr()
}
var cM = (x, l) => {
    l(!1)
}
  , uM = Be('<dialog class="modal"><div class="modal-box sm:max-h-11/12"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <div class="flex h-full flex-col gap-6"><h2 class="text-xl font-semibold">ðŸ“‘ Updated rules</h2> <section><!></section> <button class="btn btn-primary">Close</button></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function hM(x, l) {
    Lr(l, !0);
    let _ = At(l, "open", 15);
    wi( () => {
        const G = re => {
            re.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", G),
        () => document.removeEventListener("keydown", G)
    }
    );
    var T = uM()
      , E = z(T)
      , F = U(z(E), 2)
      , C = U(z(F), 2)
      , o = z(C);
    fm(o, {}),
    k(C);
    var W = U(C, 2);
    W.__click = [cM, _],
    k(F),
    k(E),
    di(2),
    k(T),
    Fn(T, () => G => {
        Gr( () => {
            _() ? G.show() : G.close()
        }
        )
    }
    ),
    _n("close", T, () => _(!1)),
    H(x, T),
    Dr()
}
Xi(["click"]);
var dM = () => {
    Za.url.searchParams.delete("new-user"),
    Ug(Za.url.toString())
}
  , pM = Be('<dialog class="modal"><div class="modal-box max-h-11/12"><section class="mb-6 flex justify-center"><h2 class="font-pixel flex flex-col justify-center"><span class="text-center text-2xl"> </span> <!></h2></section> <section class="my-2"><!></section> <form class="mt-6 flex justify-center" method="dialog"><button class="btn btn-primary sm:btn-lg"> </button></form></div></dialog>');
function fM(x, l) {
    Lr(l, !0);
    let _ = At(l, "open", 15);
    wi( () => {
        const Se = Ie => {
            Ie.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", Se),
        () => document.removeEventListener("keydown", Se)
    }
    );
    var T = pM()
      , E = z(T)
      , F = z(E)
      , C = z(F)
      , o = z(C)
      , W = z(o, !0);
    k(o);
    var G = U(o, 2);
    Yg(G, {
        hasText: !0,
        size: "medium"
    }),
    k(C),
    k(F);
    var re = U(F, 2)
      , de = z(re);
    fm(de, {}),
    k(re);
    var he = U(re, 2)
      , X = z(he);
    X.__click = [dM];
    var le = z(X, !0);
    k(X),
    k(he),
    k(E),
    k(T),
    Fn(T, () => Se => {
        Gr( () => {
            _() ? Se.show() : Se.close()
        }
        )
    }
    ),
    st( (Se, Ie) => {
        Ce(W, Se),
        Ce(le, Ie)
    }
    , [ () => Z2(), () => Sw()]),
    _n("close", T, () => _(!1)),
    H(x, T),
    Dr()
}
Xi(["click"]);
function mM() {
    const x = navigator.userAgent
      , l = navigator.vendor;
    return /Chrome/.test(x) && /Google Inc/.test(l) ? "Chrome" : /Safari/.test(x) && /Apple Computer/.test(l) ? "Safari" : /Firefox/.test(x) ? "Firefox" : /Edge/.test(x) ? "Edge" : /Opera|OPR/.test(x) ? "Opera" : "Unknown"
}
var _M = Pr('<svg><path d="M358.939 44C384.805 44 405.773 64.9683 405.773 90.834C405.773 116.7 384.805 137.668 358.939 137.668C335.282 137.668 315.725 120.127 312.558 97.3418C311.882 97.5076 311.068 97.7132 310.139 97.9658C307.227 98.7577 303.219 99.9781 298.844 101.688C289.898 105.186 280.227 110.425 274.75 117.568C269.021 125.042 265.37 135.158 263.158 143.737C262.067 147.97 261.355 151.71 260.917 154.385C260.789 155.166 260.687 155.855 260.604 156.437C304.314 157.147 344.347 169.064 375.81 188.514C386.896 180.117 400.712 175.135 415.691 175.135C452.208 175.135 481.811 204.738 481.811 241.254C481.81 267.527 466.485 290.221 444.287 300.885C441.861 377.201 358.696 438.508 256.456 438.508C154.451 438.508 71.4321 377.482 68.6426 301.409C45.8419 290.978 30.0001 267.967 30 241.254C30 204.738 59.6021 175.135 96.1182 175.135C111.321 175.135 125.325 180.267 136.494 188.892C167.617 169.488 207.216 157.484 250.507 156.473C250.517 156.392 250.528 156.307 250.539 156.218C250.646 155.398 250.811 154.224 251.049 152.771C251.524 149.867 252.293 145.823 253.475 141.24C255.808 132.188 259.872 120.54 266.814 111.484C274.011 102.098 285.828 96.04 295.202 92.375C299.987 90.5044 304.348 89.1775 307.514 88.3164C309.099 87.8852 310.394 87.568 311.302 87.3574C311.69 87.2673 312.009 87.1968 312.249 87.1445C314.13 63.0035 334.316 44.0001 358.939 44ZM255.905 334.922C234.07 334.922 213.107 336.328 193.621 338.913C190.267 341.144 188.408 343.008 187.698 344.95C187.085 346.63 187.361 348.283 188.093 350.118C200.137 369.374 217.021 383.431 236.377 389.255C237.939 389.694 239.551 390.118 241.216 390.527C246.165 391.641 251.258 392.225 256.456 392.225C283.556 392.224 307.779 376.436 323.849 351.639C325.103 348.78 325.526 346.501 324.943 344.546C324.28 342.322 322.364 340.66 319.327 339.067C299.52 336.385 278.166 334.922 255.905 334.922ZM167.196 240.151C148.634 240.151 133.586 257.42 133.586 278.721C133.586 300.022 148.634 317.29 167.196 317.29C185.759 317.29 200.806 300.022 200.806 278.721C200.806 257.42 185.759 240.152 167.196 240.151ZM343.512 240.151C324.949 240.152 309.901 257.42 309.901 278.721C309.901 300.022 324.949 317.29 343.512 317.29C362.074 317.29 377.122 300.022 377.122 278.721C377.122 257.42 362.074 240.151 343.512 240.151Z"></path></svg>');
function gM(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = _M();
    Yt(T, () => ({
        viewBox: "0 0 512 512",
        fill: "currentColor",
        xmlns: "http://www.w3.org/2000/svg",
        ..._
    })),
    H(x, T)
}
var vM = Pr('<svg><path fill="#0A0A08" d="M128 23.064c34.177 0 38.225.13 51.722.745 12.48.57 19.258 2.655 23.769 4.408 5.974 2.322 10.238 5.096 14.717 9.575 4.48 4.479 7.253 8.743 9.575 14.717 1.753 4.511 3.838 11.289 4.408 23.768.615 13.498.745 17.546.745 51.723 0 34.178-.13 38.226-.745 51.723-.57 12.48-2.655 19.257-4.408 23.768-2.322 5.974-5.096 10.239-9.575 14.718-4.479 4.479-8.743 7.253-14.717 9.574-4.511 1.753-11.289 3.839-23.769 4.408-13.495.616-17.543.746-51.722.746-34.18 0-38.228-.13-51.723-.746-12.48-.57-19.257-2.655-23.768-4.408-5.974-2.321-10.239-5.095-14.718-9.574-4.479-4.48-7.253-8.744-9.574-14.718-1.753-4.51-3.839-11.288-4.408-23.768-.616-13.497-.746-17.545-.746-51.723 0-34.177.13-38.225.746-51.722.57-12.48 2.655-19.258 4.408-23.769 2.321-5.974 5.095-10.238 9.574-14.717 4.48-4.48 8.744-7.253 14.718-9.575 4.51-1.753 11.288-3.838 23.768-4.408 13.497-.615 17.545-.745 51.723-.745M128 0C93.237 0 88.878.147 75.226.77c-13.625.622-22.93 2.786-31.071 5.95-8.418 3.271-15.556 7.648-22.672 14.764C14.367 28.6 9.991 35.738 6.72 44.155 3.555 52.297 1.392 61.602.77 75.226.147 88.878 0 93.237 0 128c0 34.763.147 39.122.77 52.774.622 13.625 2.785 22.93 5.95 31.071 3.27 8.417 7.647 15.556 14.763 22.672 7.116 7.116 14.254 11.492 22.672 14.763 8.142 3.165 17.446 5.328 31.07 5.95 13.653.623 18.012.77 52.775.77s39.122-.147 52.774-.77c13.624-.622 22.929-2.785 31.07-5.95 8.418-3.27 15.556-7.647 22.672-14.763 7.116-7.116 11.493-14.254 14.764-22.672 3.164-8.142 5.328-17.446 5.95-31.07.623-13.653.77-18.012.77-52.775s-.147-39.122-.77-52.774c-.622-13.624-2.786-22.929-5.95-31.07-3.271-8.418-7.648-15.556-14.764-22.672C227.4 14.368 220.262 9.99 211.845 6.72c-8.142-3.164-17.447-5.328-31.071-5.95C167.122.147 162.763 0 128 0Zm0 62.27C91.698 62.27 62.27 91.7 62.27 128c0 36.302 29.428 65.73 65.73 65.73 36.301 0 65.73-29.428 65.73-65.73 0-36.301-29.429-65.73-65.73-65.73Zm0 108.397c-23.564 0-42.667-19.103-42.667-42.667S104.436 85.333 128 85.333s42.667 19.103 42.667 42.667-19.103 42.667-42.667 42.667Zm83.686-110.994c0 8.484-6.876 15.36-15.36 15.36-8.483 0-15.36-6.876-15.36-15.36 0-8.483 6.877-15.36 15.36-15.36 8.484 0 15.36 6.877 15.36 15.36Z"></path></svg>');
function yM(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = vM();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        preserveAspectRatio: "xMidYMid",
        viewBox: "0 0 256 256",
        ..._
    })),
    H(x, T)
}
var xM = Pr('<svg><path d="M240-640h360v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85h-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640Zm0 480h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Z"></path></svg>');
function Ld(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = xM();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var bM = Be(' <a class="link" href="https://help.constructiononline.com/en/scheduling-webgl-and-hardware-acceleration">link</a>', 1)
  , wM = Be('<span class="link cursor-auto">chrome://settings/system</span>.', 1)
  , TM = Be('<span class="link cursor-auto">edge://settings/system/manageSystem</span>.', 1)
  , CM = Be(' <kbd class="kbd kbd-sm"> </kbd> <!>', 1)
  , SM = Be('<div class="flex h-full flex-col gap-5"><section class="mb-2 flex flex-col items-center justify-center gap-2"><!> <div class="text-center text-sm max-sm:mt-1"> <a class="link" href="https://maplibre.org/" target="_blank">MapLibre</a> | <a class="link" href="https://openfreemap.org/" target="_blank">OpenFreeMap</a> <a class="link" href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a></div> <div class="w-full text-center text-sm"><p><a class="link" href="https://www.reddit.com/r/WplaceLive/comments/1lhzmmq/bug_reports_and_feature_requests/" target="_blank"> </a> <span class="mx-0.5">|</span> <a href="https://discord.gg/nKyDX9JhMT" target="_blank"><!> <span class="link">Discord</span></a> <span class="mx-0.5">|</span> <a href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> <span class="link">Reddit</span></a> <span class="mx-0.5">|</span> <a href="https://www.instagram.com/wplace.live/" target="_blank"><!> <span class="link">Instagram</span></a></p></div></section> <section><h3 class="text-lg font-semibold"> </h3> <iframe class="mt-1 aspect-video w-full bg-black" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="not-touchscreen:hidden text-sm"> <button class="btn btn-square shadow-md"><!></button> </p> <p class="touchscreen:hidden text-sm"> <span class="kbd kbd-xs text-base-content rounded-md"> </span> </p></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="text-sm"><!></p></section> <section><!></section> <div class="grow"></div> <section class="text-base-content/80 w-full text-center text-sm"><p>Email: <a class="link" href="mailto:contact@wplace.live">contact@wplace.live</a></p></section></div>')
  , PM = Be('<dialog class="modal"><div class="modal-box sm:max-h-11/12 max-sm:size-full max-sm:rounded-none max-sm:px-4 sm:max-w-5xl"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>');
function IM(x, l) {
    Lr(l, !0);
    let _ = At(l, "open", 15);
    wi( () => {
        const de = he => {
            he.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", de),
        () => document.removeEventListener("keydown", de)
    }
    );
    const T = mM();
    var E = PM()
      , F = z(E)
      , C = U(z(F), 2);
    {
        var o = de => {
            var he = SM()
              , X = z(he)
              , le = z(X);
            Yg(le, {
                hasText: !0,
                size: "medium"
            });
            var Se = U(le, 2)
              , Ie = z(Se)
              , De = U(Ie, 4);
            di(),
            k(Se);
            var qe = U(Se, 2)
              , Ne = z(qe)
              , Ze = z(Ne)
              , ut = z(Ze, !0);
            k(Ze);
            var rt = U(Ze, 4)
              , Ue = z(rt);
            pv(Ue, {
                class: "mr-0.5 inline size-4"
            }),
            di(2),
            k(rt);
            var lt = U(rt, 4)
              , et = z(lt);
            gM(et, {
                class: "mr-0.5 inline size-4"
            }),
            di(2),
            k(lt);
            var Ve = U(lt, 4)
              , gt = z(Ve);
            yM(gt, {
                class: "mr-0.5 inline size-4"
            }),
            di(2),
            k(Ve),
            k(Ne),
            k(qe),
            k(X);
            var dt = U(X, 2)
              , ct = z(dt)
              , ze = z(ct, !0);
            k(ct);
            var vt = U(ct, 2);
            k(dt);
            var Q = U(dt, 2)
              , ie = z(Q)
              , xe = z(ie, !0);
            k(ie);
            var ue = U(ie, 2)
              , Le = z(ue)
              , Re = U(Le)
              , We = z(Re);
            Ld(We, {
                class: "size-5"
            }),
            k(Re);
            var it = U(Re);
            k(ue);
            var at = U(ue, 2)
              , ht = z(at)
              , Ft = U(ht)
              , zt = z(Ft, !0);
            k(Ft);
            var lr = U(Ft);
            k(at),
            k(Q);
            var kt = U(Q, 2)
              , xt = z(kt)
              , Pt = z(xt, !0);
            k(xt);
            var jt = U(xt, 2)
              , Lt = z(jt);
            {
                var nr = $t => {
                    var tr = bM()
                      , $r = Rt(tr);
                    di(),
                    st(zr => Ce($r, `${zr ?? ""}: `), [ () => GS()]),
                    H($t, tr)
                }
                  , xr = $t => {
                    var tr = CM()
                      , $r = Rt(tr)
                      , zr = U($r)
                      , Mr = z(zr, !0);
                    k(zr);
                    var sr = U(zr)
                      , Xt = U(sr);
                    {
                        var Ir = vr => {
                            var br = wM();
                            di(),
                            H(vr, br)
                        }
                          , mr = vr => {
                            var br = cr()
                              , _r = Rt(br);
                            {
                                var Ar = Tr => {
                                    var be = TM();
                                    di(),
                                    H(Tr, be)
                                }
                                ;
                                tt(_r, Tr => {
                                    T === "Edge" && Tr(Ar)
                                }
                                , !0)
                            }
                            H(vr, br)
                        }
                        ;
                        tt(Xt, vr => {
                            T === "Chrome" ? vr(Ir) : vr(mr, !1)
                        }
                        )
                    }
                    st( (vr, br, _r) => {
                        Ce($r, `${vr ?? ""} `),
                        Ce(Mr, br),
                        Ce(sr, ` ${_r ?? ""} `)
                    }
                    , [ () => FS(), () => jS(), () => ZS()]),
                    H($t, tr)
                }
                ;
                tt(Lt, $t => {
                    T !== "Chrome" && T !== "Edge" ? $t(nr) : $t(xr, !1)
                }
                )
            }
            k(jt),
            k(kt);
            var er = U(kt, 2)
              , Qt = z(er);
            fm(Qt, {}),
            k(er),
            di(4),
            k(he),
            st( ($t, tr, $r, zr, Mr, sr, Xt, Ir, mr, vr, br) => {
                Ce(Ie, `${$t ?? ""} `),
                Ce(De, ` Â©
						${tr ?? ""} `),
                Ce(ut, $r),
                Ce(ze, zr),
                jr(vt, "src", aa.language === "pt" ? "https://www.youtube.com/embed/AcE85QM4iPQ?si=wbeZD8vxOzvlB_Z9" : "https://www.youtube.com/embed/xOXtd-WzRxA?si=fHz8Z6ecXGYrDhkN"),
                Ce(xe, Mr),
                Ce(Le, `${sr ?? ""} `),
                Ce(it, ` ${Xt ?? ""}`),
                Ce(ht, `${Ir ?? ""} `),
                Ce(zt, mr),
                Ce(lr, ` ${vr ?? ""}`),
                Ce(Pt, br)
            }
            , [ () => z1(), () => R1(), () => O1(), () => q1(), () => $1(), () => H1(), () => K1(), () => Q1(), () => rb(), () => ab(), () => DS()]),
            Cn(2, he, () => Wn, () => ({
                duration: 300
            })),
            H(de, he)
        }
        ;
        tt(C, de => {
            _() && de(o)
        }
        )
    }
    k(F);
    var W = U(F, 2)
      , G = z(W)
      , re = z(G, !0);
    k(G),
    k(W),
    k(E),
    Fn(E, () => de => {
        Gr( () => {
            _() ? de.show() : de.close()
        }
        )
    }
    ),
    st(de => Ce(re, de), [ () => Ql()]),
    _n("close", E, () => _(!1)),
    H(x, E),
    Dr()
}
function MM(x) {
    return typeof x == "function"
}
function _h(x) {
    return x !== null && typeof x == "object"
}
const AM = ["string", "number", "bigint", "boolean"];
function If(x) {
    return x == null || AM.includes(typeof x) ? !0 : Array.isArray(x) ? x.every(l => If(l)) : typeof x == "object" ? Object.getPrototypeOf(x) === Object.prototype : !1
}
const Mu = Symbol("box")
  , mm = Symbol("is-writable");
function kM(x) {
    return _h(x) && Mu in x
}
function EM(x) {
    return dr.isBox(x) && mm in x
}
function dr(x) {
    let l = mt(Mn(x));
    return {
        [Mu]: !0,
        [mm]: !0,
        get current() {
            return w(l)
        },
        set current(_) {
            fe(l, _, !0)
        }
    }
}
function zM(x, l) {
    const _ = _t(x);
    return l ? {
        [Mu]: !0,
        [mm]: !0,
        get current() {
            return w(_)
        },
        set current(T) {
            l(T)
        }
    } : {
        [Mu]: !0,
        get current() {
            return x()
        }
    }
}
function LM(x) {
    return dr.isBox(x) ? x : MM(x) ? dr.with(x) : dr(x)
}
function DM(x) {
    return Object.entries(x).reduce( (l, [_,T]) => dr.isBox(T) ? (dr.isWritableBox(T) ? Object.defineProperty(l, _, {
        get() {
            return T.current
        },
        set(E) {
            T.current = E
        }
    }) : Object.defineProperty(l, _, {
        get() {
            return T.current
        }
    }),
    l) : Object.assign(l, {
        [_]: T
    }), {})
}
function RM(x) {
    return dr.isWritableBox(x) ? {
        [Mu]: !0,
        get current() {
            return x.current
        }
    } : x
}
dr.from = LM;
dr.with = zM;
dr.flatten = DM;
dr.readonly = RM;
dr.isBox = kM;
dr.isWritableBox = EM;
function BM(...x) {
    return function(l) {
        var _;
        for (const T of x)
            if (T) {
                if (l.defaultPrevented)
                    return;
                typeof T == "function" ? T.call(this, l) : (_ = T.current) == null || _.call(this, l)
            }
    }
}
var Gl = {}, pf, Ag;
function FM() {
    if (Ag)
        return pf;
    Ag = 1;
    var x = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g
      , l = /\n/g
      , _ = /^\s*/
      , T = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/
      , E = /^:\s*/
      , F = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/
      , C = /^[;\s]*/
      , o = /^\s+|\s+$/g
      , W = `
`
      , G = "/"
      , re = "*"
      , de = ""
      , he = "comment"
      , X = "declaration";
    pf = function(Se, Ie) {
        if (typeof Se != "string")
            throw new TypeError("First argument must be a string");
        if (!Se)
            return [];
        Ie = Ie || {};
        var De = 1
          , qe = 1;
        function Ne(ct) {
            var ze = ct.match(l);
            ze && (De += ze.length);
            var vt = ct.lastIndexOf(W);
            qe = ~vt ? ct.length - vt : qe + ct.length
        }
        function Ze() {
            var ct = {
                line: De,
                column: qe
            };
            return function(ze) {
                return ze.position = new ut(ct),
                lt(),
                ze
            }
        }
        function ut(ct) {
            this.start = ct,
            this.end = {
                line: De,
                column: qe
            },
            this.source = Ie.source
        }
        ut.prototype.content = Se;
        function rt(ct) {
            var ze = new Error(Ie.source + ":" + De + ":" + qe + ": " + ct);
            if (ze.reason = ct,
            ze.filename = Ie.source,
            ze.line = De,
            ze.column = qe,
            ze.source = Se,
            !Ie.silent)
                throw ze
        }
        function Ue(ct) {
            var ze = ct.exec(Se);
            if (ze) {
                var vt = ze[0];
                return Ne(vt),
                Se = Se.slice(vt.length),
                ze
            }
        }
        function lt() {
            Ue(_)
        }
        function et(ct) {
            var ze;
            for (ct = ct || []; ze = Ve(); )
                ze !== !1 && ct.push(ze);
            return ct
        }
        function Ve() {
            var ct = Ze();
            if (!(G != Se.charAt(0) || re != Se.charAt(1))) {
                for (var ze = 2; de != Se.charAt(ze) && (re != Se.charAt(ze) || G != Se.charAt(ze + 1)); )
                    ++ze;
                if (ze += 2,
                de === Se.charAt(ze - 1))
                    return rt("End of comment missing");
                var vt = Se.slice(2, ze - 2);
                return qe += 2,
                Ne(vt),
                Se = Se.slice(ze),
                qe += 2,
                ct({
                    type: he,
                    comment: vt
                })
            }
        }
        function gt() {
            var ct = Ze()
              , ze = Ue(T);
            if (ze) {
                if (Ve(),
                !Ue(E))
                    return rt("property missing ':'");
                var vt = Ue(F)
                  , Q = ct({
                    type: X,
                    property: le(ze[0].replace(x, de)),
                    value: vt ? le(vt[0].replace(x, de)) : de
                });
                return Ue(C),
                Q
            }
        }
        function dt() {
            var ct = [];
            et(ct);
            for (var ze; ze = gt(); )
                ze !== !1 && (ct.push(ze),
                et(ct));
            return ct
        }
        return lt(),
        dt()
    }
    ;
    function le(Se) {
        return Se ? Se.replace(o, de) : de
    }
    return pf
}
var kg;
function OM() {
    if (kg)
        return Gl;
    kg = 1;
    var x = Gl && Gl.__importDefault || function(T) {
        return T && T.__esModule ? T : {
            default: T
        }
    }
    ;
    Object.defineProperty(Gl, "__esModule", {
        value: !0
    }),
    Gl.default = _;
    var l = x(FM());
    function _(T, E) {
        var F = null;
        if (!T || typeof T != "string")
            return F;
        var C = (0,
        l.default)(T)
          , o = typeof E == "function";
        return C.forEach(function(W) {
            if (W.type === "declaration") {
                var G = W.property
                  , re = W.value;
                o ? E(G, re, W) : re && (F = F || {},
                F[G] = re)
            }
        }),
        F
    }
    return Gl
}
var NM = OM();
const Eg = um(NM)
  , jM = Eg.default || Eg
  , qM = /\d/
  , VM = ["-", "_", "/", "."];
function ZM(x="") {
    if (!qM.test(x))
        return x !== x.toLowerCase()
}
function $M(x) {
    const l = [];
    let _ = "", T, E;
    for (const F of x) {
        const C = VM.includes(F);
        if (C === !0) {
            l.push(_),
            _ = "",
            T = void 0;
            continue
        }
        const o = ZM(F);
        if (E === !1) {
            if (T === !1 && o === !0) {
                l.push(_),
                _ = F,
                T = o;
                continue
            }
            if (T === !0 && o === !1 && _.length > 1) {
                const W = _.at(-1);
                l.push(_.slice(0, Math.max(0, _.length - 1))),
                _ = W + F,
                T = o;
                continue
            }
        }
        _ += F,
        T = o,
        E = C
    }
    return l.push(_),
    l
}
function gv(x) {
    return x ? $M(x).map(l => GM(l)).join("") : ""
}
function UM(x) {
    return HM(gv(x || ""))
}
function GM(x) {
    return x ? x[0].toUpperCase() + x.slice(1) : ""
}
function HM(x) {
    return x ? x[0].toLowerCase() + x.slice(1) : ""
}
function wd(x) {
    if (!x)
        return {};
    const l = {};
    function _(T, E) {
        if (T.startsWith("-moz-") || T.startsWith("-webkit-") || T.startsWith("-ms-") || T.startsWith("-o-")) {
            l[gv(T)] = E;
            return
        }
        if (T.startsWith("--")) {
            l[T] = E;
            return
        }
        l[UM(T)] = E
    }
    return jM(x, _),
    l
}
function WM(...x) {
    return (...l) => {
        for (const _ of x)
            typeof _ == "function" && _(...l)
    }
}
function XM(x, l) {
    const _ = RegExp(x, "g");
    return T => {
        if (typeof T != "string")
            throw new TypeError(`expected an argument of type string, but got ${typeof T}`);
        return T.match(_) ? T.replace(_, l) : T
    }
}
const KM = XM(/[A-Z]/, x => `-${x.toLowerCase()}`);
function YM(x) {
    if (!x || typeof x != "object" || Array.isArray(x))
        throw new TypeError(`expected an argument of type object, but got ${typeof x}`);
    return Object.keys(x).map(l => `${KM(l)}: ${x[l]};`).join(`
`)
}
function vv(x={}) {
    return YM(x).replace(`
`, " ")
}
const yv = {
    position: "absolute",
    width: "1px",
    height: "1px",
    padding: "0",
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    borderWidth: "0",
    transform: "translateX(-100%)"
};
vv(yv);
const JM = ["onabort", "onanimationcancel", "onanimationend", "onanimationiteration", "onanimationstart", "onauxclick", "onbeforeinput", "onbeforetoggle", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncompositionend", "oncompositionstart", "oncompositionupdate", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onfocusin", "onfocusout", "onformdata", "ongotpointercapture", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onlostpointercapture", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onpaste", "onpause", "onplay", "onplaying", "onpointercancel", "onpointerdown", "onpointerenter", "onpointerleave", "onpointermove", "onpointerout", "onpointerover", "onpointerup", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onselectionchange", "onselectstart", "onslotchange", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart", "ontransitioncancel", "ontransitionend", "ontransitionrun", "ontransitionstart", "onvolumechange", "onwaiting", "onwebkitanimationend", "onwebkitanimationiteration", "onwebkitanimationstart", "onwebkittransitionend", "onwheel"]
  , QM = new Set(JM);
function e4(x) {
    return QM.has(x)
}
function Ta(...x) {
    const l = {
        ...x[0]
    };
    for (let _ = 1; _ < x.length; _++) {
        const T = x[_];
        if (T) {
            for (const E of Object.keys(T)) {
                const F = l[E]
                  , C = T[E]
                  , o = typeof F == "function"
                  , W = typeof C == "function";
                if (o && e4(E)) {
                    const G = F
                      , re = C;
                    l[E] = BM(G, re)
                } else if (o && W)
                    l[E] = WM(F, C);
                else if (E === "class") {
                    const G = If(F)
                      , re = If(C);
                    G && re ? l[E] = Su(F, C) : G ? l[E] = Su(F) : re && (l[E] = Su(C))
                } else if (E === "style") {
                    const G = typeof F == "object"
                      , re = typeof C == "object"
                      , de = typeof F == "string"
                      , he = typeof C == "string";
                    if (G && re)
                        l[E] = {
                            ...F,
                            ...C
                        };
                    else if (G && he) {
                        const X = wd(C);
                        l[E] = {
                            ...F,
                            ...X
                        }
                    } else if (de && re) {
                        const X = wd(F);
                        l[E] = {
                            ...X,
                            ...C
                        }
                    } else if (de && he) {
                        const X = wd(F)
                          , le = wd(C);
                        l[E] = {
                            ...X,
                            ...le
                        }
                    } else
                        G ? l[E] = F : re ? l[E] = C : de ? l[E] = F : he && (l[E] = C)
                } else
                    l[E] = C !== void 0 ? C : F
            }
            for (const E of Object.getOwnPropertySymbols(T)) {
                const F = l[E]
                  , C = T[E];
                l[E] = C !== void 0 ? C : F
            }
        }
    }
    return typeof l.style == "object" && (l.style = vv(l.style).replaceAll(`
`, " ")),
    l.hidden !== !0 && (l.hidden = void 0,
    delete l.hidden),
    l.disabled !== !0 && (l.disabled = void 0,
    delete l.disabled),
    l
}
const t4 = typeof window < "u" ? window : void 0;
function r4(x) {
    let l = x.activeElement;
    for (; l != null && l.shadowRoot; ) {
        const _ = l.shadowRoot.activeElement;
        if (_ === l)
            break;
        l = _
    }
    return l
}
var tc, Du;
class i4 {
    constructor(l={}) {
        Sr(this, tc);
        Sr(this, Du);
        const {window: _=t4, document: T=_ == null ? void 0 : _.document} = l;
        _ !== void 0 && (Hn(this, tc, T),
        Hn(this, Du, $g(E => {
            const F = Pu(_, "focusin", E)
              , C = Pu(_, "focusout", E);
            return () => {
                F(),
                C()
            }
        }
        )))
    }
    get current() {
        var l;
        return (l = nt(this, Du)) == null || l.call(this),
        nt(this, tc) ? r4(nt(this, tc)) : null
    }
}
tc = new WeakMap,
Du = new WeakMap;
new i4;
var Ru, bs;
class _m {
    constructor(l) {
        Sr(this, Ru);
        Sr(this, bs);
        Hn(this, Ru, l),
        Hn(this, bs, Symbol(l))
    }
    get key() {
        return nt(this, bs)
    }
    exists() {
        return sx(nt(this, bs))
    }
    get() {
        const l = vg(nt(this, bs));
        if (l === void 0)
            throw new Error(`Context "${nt(this, Ru)}" not found`);
        return l
    }
    getOr(l) {
        const _ = vg(nt(this, bs));
        return _ === void 0 ? l : _
    }
    set(l) {
        return ox(nt(this, bs), l)
    }
}
Ru = new WeakMap,
bs = new WeakMap;
function n4(x, l) {
    switch (x) {
    case "post":
        Gr(l);
        break;
    case "pre":
        Kf(l);
        break
    }
}
function xv(x, l, _, T={}) {
    const {lazy: E=!1} = T;
    let F = !E
      , C = Array.isArray(x) ? [] : void 0;
    n4(l, () => {
        const o = Array.isArray(x) ? x.map(G => G()) : x();
        if (!F) {
            F = !0,
            C = o;
            return
        }
        const W = so( () => _(o, C));
        return C = o,
        W
    }
    )
}
function oo(x, l, _) {
    xv(x, "post", l, _)
}
function a4(x, l, _) {
    xv(x, "pre", l, _)
}
oo.pre = a4;
var rc;
class s4 {
    constructor(l, _) {
        Sr(this, rc, mt(void 0));
        _ !== void 0 && fe(nt(this, rc), _, !0),
        oo( () => l(), (T, E) => {
            fe(nt(this, rc), E, !0)
        }
        )
    }
    get current() {
        return w(nt(this, rc))
    }
}
rc = new WeakMap;
function o4(x, l) {
    return setTimeout(l, x)
}
function Hl(x) {
    qg().then(x)
}
const l4 = 1
  , c4 = 9
  , u4 = 11;
function h4(x) {
    return _h(x) && x.nodeType === l4 && typeof x.nodeName == "string"
}
function bv(x) {
    return _h(x) && x.nodeType === c4
}
function d4(x) {
    var l;
    return _h(x) && ((l = x.constructor) == null ? void 0 : l.name) === "VisualViewport"
}
function p4(x) {
    return _h(x) && x.nodeType !== void 0
}
function f4(x) {
    return p4(x) && x.nodeType === u4 && "host"in x
}
function m4(x) {
    return bv(x) ? x : d4(x) ? x.document : (x == null ? void 0 : x.ownerDocument) ?? document
}
function wv(x) {
    var l;
    return f4(x) ? wv(x.host) : bv(x) ? x.defaultView ?? window : h4(x) ? ((l = x.ownerDocument) == null ? void 0 : l.defaultView) ?? window : window
}
function _4(x) {
    let l = x.activeElement;
    for (; l != null && l.shadowRoot; ) {
        const _ = l.shadowRoot.activeElement;
        if (_ === l)
            break;
        l = _
    }
    return l
}
var Bu;
class g4 {
    constructor(l) {
        hr(this, "element");
        Sr(this, Bu, _t( () => this.element.current ? this.element.current.getRootNode() ?? document : document));
        hr(this, "getDocument", () => m4(this.root));
        hr(this, "getWindow", () => this.getDocument().defaultView ?? window);
        hr(this, "getActiveElement", () => _4(this.root));
        hr(this, "isActiveElement", l => l === this.getActiveElement());
        hr(this, "querySelector", l => this.root ? this.root.querySelector(l) : null);
        hr(this, "querySelectorAll", l => this.root ? this.root.querySelectorAll(l) : []);
        hr(this, "setTimeout", (l, _) => this.getWindow().setTimeout(l, _));
        hr(this, "clearTimeout", l => this.getWindow().clearTimeout(l));
        typeof l == "function" ? this.element = dr.with(l) : this.element = l
    }
    get root() {
        return w(nt(this, Bu))
    }
    set root(l) {
        fe(nt(this, Bu), l)
    }
    getElementById(l) {
        return this.root.getElementById(l)
    }
}
Bu = new WeakMap;
function za(x, l) {
    return {
        [Ox()]: _ => dr.isBox(x) ? (x.current = _,
        so( () => l == null ? void 0 : l(_)),
        () => {
            "isConnected"in _ && _.isConnected || (x.current = null,
            l == null || l(null))
        }
        ) : (x(_),
        so( () => l == null ? void 0 : l(_)),
        () => {
            "isConnected"in _ && _.isConnected || (x(null),
            l == null || l(null))
        }
        )
    }
}
function v4(x) {
    return x ? "true" : "false"
}
function y4(x) {
    return x ? "true" : "false"
}
function x4(x) {
    return x ? "" : void 0
}
function b4(x) {
    return x ? "true" : "false"
}
function w4(x) {
    return x ? "" : void 0
}
function T4(x) {
    return x ? !0 : void 0
}
var ic, Fu;
class C4 {
    constructor(l) {
        Sr(this, ic);
        Sr(this, Fu);
        hr(this, "attrs");
        Hn(this, ic, l.getVariant ? l.getVariant() : null),
        Hn(this, Fu, nt(this, ic) ? `data-${nt(this, ic)}-` : `data-${l.component}-`),
        this.getAttr = this.getAttr.bind(this),
        this.selector = this.selector.bind(this),
        this.attrs = Object.fromEntries(l.parts.map(_ => [_, this.getAttr(_)]))
    }
    getAttr(l, _) {
        return _ ? `data-${_}-${l}` : `${nt(this, Fu)}${l}`
    }
    selector(l, _) {
        return `[${this.getAttr(l, _)}]`
    }
}
ic = new WeakMap,
Fu = new WeakMap;
function Tv(x) {
    const l = new C4(x);
    return {
        ...l.attrs,
        selector: l.selector,
        getAttr: l.getAttr
    }
}
const S4 = "ArrowDown"
  , P4 = "ArrowLeft"
  , I4 = "ArrowRight"
  , M4 = "ArrowUp"
  , A4 = "End"
  , k4 = "Enter"
  , E4 = "Home"
  , z4 = "p"
  , L4 = "n"
  , D4 = "j"
  , R4 = "k"
  , B4 = "h"
  , F4 = "l";
function Au() {}
function La(x, l) {
    return `bits-${x}`
}
function O4(x) {
    if (!x)
        return null;
    for (const l of x.childNodes)
        if (l.nodeType !== Node.COMMENT_NODE)
            return l;
    return null
}
globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = {
    current: 0
});
function N4(x="bits") {
    return globalThis.bitsIdCounter.current++,
    `${x}-${globalThis.bitsIdCounter.current}`
}
function j4(x, l) {
    let _ = x.nextElementSibling;
    for (; _; ) {
        if (_.matches(l))
            return _;
        _ = _.nextElementSibling
    }
}
function q4(x, l) {
    let _ = x.previousElementSibling;
    for (; _; ) {
        if (_.matches(l))
            return _;
        _ = _.previousElementSibling
    }
}
function Cv(x) {
    if (typeof CSS < "u" && typeof CSS.escape == "function")
        return CSS.escape(x);
    const l = x.length;
    let _ = -1, T, E = "";
    const F = x.charCodeAt(0);
    if (l === 1 && F === 45)
        return "\\" + x;
    for (; ++_ < l; ) {
        if (T = x.charCodeAt(_),
        T === 0) {
            E += "ï¿½";
            continue
        }
        if (T >= 1 && T <= 31 || T === 127 || _ === 0 && T >= 48 && T <= 57 || _ === 1 && T >= 48 && T <= 57 && F === 45) {
            E += "\\" + T.toString(16) + " ";
            continue
        }
        if (T >= 128 || T === 45 || T === 95 || T >= 48 && T <= 57 || T >= 65 && T <= 90 || T >= 97 && T <= 122) {
            E += x.charAt(_);
            continue
        }
        E += "\\" + x.charAt(_)
    }
    return E
}
const Xo = "data-value"
  , ha = Tv({
    component: "command",
    parts: ["root", "list", "input", "separator", "loading", "empty", "group", "group-items", "group-heading", "item", "viewport", "input-label"]
})
  , Wl = ha.selector("group")
  , ff = ha.selector("group-items")
  , zg = ha.selector("group-heading")
  , Sv = ha.selector("item")
  , mf = `${ha.selector("item")}:not([aria-disabled="true"])`
  , el = new _m("Command.Root")
  , V4 = new _m("Command.List")
  , ku = new _m("Command.Group")
  , Lg = {
    search: "",
    value: "",
    filtered: {
        count: 0,
        items: new Map,
        groups: new Set
    }
};
var nc, Ou, Nu, ju, qu, Vu, Zu, $u, or, Pv, Id, Af, Md, Ad, kd, io, Iv, Mv, kf, bu, Ef, zf, Av, wu, Lf, Df, kv, Tu, Cu, Uu;
const ym = class ym {
    constructor(l) {
        Sr(this, or);
        hr(this, "opts");
        hr(this, "attachment");
        Sr(this, nc, !1);
        Sr(this, Ou, !0);
        hr(this, "sortAfterTick", !1);
        hr(this, "sortAndFilterAfterTick", !1);
        hr(this, "allItems", new Set);
        hr(this, "allGroups", new Map);
        hr(this, "allIds", new Map);
        Sr(this, Nu, mt(0));
        Sr(this, ju, mt(null));
        Sr(this, qu, mt(null));
        Sr(this, Vu, mt(null));
        Sr(this, Zu, mt(Lg));
        Sr(this, $u, mt(Mn(Lg)));
        Sr(this, Uu, _t( () => ({
            id: this.opts.id.current,
            role: "application",
            [ha.root]: "",
            tabindex: -1,
            onkeydown: this.onkeydown,
            ...this.attachment
        })));
        this.opts = l,
        this.attachment = za(this.opts.ref);
        const _ = {
            ...this._commandState,
            value: this.opts.value.current ?? ""
        };
        this._commandState = _,
        this.commandState = _,
        this.onkeydown = this.onkeydown.bind(this)
    }
    static create(l) {
        return el.set(new ym(l))
    }
    get key() {
        return w(nt(this, Nu))
    }
    set key(l) {
        fe(nt(this, Nu), l, !0)
    }
    get viewportNode() {
        return w(nt(this, ju))
    }
    set viewportNode(l) {
        fe(nt(this, ju), l, !0)
    }
    get inputNode() {
        return w(nt(this, qu))
    }
    set inputNode(l) {
        fe(nt(this, qu), l, !0)
    }
    get labelNode() {
        return w(nt(this, Vu))
    }
    set labelNode(l) {
        fe(nt(this, Vu), l, !0)
    }
    get commandState() {
        return w(nt(this, Zu))
    }
    set commandState(l) {
        fe(nt(this, Zu), l)
    }
    get _commandState() {
        return w(nt(this, $u))
    }
    set _commandState(l) {
        fe(nt(this, $u), l, !0)
    }
    setState(l, _, T) {
        Object.is(this._commandState[l], _) || (this._commandState[l] = _,
        l === "search" ? (Nr(this, or, kd).call(this),
        Nr(this, or, Md).call(this)) : l === "value" && (T || Nr(this, or, Iv).call(this)),
        Nr(this, or, Id).call(this))
    }
    setValue(l, _) {
        l !== this.opts.value.current && l === "" && Hl( () => {
            this.key++
        }
        ),
        this.setState("value", l, _),
        this.opts.value.current = l
    }
    getValidItems() {
        const l = this.opts.ref.current;
        return l ? Array.from(l.querySelectorAll(mf)).filter(T => !!T) : []
    }
    getVisibleItems() {
        const l = this.opts.ref.current;
        return l ? Array.from(l.querySelectorAll(Sv)).filter(T => !!T) : []
    }
    get itemsGrid() {
        var o, W, G, re;
        if (!this.isGrid)
            return [];
        const l = this.opts.columns.current ?? 1
          , _ = this.getVisibleItems()
          , T = [[]];
        let E = (o = _[0]) == null ? void 0 : o.getAttribute("data-group")
          , F = 0
          , C = 0;
        for (let de = 0; de < _.length; de++) {
            const he = _[de]
              , X = he == null ? void 0 : he.getAttribute("data-group");
            E !== X ? (E = X,
            F = 1,
            C++,
            T.push([{
                index: de,
                firstRowOfGroup: !0,
                ref: he
            }])) : (F++,
            F > l && (C++,
            F = 1,
            T.push([])),
            (re = T[C]) == null || re.push({
                index: de,
                firstRowOfGroup: ((G = (W = T[C]) == null ? void 0 : W[0]) == null ? void 0 : G.firstRowOfGroup) ?? de === 0,
                ref: he
            }))
        }
        return T
    }
    updateSelectedToIndex(l) {
        const _ = this.getValidItems()[l];
        _ && this.setValue(_.getAttribute(Xo) ?? "")
    }
    updateSelectedByItem(l) {
        const _ = Nr(this, or, io).call(this)
          , T = this.getValidItems()
          , E = T.findIndex(C => C === _);
        let F = T[E + l];
        this.opts.loop.current && (F = E + l < 0 ? T[T.length - 1] : E + l === T.length ? T[0] : T[E + l]),
        F && this.setValue(F.getAttribute(Xo) ?? "")
    }
    updateSelectedByGroup(l) {
        const _ = Nr(this, or, io).call(this);
        let T = _ == null ? void 0 : _.closest(Wl), E;
        for (; T && !E; )
            T = l > 0 ? j4(T, Wl) : q4(T, Wl),
            E = T == null ? void 0 : T.querySelector(mf);
        E ? this.setValue(E.getAttribute(Xo) ?? "") : this.updateSelectedByItem(l)
    }
    registerValue(l, _) {
        var T;
        return l && l === ((T = this.allIds.get(l)) == null ? void 0 : T.value) || this.allIds.set(l, {
            value: l,
            keywords: _
        }),
        this._commandState.filtered.items.set(l, Nr(this, or, Af).call(this, l, _)),
        this.sortAfterTick || (this.sortAfterTick = !0,
        Hl( () => {
            Nr(this, or, Md).call(this),
            this.sortAfterTick = !1
        }
        )),
        () => {
            this.allIds.delete(l)
        }
    }
    registerItem(l, _) {
        return this.allItems.add(l),
        _ && (this.allGroups.has(_) ? this.allGroups.get(_).add(l) : this.allGroups.set(_, new Set([l]))),
        this.sortAndFilterAfterTick || (this.sortAndFilterAfterTick = !0,
        Hl( () => {
            Nr(this, or, kd).call(this),
            Nr(this, or, Md).call(this),
            this.sortAndFilterAfterTick = !1
        }
        )),
        Nr(this, or, Id).call(this),
        () => {
            const T = Nr(this, or, io).call(this);
            this.allIds.delete(l),
            this.allItems.delete(l),
            this.commandState.filtered.items.delete(l),
            Nr(this, or, kd).call(this),
            (T == null ? void 0 : T.getAttribute("id")) === l && Nr(this, or, Ad).call(this),
            Nr(this, or, Id).call(this)
        }
    }
    registerGroup(l) {
        return this.allGroups.has(l) || this.allGroups.set(l, new Set),
        () => {
            this.allIds.delete(l),
            this.allGroups.delete(l)
        }
    }
    get isGrid() {
        return this.opts.columns.current !== null
    }
    onkeydown(l) {
        const _ = this.opts.vimBindings.current && l.ctrlKey;
        switch (l.key) {
        case L4:
        case D4:
            {
                _ && (this.isGrid ? Nr(this, or, Ef).call(this, l) : Nr(this, or, bu).call(this, l));
                break
            }
        case F4:
            {
                _ && this.isGrid && Nr(this, or, bu).call(this, l);
                break
            }
        case S4:
            this.isGrid ? Nr(this, or, Ef).call(this, l) : Nr(this, or, bu).call(this, l);
            break;
        case I4:
            if (!this.isGrid)
                break;
            Nr(this, or, bu).call(this, l);
            break;
        case z4:
        case R4:
            {
                _ && (this.isGrid ? Nr(this, or, Df).call(this, l) : Nr(this, or, Cu).call(this, l));
                break
            }
        case B4:
            {
                _ && this.isGrid && Nr(this, or, Cu).call(this, l);
                break
            }
        case M4:
            this.isGrid ? Nr(this, or, Df).call(this, l) : Nr(this, or, Cu).call(this, l);
            break;
        case P4:
            if (!this.isGrid)
                break;
            Nr(this, or, Cu).call(this, l);
            break;
        case E4:
            l.preventDefault(),
            this.updateSelectedToIndex(0);
            break;
        case A4:
            l.preventDefault(),
            Nr(this, or, kf).call(this);
            break;
        case k4:
            if (!l.isComposing && l.keyCode !== 229) {
                l.preventDefault();
                const T = Nr(this, or, io).call(this);
                T && (T == null || T.click())
            }
        }
    }
    get props() {
        return w(nt(this, Uu))
    }
    set props(l) {
        fe(nt(this, Uu), l)
    }
}
;
nc = new WeakMap,
Ou = new WeakMap,
Nu = new WeakMap,
ju = new WeakMap,
qu = new WeakMap,
Vu = new WeakMap,
Zu = new WeakMap,
$u = new WeakMap,
or = new WeakSet,
Pv = function() {
    return Fx(this._commandState)
}
,
Id = function() {
    nt(this, nc) || (Hn(this, nc, !0),
    Hl( () => {
        var T, E;
        Hn(this, nc, !1);
        const l = Nr(this, or, Pv).call(this);
        !Object.is(this.commandState, l) && (this.commandState = l,
        (E = (T = this.opts.onStateChange) == null ? void 0 : T.current) == null || E.call(T, l))
    }
    ))
}
,
Af = function(l, _) {
    const T = this.opts.filter.current ?? Lv;
    return l ? T(l, this._commandState.search, _) : 0
}
,
Md = function() {
    var C;
    if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
        Nr(this, or, Ad).call(this);
        return
    }
    const l = this._commandState.filtered.items
      , _ = [];
    for (const o of this._commandState.filtered.groups) {
        const W = this.allGroups.get(o);
        let G = 0;
        if (!W) {
            _.push([o, G]);
            continue
        }
        for (const re of W) {
            const de = l.get(re);
            G = Math.max(de ?? 0, G)
        }
        _.push([o, G])
    }
    const T = this.viewportNode
      , E = this.getValidItems().sort( (o, W) => {
        const G = o.getAttribute("data-value")
          , re = W.getAttribute("data-value")
          , de = l.get(G) ?? 0;
        return (l.get(re) ?? 0) - de
    }
    );
    for (const o of E) {
        const W = o.closest(ff);
        if (W) {
            const G = o.parentElement === W ? o : o.closest(`${ff} > *`);
            G && W.appendChild(G)
        } else {
            const G = o.parentElement === T ? o : o.closest(`${ff} > *`);
            G && (T == null || T.appendChild(G))
        }
    }
    const F = _.sort( (o, W) => W[1] - o[1]);
    for (const o of F) {
        const W = T == null ? void 0 : T.querySelector(`${Wl}[${Xo}="${Cv(o[0])}"]`);
        (C = W == null ? void 0 : W.parentElement) == null || C.appendChild(W)
    }
    Nr(this, or, Ad).call(this)
}
,
Ad = function() {
    Hl( () => {
        const l = this.getValidItems().find(E => E.getAttribute("aria-disabled") !== "true")
          , _ = l == null ? void 0 : l.getAttribute(Xo)
          , T = nt(this, Ou) && this.opts.disableInitialScroll.current;
        this.setValue(_ ?? "", T),
        Hn(this, Ou, !1)
    }
    )
}
,
kd = function() {
    var _, T;
    if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
        this._commandState.filtered.count = this.allItems.size;
        return
    }
    this._commandState.filtered.groups = new Set;
    let l = 0;
    for (const E of this.allItems) {
        const F = ((_ = this.allIds.get(E)) == null ? void 0 : _.value) ?? ""
          , C = ((T = this.allIds.get(E)) == null ? void 0 : T.keywords) ?? []
          , o = Nr(this, or, Af).call(this, F, C);
        this._commandState.filtered.items.set(E, o),
        o > 0 && l++
    }
    for (const [E,F] of this.allGroups)
        for (const C of F) {
            const o = this._commandState.filtered.items.get(C);
            if (o && o > 0) {
                this._commandState.filtered.groups.add(E);
                break
            }
        }
    this._commandState.filtered.count = l
}
,
io = function() {
    const l = this.opts.ref.current;
    if (!l)
        return;
    const _ = l.querySelector(`${mf}[data-selected]`);
    if (_)
        return _
}
,
Iv = function() {
    Hl( () => {
        var T, E, F, C, o;
        const l = Nr(this, or, io).call(this);
        if (!l)
            return;
        const _ = (T = l.parentElement) == null ? void 0 : T.parentElement;
        if (_) {
            if (this.isGrid) {
                const W = Nr(this, or, Mv).call(this, l);
                if (l.scrollIntoView({
                    block: "nearest"
                }),
                W) {
                    const G = (E = l == null ? void 0 : l.closest(Wl)) == null ? void 0 : E.querySelector(zg);
                    G == null || G.scrollIntoView({
                        block: "nearest"
                    });
                    return
                }
            } else {
                const W = O4(_);
                if (W && ((F = W.dataset) == null ? void 0 : F.value) === ((C = l.dataset) == null ? void 0 : C.value)) {
                    const G = (o = l == null ? void 0 : l.closest(Wl)) == null ? void 0 : o.querySelector(zg);
                    G == null || G.scrollIntoView({
                        block: "nearest"
                    });
                    return
                }
            }
            l.scrollIntoView({
                block: "nearest"
            })
        }
    }
    )
}
,
Mv = function(l) {
    const _ = this.itemsGrid;
    if (_.length === 0)
        return !1;
    for (let T = 0; T < _.length; T++) {
        const E = _[T];
        if (E !== void 0)
            for (let F = 0; F < E.length; F++) {
                const C = E[F];
                if (!(C === void 0 || C.ref !== l))
                    return C.firstRowOfGroup
            }
    }
    return !1
}
,
kf = function() {
    return this.updateSelectedToIndex(this.getValidItems().length - 1)
}
,
bu = function(l) {
    l.preventDefault(),
    l.metaKey ? Nr(this, or, kf).call(this) : l.altKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(1)
}
,
Ef = function(l) {
    this.opts.columns.current !== null && (l.preventDefault(),
    l.metaKey ? this.updateSelectedByGroup(1) : this.updateSelectedByItem(Nr(this, or, Av).call(this, l)))
}
,
zf = function(l, _) {
    if (_.length === 0)
        return null;
    for (let T = 0; T < _.length; T++) {
        const E = _[T];
        if (E !== void 0)
            for (let F = 0; F < E.length; F++) {
                const C = E[F];
                if (!(C === void 0 || C.ref !== l))
                    return {
                        columnIndex: F,
                        rowIndex: T
                    }
            }
    }
    return null
}
,
Av = function(l) {
    const _ = this.itemsGrid
      , T = Nr(this, or, io).call(this);
    if (!T)
        return 0;
    const E = Nr(this, or, zf).call(this, T, _);
    if (!E)
        return 0;
    let F = null;
    const C = l.altKey ? 1 : 0;
    if (l.altKey && E.rowIndex === _.length - 2 && !this.opts.loop.current)
        F = Nr(this, or, wu).call(this, {
            start: _.length - 1,
            end: _.length,
            expectedColumnIndex: E.columnIndex,
            grid: _
        });
    else if (E.rowIndex === _.length - 1) {
        if (!this.opts.loop.current)
            return 0;
        F = Nr(this, or, wu).call(this, {
            start: 0 + C,
            end: E.rowIndex,
            expectedColumnIndex: E.columnIndex,
            grid: _
        })
    } else
        F = Nr(this, or, wu).call(this, {
            start: E.rowIndex + 1 + C,
            end: _.length,
            expectedColumnIndex: E.columnIndex,
            grid: _
        }),
        F === null && this.opts.loop.current && (F = Nr(this, or, wu).call(this, {
            start: 0,
            end: E.rowIndex,
            expectedColumnIndex: E.columnIndex,
            grid: _
        }));
    return Nr(this, or, Lf).call(this, T, F)
}
,
wu = function({start: l, end: _, grid: T, expectedColumnIndex: E}) {
    var C;
    let F = null;
    for (let o = l; o < _; o++) {
        const W = T[o];
        if (F = ((C = W[E]) == null ? void 0 : C.ref) ?? null,
        F !== null && Td(F)) {
            F = null;
            continue
        }
        if (F === null)
            for (let G = W.length - 1; G >= 0; G--) {
                const re = W[W.length - 1];
                if (!(re === void 0 || Td(re.ref))) {
                    F = re.ref;
                    break
                }
            }
        break
    }
    return F
}
,
Lf = function(l, _) {
    if (_ === null)
        return 0;
    const T = this.getValidItems()
      , E = T.findIndex(C => C === l);
    return T.findIndex(C => C === _) - E
}
,
Df = function(l) {
    this.opts.columns.current !== null && (l.preventDefault(),
    l.metaKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(Nr(this, or, kv).call(this, l)))
}
,
kv = function(l) {
    const _ = this.itemsGrid
      , T = Nr(this, or, io).call(this);
    if (T === void 0)
        return 0;
    const E = Nr(this, or, zf).call(this, T, _);
    if (E === null)
        return 0;
    let F = null;
    const C = l.altKey ? 1 : 0;
    if (l.altKey && E.rowIndex === 1 && this.opts.loop.current === !1)
        F = Nr(this, or, Tu).call(this, {
            start: 0,
            end: 0,
            expectedColumnIndex: E.columnIndex,
            grid: _
        });
    else if (E.rowIndex === 0) {
        if (this.opts.loop.current === !1)
            return 0;
        F = Nr(this, or, Tu).call(this, {
            start: _.length - 1 - C,
            end: E.rowIndex + 1,
            expectedColumnIndex: E.columnIndex,
            grid: _
        })
    } else
        F = Nr(this, or, Tu).call(this, {
            start: E.rowIndex - 1 - C,
            end: 0,
            expectedColumnIndex: E.columnIndex,
            grid: _
        }),
        F === null && this.opts.loop.current && (F = Nr(this, or, Tu).call(this, {
            start: _.length - 1,
            end: E.rowIndex + 1,
            expectedColumnIndex: E.columnIndex,
            grid: _
        }));
    return Nr(this, or, Lf).call(this, T, F)
}
,
Tu = function({start: l, end: _, grid: T, expectedColumnIndex: E}) {
    var C;
    let F = null;
    for (let o = l; o >= _; o--) {
        const W = T[o];
        if (W !== void 0) {
            if (F = ((C = W[E]) == null ? void 0 : C.ref) ?? null,
            F !== null && Td(F)) {
                F = null;
                continue
            }
            if (F === null)
                for (let G = W.length - 1; G >= 0; G--) {
                    const re = W[W.length - 1];
                    if (!(re === void 0 || Td(re.ref))) {
                        F = re.ref;
                        break
                    }
                }
            break
        }
    }
    return F
}
,
Cu = function(l) {
    l.preventDefault(),
    l.metaKey ? this.updateSelectedToIndex(0) : l.altKey ? this.updateSelectedByGroup(-1) : this.updateSelectedByItem(-1)
}
,
Uu = new WeakMap;
let Mf = ym;
function Td(x) {
    return x.getAttribute("aria-disabled") === "true"
}
var Gu, Hu, Wu;
const xm = class xm {
    constructor(l, _) {
        hr(this, "opts");
        hr(this, "root");
        hr(this, "attachment");
        Sr(this, Gu, _t( () => this.root._commandState.filtered.count === 0 && nt(this, Hu) === !1 || this.opts.forceMount.current));
        Sr(this, Hu, !0);
        Sr(this, Wu, _t( () => ({
            id: this.opts.id.current,
            role: "presentation",
            [ha.empty]: "",
            ...this.attachment
        })));
        this.opts = l,
        this.root = _,
        this.attachment = za(this.opts.ref),
        Kf( () => {
            Hn(this, Hu, !1)
        }
        )
    }
    static create(l) {
        return new xm(l,el.get())
    }
    get shouldRender() {
        return w(nt(this, Gu))
    }
    set shouldRender(l) {
        fe(nt(this, Gu), l)
    }
    get props() {
        return w(nt(this, Wu))
    }
    set props(l) {
        fe(nt(this, Wu), l)
    }
}
;
Gu = new WeakMap,
Hu = new WeakMap,
Wu = new WeakMap;
let Rf = xm;
var Xu, Ku, Yu, Ju;
const bm = class bm {
    constructor(l, _) {
        hr(this, "opts");
        hr(this, "root");
        hr(this, "attachment");
        Sr(this, Xu, _t( () => this.opts.forceMount.current || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search ? !0 : this.root._commandState.filtered.groups.has(this.trueValue)));
        Sr(this, Ku, mt(null));
        Sr(this, Yu, mt(""));
        Sr(this, Ju, _t( () => ({
            id: this.opts.id.current,
            role: "presentation",
            hidden: this.shouldRender ? void 0 : !0,
            "data-value": this.trueValue,
            [ha.group]: "",
            ...this.attachment
        })));
        this.opts = l,
        this.root = _,
        this.attachment = za(this.opts.ref),
        this.trueValue = l.value.current ?? l.id.current,
        oo( () => this.trueValue, () => this.root.registerGroup(this.trueValue)),
        Gr( () => this.opts.value.current ? (this.trueValue = this.opts.value.current,
        this.root.registerValue(this.opts.value.current)) : this.headingNode && this.headingNode.textContent ? (this.trueValue = this.headingNode.textContent.trim().toLowerCase(),
        this.root.registerValue(this.trueValue)) : (this.trueValue = `-----${this.opts.id.current}`,
        this.root.registerValue(this.trueValue)))
    }
    static create(l) {
        return ku.set(new bm(l,el.get()))
    }
    get shouldRender() {
        return w(nt(this, Xu))
    }
    set shouldRender(l) {
        fe(nt(this, Xu), l)
    }
    get headingNode() {
        return w(nt(this, Ku))
    }
    set headingNode(l) {
        fe(nt(this, Ku), l, !0)
    }
    get trueValue() {
        return w(nt(this, Yu))
    }
    set trueValue(l) {
        fe(nt(this, Yu), l, !0)
    }
    get props() {
        return w(nt(this, Ju))
    }
    set props(l) {
        fe(nt(this, Ju), l)
    }
}
;
Xu = new WeakMap,
Ku = new WeakMap,
Yu = new WeakMap,
Ju = new WeakMap;
let Bf = bm;
var Qu;
const wm = class wm {
    constructor(l, _) {
        hr(this, "opts");
        hr(this, "group");
        hr(this, "attachment");
        Sr(this, Qu, _t( () => ({
            id: this.opts.id.current,
            [ha["group-heading"]]: "",
            ...this.attachment
        })));
        this.opts = l,
        this.group = _,
        this.attachment = za(this.opts.ref, T => this.group.headingNode = T)
    }
    static create(l) {
        return new wm(l,ku.get())
    }
    get props() {
        return w(nt(this, Qu))
    }
    set props(l) {
        fe(nt(this, Qu), l)
    }
}
;
Qu = new WeakMap;
let Ff = wm;
var eh;
const Tm = class Tm {
    constructor(l, _) {
        hr(this, "opts");
        hr(this, "group");
        hr(this, "attachment");
        Sr(this, eh, _t( () => {
            var l;
            return {
                id: this.opts.id.current,
                role: "group",
                [ha["group-items"]]: "",
                "aria-labelledby": ((l = this.group.headingNode) == null ? void 0 : l.id) ?? void 0,
                ...this.attachment
            }
        }
        ));
        this.opts = l,
        this.group = _,
        this.attachment = za(this.opts.ref)
    }
    static create(l) {
        return new Tm(l,ku.get())
    }
    get props() {
        return w(nt(this, eh))
    }
    set props(l) {
        fe(nt(this, eh), l)
    }
}
;
eh = new WeakMap;
let Of = Tm;
var Dd, th;
const Cm = class Cm {
    constructor(l, _) {
        hr(this, "opts");
        hr(this, "root");
        hr(this, "attachment");
        Sr(this, Dd, _t( () => {
            var _;
            const l = (_ = this.root.viewportNode) == null ? void 0 : _.querySelector(`${Sv}[${Xo}="${Cv(this.root.opts.value.current)}"]`);
            if (l != null)
                return l.getAttribute("id") ?? void 0
        }
        ));
        Sr(this, th, _t( () => {
            var l, _;
            return {
                id: this.opts.id.current,
                type: "text",
                [ha.input]: "",
                autocomplete: "off",
                autocorrect: "off",
                spellcheck: !1,
                "aria-autocomplete": "list",
                role: "combobox",
                "aria-expanded": y4(!0),
                "aria-controls": ((l = this.root.viewportNode) == null ? void 0 : l.id) ?? void 0,
                "aria-labelledby": ((_ = this.root.labelNode) == null ? void 0 : _.id) ?? void 0,
                "aria-activedescendant": w(nt(this, Dd)),
                ...this.attachment
            }
        }
        ));
        this.opts = l,
        this.root = _,
        this.attachment = za(this.opts.ref, T => this.root.inputNode = T),
        oo( () => this.opts.ref.current, () => {
            const T = this.opts.ref.current;
            T && this.opts.autofocus.current && o4(10, () => T.focus())
        }
        ),
        oo( () => this.opts.value.current, () => {
            this.root.commandState.search !== this.opts.value.current && this.root.setState("search", this.opts.value.current)
        }
        )
    }
    static create(l) {
        return new Cm(l,el.get())
    }
    get props() {
        return w(nt(this, th))
    }
    set props(l) {
        fe(nt(this, th), l)
    }
}
;
Dd = new WeakMap,
th = new WeakMap;
let Nf = Cm;
var no, Rd, rh, ih, nh, Qo, Ev, qf, ah;
const Sm = class Sm {
    constructor(l, _) {
        Sr(this, Qo);
        hr(this, "opts");
        hr(this, "root");
        hr(this, "attachment");
        Sr(this, no, null);
        Sr(this, Rd, _t( () => {
            var l;
            return this.opts.forceMount.current || ((l = nt(this, no)) == null ? void 0 : l.opts.forceMount.current) === !0
        }
        ));
        Sr(this, rh, _t( () => {
            if (this.opts.ref.current,
            w(nt(this, Rd)) || this.root.opts.shouldFilter.current === !1 || !this.root.commandState.search)
                return !0;
            const l = this.root.commandState.filtered.items.get(this.trueValue);
            return l === void 0 ? !1 : l > 0
        }
        ));
        Sr(this, ih, _t( () => this.root.opts.value.current === this.trueValue && this.trueValue !== ""));
        Sr(this, nh, mt(""));
        Sr(this, ah, _t( () => {
            var l;
            return {
                id: this.opts.id.current,
                "aria-disabled": v4(this.opts.disabled.current),
                "aria-selected": b4(this.isSelected),
                "data-disabled": x4(this.opts.disabled.current),
                "data-selected": w4(this.isSelected),
                "data-value": this.trueValue,
                "data-group": (l = nt(this, no)) == null ? void 0 : l.trueValue,
                [ha.item]: "",
                role: "option",
                onpointermove: this.onpointermove,
                onclick: this.onclick,
                ...this.attachment
            }
        }
        ));
        this.opts = l,
        this.root = _,
        Hn(this, no, ku.getOr(null)),
        this.trueValue = l.value.current,
        this.attachment = za(this.opts.ref),
        oo([ () => this.trueValue, () => {
            var T;
            return (T = nt(this, no)) == null ? void 0 : T.trueValue
        }
        , () => this.opts.forceMount.current], () => {
            var T;
            if (!this.opts.forceMount.current)
                return this.root.registerItem(this.trueValue, (T = nt(this, no)) == null ? void 0 : T.trueValue)
        }
        ),
        oo([ () => this.opts.value.current, () => this.opts.ref.current], () => {
            var T, E;
            !this.opts.value.current && ((T = this.opts.ref.current) != null && T.textContent) && (this.trueValue = this.opts.ref.current.textContent.trim()),
            this.root.registerValue(this.trueValue, l.keywords.current.map(F => F.trim())),
            (E = this.opts.ref.current) == null || E.setAttribute(Xo, this.trueValue)
        }
        ),
        this.onclick = this.onclick.bind(this),
        this.onpointermove = this.onpointermove.bind(this)
    }
    static create(l) {
        const _ = ku.getOr(null);
        return new Sm({
            ...l,
            group: _
        },el.get())
    }
    get shouldRender() {
        return w(nt(this, rh))
    }
    set shouldRender(l) {
        fe(nt(this, rh), l)
    }
    get isSelected() {
        return w(nt(this, ih))
    }
    set isSelected(l) {
        fe(nt(this, ih), l)
    }
    get trueValue() {
        return w(nt(this, nh))
    }
    set trueValue(l) {
        fe(nt(this, nh), l, !0)
    }
    onpointermove(l) {
        this.opts.disabled.current || this.root.opts.disablePointerSelection.current || Nr(this, Qo, qf).call(this)
    }
    onclick(l) {
        this.opts.disabled.current || Nr(this, Qo, Ev).call(this)
    }
    get props() {
        return w(nt(this, ah))
    }
    set props(l) {
        fe(nt(this, ah), l)
    }
}
;
no = new WeakMap,
Rd = new WeakMap,
rh = new WeakMap,
ih = new WeakMap,
nh = new WeakMap,
Qo = new WeakSet,
Ev = function() {
    var l;
    this.opts.disabled.current || (Nr(this, Qo, qf).call(this),
    (l = this.opts.onSelect) == null || l.current())
}
,
qf = function() {
    this.opts.disabled.current || this.root.setValue(this.trueValue, !0)
}
,
ah = new WeakMap;
let jf = Sm;
var sh;
const Pm = class Pm {
    constructor(l, _) {
        hr(this, "opts");
        hr(this, "root");
        hr(this, "attachment");
        Sr(this, sh, _t( () => ({
            id: this.opts.id.current,
            role: "listbox",
            "aria-label": this.opts.ariaLabel.current,
            [ha.list]: "",
            ...this.attachment
        })));
        this.opts = l,
        this.root = _,
        this.attachment = za(this.opts.ref)
    }
    static create(l) {
        return V4.set(new Pm(l,el.get()))
    }
    get props() {
        return w(nt(this, sh))
    }
    set props(l) {
        fe(nt(this, sh), l)
    }
}
;
sh = new WeakMap;
let Vf = Pm;
var oh;
const Im = class Im {
    constructor(l, _) {
        hr(this, "opts");
        hr(this, "root");
        hr(this, "attachment");
        Sr(this, oh, _t( () => {
            var l;
            return {
                id: this.opts.id.current,
                [ha["input-label"]]: "",
                for: (l = this.opts.for) == null ? void 0 : l.current,
                style: yv,
                ...this.attachment
            }
        }
        ));
        this.opts = l,
        this.root = _,
        this.attachment = za(this.opts.ref, T => this.root.labelNode = T)
    }
    static create(l) {
        return new Im(l,el.get())
    }
    get props() {
        return w(nt(this, oh))
    }
    set props(l) {
        fe(nt(this, oh), l)
    }
}
;
oh = new WeakMap;
let Zf = Im;
var Z4 = Be("<label><!></label>");
function $4(x, l) {
    const _ = $a();
    Lr(l, !0);
    let T = At(l, "id", 19, () => La(_))
      , E = At(l, "ref", 15, null)
      , F = Jt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"]);
    const C = Zf.create({
        id: dr.with( () => T()),
        ref: dr.with( () => E(), re => E(re))
    })
      , o = _t( () => Ta(F, C.props));
    var W = Z4();
    Yt(W, () => ({
        ...w(o)
    }));
    var G = z(W);
    Wi(G, () => l.children ?? Sn),
    k(W),
    H(x, W),
    Dr()
}
var U4 = Be("<!> <!>", 1)
  , G4 = Be("<div><!> <!></div>");
function H4(x, l) {
    const _ = $a();
    Lr(l, !0);
    const T = dt => {
        $4(dt, {
            children: (ct, ze) => {
                di();
                var vt = wa();
                st( () => Ce(vt, he())),
                H(ct, vt)
            }
            ,
            $$slots: {
                default: !0
            }
        })
    }
    ;
    let E = At(l, "id", 19, () => La(_))
      , F = At(l, "ref", 15, null)
      , C = At(l, "value", 15, "")
      , o = At(l, "onValueChange", 3, Au)
      , W = At(l, "onStateChange", 3, Au)
      , G = At(l, "loop", 3, !1)
      , re = At(l, "shouldFilter", 3, !0)
      , de = At(l, "filter", 3, Lv)
      , he = At(l, "label", 3, "")
      , X = At(l, "vimBindings", 3, !0)
      , le = At(l, "disablePointerSelection", 3, !1)
      , Se = At(l, "disableInitialScroll", 3, !1)
      , Ie = At(l, "columns", 3, null)
      , De = Jt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "onValueChange", "onStateChange", "loop", "shouldFilter", "filter", "label", "vimBindings", "disablePointerSelection", "disableInitialScroll", "columns", "children", "child"]);
    const qe = Mf.create({
        id: dr.with( () => E()),
        ref: dr.with( () => F(), dt => F(dt)),
        filter: dr.with( () => de()),
        shouldFilter: dr.with( () => re()),
        loop: dr.with( () => G()),
        value: dr.with( () => C(), dt => {
            C() !== dt && (C(dt),
            o()(dt))
        }
        ),
        vimBindings: dr.with( () => X()),
        disablePointerSelection: dr.with( () => le()),
        disableInitialScroll: dr.with( () => Se()),
        onStateChange: dr.with( () => W()),
        columns: dr.with( () => Ie())
    })
      , Ne = dt => qe.updateSelectedToIndex(dt)
      , Ze = dt => qe.updateSelectedByGroup(dt)
      , ut = dt => qe.updateSelectedByItem(dt)
      , rt = () => qe.getValidItems()
      , Ue = _t( () => Ta(De, qe.props));
    var lt = cr()
      , et = Rt(lt);
    {
        var Ve = dt => {
            var ct = U4()
              , ze = Rt(ct);
            T(ze);
            var vt = U(ze, 2);
            Wi(vt, () => l.child, () => ({
                props: w(Ue)
            })),
            H(dt, ct)
        }
          , gt = dt => {
            var ct = G4();
            Yt(ct, () => ({
                ...w(Ue)
            }));
            var ze = z(ct);
            T(ze);
            var vt = U(ze, 2);
            Wi(vt, () => l.children ?? Sn),
            k(ct),
            H(dt, ct)
        }
        ;
        tt(et, dt => {
            l.child ? dt(Ve) : dt(gt, !1)
        }
        )
    }
    return H(x, lt),
    Dr({
        updateSelectedToIndex: Ne,
        updateSelectedByGroup: Ze,
        updateSelectedByItem: ut,
        getValidItems: rt
    })
}
var W4 = Be("<div><!></div>");
function X4(x, l) {
    const _ = $a();
    Lr(l, !0);
    let T = At(l, "id", 19, () => La(_))
      , E = At(l, "ref", 15, null)
      , F = At(l, "forceMount", 3, !1)
      , C = Jt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child", "forceMount"]);
    const o = Rf.create({
        id: dr.with( () => T()),
        ref: dr.with( () => E(), he => E(he)),
        forceMount: dr.with( () => F())
    })
      , W = _t( () => Ta(o.props, C));
    var G = cr()
      , re = Rt(G);
    {
        var de = he => {
            var X = cr()
              , le = Rt(X);
            {
                var Se = De => {
                    var qe = cr()
                      , Ne = Rt(qe);
                    Wi(Ne, () => l.child, () => ({
                        props: w(W)
                    })),
                    H(De, qe)
                }
                  , Ie = De => {
                    var qe = W4();
                    Yt(qe, () => ({
                        ...w(W)
                    }));
                    var Ne = z(qe);
                    Wi(Ne, () => l.children ?? Sn),
                    k(qe),
                    H(De, qe)
                }
                ;
                tt(le, De => {
                    l.child ? De(Se) : De(Ie, !1)
                }
                )
            }
            H(he, X)
        }
        ;
        tt(re, he => {
            o.shouldRender && he(de)
        }
        )
    }
    H(x, G),
    Dr()
}
var K4 = Be("<div><!></div>");
function Y4(x, l) {
    const _ = $a();
    Lr(l, !0);
    let T = At(l, "id", 19, () => La(_))
      , E = At(l, "ref", 15, null)
      , F = At(l, "value", 3, "")
      , C = At(l, "forceMount", 3, !1)
      , o = Jt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "forceMount", "children", "child"]);
    const W = Bf.create({
        id: dr.with( () => T()),
        ref: dr.with( () => E(), le => E(le)),
        forceMount: dr.with( () => C()),
        value: dr.with( () => F())
    })
      , G = _t( () => Ta(o, W.props));
    var re = cr()
      , de = Rt(re);
    {
        var he = le => {
            var Se = cr()
              , Ie = Rt(Se);
            Wi(Ie, () => l.child, () => ({
                props: w(G)
            })),
            H(le, Se)
        }
          , X = le => {
            var Se = K4();
            Yt(Se, () => ({
                ...w(G)
            }));
            var Ie = z(Se);
            Wi(Ie, () => l.children ?? Sn),
            k(Se),
            H(le, Se)
        }
        ;
        tt(de, le => {
            l.child ? le(he) : le(X, !1)
        }
        )
    }
    H(x, re),
    Dr()
}
var J4 = Be("<div><!></div>");
function Q4(x, l) {
    const _ = $a();
    Lr(l, !0);
    let T = At(l, "id", 19, () => La(_))
      , E = At(l, "ref", 15, null)
      , F = Jt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
    const C = Ff.create({
        id: dr.with( () => T()),
        ref: dr.with( () => E(), he => E(he))
    })
      , o = _t( () => Ta(F, C.props));
    var W = cr()
      , G = Rt(W);
    {
        var re = he => {
            var X = cr()
              , le = Rt(X);
            Wi(le, () => l.child, () => ({
                props: w(o)
            })),
            H(he, X)
        }
          , de = he => {
            var X = J4();
            Yt(X, () => ({
                ...w(o)
            }));
            var le = z(X);
            Wi(le, () => l.children ?? Sn),
            k(X),
            H(he, X)
        }
        ;
        tt(G, he => {
            l.child ? he(re) : he(de, !1)
        }
        )
    }
    H(x, W),
    Dr()
}
var e6 = Be("<div><!></div>")
  , t6 = Be('<div style="display: contents;"><!></div>');
function r6(x, l) {
    const _ = $a();
    Lr(l, !0);
    let T = At(l, "id", 19, () => La(_))
      , E = At(l, "ref", 15, null)
      , F = Jt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "children", "child"]);
    const C = Of.create({
        id: dr.with( () => T()),
        ref: dr.with( () => E(), he => E(he))
    })
      , o = _t( () => Ta(F, C.props));
    var W = t6()
      , G = z(W);
    {
        var re = he => {
            var X = cr()
              , le = Rt(X);
            Wi(le, () => l.child, () => ({
                props: w(o)
            })),
            H(he, X)
        }
          , de = he => {
            var X = e6();
            Yt(X, () => ({
                ...w(o)
            }));
            var le = z(X);
            Wi(le, () => l.children ?? Sn),
            k(X),
            H(he, X)
        }
        ;
        tt(G, he => {
            l.child ? he(re) : he(de, !1)
        }
        )
    }
    k(W),
    H(x, W),
    Dr()
}
var i6 = Be("<input/>");
function n6(x, l) {
    const _ = $a();
    Lr(l, !0);
    let T = At(l, "value", 15, "")
      , E = At(l, "autofocus", 3, !1)
      , F = At(l, "id", 19, () => La(_))
      , C = At(l, "ref", 15, null)
      , o = Jt(l, ["$$slots", "$$events", "$$legacy", "value", "autofocus", "id", "ref", "child"]);
    const W = Nf.create({
        id: dr.with( () => F()),
        ref: dr.with( () => C(), le => C(le)),
        value: dr.with( () => T(), le => {
            T(le)
        }
        ),
        autofocus: dr.with( () => E() ?? !1)
    })
      , G = _t( () => Ta(o, W.props));
    var re = cr()
      , de = Rt(re);
    {
        var he = le => {
            var Se = cr()
              , Ie = Rt(Se);
            Wi(Ie, () => l.child, () => ({
                props: w(G)
            })),
            H(le, Se)
        }
          , X = le => {
            var Se = i6();
            Ea(Se),
            Yt(Se, () => ({
                ...w(G)
            })),
            jd(Se, T),
            H(le, Se)
        }
        ;
        tt(de, le => {
            l.child ? le(he) : le(X, !1)
        }
        )
    }
    H(x, re),
    Dr()
}
var a6 = Be("<div><!></div>")
  , s6 = Be('<div style="display: contents;" data-item-wrapper=""><!></div>');
function o6(x, l) {
    const _ = $a();
    Lr(l, !0);
    let T = At(l, "id", 19, () => La(_))
      , E = At(l, "ref", 15, null)
      , F = At(l, "value", 3, "")
      , C = At(l, "disabled", 3, !1)
      , o = At(l, "onSelect", 3, Au)
      , W = At(l, "forceMount", 3, !1)
      , G = At(l, "keywords", 19, () => [])
      , re = Jt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "value", "disabled", "children", "child", "onSelect", "forceMount", "keywords"]);
    const de = jf.create({
        id: dr.with( () => T()),
        ref: dr.with( () => E(), Se => E(Se)),
        value: dr.with( () => F()),
        disabled: dr.with( () => C()),
        onSelect: dr.with( () => o()),
        forceMount: dr.with( () => W()),
        keywords: dr.with( () => G())
    })
      , he = _t( () => Ta(re, de.props));
    var X = cr()
      , le = Rt(X);
    Iu(le, () => de.root.key, Se => {
        var Ie = s6()
          , De = z(Ie);
        {
            var qe = Ne => {
                var Ze = cr()
                  , ut = Rt(Ze);
                {
                    var rt = lt => {
                        var et = cr()
                          , Ve = Rt(et);
                        Wi(Ve, () => l.child, () => ({
                            props: w(he)
                        })),
                        H(lt, et)
                    }
                      , Ue = lt => {
                        var et = a6();
                        Yt(et, () => ({
                            ...w(he)
                        }));
                        var Ve = z(et);
                        Wi(Ve, () => l.children ?? Sn),
                        k(et),
                        H(lt, et)
                    }
                    ;
                    tt(ut, lt => {
                        l.child ? lt(rt) : lt(Ue, !1)
                    }
                    )
                }
                H(Ne, Ze)
            }
            ;
            tt(De, Ne => {
                de.shouldRender && Ne(qe)
            }
            )
        }
        k(Ie),
        st( () => jr(Ie, "data-value", de.trueValue)),
        H(Se, Ie)
    }
    ),
    H(x, X),
    Dr()
}
var l6 = Be("<div><!></div>");
function c6(x, l) {
    const _ = $a();
    Lr(l, !0);
    let T = At(l, "id", 19, () => La(_))
      , E = At(l, "ref", 15, null)
      , F = Jt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "child", "children", "aria-label"]);
    const C = Vf.create({
        id: dr.with( () => T()),
        ref: dr.with( () => E(), re => E(re)),
        ariaLabel: dr.with( () => l["aria-label"] ?? "Suggestions...")
    })
      , o = _t( () => Ta(F, C.props));
    var W = cr()
      , G = Rt(W);
    Iu(G, () => C.root._commandState.search === "", re => {
        var de = cr()
          , he = Rt(de);
        {
            var X = Se => {
                var Ie = cr()
                  , De = Rt(Ie);
                Wi(De, () => l.child, () => ({
                    props: w(o)
                })),
                H(Se, Ie)
            }
              , le = Se => {
                var Ie = l6();
                Yt(Ie, () => ({
                    ...w(o)
                }));
                var De = z(Ie);
                Wi(De, () => l.children ?? Sn),
                k(Ie),
                H(Se, Ie)
            }
            ;
            tt(he, Se => {
                l.child ? Se(X) : Se(le, !1)
            }
            )
        }
        H(re, de)
    }
    ),
    H(x, W),
    Dr()
}
const Dg = 1
  , u6 = .9
  , h6 = .8
  , d6 = .17
  , _f = .1
  , gf = .999
  , p6 = .9999
  , f6 = .99
  , m6 = /[\\/_+.#"@[({&]/
  , _6 = /[\\/_+.#"@[({&]/g
  , g6 = /[\s-]/
  , zv = /[\s-]/g;
function $f(x, l, _, T, E, F, C) {
    if (F === l.length)
        return E === x.length ? Dg : f6;
    const o = `${E},${F}`;
    if (C[o] !== void 0)
        return C[o];
    const W = T.charAt(F);
    let G = _.indexOf(W, E), re = 0, de, he, X, le;
    for (; G >= 0; )
        de = $f(x, l, _, T, G + 1, F + 1, C),
        de > re && (G === E ? de *= Dg : m6.test(x.charAt(G - 1)) ? (de *= h6,
        X = x.slice(E, G - 1).match(_6),
        X && E > 0 && (de *= gf ** X.length)) : g6.test(x.charAt(G - 1)) ? (de *= u6,
        le = x.slice(E, G - 1).match(zv),
        le && E > 0 && (de *= gf ** le.length)) : (de *= d6,
        E > 0 && (de *= gf ** (G - E))),
        x.charAt(G) !== l.charAt(F) && (de *= p6)),
        (de < _f && _.charAt(G - 1) === T.charAt(F + 1) || T.charAt(F + 1) === T.charAt(F) && _.charAt(G - 1) !== T.charAt(F)) && (he = $f(x, l, _, T, G + 1, F + 2, C),
        he * _f > de && (de = he * _f)),
        de > re && (re = de),
        G = _.indexOf(W, G + 1);
    return C[o] = re,
    re
}
function Rg(x) {
    return x.toLowerCase().replace(zv, " ")
}
function Lv(x, l, _) {
    return x = _ && _.length > 0 ? `${`${x} ${_ == null ? void 0 : _.join(" ")}`}` : x,
    $f(x, l, Rg(x), Rg(l), 0, 0, {})
}
const v6 = 18
  , Dv = 40
  , y6 = `${Dv}px`
  , x6 = ["[data-lastpass-icon-root]", "com-1password-button", "[data-dashlanecreated]", '[style$="2147483647 !important;"]'].join(",");
function b6({containerRef: x, inputRef: l, pushPasswordManagerStrategy: _, isFocused: T, domContext: E}) {
    let F = mt(!1)
      , C = mt(!1)
      , o = mt(!1);
    function W() {
        const re = _.current;
        return re === "none" ? !1 : re === "increase-width" && w(F) && w(C)
    }
    function G() {
        const re = x.current
          , de = l.current;
        if (!re || !de || w(o) || _.current === "none")
            return;
        const he = re
          , X = he.getBoundingClientRect().left + he.offsetWidth
          , le = he.getBoundingClientRect().top + he.offsetHeight / 2
          , Se = X - v6
          , Ie = le;
        E.querySelectorAll(x6).length === 0 && E.getDocument().elementFromPoint(Se, Ie) === re || (fe(F, !0),
        fe(o, !0))
    }
    return Gr( () => {
        const re = x.current;
        if (!re || _.current === "none")
            return;
        function de() {
            const le = wv(re).innerWidth - re.getBoundingClientRect().right;
            fe(C, le >= Dv)
        }
        de();
        const he = setInterval(de, 1e3);
        return () => {
            clearInterval(he)
        }
    }
    ),
    Gr( () => {
        const re = T.current || E.getActiveElement() === l.current;
        if (_.current === "none" || !re)
            return;
        const de = setTimeout(G, 0)
          , he = setTimeout(G, 2e3)
          , X = setTimeout(G, 5e3)
          , le = setTimeout( () => {
            fe(o, !0)
        }
        , 6e3);
        return () => {
            clearTimeout(de),
            clearTimeout(he),
            clearTimeout(X),
            clearTimeout(le)
        }
    }
    ),
    {
        get hasPwmBadge() {
            return w(F)
        },
        get willPushPwmBadge() {
            return W()
        },
        PWM_BADGE_SPACE_WIDTH: y6
    }
}
const Rv = Tv({
    component: "pin-input",
    parts: ["root", "cell"]
})
  , w6 = ["Backspace", "Delete", "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End", "Escape", "Enter", "Tab", "Shift", "Control", "Meta"];
var Aa, ac, ws, ba, ka, sc, ns, Ts, ao, oc, Bd, lh, ch, Fd, Od, Bv, uh, hh, Nd, dh;
const Mm = class Mm {
    constructor(l) {
        Sr(this, Od);
        hr(this, "opts");
        hr(this, "attachment");
        Sr(this, Aa, dr(null));
        Sr(this, ac, mt(!1));
        hr(this, "inputAttachment", za(nt(this, Aa)));
        Sr(this, ws, dr(!1));
        Sr(this, ba, mt(null));
        Sr(this, ka, mt(null));
        Sr(this, sc, new s4( () => this.opts.value.current ?? ""));
        Sr(this, ns, _t( () => typeof this.opts.pattern.current == "string" ? new RegExp(this.opts.pattern.current) : this.opts.pattern.current));
        Sr(this, Ts, mt(Mn({
            prev: [null, null, "none"],
            willSyntheticBlur: !1
        })));
        Sr(this, ao);
        Sr(this, oc);
        hr(this, "domContext");
        hr(this, "onkeydown", l => {
            const _ = l.key;
            w6.includes(_) || l.ctrlKey || l.metaKey || _ && w(nt(this, ns)) && !w(nt(this, ns)).test(_) && l.preventDefault()
        }
        );
        Sr(this, Bd, _t( () => ({
            position: "relative",
            cursor: this.opts.disabled.current ? "default" : "text",
            userSelect: "none",
            WebkitUserSelect: "none",
            pointerEvents: "none"
        })));
        Sr(this, lh, _t( () => ({
            id: this.opts.id.current,
            [Rv.root]: "",
            style: w(nt(this, Bd)),
            ...this.attachment
        })));
        Sr(this, ch, _t( () => ({
            style: {
                position: "absolute",
                inset: 0,
                pointerEvents: "none"
            }
        })));
        Sr(this, Fd, _t( () => ({
            position: "absolute",
            inset: 0,
            width: nt(this, ao).willPushPwmBadge ? `calc(100% + ${nt(this, ao).PWM_BADGE_SPACE_WIDTH})` : "100%",
            clipPath: nt(this, ao).willPushPwmBadge ? `inset(0 ${nt(this, ao).PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0,
            height: "100%",
            display: "flex",
            textAlign: this.opts.textAlign.current,
            opacity: "1",
            color: "transparent",
            pointerEvents: "all",
            background: "transparent",
            caretColor: "transparent",
            border: "0 solid transparent",
            outline: "0 solid transparent",
            boxShadow: "none",
            lineHeight: "1",
            letterSpacing: "-.5em",
            fontSize: "var(--bits-pin-input-root-height)",
            fontFamily: "monospace",
            fontVariantNumeric: "tabular-nums"
        })));
        Sr(this, uh, () => {
            var Se;
            const l = nt(this, Aa).current
              , _ = this.opts.ref.current;
            if (!l || !_)
                return;
            if (this.domContext.getActiveElement() !== l) {
                fe(nt(this, ba), null),
                fe(nt(this, ka), null);
                return
            }
            const T = l.selectionStart
              , E = l.selectionEnd
              , F = l.selectionDirection ?? "none"
              , C = l.maxLength
              , o = l.value
              , W = w(nt(this, Ts)).prev;
            let G = -1, re = -1, de;
            if (o.length !== 0 && T !== null && E !== null) {
                const Ie = T === E
                  , De = T === o.length && o.length < C;
                if (Ie && !De) {
                    const qe = T;
                    if (qe === 0)
                        G = 0,
                        re = 1,
                        de = "forward";
                    else if (qe === C)
                        G = qe - 1,
                        re = qe,
                        de = "backward";
                    else if (C > 1 && o.length > 1) {
                        let Ne = 0;
                        if (W[0] !== null && W[1] !== null) {
                            de = qe < W[0] ? "backward" : "forward";
                            const Ze = W[0] === W[1] && W[0] < C;
                            de === "backward" && !Ze && (Ne = -1)
                        }
                        G = Ne - qe,
                        re = Ne + qe + 1
                    }
                }
                G !== -1 && re !== -1 && G !== re && ((Se = nt(this, Aa).current) == null || Se.setSelectionRange(G, re, de))
            }
            const he = G !== -1 ? G : T
              , X = re !== -1 ? re : E
              , le = de ?? F;
            fe(nt(this, ba), he, !0),
            fe(nt(this, ka), X, !0),
            w(nt(this, Ts)).prev = [he, X, le]
        }
        );
        hr(this, "oninput", l => {
            const _ = l.currentTarget.value.slice(0, this.opts.maxLength.current);
            if (_.length > 0 && w(nt(this, ns)) && !w(nt(this, ns)).test(_)) {
                l.preventDefault();
                return
            }
            typeof nt(this, sc).current == "string" && _.length < nt(this, sc).current.length && this.domContext.getDocument().dispatchEvent(new Event("selectionchange")),
            this.opts.value.current = _
        }
        );
        hr(this, "onfocus", l => {
            const _ = nt(this, Aa).current;
            if (_) {
                const T = Math.min(_.value.length, this.opts.maxLength.current - 1)
                  , E = _.value.length;
                _.setSelectionRange(T, E),
                fe(nt(this, ba), T, !0),
                fe(nt(this, ka), E, !0)
            }
            nt(this, ws).current = !0
        }
        );
        hr(this, "onpaste", l => {
            var re, de, he, X;
            const _ = nt(this, Aa).current;
            if (!_)
                return;
            const T = le => {
                const Se = _.selectionStart === null ? void 0 : _.selectionStart
                  , Ie = _.selectionEnd === null ? void 0 : _.selectionEnd
                  , De = Se !== Ie
                  , qe = this.opts.value.current;
                return (De ? qe.slice(0, Se) + le + qe.slice(Ie) : qe.slice(0, Se) + le + qe.slice(Se)).slice(0, this.opts.maxLength.current)
            }
              , E = le => le.length > 0 && w(nt(this, ns)) && !w(nt(this, ns)).test(le);
            if (!((re = this.opts.pasteTransformer) != null && re.current) && (!nt(this, oc).isIOS || !l.clipboardData || !_)) {
                const le = T((de = l.clipboardData) == null ? void 0 : de.getData("text/plain"));
                E(le) && l.preventDefault();
                return
            }
            const F = ((he = l.clipboardData) == null ? void 0 : he.getData("text/plain")) ?? ""
              , C = (X = this.opts.pasteTransformer) != null && X.current ? this.opts.pasteTransformer.current(F) : F;
            l.preventDefault();
            const o = T(C);
            if (E(o))
                return;
            _.value = o,
            this.opts.value.current = o;
            const W = Math.min(o.length, this.opts.maxLength.current - 1)
              , G = o.length;
            _.setSelectionRange(W, G),
            fe(nt(this, ba), W, !0),
            fe(nt(this, ka), G, !0)
        }
        );
        hr(this, "onmouseover", l => {
            fe(nt(this, ac), !0)
        }
        );
        hr(this, "onmouseleave", l => {
            fe(nt(this, ac), !1)
        }
        );
        hr(this, "onblur", l => {
            if (w(nt(this, Ts)).willSyntheticBlur) {
                w(nt(this, Ts)).willSyntheticBlur = !1;
                return
            }
            nt(this, ws).current = !1
        }
        );
        Sr(this, hh, _t( () => {
            var l;
            return {
                id: this.opts.inputId.current,
                style: w(nt(this, Fd)),
                autocomplete: this.opts.autocomplete.current || "one-time-code",
                "data-pin-input-input": "",
                "data-pin-input-input-mss": w(nt(this, ba)),
                "data-pin-input-input-mse": w(nt(this, ka)),
                inputmode: this.opts.inputmode.current,
                pattern: (l = w(nt(this, ns))) == null ? void 0 : l.source,
                maxlength: this.opts.maxLength.current,
                value: this.opts.value.current,
                disabled: T4(this.opts.disabled.current),
                onpaste: this.onpaste,
                oninput: this.oninput,
                onkeydown: this.onkeydown,
                onmouseover: this.onmouseover,
                onmouseleave: this.onmouseleave,
                onfocus: this.onfocus,
                onblur: this.onblur,
                ...this.inputAttachment
            }
        }
        ));
        Sr(this, Nd, _t( () => Array.from({
            length: this.opts.maxLength.current
        }).map( (l, _) => {
            const T = nt(this, ws).current && w(nt(this, ba)) !== null && w(nt(this, ka)) !== null && (w(nt(this, ba)) === w(nt(this, ka)) && _ === w(nt(this, ba)) || _ >= w(nt(this, ba)) && _ < w(nt(this, ka)))
              , E = this.opts.value.current[_] !== void 0 ? this.opts.value.current[_] : null;
            return {
                char: E,
                isActive: T,
                hasFakeCaret: T && E === null
            }
        }
        )));
        Sr(this, dh, _t( () => ({
            cells: w(nt(this, Nd)),
            isFocused: nt(this, ws).current,
            isHovering: w(nt(this, ac))
        })));
        var _;
        this.opts = l,
        this.attachment = za(this.opts.ref),
        this.domContext = new g4(l.ref),
        Hn(this, oc, {
            value: this.opts.value,
            isIOS: typeof window < "u" && ((_ = window == null ? void 0 : window.CSS) == null ? void 0 : _.supports("-webkit-touch-callout", "none"))
        }),
        Hn(this, ao, b6({
            containerRef: this.opts.ref,
            inputRef: nt(this, Aa),
            isFocused: nt(this, ws),
            pushPasswordManagerStrategy: this.opts.pushPasswordManagerStrategy,
            domContext: this.domContext
        })),
        wi( () => {
            const T = nt(this, Aa).current
              , E = this.opts.ref.current;
            if (!T || !E)
                return;
            nt(this, oc).value.current !== T.value && (this.opts.value.current = T.value),
            w(nt(this, Ts)).prev = [T.selectionStart, T.selectionEnd, T.selectionDirection ?? "none"];
            const F = Pu(this.domContext.getDocument(), "selectionchange", nt(this, uh), {
                capture: !0
            });
            nt(this, uh).call(this),
            this.domContext.getActiveElement() === T && (nt(this, ws).current = !0),
            this.domContext.getElementById("pin-input-style") || Nr(this, Od, Bv).call(this);
            const C = () => {
                E && E.style.setProperty("--bits-pin-input-root-height", `${T.clientHeight}px`)
            }
            ;
            C();
            const o = new ResizeObserver(C);
            return o.observe(T),
            () => {
                F(),
                o.disconnect()
            }
        }
        ),
        oo([ () => this.opts.value.current, () => nt(this, Aa).current], () => {
            T6( () => {
                const T = nt(this, Aa).current;
                if (!T)
                    return;
                T.dispatchEvent(new Event("input"));
                const E = T.selectionStart
                  , F = T.selectionEnd
                  , C = T.selectionDirection ?? "none";
                E !== null && F !== null && (fe(nt(this, ba), E, !0),
                fe(nt(this, ka), F, !0),
                w(nt(this, Ts)).prev = [E, F, C])
            }
            , this.domContext)
        }
        ),
        Gr( () => {
            const T = this.opts.value.current
              , E = nt(this, sc).current
              , F = this.opts.maxLength.current
              , C = this.opts.onComplete.current;
            E !== void 0 && T !== E && E.length < F && T.length === F && C(T)
        }
        )
    }
    static create(l) {
        return new Mm(l)
    }
    get rootProps() {
        return w(nt(this, lh))
    }
    set rootProps(l) {
        fe(nt(this, lh), l)
    }
    get inputWrapperProps() {
        return w(nt(this, ch))
    }
    set inputWrapperProps(l) {
        fe(nt(this, ch), l)
    }
    get inputProps() {
        return w(nt(this, hh))
    }
    set inputProps(l) {
        fe(nt(this, hh), l)
    }
    get snippetProps() {
        return w(nt(this, dh))
    }
    set snippetProps(l) {
        fe(nt(this, dh), l)
    }
}
;
Aa = new WeakMap,
ac = new WeakMap,
ws = new WeakMap,
ba = new WeakMap,
ka = new WeakMap,
sc = new WeakMap,
ns = new WeakMap,
Ts = new WeakMap,
ao = new WeakMap,
oc = new WeakMap,
Bd = new WeakMap,
lh = new WeakMap,
ch = new WeakMap,
Fd = new WeakMap,
Od = new WeakSet,
Bv = function() {
    const l = this.domContext.getDocument()
      , _ = l.createElement("style");
    if (_.id = "pin-input-style",
    l.head.appendChild(_),
    _.sheet) {
        const T = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
        yu(_.sheet, "[data-pin-input-input]::selection { background: transparent !important; color: transparent !important; }"),
        yu(_.sheet, `[data-pin-input-input]:autofill { ${T} }`),
        yu(_.sheet, `[data-pin-input-input]:-webkit-autofill { ${T} }`),
        yu(_.sheet, "@supports (-webkit-touch-callout: none) { [data-pin-input-input] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"),
        yu(_.sheet, "[data-pin-input-input] + * { pointer-events: all !important; }")
    }
}
,
uh = new WeakMap,
hh = new WeakMap,
Nd = new WeakMap,
dh = new WeakMap;
let Uf = Mm;
var ph;
const Am = class Am {
    constructor(l) {
        hr(this, "opts");
        hr(this, "attachment");
        Sr(this, ph, _t( () => ({
            id: this.opts.id.current,
            [Rv.cell]: "",
            "data-active": this.opts.cell.current.isActive ? "" : void 0,
            "data-inactive": this.opts.cell.current.isActive ? void 0 : "",
            ...this.attachment
        })));
        this.opts = l,
        this.attachment = za(this.opts.ref)
    }
    static create(l) {
        return new Am(l)
    }
    get props() {
        return w(nt(this, ph))
    }
    set props(l) {
        fe(nt(this, ph), l)
    }
}
;
ph = new WeakMap;
let Gf = Am;
function T6(x, l) {
    const _ = l.setTimeout(x, 0)
      , T = l.setTimeout(x, 10)
      , E = l.setTimeout(x, 50);
    return [_, T, E]
}
function yu(x, l) {
    try {
        x.insertRule(l)
    } catch {
        console.error("pin input could not insert CSS rule:", l)
    }
}
var C6 = Be("<div><!> <div><input/></div></div>");
function S6(x, l) {
    const _ = $a();
    Lr(l, !0);
    let T = At(l, "id", 19, () => La(_))
      , E = At(l, "inputId", 19, () => `${La(_)}-input`)
      , F = At(l, "ref", 15, null)
      , C = At(l, "maxlength", 3, 6)
      , o = At(l, "textalign", 3, "left")
      , W = At(l, "inputmode", 3, "numeric")
      , G = At(l, "onComplete", 3, Au)
      , re = At(l, "pushPasswordManagerStrategy", 3, "increase-width")
      , de = At(l, "class", 3, "")
      , he = At(l, "autocomplete", 3, "one-time-code")
      , X = At(l, "disabled", 3, !1)
      , le = At(l, "value", 15, "")
      , Se = At(l, "onValueChange", 3, Au)
      , Ie = Jt(l, ["$$slots", "$$events", "$$legacy", "id", "inputId", "ref", "maxlength", "textalign", "pattern", "inputmode", "onComplete", "pushPasswordManagerStrategy", "class", "children", "autocomplete", "disabled", "value", "onValueChange", "pasteTransformer"]);
    const De = Uf.create({
        id: dr.with( () => T()),
        ref: dr.with( () => F(), et => F(et)),
        inputId: dr.with( () => E()),
        autocomplete: dr.with( () => he()),
        maxLength: dr.with( () => C()),
        textAlign: dr.with( () => o()),
        disabled: dr.with( () => X()),
        inputmode: dr.with( () => W()),
        pattern: dr.with( () => l.pattern),
        onComplete: dr.with( () => G()),
        value: dr.with( () => le(), et => {
            le(et),
            Se()(et)
        }
        ),
        pushPasswordManagerStrategy: dr.with( () => re()),
        pasteTransformer: dr.with( () => l.pasteTransformer)
    })
      , qe = _t( () => Ta(Ie, De.inputProps))
      , Ne = _t( () => Ta(De.rootProps, {
        class: de()
    }))
      , Ze = _t( () => Ta(De.inputWrapperProps, {}));
    var ut = C6();
    Yt(ut, () => ({
        ...w(Ne)
    }));
    var rt = z(ut);
    Wi(rt, () => l.children ?? Sn, () => De.snippetProps);
    var Ue = U(rt, 2);
    Yt(Ue, () => ({
        ...w(Ze)
    }));
    var lt = z(Ue);
    Ea(lt),
    Yt(lt, () => ({
        ...w(qe)
    })),
    k(Ue),
    k(ut),
    H(x, ut),
    Dr()
}
var P6 = Be("<div><!></div>");
function I6(x, l) {
    const _ = $a();
    Lr(l, !0);
    let T = At(l, "id", 19, () => La(_))
      , E = At(l, "ref", 15, null)
      , F = Jt(l, ["$$slots", "$$events", "$$legacy", "id", "ref", "cell", "child", "children"]);
    const C = Gf.create({
        id: dr.with( () => T()),
        ref: dr.with( () => E(), he => E(he)),
        cell: dr.with( () => l.cell)
    })
      , o = _t( () => Ta(F, C.props));
    var W = cr()
      , G = Rt(W);
    {
        var re = he => {
            var X = cr()
              , le = Rt(X);
            Wi(le, () => l.child, () => ({
                props: w(o)
            })),
            H(he, X)
        }
          , de = he => {
            var X = P6();
            Yt(X, () => ({
                ...w(o)
            }));
            var le = z(X);
            Wi(le, () => l.children ?? Sn),
            k(X),
            H(he, X)
        }
        ;
        tt(G, he => {
            l.child ? he(re) : he(de, !1)
        }
        )
    }
    H(x, W),
    Dr()
}
function hc(...x) {
    return Hg(Su(x))
}
function M6(x, l) {
    Lr(l, !0);
    let _ = At(l, "ref", 15, null)
      , T = At(l, "value", 15, "")
      , E = Jt(l, ["$$slots", "$$events", "$$legacy", "ref", "value", "class"]);
    var F = cr()
      , C = Rt(F);
    {
        let o = _t( () => hc("bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", l.class));
        an(C, () => H4, (W, G) => {
            G(W, lo({
                "data-slot": "command",
                get class() {
                    return w(o)
                }
            }, () => E, {
                get value() {
                    return T()
                },
                set value(re) {
                    T(re)
                },
                get ref() {
                    return _()
                },
                set ref(re) {
                    _(re)
                }
            }))
        }
        )
    }
    H(x, F),
    Dr()
}
var A6 = Pr('<svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"></path></svg>');
function dc(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = A6();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
function k6(x, l) {
    Lr(l, !0);
    let _ = At(l, "ref", 15, null)
      , T = Jt(l, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
    var E = cr()
      , F = Rt(E);
    {
        let C = _t( () => hc("py-6 text-center text-sm", l.class));
        an(F, () => X4, (o, W) => {
            W(o, lo({
                "data-slot": "command-empty",
                get class() {
                    return w(C)
                }
            }, () => T, {
                get ref() {
                    return _()
                },
                set ref(G) {
                    _(G)
                }
            }))
        }
        )
    }
    H(x, E),
    Dr()
}
var E6 = Be("<!> <!>", 1);
function z6(x, l) {
    Lr(l, !0);
    let _ = At(l, "ref", 15, null)
      , T = Jt(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "children", "heading", "value"]);
    var E = cr()
      , F = Rt(E);
    {
        let C = _t( () => hc("text-foreground overflow-hidden p-1", l.class))
          , o = _t( () => l.value ?? l.heading ?? `----${N4()}`);
        an(F, () => Y4, (W, G) => {
            G(W, lo({
                "data-slot": "command-group",
                get class() {
                    return w(C)
                },
                get value() {
                    return w(o)
                }
            }, () => T, {
                get ref() {
                    return _()
                },
                set ref(re) {
                    _(re)
                },
                children: (re, de) => {
                    var he = E6()
                      , X = Rt(he);
                    {
                        var le = Ie => {
                            var De = cr()
                              , qe = Rt(De);
                            an(qe, () => Q4, (Ne, Ze) => {
                                Ze(Ne, {
                                    class: "text-muted-foreground px-2 py-1.5 text-xs font-medium",
                                    children: (ut, rt) => {
                                        di();
                                        var Ue = wa();
                                        st( () => Ce(Ue, l.heading)),
                                        H(ut, Ue)
                                    }
                                    ,
                                    $$slots: {
                                        default: !0
                                    }
                                })
                            }
                            ),
                            H(Ie, De)
                        }
                        ;
                        tt(X, Ie => {
                            l.heading && Ie(le)
                        }
                        )
                    }
                    var Se = U(X, 2);
                    an(Se, () => r6, (Ie, De) => {
                        De(Ie, {
                            get children() {
                                return l.children
                            }
                        })
                    }
                    ),
                    H(re, he)
                }
                ,
                $$slots: {
                    default: !0
                }
            }))
        }
        )
    }
    H(x, E),
    Dr()
}
function L6(x, l) {
    Lr(l, !0);
    let _ = At(l, "ref", 15, null)
      , T = Jt(l, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
    var E = cr()
      , F = Rt(E);
    {
        let C = _t( () => hc("aria-selected:bg-base-300 aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", l.class));
        an(F, () => o6, (o, W) => {
            W(o, lo({
                "data-slot": "command-item",
                get class() {
                    return w(C)
                }
            }, () => T, {
                get ref() {
                    return _()
                },
                set ref(G) {
                    _(G)
                }
            }))
        }
        )
    }
    H(x, E),
    Dr()
}
var D6 = Pr('<svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"></path></svg>');
function R6(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = D6();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var B6 = Be('<div class="border-base-content/10 flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper"><!> <!></div>');
function F6(x, l) {
    Lr(l, !0);
    let _ = At(l, "ref", 15, null)
      , T = At(l, "value", 15, "")
      , E = Jt(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
    var F = B6()
      , C = z(F);
    R6(C, {
        class: "size-5 opacity-50"
    });
    var o = U(C, 2);
    {
        let W = _t( () => hc("placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50", l.class));
        an(o, () => n6, (G, re) => {
            re(G, lo({
                "data-slot": "command-input",
                get class() {
                    return w(W)
                }
            }, () => E, {
                get ref() {
                    return _()
                },
                set ref(de) {
                    _(de)
                },
                get value() {
                    return T()
                },
                set value(de) {
                    T(de)
                }
            }))
        }
        )
    }
    k(F),
    H(x, F),
    Dr()
}
function O6(x, l) {
    Lr(l, !0);
    let _ = At(l, "ref", 15, null)
      , T = Jt(l, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
    var E = cr()
      , F = Rt(E);
    {
        let C = _t( () => hc("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", l.class));
        an(F, () => c6, (o, W) => {
            W(o, lo({
                "data-slot": "command-list",
                get class() {
                    return w(C)
                }
            }, () => T, {
                get ref() {
                    return _()
                },
                set ref(G) {
                    _(G)
                }
            }))
        }
        )
    }
    H(x, E),
    Dr()
}
var N6 = Pr('<svg><path d="M480-80 240-320l57-57 183 183 183-183 57 57L480-80ZM298-584l-58-56 240-240 240 240-58 56-182-182-182 182Z"></path></svg>');
function j6(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = N6();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var q6 = Be("<span> </span> <!>", 1)
  , V6 = Be('<span class="font-flag ml-0.5"> </span> ', 1)
  , Z6 = Be('<span class="flex gap-1.5"><span class="font-flag"> </span> </span>')
  , $6 = Be("<!> <!>", 1)
  , U6 = Be("<!> <!>", 1)
  , G6 = (x, l) => {
    l(0)
}
  , H6 = Be('<button class="btn btn-xs btn-circle btn-ghost"><!></button>')
  , W6 = Be('<div class="flex items-center"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-sm max-w-74 text-base-content/80 m-1"><!></div> <div><!></div></div> <!></div>');
function Bg(x, l) {
    Lr(l, !0);
    let _ = At(l, "countryId", 15, 0)
      , T = At(l, "dropdownDirection", 3, "right")
      , E = mt(null)
      , F = mt(null)
      , C = mt("");
    function o() {
        qg().then( () => {
            var Ne;
            (Ne = document.activeElement) == null || Ne.blur(),
            fe(C, "")
        }
        )
    }
    var W = W6()
      , G = z(W)
      , re = z(G)
      , de = z(re);
    {
        var he = Ne => {
            var Ze = q6()
              , ut = Rt(Ze)
              , rt = z(ut, !0);
            k(ut);
            var Ue = U(ut, 2);
            j6(Ue, {
                class: "size-3.5"
            }),
            st(lt => Ce(rt, lt), [ () => tv()]),
            H(Ne, Ze)
        }
          , X = Ne => {
            const Ze = _t( () => as(_()));
            var ut = V6()
              , rt = Rt(ut)
              , Ue = z(rt, !0);
            k(rt);
            var lt = U(rt);
            st( () => {
                Ce(Ue, w(Ze).flag),
                Ce(lt, ` ${w(Ze).name ?? ""}`)
            }
            ),
            H(Ne, ut)
        }
        ;
        tt(de, Ne => {
            _() === 0 ? Ne(he) : Ne(X, !1)
        }
        )
    }
    k(re);
    var le = U(re, 2);
    let Se;
    var Ie = z(le);
    an(Ie, () => M6, (Ne, Ze) => {
        Ze(Ne, {
            children: (ut, rt) => {
                var Ue = U6()
                  , lt = Rt(Ue);
                an(lt, () => F6, (Ve, gt) => {
                    gt(Ve, {
                        placeholder: "Country",
                        get ref() {
                            return w(E)
                        },
                        set ref(dt) {
                            fe(E, dt)
                        },
                        get value() {
                            return w(C)
                        },
                        set value(dt) {
                            fe(C, dt, !0)
                        }
                    })
                }
                );
                var et = U(lt, 2);
                an(et, () => O6, (Ve, gt) => {
                    gt(Ve, {
                        children: (dt, ct) => {
                            var ze = $6()
                              , vt = Rt(ze);
                            an(vt, () => k6, (ie, xe) => {
                                xe(ie, {
                                    children: (ue, Le) => {
                                        di();
                                        var Re = wa();
                                        st(We => Ce(Re, We), [ () => j2()]),
                                        H(ue, Re)
                                    }
                                    ,
                                    $$slots: {
                                        default: !0
                                    }
                                })
                            }
                            );
                            var Q = U(vt, 2);
                            an(Q, () => z6, (ie, xe) => {
                                xe(ie, {
                                    children: (ue, Le) => {
                                        var Re = cr()
                                          , We = Rt(Re);
                                        mn(We, 17, () => Bn.countries, it => it.id, (it, at) => {
                                            var ht = cr()
                                              , Ft = Rt(ht);
                                            an(Ft, () => L6, (zt, lr) => {
                                                lr(zt, {
                                                    get value() {
                                                        return w(at).name
                                                    },
                                                    onSelect: () => {
                                                        _(w(at).id),
                                                        o()
                                                    }
                                                    ,
                                                    children: (kt, xt) => {
                                                        var Pt = Z6()
                                                          , jt = z(Pt)
                                                          , Lt = z(jt, !0);
                                                        k(jt);
                                                        var nr = U(jt);
                                                        k(Pt),
                                                        st( () => {
                                                            Ce(Lt, w(at).flag),
                                                            Ce(nr, ` ${w(at).name ?? ""}`)
                                                        }
                                                        ),
                                                        H(kt, Pt)
                                                    }
                                                    ,
                                                    $$slots: {
                                                        default: !0
                                                    }
                                                })
                                            }
                                            ),
                                            H(it, ht)
                                        }
                                        ),
                                        H(ue, Re)
                                    }
                                    ,
                                    $$slots: {
                                        default: !0
                                    }
                                })
                            }
                            ),
                            H(dt, ze)
                        }
                        ,
                        $$slots: {
                            default: !0
                        }
                    })
                }
                ),
                H(ut, Ue)
            }
            ,
            $$slots: {
                default: !0
            }
        })
    }
    ),
    k(le),
    k(G);
    var De = U(G, 2);
    {
        var qe = Ne => {
            var Ze = H6();
            Ze.__click = [G6, _];
            var ut = z(Ze);
            dc(ut, {
                class: "size-3.5"
            }),
            k(Ze),
            H(Ne, Ze)
        }
        ;
        tt(De, Ne => {
            _() != 0 && Ne(qe)
        }
        )
    }
    k(W),
    Ss(W, Ne => fe(F, Ne), () => w(F)),
    st(Ne => Se = Vr(le, 1, "dropdown-content menu bg-base-100 rounded-box z-1 border-base-content/10 w-52 rounded-lg border py-1 shadow-sm", null, Se, Ne), [ () => ({
        "right-1": T() === "left"
    })]),
    _n("focus", re, () => {
        w(E).focus()
    }
    ),
    H(x, W),
    Dr()
}
Xi(["click"]);
var X6 = Pr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-7-.5-14.5T799-507q-5 29-27 48t-52 19h-80q-33 0-56.5-23.5T560-520v-40H400v-80q0-33 23.5-56.5T480-720h40q0-23 12.5-40.5T563-789q-20-5-40.5-8t-42.5-3q-134 0-227 93t-93 227h200q66 0 113 47t47 113v40H400v110q20 5 39.5 7.5T480-160Z"></path></svg>');
function K6(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = X6();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var Y6 = Pr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"></path></svg>')
  , J6 = Pr('<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>');
function Hf(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
    var T = cr()
      , E = Rt(T);
    {
        var F = o => {
            var W = Y6();
            Yt(W, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, W)
        }
          , C = o => {
            var W = J6();
            Yt(W, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, W)
        }
        ;
        tt(E, o => {
            l.filled ? o(F) : o(C, !1)
        }
        )
    }
    H(x, T)
}
var Q6 = Be('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>')
  , eA = Be('<div class="mb-2"><!></div>')
  , tA = Be('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>')
  , rA = (x, l, _) => {
    l.onvisitclick({
        lat: w(_).lastLatitude,
        lng: w(_).lastLongitude
    })
}
  , iA = Be('<tr><td class="text-base-content/80 text-center font-medium max-sm:hidden"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> <span class="ml-0.5"> </span></span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td><td class="px-1 text-center"><button class="btn btn-sm"> </button></td></tr>')
  , nA = Be('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th class="max-sm:hidden"></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip max-sm:hidden"><!></span></th><th class="px-1"></th></tr></thead><tbody></tbody></table>')
  , aA = Be('<tr><td class="text-base-content/80 text-center font-medium"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>')
  , sA = Be('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip before:-translate-x-1/4 max-sm:hidden"><!></span></th></tr></thead><tbody></tbody></table>')
  , oA = Be('<span class="font-flag tooltip ml-0.5"> </span>')
  , lA = Be("<span> </span>")
  , cA = Be('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>')
  , uA = Be('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>')
  , hA = Be('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>')
  , dA = Be('<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>')
  , pA = Be('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>')
  , fA = Be('<div class="tabs tabs-box max-sm:tabs-xs"></div> <div class="my-4 flex items-center justify-between"><!> <!></div> <!> <!>', 1);
function mA(x, l) {
    Lr(l, !0);
    const _ = [];
    let T = mt(1e3);
    const E = _t( () => w(T) <= 640);
    let F = mt("today")
      , C = {
        regions: {
            label: f3(),
            icon: dm
        },
        countries: {
            label: g3(),
            icon: K6
        },
        players: {
            label: lv(),
            icon: Gd
        },
        alliances: {
            label: cv(),
            icon: Hd
        }
    }
      , o = mt("regions")
      , W = mt(0)
      , G = Mn({
        players: {},
        alliances: {},
        regions: {},
        countries: {}
    })
      , re = _t( () => {
        var Ue, lt, et;
        return w(o) === "regions" ? (lt = (Ue = G[w(o)][w(W)]) == null ? void 0 : Ue[w(F)]) == null ? void 0 : lt.entries : (et = G[w(o)][w(F)]) == null ? void 0 : et.entries
    }
    );
    const de = 5 * 1e3;
    Gr( () => {
        var Ve;
        if (!l.open)
            return;
        const Ue = w(F)
          , lt = w(o)
          , et = w(W);
        lt === "players" && (!G[lt][Ue] || Date.now() - G[lt][Ue].time > de) ? ri.leaderboardPlayers(Ue).then(gt => {
            G[lt][Ue] = {
                time: Date.now(),
                entries: gt
            }
        }
        ).catch(gt => Zr.error(gt.message)) : lt === "alliances" && (!G[lt][Ue] || Date.now() - G[lt][Ue].time > de) ? ri.leaderboardAlliances(Ue).then(gt => {
            G[lt][Ue] = {
                time: Date.now(),
                entries: gt
            }
        }
        ).catch(gt => Zr.error(gt.message)) : lt === "countries" && (!G[lt][Ue] || Date.now() - G[lt][Ue].time > de) ? ri.leaderboardCountries(Ue).then(gt => {
            G[lt][Ue] = {
                time: Date.now(),
                entries: gt
            }
        }
        ).catch(gt => Zr.error(gt.message)) : lt === "regions" && (!((Ve = G[lt][et]) != null && Ve[Ue]) || Date.now() - G[lt][et][Ue].time > de) && ri.leaderboardRegions(Ue, et).then(gt => {
            G[lt][et] || (G[lt][et] = {}),
            G[lt][et][Ue] = {
                time: Date.now(),
                entries: gt
            }
        }
        ).catch(gt => Zr.error(gt.message))
    }
    );
    var he = fA()
      , X = Rt(he);
    mn(X, 21, () => Object.entries(C), ([Ue,{label: lt, icon: et}]) => Ue, (Ue, lt) => {
        var et = _t( () => Vg(w(lt), 2));
        let Ve = () => w(et)[0]
          , gt = () => w(et)[1].label
          , dt = () => w(et)[1].icon;
        const ct = _t(dt);
        var ze = Q6()
          , vt = z(ze);
        Ea(vt);
        var Q, ie = U(vt, 2);
        an(ie, () => w(ct), (ue, Le) => {
            Le(ue, {
                get this() {
                    return dt()
                },
                class: "mr-1 size-5 max-sm:hidden"
            })
        }
        );
        var xe = U(ie);
        k(ze),
        st( () => {
            jr(vt, "aria-label", gt()),
            Q !== (Q = Ve()) && (vt.value = (vt.__value = Ve()) ?? ""),
            Ce(xe, ` ${gt() ?? ""}`)
        }
        ),
        em(_, [], vt, () => (Ve(),
        w(o)), ue => fe(o, ue)),
        H(Ue, ze)
    }
    ),
    k(X);
    var le = U(X, 2)
      , Se = z(le);
    hm(Se, {
        get value() {
            return w(F)
        },
        set value(Ue) {
            fe(F, Ue, !0)
        }
    });
    var Ie = U(Se, 2);
    {
        var De = Ue => {
            Bg(Ue, {
                dropdownDirection: "left",
                get countryId() {
                    return w(W)
                },
                set countryId(lt) {
                    fe(W, lt, !0)
                }
            })
        }
        ;
        tt(Ie, Ue => {
            w(o) === "regions" && !w(E) && Ue(De)
        }
        )
    }
    k(le);
    var qe = U(le, 2);
    {
        var Ne = Ue => {
            var lt = eA()
              , et = z(lt);
            Bg(et, {
                get countryId() {
                    return w(W)
                },
                set countryId(Ve) {
                    fe(W, Ve, !0)
                }
            }),
            k(lt),
            H(Ue, lt)
        }
        ;
        tt(qe, Ue => {
            w(o) === "regions" && w(E) && Ue(Ne)
        }
        )
    }
    var Ze = U(qe, 2);
    {
        var ut = Ue => {
            var lt = tA()
              , et = z(lt)
              , Ve = U(et);
            {
                var gt = ct => {
                    var ze = wa();
                    st(vt => Ce(ze, vt), [ () => Ud().toLowerCase()]),
                    H(ct, ze)
                }
                  , dt = ct => {
                    var ze = cr()
                      , vt = Rt(ze);
                    {
                        var Q = xe => {
                            var ue = wa();
                            st(Le => Ce(ue, Le), [ () => am()]),
                            H(xe, ue)
                        }
                          , ie = xe => {
                            var ue = cr()
                              , Le = Rt(ue);
                            {
                                var Re = We => {
                                    var it = wa();
                                    st(at => Ce(it, at), [ () => sm()]),
                                    H(We, it)
                                }
                                ;
                                tt(Le, We => {
                                    w(F) === "month" && We(Re)
                                }
                                , !0)
                            }
                            H(xe, ue)
                        }
                        ;
                        tt(vt, xe => {
                            w(F) === "week" ? xe(Q) : xe(ie, !1)
                        }
                        , !0)
                    }
                    H(ct, ze)
                }
                ;
                tt(Ve, ct => {
                    w(F) === "today" ? ct(gt) : ct(dt, !1)
                }
                )
            }
            k(lt),
            st(ct => Ce(et, `${ct ?? ""} `), [ () => nm()]),
            H(Ue, lt)
        }
          , rt = Ue => {
            var lt = cr()
              , et = Rt(lt);
            {
                var Ve = dt => {
                    var ct = cr()
                      , ze = Rt(ct);
                    {
                        var vt = ie => {
                            const xe = _t( () => w(re));
                            var ue = nA()
                              , Le = z(ue)
                              , Re = z(Le)
                              , We = U(z(Re))
                              , it = z(We, !0);
                            k(We);
                            var at = U(We)
                              , ht = z(at)
                              , Ft = U(ht, 2)
                              , zt = U(Ft)
                              , lr = z(zt);
                            Hf(lr, {
                                class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                            }),
                            k(zt),
                            k(at),
                            di(),
                            k(Re),
                            k(Le);
                            var kt = U(Le);
                            mn(kt, 31, () => w(xe), xt => xt.id, (xt, Pt, jt) => {
                                const Lt = _t( () => as(w(Pt).countryId));
                                var nr = iA()
                                  , xr = z(nr)
                                  , er = z(xr, !0);
                                k(xr);
                                var Qt = U(xr)
                                  , $t = z(Qt)
                                  , tr = z($t, !0);
                                k($t);
                                var $r = U($t, 2)
                                  , zr = z($r)
                                  , Mr = U(zr)
                                  , sr = z(Mr);
                                k(Mr),
                                k($r),
                                k(Qt);
                                var Xt = U(Qt)
                                  , Ir = z(Xt, !0);
                                k(Xt);
                                var mr = U(Xt)
                                  , vr = z(mr);
                                vr.__click = [rA, l, Pt];
                                var br = z(vr, !0);
                                k(vr),
                                k(mr),
                                k(nr),
                                st( (_r, Ar, Tr) => {
                                    Ce(er, w(jt) + 1),
                                    jr($t, "data-tip", w(Lt).name),
                                    Ce(tr, w(Lt).flag),
                                    Vr($r, 1, `font-semibold ${_r ?? ""}`),
                                    Ce(zr, `${w(Pt).name ?? ""} `),
                                    Ce(sr, `#${w(Pt).number ?? ""}`),
                                    Ce(Ir, Ar),
                                    Ce(br, Tr)
                                }
                                , [ () => Xn(w(Pt).cityId), () => w(Pt).pixelsPainted.toLocaleString("en-US"), () => D3()]),
                                Ko(nr, () => Yo, () => ({
                                    duration: 200
                                })),
                                H(xt, nr)
                            }
                            ),
                            k(kt),
                            k(ue),
                            st( (xt, Pt, jt, Lt) => {
                                Ce(it, xt),
                                Ce(ht, `${Pt ?? ""} `),
                                Ce(Ft, `${jt ?? ""} `),
                                jr(zt, "data-tip", Lt)
                            }
                            , [ () => C3(), () => Yl(), () => Jl().toLowerCase(), () => E3()]),
                            H(ie, ue)
                        }
                          , Q = ie => {
                            var xe = cr()
                              , ue = Rt(xe);
                            {
                                var Le = We => {
                                    var it = sA()
                                      , at = z(it)
                                      , ht = z(at)
                                      , Ft = U(z(ht))
                                      , zt = z(Ft, !0);
                                    k(Ft);
                                    var lr = U(Ft)
                                      , kt = z(lr)
                                      , xt = U(kt, 2)
                                      , Pt = U(xt)
                                      , jt = z(Pt);
                                    Hf(jt, {
                                        class: "text-base-content/50 mb-0.5 ml-1 inline size-4"
                                    }),
                                    k(Pt),
                                    k(lr),
                                    k(ht),
                                    k(at);
                                    var Lt = U(at);
                                    mn(Lt, 31, () => w(re), nr => nr.id, (nr, xr, er) => {
                                        const Qt = _t( () => as(w(xr).id));
                                        var $t = aA()
                                          , tr = z($t)
                                          , $r = z(tr, !0);
                                        k(tr);
                                        var zr = U(tr)
                                          , Mr = z(zr)
                                          , sr = z(Mr, !0);
                                        k(Mr);
                                        var Xt = U(Mr, 2)
                                          , Ir = z(Xt, !0);
                                        k(Xt),
                                        k(zr);
                                        var mr = U(zr)
                                          , vr = z(mr, !0);
                                        k(mr),
                                        k($t),
                                        st( (br, _r) => {
                                            Ce($r, w(er) + 1),
                                            jr(Mr, "data-tip", w(Qt).name),
                                            Ce(sr, w(Qt).flag),
                                            Vr(Xt, 1, `font-semibold ${br ?? ""}`),
                                            Ce(Ir, w(Qt).name),
                                            Ce(vr, _r)
                                        }
                                        , [ () => Xn(w(xr).id), () => w(xr).pixelsPainted.toLocaleString("en-US")]),
                                        Ko($t, () => Yo, () => ({
                                            duration: 200
                                        })),
                                        H(nr, $t)
                                    }
                                    ),
                                    k(Lt),
                                    k(it),
                                    st( (nr, xr, er, Qt) => {
                                        Ce(zt, nr),
                                        Ce(kt, `${xr ?? ""} `),
                                        Ce(xt, `${er ?? ""} `),
                                        jr(Pt, "data-tip", Qt)
                                    }
                                    , [ () => tv(), () => Yl(), () => Jl().toLowerCase(), () => uC()]),
                                    H(We, it)
                                }
                                  , Re = We => {
                                    var it = cr()
                                      , at = Rt(it);
                                    {
                                        var ht = zt => {
                                            const lr = _t( () => w(re));
                                            var kt = uA()
                                              , xt = z(kt)
                                              , Pt = z(xt)
                                              , jt = U(z(Pt))
                                              , Lt = z(jt, !0);
                                            k(jt);
                                            var nr = U(jt)
                                              , xr = z(nr)
                                              , er = U(xr, 2, !0);
                                            k(nr),
                                            k(Pt),
                                            k(xt);
                                            var Qt = U(xt);
                                            mn(Qt, 31, () => w(lr), $t => $t.id, ($t, tr, $r) => {
                                                const zr = _t( () => {
                                                    var Oe;
                                                    return ((Oe = Vt.data) == null ? void 0 : Oe.id) === w(tr).id
                                                }
                                                );
                                                var Mr = cA();
                                                let sr;
                                                var Xt = z(Mr)
                                                  , Ir = z(Xt, !0);
                                                k(Xt);
                                                var mr = U(Xt)
                                                  , vr = z(mr)
                                                  , br = z(vr);
                                                ss(br, {
                                                    class: "size-8 border sm:size-10",
                                                    get userId() {
                                                        return w(tr).id
                                                    },
                                                    get pictureUrl() {
                                                        return w(tr).picture
                                                    }
                                                });
                                                var _r = U(br, 2)
                                                  , Ar = z(_r)
                                                  , Tr = z(Ar)
                                                  , be = U(Tr)
                                                  , q = z(be);
                                                k(be),
                                                k(Ar);
                                                var V = U(Ar, 2);
                                                {
                                                    var K = Oe => {
                                                        const Ee = _t( () => as(w(tr).equippedFlag));
                                                        var Ke = oA()
                                                          , ye = z(Ke, !0);
                                                        k(Ke),
                                                        st( () => {
                                                            jr(Ke, "data-tip", w(Ee).name),
                                                            Ce(ye, w(Ee).flag)
                                                        }
                                                        ),
                                                        H(Oe, Ke)
                                                    }
                                                    ;
                                                    tt(V, Oe => {
                                                        w(tr).equippedFlag && Oe(K)
                                                    }
                                                    )
                                                }
                                                var ae = U(V, 2);
                                                {
                                                    var we = Oe => {
                                                        fh(Oe, {
                                                            get username() {
                                                                return w(tr).discord
                                                            }
                                                        })
                                                    }
                                                    ;
                                                    tt(ae, Oe => {
                                                        w(tr).discord && Oe(we)
                                                    }
                                                    )
                                                }
                                                var Me = U(ae, 2);
                                                {
                                                    var ke = Oe => {
                                                        var Ee = lA()
                                                          , Ke = z(Ee, !0);
                                                        k(Ee),
                                                        st( (ye, It) => {
                                                            Vr(Ee, 1, `badge badge-sm ml-0.5 border-0 ${ye ?? ""} ${It ?? ""}`),
                                                            Ce(Ke, w(tr).allianceName)
                                                        }
                                                        , [ () => tm(w(tr).allianceId), () => Xn(w(tr).allianceId)]),
                                                        H(Oe, Ee)
                                                    }
                                                    ;
                                                    tt(Me, Oe => {
                                                        "allianceName"in w(tr) && w(tr).allianceName && Oe(ke)
                                                    }
                                                    )
                                                }
                                                k(_r),
                                                k(vr),
                                                k(mr);
                                                var ge = U(mr)
                                                  , je = z(ge, !0);
                                                k(ge),
                                                k(Mr),
                                                st( (Oe, Ee, Ke) => {
                                                    sr = Vr(Mr, 1, "", null, sr, Oe),
                                                    Ce(Ir, w($r) + 1),
                                                    Vr(Ar, 1, `font-semibold max-sm:ml-2 ${Ee ?? ""}`),
                                                    Ce(Tr, `${w(tr).name ?? ""} `),
                                                    Ce(q, `#${w(tr).id ?? ""}`),
                                                    Ce(je, Ke)
                                                }
                                                , [ () => ({
                                                    "bg-base-200": w(zr)
                                                }), () => Xn(w(tr).id), () => w(tr).pixelsPainted.toLocaleString("en-US")]),
                                                Ko(Mr, () => Yo, () => ({
                                                    duration: 200
                                                })),
                                                H($t, Mr)
                                            }
                                            ),
                                            k(Qt),
                                            k(kt),
                                            st( ($t, tr, $r) => {
                                                Ce(Lt, $t),
                                                Ce(xr, `${tr ?? ""} `),
                                                Ce(er, $r)
                                            }
                                            , [ () => om(), () => Yl(), () => Jl().toLowerCase()]),
                                            H(zt, kt)
                                        }
                                          , Ft = zt => {
                                            var lr = cr()
                                              , kt = Rt(lr);
                                            {
                                                var xt = Pt => {
                                                    var jt = dA()
                                                      , Lt = z(jt)
                                                      , nr = z(Lt)
                                                      , xr = U(z(nr))
                                                      , er = z(xr, !0);
                                                    k(xr);
                                                    var Qt = U(xr)
                                                      , $t = z(Qt)
                                                      , tr = U($t, 2, !0);
                                                    k(Qt),
                                                    k(nr),
                                                    k(Lt);
                                                    var $r = U(Lt);
                                                    mn($r, 31, () => w(re), zr => zr.id, (zr, Mr, sr) => {
                                                        const Xt = _t( () => {
                                                            var V;
                                                            return ((V = Vt.data) == null ? void 0 : V.allianceId) === w(Mr).id
                                                        }
                                                        );
                                                        var Ir = hA();
                                                        let mr;
                                                        var vr = z(Ir)
                                                          , br = z(vr, !0);
                                                        k(vr);
                                                        var _r = U(vr)
                                                          , Ar = z(_r)
                                                          , Tr = z(Ar, !0);
                                                        k(Ar),
                                                        k(_r);
                                                        var be = U(_r)
                                                          , q = z(be, !0);
                                                        k(be),
                                                        k(Ir),
                                                        st( (V, K, ae) => {
                                                            mr = Vr(Ir, 1, "", null, mr, V),
                                                            Ce(br, w(sr) + 1),
                                                            Vr(Ar, 1, `font-semibold ${K ?? ""}`),
                                                            Ce(Tr, w(Mr).name),
                                                            Ce(q, ae)
                                                        }
                                                        , [ () => ({
                                                            "bg-base-200": w(Xt)
                                                        }), () => Xn(w(Mr).id), () => w(Mr).pixelsPainted.toLocaleString("en-US")]),
                                                        Ko(Ir, () => Yo, () => ({
                                                            duration: 200
                                                        })),
                                                        H(zr, Ir)
                                                    }
                                                    ),
                                                    k($r),
                                                    k(jt),
                                                    st( (zr, Mr, sr) => {
                                                        Ce(er, zr),
                                                        Ce($t, `${Mr ?? ""} `),
                                                        Ce(tr, sr)
                                                    }
                                                    , [ () => Zd(), () => Yl(), () => Jl().toLowerCase()]),
                                                    H(Pt, jt)
                                                }
                                                ;
                                                tt(kt, Pt => {
                                                    w(o) === "alliances" && Pt(xt)
                                                }
                                                , !0)
                                            }
                                            H(zt, lr)
                                        }
                                        ;
                                        tt(at, zt => {
                                            w(o) === "players" ? zt(ht) : zt(Ft, !1)
                                        }
                                        , !0)
                                    }
                                    H(We, it)
                                }
                                ;
                                tt(ue, We => {
                                    w(o) === "countries" ? We(Le) : We(Re, !1)
                                }
                                , !0)
                            }
                            H(ie, xe)
                        }
                        ;
                        tt(ze, ie => {
                            w(o) === "regions" ? ie(vt) : ie(Q, !1)
                        }
                        )
                    }
                    H(dt, ct)
                }
                  , gt = dt => {
                    var ct = pA();
                    H(dt, ct)
                }
                ;
                tt(et, dt => {
                    w(re) ? dt(Ve) : dt(gt, !1)
                }
                , !0)
            }
            H(Ue, lt)
        }
        ;
        tt(Ze, Ue => {
            w(re) && w(re).length === 0 ? Ue(ut) : Ue(rt, !1)
        }
        )
    }
    Vd("innerWidth", Ue => fe(T, Ue, !0)),
    H(x, he),
    Dr()
}
Xi(["click"]);
var _A = Pr('<svg><path d="M160-200h160v-320H160v320Zm240 0h160v-560H400v560Zm240 0h160v-240H640v240ZM80-120v-480h240v-240h320v320h240v400H80Z"></path></svg>');
function Fv(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = _A();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var gA = Be('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5 sm:overflow-x-hidden"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> </h3></div> <div class="mt-4"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function vA(x, l) {
    Lr(l, !0);
    let _ = At(l, "open", 15);
    wi( () => {
        const de = he => {
            he.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", de),
        () => document.removeEventListener("keydown", de)
    }
    );
    var T = gA()
      , E = z(T)
      , F = U(z(E), 2)
      , C = z(F);
    Fv(C, {
        class: "size-6"
    });
    var o = U(C, 2)
      , W = z(o, !0);
    k(o),
    k(F);
    var G = U(F, 2)
      , re = z(G);
    mA(re, {
        get onvisitclick() {
            return l.onvisitclick
        },
        get open() {
            return _()
        }
    }),
    k(G),
    k(E),
    di(2),
    k(T),
    Fn(T, () => de => {
        Gr( () => {
            _() ? de.show() : de.close()
        }
        )
    }
    ),
    st(de => Ce(W, de), [ () => rm()]),
    _n("close", T, () => _(!1)),
    H(x, T),
    Dr()
}
var yA = Be("<div><!></div>")
  , xA = Be('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function bA(x, l) {
    Lr(l, !0);
    let _ = At(l, "open", 15);
    wi( () => {
        const o = W => {
            W.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", o),
        () => document.removeEventListener("keydown", o)
    }
    );
    var T = xA()
      , E = z(T)
      , F = U(z(E), 2);
    {
        var C = o => {
            var W = yA()
              , G = z(W);
            kx(G, {}),
            k(W),
            Cn(2, W, () => Wn, () => ({
                duration: 300
            })),
            H(o, W)
        }
        ;
        tt(F, o => {
            _() && o(C)
        }
        )
    }
    k(E),
    di(2),
    k(T),
    Fn(T, () => o => {
        Gr( () => {
            _() ? o.show() : o.close()
        }
        )
    }
    ),
    _n("close", T, () => _(!1)),
    H(x, T),
    Dr()
}
var wA = (x, l, _) => {
    localStorage.setItem(w(l), "true"),
    fe(_, !1)
}
  , TA = Be('<span class="indicator-item indicator-bottom indicator-center badge badge-primary badge-xs">new</span>')
  , CA = Be("<div><!> <!></div>");
function vf(x, l) {
    Lr(l, !0);
    let _ = mt(!1);
    const T = _t( () => "showed:" + l.key);
    wi( () => {
        fe(_, !localStorage.getItem(w(T)))
    }
    );
    var E = CA();
    E.__click = [wA, T, _];
    var F = z(E);
    {
        var C = W => {
            var G = TA();
            Cn(3, G, () => Wn, () => ({
                duration: 200
            })),
            H(W, G)
        }
        ;
        tt(F, W => {
            w(_) && W(C)
        }
        )
    }
    var o = U(F, 2);
    Wi(o, () => l.children),
    k(E),
    st( () => Vr(E, 1, `indicator ${l.class ?? ""}`)),
    H(x, E),
    Dr()
}
Xi(["click"]);
var SA = Be("<p>You don't have charges to paint. <br/> </p>");
function PA(x, l) {
    Lr(l, !1),
    Kg();
    var _ = SA()
      , T = U(z(_), 2);
    k(_),
    st(E => Ce(T, ` Next charge in ${E ?? ""}`), [ () => zd(Vt.cooldown ?? 0)]),
    H(x, _),
    Dr()
}
var IA = Be("<canvas></canvas>");
function Ov(x, l) {
    Lr(l, !0);
    let _ = At(l, "width", 15, 0)
      , T = Jt(l, ["$$slots", "$$events", "$$legacy", "value", "fontSize", "color", "weight", "mono", "width"])
      , E = _t( () => Math.ceil(l.fontSize))
      , F = mt(null);
    const C = window.devicePixelRatio ?? 1
      , o = '"Geist", ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"'
      , W = '"Geist Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    Gr( () => {
        const re = w(F).getContext("2d");
        re.textBaseline = "top",
        re.font = `${l.weight ?? "normal"} ${l.fontSize}px ${l.mono ? W : o}`,
        re.fillStyle = l.color ?? "#394e6a",
        re.setTransform(C, 0, 0, C, 0, 0),
        re.clearRect(0, 0, _(), w(E)),
        re.fillText(l.value, 0, 0);
        const de = re.measureText(l.value);
        _(Math.ceil(de.actualBoundingBoxRight)),
        fe(E, de.actualBoundingBoxDescent)
    }
    );
    var G = IA();
    Yt(G, () => ({
        width: _() * C,
        height: w(E) * C,
        style: `width: ${_() ?? ""}px; height: ${w(E) ?? ""}px`,
        ...T
    })),
    Ss(G, re => fe(F, re), () => w(F)),
    H(x, G),
    Dr()
}
var MA = Be('<span class="w-7 text-xs"> </span>')
  , AA = Be('<span class="flex items-center gap-1 sm:mt-[1px]"><span><!></span> <!></span>')
  , kA = Be('<span class="loading loading-spinner center-absolute absolute"></span>')
  , EA = Be('<button><!> <div class="flex items-center gap-2"> <!></div> <!></button>');
function Nv(x, l) {
    Lr(l, !0);
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy", "loading", "charges"])
      , T = mt(0);
    var E = EA();
    Yt(E, () => ({
        ..._,
        class: `btn btn-primary btn-lg sm:btn-xl relative ${l.class ?? ""}`
    }));
    var F = z(E);
    mh(F, {
        class: "size-6"
    });
    var C = U(F, 2)
      , o = z(C)
      , W = U(o);
    {
        var G = he => {
            const X = _t( () => `${Math.floor(l.charges)}/${Vt.data.charges.max}`);
            var le = AA()
              , Se = z(le)
              , Ie = z(Se);
            {
                let Ne = _t( () => l.disabled ? "#394e6a33" : "#ffffff");
                Ov(Ie, {
                    weight: 600,
                    fontSize: 16,
                    get value() {
                        return w(X)
                    },
                    get color() {
                        return w(Ne)
                    },
                    get width() {
                        return w(T)
                    },
                    set width(Ze) {
                        fe(T, Ze, !0)
                    }
                })
            }
            k(Se);
            var De = U(Se, 2);
            {
                var qe = Ne => {
                    var Ze = MA()
                      , ut = z(Ze);
                    k(Ze),
                    st(rt => Ce(ut, `(${rt ?? ""})`), [ () => zd(Vt.cooldown)]),
                    H(Ne, Ze)
                }
                ;
                tt(De, Ne => {
                    l.charges < Vt.data.charges.max && Vt.cooldown !== void 0 && Ne(qe)
                }
                )
            }
            k(le),
            st(Ne => lc(Se, `width: ${Ne ?? ""}px`), [ () => (Math.floor(w(T) / 5) + 1) * 5]),
            H(he, le)
        }
        ;
        tt(W, he => {
            l.charges !== void 0 && Vt.data && he(G)
        }
        )
    }
    k(C);
    var re = U(C, 2);
    {
        var de = he => {
            var X = kA();
            H(he, X)
        }
        ;
        tt(re, he => {
            l.loading && he(de)
        }
        )
    }
    k(E),
    st(he => Ce(o, `${he ?? ""} `), [ () => iv()]),
    H(x, E),
    Dr()
}
const zA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAABVQTFRFAAAASkKEenHEta7xWmmLi5y0v8vc+SuCVQAAAAF0Uk5TAEDm2GYAAAA/SURBVHjaXcjBDcAwDMNAUW28/8hF0MCIzN9RV7aVfuxp+IGPe+AdPQRpFaRrgcNrn/Bb4LAE4W5aNb3TXUofoSgBYpzN5I4AAAAASUVORK5CYII="
  , LA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAFxJREFUeNq107EJACAMRFEHyxSu4jbuZ+0IyhUS4ZDogYEr3++Svp+ZDUzGrRTMIwKmiIApImCKiBgbOXOEcRxQsQcW7rVKeA9gj5gD2D3mgC/GcQSLMEdO+/qtE+/GV5duYCOPAAAAAElFTkSuQmCC"
  , DA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAAXNSR0IArs4c6QAAAAJ0Uk5TAAB2k804AAAAKklEQVR42mOAAhsbCA3n//9vQ74ApqE2QIAgwIqBykFaICwMAQwt9HEpAIf2Me1Ro5Q9AAAAAElFTkSuQmCC"
  , RA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAABVJREFUeNpjYGA48x8DYwoB1Q0RlQDDCVmniJ241gAAAABJRU5ErkJggg==";
function BA(x, l, _) {
    return new Promise( (T, E) => {
        x.once("render", () => {
            const F = x.getCanvas().toDataURL()
              , C = document.createElement("img");
            C.src = F,
            C.onload = () => {
                const o = document.createElement("canvas");
                o.width = C.width,
                o.height = C.height;
                const W = o.getContext("2d");
                if (W) {
                    W.drawImage(C, 0, 0);
                    const [G,re,de,he] = W.getImageData(l, _, 1, 1).data;
                    T([G, re, de, he])
                } else
                    E(new Error("Could not get 2d context from canvas"));
                C.remove(),
                o.remove()
            }
        }
        ),
        x.triggerRepaint()
    }
    )
}
class FA {
    constructor(l) {
        hr(this, "gm");
        hr(this, "opacity", 1);
        hr(this, "id", `paint-preview-${Math.random()}`);
        hr(this, "tiles", new Map);
        this.input = l,
        this.gm = new cc(this.input.tileSize)
    }
    place([l,_], T) {
        const {tile: E, pixel: F} = this.gm.latLonToTileAndPixel(l, _, this.input.tileZoom)
          , C = this.getTileKey(E[0], E[1]);
        let o = this.tiles.get(C);
        if (!o) {
            const W = this.gm.tileBoundsLatLon(E[0], E[1], this.input.tileZoom)
              , G = lm(W, !0)
              , re = new OA({
                coordinates: G,
                id: `${this.id}-${C}`,
                layerPaint: {
                    "raster-opacity": this.opacity,
                    "raster-resampling": "nearest"
                },
                tileSize: this.input.tileSize,
                beforeLayerId: this.input.beforeLayerId
            });
            re.addTo(this.input.map),
            this.tiles.set(C, re),
            o = re
        }
        o.place(F[0], this.input.tileSize - F[1] - 1, T)
    }
    clear() {
        const l = this.input.map;
        for (const _ of this.tiles.values())
            _.removeFrom(l),
            _.removeDOM();
        this.tiles.clear()
    }
    clearAndPlace(l, _) {
        this.clear(),
        this.place(l, _)
    }
    remove([l,_]) {
        const {tile: T, pixel: E} = this.gm.latLonToTileAndPixel(l, _, this.input.tileZoom)
          , F = this.getTileKey(T[0], T[1])
          , C = this.tiles.get(F);
        C && C.remove(E[0], this.input.tileSize - E[1] - 1)
    }
    setCanvasOpacity(l) {
        this.opacity = l;
        for (const _ of this.tiles.values())
            _.setOpacity(l)
    }
    getTileKey(l, _) {
        return `${l},${_}`
    }
}
class OA {
    constructor(l) {
        hr(this, "canvas");
        hr(this, "maps", new Set);
        this.input = l;
        const _ = this.input.tileSize;
        this.canvas = document.createElement("canvas"),
        this.canvas.width = _,
        this.canvas.height = _
    }
    place(l, _, T) {
        var C;
        const E = ((C = Bn.colors) == null ? void 0 : C[T]) ?? Bn.colors[0]
          , F = this.canvas.getContext("2d");
        if (F) {
            const o = F.createImageData(1, 1)
              , [W,G,re] = E.rgb
              , de = T === 0 ? 0 : 255;
            o.data[0] = W,
            o.data[1] = G,
            o.data[2] = re,
            o.data[3] = de,
            F.putImageData(o, l, _)
        }
    }
    remove(l, _) {
        const T = this.canvas.getContext("2d");
        T && T.clearRect(l, _, 1, 1)
    }
    addTo(l) {
        const _ = this.input.id;
        l.getSource(_) || l.addSource(_, {
            type: "canvas",
            canvas: this.canvas,
            coordinates: this.input.coordinates
        }),
        l.getLayer(_) || (l.addLayer({
            id: _,
            type: "raster",
            source: _,
            paint: this.input.layerPaint
        }),
        this.input.beforeLayerId && l.moveLayer(_, this.input.beforeLayerId)),
        this.maps.add(l)
    }
    removeFrom(l) {
        const {id: _} = this.input;
        l.getLayer(_) && l.removeLayer(_),
        l.getSource(_) && l.removeSource(_),
        this.maps.delete(l)
    }
    removeDOM() {
        this.canvas.remove()
    }
    setOpacity(l) {
        for (const _ of this.maps.values())
            _.setPaintProperty(this.input.id, "raster-opacity", l)
    }
}
var NA = Pr('<svg><path d="M5 21C4.45 21 3.97917 20.8042 3.5875 20.4125C3.19583 20.0208 3 19.55 3 19V15H5V19H9V21H5ZM15 21V19H19V15H21V19C21 19.55 20.8042 20.0208 20.4125 20.4125C20.0208 20.8042 19.55 21 19 21H15ZM3 9V5C3 4.45 3.19583 3.97917 3.5875 3.5875C3.97917 3.19583 4.45 3 5 3H9V5H5V9H3ZM19 9V5H15V3H19C19.55 3 20.0208 3.19583 20.4125 3.5875C20.8042 3.97917 21 4.45 21 5V9H19Z"></path></svg>');
function jA(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = NA();
    Yt(T, () => ({
        viewBox: "0 0 24 24",
        fill: "currentColor",
        xmlns: "http://www.w3.org/2000/svg",
        ..._
    })),
    H(x, T)
}
var qA = Pr('<svg><path d="M5 19H9V21H5C4.45 21 3.97956 20.8038 3.58789 20.4121C3.19622 20.0204 3 19.55 3 19V15H5V19ZM20.6768 20.0908C20.6015 20.2031 20.5138 20.3105 20.4121 20.4121C20.0204 20.8038 19.55 21 19 21H15V19H19V18.4141L20.6768 20.0908ZM21 17.5859L19 15.5859V15H21V17.5859ZM5.58594 5H5V9H3V5C3 4.45 3.19622 3.97956 3.58789 3.58789C3.68947 3.48631 3.79597 3.3975 3.9082 3.32227L5.58594 5ZM19 3C19.55 3 20.0204 3.19622 20.4121 3.58789C20.8038 3.97956 21 4.45 21 5V9H19V5H15V3H19ZM9 5H8.41406L6.41406 3H9V5Z"></path><rect x="1" y="2.41422" width="2" height="29" transform="rotate(-45 1 2.41422)"></rect></svg>');
function VA(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = qA();
    Yt(T, () => ({
        viewBox: "0 0 24 24",
        fill: "currentColor",
        xmlns: "http://www.w3.org/2000/svg",
        ..._
    })),
    H(x, T)
}
var ZA = Be("<div><!></div>");
function xu(x, l) {
    Lr(l, !0);
    var _ = ZA()
      , T = z(_);
    Wi(T, () => l.children ?? Sn),
    k(_),
    st( () => Vr(_, 1, `bg-base-100/60 border-base-content/20 -top-15 pointer-events-none absolute left-1/2 line-clamp-1 flex w-max -translate-x-1/2 select-none items-center gap-1 rounded-full border-2 px-3 py-1.5 ${l.class ?? ""}`)),
    H(x, _),
    Dr()
}
var $A = Be('<div class="confetti svelte-15ksp55"></div>')
  , UA = Be("<div></div>");
function gm(x, l) {
    Lr(l, !0);
    const _ = At(l, "size", 3, 10)
      , T = At(l, "x", 19, () => [-.5, .5])
      , E = At(l, "y", 19, () => [.25, 1])
      , F = At(l, "duration", 3, 2e3)
      , C = At(l, "infinite", 3, !1)
      , o = At(l, "delay", 19, () => [0, 50])
      , W = At(l, "colorRange", 19, () => [0, 360])
      , G = At(l, "colorArray", 19, () => [])
      , re = At(l, "amount", 3, 50)
      , de = At(l, "iterationCount", 3, 1)
      , he = At(l, "fallDistance", 3, "100px")
      , X = At(l, "rounded", 3, !1)
      , le = At(l, "cone", 3, !1)
      , Se = At(l, "noGravity", 3, !1)
      , Ie = At(l, "xSpread", 3, .15)
      , De = At(l, "destroyOnComplete", 3, !0)
      , qe = At(l, "disableForReducedMotion", 3, !1);
    let Ne = mt(!1);
    wi( () => {
        !De() || C() || typeof de() == "string" || setTimeout( () => fe(Ne, !0), (F() + o()[1]) * de())
    }
    );
    function Ze(et, Ve) {
        return Math.random() * (Ve - et) + et
    }
    function ut() {
        return G().length ? G()[Math.round(Math.random() * (G().length - 1))] : `hsl(${Math.round(Ze(W()[0], W()[1]))}, 75%, 50%)`
    }
    var rt = cr()
      , Ue = Rt(rt);
    {
        var lt = et => {
            var Ve = UA();
            let gt;
            mn(Ve, 21, () => ({
                length: re()
            }), Jf, (dt, ct) => {
                var ze = $A();
                st( (vt, Q, ie, xe, ue, Le, Re, We, it, at, ht) => lc(ze, `
        --color: ${vt ?? ""};
        --skew: ${Q ?? ""}deg,${ie ?? ""}deg;
        --rotation-xyz: ${xe ?? ""}, ${ue ?? ""}, ${Le ?? ""};
        --rotation-deg: ${Re ?? ""}deg;
        --translate-y-multiplier: ${We ?? ""};
        --translate-x-multiplier: ${it ?? ""};
        --scale: ${at ?? ""};
        --transition-delay: ${ht ?? ""}ms;
        --transition-duration: ${C() ? `calc(${F()}ms * var(--scale))` : `${F()}ms`};`), [ut, () => Ze(-45, 45), () => Ze(-45, 45), () => Ze(-10, 10), () => Ze(-10, 10), () => Ze(-10, 10), () => Ze(0, 360), () => Ze(E()[0], E()[1]), () => Ze(T()[0], T()[1]), () => .1 * Ze(2, 10), () => Ze(o()[0], o()[1])]),
                H(dt, ze)
            }
            ),
            k(Ve),
            st(dt => {
                gt = Vr(Ve, 1, "confetti-holder svelte-15ksp55", null, gt, dt),
                lc(Ve, `
    --fall-distance: ${he() ?? ""};
    --size: ${_() ?? ""}px;
    --x-spread: ${1 - Ie()};
    --transition-iteration-count: ${(C() ? "infinite" : de()) ?? ""};`)
            }
            , [ () => ({
                rounded: X(),
                cone: le(),
                "no-gravity": Se(),
                "reduced-motion": qe()
            })]),
            H(et, Ve)
        }
        ;
        tt(Ue, et => {
            w(Ne) || et(lt)
        }
        )
    }
    H(x, rt),
    Dr()
}
var GA = async (x, l, _, T) => {
    try {
        fe(l, !0),
        await ri.purchase({
            id: _,
            amount: 1,
            variant: T.colorIdx
        }),
        await Vt.refresh(),
        ua.notification1.play()
    } catch (E) {
        Zr.error(E.message)
    } finally {
        fe(l, !1)
    }
}
  , HA = Be('<span class="loading loading-spinner center-absolute absolute"></span>')
  , WA = Be('<!> <span class="text-sm">Droplets</span>', 1)
  , XA = Be('<!> Unlocked <span class="center-absolute absolute"><!></span>', 1)
  , KA = (x, l) => l(!1)
  , YA = Be('<div class="flex flex-col gap-4"><section><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold">Unlock</h3> <div class="ml-auto mr-4"><!></div></div> <p class="text-base-content/80 mt-1 text-sm">Permanently unlock the color</p></section> <div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="border-base-content/20 size-32 rounded-2xl border-4"></div></div> <p class="mt-4 text-center text-2xl font-bold"> </p> <div class="flex w-max flex-col"><div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!></button></div> <button class="btn relative mt-3 h-10">Close</button></div></div></div>')
  , JA = Be('<dialog class="modal !bg-black/80"><div class="modal-box max-h-11/12 w-11/12 max-w-md"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function QA(x, l) {
    Lr(l, !0);
    let _ = At(l, "open", 15);
    const T = _t( () => Bn.colors[l.colorIdx])
      , E = _t( () => {
        var X;
        return ((X = Vt.data) == null ? void 0 : X.droplets) ?? 0
    }
    );
    let F = mt(!1);
    const C = _t( () => (w(F),
    Vt.hasColor(l.colorIdx)));
    wi( () => {
        const X = le => {
            le.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", X),
        () => document.removeEventListener("keydown", X)
    }
    );
    const o = 100
      , W = Bn.products[o];
    var G = JA()
      , re = z(G)
      , de = U(z(re), 2);
    {
        var he = X => {
            var le = YA()
              , Se = z(le)
              , Ie = z(Se)
              , De = z(Ie);
            Ld(De, {
                class: "size-6"
            });
            var qe = U(De, 4)
              , Ne = z(qe);
            Wg(Ne, {
                get value() {
                    return w(E)
                }
            }),
            k(qe),
            k(Ie),
            di(2),
            k(Se);
            var Ze = U(Se, 2)
              , ut = z(Ze)
              , rt = z(ut);
            k(ut);
            var Ue = U(ut, 2)
              , lt = z(Ue, !0);
            k(Ue);
            var et = U(Ue, 2)
              , Ve = z(et);
            let gt;
            var dt = z(Ve);
            dt.__click = [GA, F, o, l];
            var ct = z(dt);
            {
                var ze = ue => {
                    var Le = HA();
                    H(ue, Le)
                }
                ;
                tt(ct, ue => {
                    w(F) && ue(ze)
                }
                )
            }
            var vt = U(ct, 2);
            {
                var Q = ue => {
                    var Le = WA()
                      , Re = Rt(Le);
                    qd(Re, {
                        class: "size-5"
                    });
                    var We = U(Re);
                    di(),
                    st(it => Ce(We, ` ${it ?? ""} `), [ () => W.price.toLocaleString("en-US")]),
                    H(ue, Le)
                }
                  , ie = ue => {
                    var Le = XA()
                      , Re = Rt(Le);
                    Ld(Re, {
                        class: "size-5"
                    });
                    var We = U(Re, 2)
                      , it = z(We);
                    gm(it, {}),
                    k(We),
                    H(ue, Le)
                }
                ;
                tt(vt, ue => {
                    w(C) ? ue(ie, !1) : ue(Q)
                }
                )
            }
            k(dt),
            k(Ve);
            var xe = U(Ve, 2);
            xe.__click = [KA, _],
            k(et),
            k(Ze),
            k(le),
            st( (ue, Le) => {
                lc(rt, `background: rgb(${w(T).rgb[0]} ${w(T).rgb[1]} ${w(T).rgb[2]})`),
                jr(rt, "aria-label", w(T).name),
                Ce(lt, w(T).name),
                jr(Ve, "data-tip", ue),
                gt = Vr(Ve, 1, "", null, gt, Le),
                dt.disabled = w(E) < W.price || w(F) || w(C)
            }
            , [ () => $d(), () => ({
                tooltip: !w(C) && w(E) < W.price
            })]),
            H(X, le)
        }
        ;
        tt(de, X => {
            Vt.data && X(he)
        }
        )
    }
    k(re),
    di(2),
    k(G),
    Fn(G, () => X => {
        Gr( () => {
            _() ? X.show() : X.close()
        }
        )
    }
    ),
    _n("close", G, () => _(!1)),
    H(x, G),
    Dr()
}
Xi(["click"]);
var ek = Pr('<svg><path d="M120-120v-190l358-358-58-56 58-56 76 76 124-124q5-5 12.5-8t15.5-3q8 0 15 3t13 8l94 94q5 6 8 13t3 15q0 8-3 15.5t-8 12.5L705-555l76 78-57 57-56-58-358 358H120Zm80-80h78l332-334-76-76-334 332v78Zm447-410 96-96-37-37-96 96 37 37Zm0 0-37-37 37 37Z"></path></svg>');
function Fg(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = ek();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var tk = Pr('<svg><path d="m247-904 57-56 343 343q23 23 23 57t-23 57L457-313q-23 23-57 23t-57-23L153-503q-23-23-23-57t23-57l190-191-96-96Zm153 153L209-560h382L400-751Zm360 471q-33 0-56.5-23.5T680-360q0-21 12.5-45t27.5-45q9-12 19-25t21-25q11 12 21 25t19 25q15 21 27.5 45t12.5 45q0 33-23.5 56.5T760-280ZM80 0v-160h800V0H80Z"></path></svg>');
function jv(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = tk();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var rk = Pr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm240-400v80h80v-80h-80Zm-160 0v80h80v-80h-80Zm80 80v80h80v-80h-80Zm160 0v80h80v-80h-80Zm-320 0v80h80v-80h-80Zm400-80v80h80v80h80v-80h-80v-80h-80ZM280-360v80h-80v80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h-80v80h-80v-80h-80v80h-80v-80h-80Zm480-160v80-80Zm0 160v80-80Z"></path></svg>')
  , ik = Pr('<svg><path d="M440-440v-80h80v80h-80Zm-80 80v-80h80v80h-80Zm160 0v-80h80v80h-80Zm80-80v-80h80v80h-80Zm-320 0v-80h80v80h-80Zm-80 320q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm80-80h80v-80h-80v80Zm160 0h80v-80h-80v80Zm320 0v-80 80Zm-560-80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h80v-320H200v320h80v80h-80v80Zm0 80v-560 560Zm560-240v80-80ZM600-280v80h80v-80h-80Z"></path></svg>');
function qv(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
    var T = cr()
      , E = Rt(T);
    {
        var F = o => {
            var W = rk();
            Yt(W, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, W)
        }
          , C = o => {
            var W = ik();
            Yt(W, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, W)
        }
        ;
        tt(E, o => {
            l.filled ? o(F) : o(C, !1)
        }
        )
    }
    H(x, T)
}
var nk = Pr('<svg><path d="M240-80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h40v-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Zm0-80h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM360-640h240v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80ZM240-160v-400 400Z"></path></svg>');
function Wf(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = nk();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var ak = Pr('<svg><path d="M419-80q-28 0-52.5-12T325-126L107-403l19-20q20-21 48-25t52 11l74 45v-328q0-17 11.5-28.5T340-760q17 0 29 11.5t12 28.5v472l-97-60 104 133q6 7 14 11t17 4h221q33 0 56.5-23.5T720-240v-160q0-17-11.5-28.5T680-440H461v-80h219q50 0 85 35t35 85v160q0 66-47 113T640-80H419ZM167-620q-13-22-20-47.5t-7-52.5q0-83 58.5-141.5T340-920q83 0 141.5 58.5T540-720q0 27-7 52.5T513-620l-69-40q8-14 12-28.5t4-31.5q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 17 4 31.5t12 28.5l-69 40Zm335 280Z"></path></svg>');
function Vv(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = ak();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var sk = Pr('<svg><path d="m356-160-56-56 180-180 180 180-56 56-124-124-124 124Zm124-404L300-744l56-56 124 124 124-124 56 56-180 180Z"></path></svg>');
function ok(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = sk();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var lk = Pr('<svg><path d="M480-120 300-300l58-58 122 122 122-122 58 58-180 180ZM358-598l-58-58 180-180 180 180-58 58-122-122-122 122Z"></path></svg>');
function ck(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = lk();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var uk = Be("<!> ", 1)
  , hk = Be("<!> ", 1)
  , dk = Be("<!> ", 1)
  , pk = Be('<!><b> </b> <span class="touchscreen:hidden"> <span class="kbd kbd-xs text-base-content rounded-md"> </span></span> ', 1)
  , fk = Be("<!> ", 1)
  , mk = (x, l) => fe(l, !w(l))
  , _k = (x, l) => {
    fe(l, "colorpicker")
}
  , gk = (x, l) => {
    l(!l())
}
  , vk = (x, l) => {
    ua.smallPlop.play(),
    l()
}
  , yk = (x, l, _) => {
    l(w(_).idx)
}
  , xk = Be('<!> <span class="bg-base-100 translate-1/2 absolute bottom-0 right-0 flex size-5 items-center justify-center rounded-full max-sm:hidden"><!></span>', 1)
  , bk = Be("<div><button><!></button></div>")
  , wk = (x, l) => {
    fe(l, !w(l))
}
  , Tk = (x, l) => {
    fe(l, w(l) === "eraser" ? "pencil" : "eraser", !0)
}
  , Ck = Be('<div class="relative px-3"><!> <div class="flex items-center gap-1.5"><button class="btn btn-circle btn-sm btn-soft"><!></button> <div class="flex grow items-center gap-1"><h2 class="select-none text-xl"> <!></h2> <div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">I</kbd></div> <button><!></button></div> <div class="tooltip"><button title="Toggle art opacity"><!></button></div></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mb-4 mt-3"><div></div></div> <div class="relative h-12 sm:h-14"><button class="btn btn-lg btn-square sm:btn-xl absolute bottom-0 left-0 shadow-md"><!></button> <div class="absolute bottom-0 left-1/2 -translate-x-1/2"><!></div> <div class="absolute bottom-0 right-0"><div class="tooltip ml-auto"><div class="tooltip-content not-touchscreen:-translate-x-[10%]"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">E</kbd></div> <button><!></button></div></div></div></div> <!>', 1);
function Sk(x, l) {
    Lr(l, !0);
    let _ = At(l, "screenLocked", 15)
      , T = At(l, "opaquePixelArt", 15);
    const E = _t( () => new cc(l.tileSize));
    let F = mt(1)
      , C = mt("pencil");
    const o = new Map
      , W = new Map;
    let G = mt(0)
      , re = mt(!1)
      , de = mt(!0)
      , he = _t( () => Vt.charges ?? 0)
      , X = _t( () => w(he) - w(G))
      , le = mt(!1)
      , Se = !1
      , Ie = mt(!1);
    const De = _t( () => w(C) === "pencil")
      , qe = _t( () => w(C) === "eraser")
      , Ne = _t( () => w(C) === "colorpicker");
    let Ze = mt(!1)
      , ut = mt(0)
      , rt = mt(void 0)
      , Ue = mt(void 0);
    const lt = [1, 2, 3, 32, 4, 5, 6, 33, 7, 34, 35, 8, 9, 10, 11, 37, 38, 39, 40, 41, 42, 12, 13, 14, 15, 16, 17, 43, 20, 44, 18, 19, 45, 46, 21, 22, 47, 48, 49, 23, 24, 25, 26, 27, 28, 53, 54, 55, 29, 30, 50, 56, 57, 36, 51, 31, 52, 61, 62, 63, 58, 59, 60, 0].map(yt => ({
        ...Bn.colors[yt],
        idx: yt
    }))
      , et = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0].map(yt => ({
        ...Bn.colors[yt],
        idx: yt
    }));
    let Ve = mt(!1);
    const gt = _t( () => w(Ve) ? lt : et)
      , dt = "show-all-colors";
    wi( () => {
        fe(Ve, localStorage.getItem(dt) === "true")
    }
    ),
    Gr( () => {
        localStorage.setItem(dt, w(Ve) ? "true" : "false")
    }
    );
    const ct = "selected-color";
    wi( () => {
        const yt = Number(localStorage.getItem(ct));
        !isNaN(yt) && yt < Bn.colors.length && yt > 0 && fe(F, yt, !0)
    }
    ),
    Gr( () => {
        localStorage.setItem(ct, w(F).toString())
    }
    );
    const ze = new FA({
        map: l.map,
        tileSize: l.tileSize,
        tileZoom: l.tileZoom,
        beforeLayerId: l.hoverLayerId
    });
    Gr( () => {
        const yt = T() ? 1 : 0;
        ze.setCanvasOpacity(yt)
    }
    ),
    Gr( () => {
        T() ? bf() : Re([...o.values()])
    }
    );
    let vt = !1;
    wi( () => {
        Va(l.map.getCenter(), l.map.getZoom());
        const yt = l.map.on("click", Or => {
            l.zoom < l.tileZoom + 2.5 && l.map.easeTo({
                center: Or.lngLat,
                zoom: 17
            });
            const si = [Or.lngLat.lat, Or.lngLat.lng];
            w(De) ? ie([si], w(F)) : w(qe) ? xe([si]) : w(Ne) && ue(si, Or.point),
            fe(le, !0)
        }
        );
        function Mt(Or, si) {
            const fr = w(E).latLonToPixels(Or.lat, Or.lng, l.tileZoom)
              , $i = si ? w(E).latLonToPixels(si.lat, si.lng, l.tileZoom) : fr;
            return Sx(fr, $i).map(_i => w(E).pixelsToLatLon(_i[0] + .5, _i[1] + .5, l.tileZoom))
        }
        function Gt(Or, si) {
            const fr = Mt(Or, si);
            w(De) ? ie(fr, w(F)) : w(qe) && xe(fr),
            fe(le, !0)
        }
        let Fr;
        function ft(Or) {
            const si = l.map.unproject([Or.clientX, Or.clientY]);
            if (w(Ie)) {
                const fr = Mt(si, Fr);
                xe(fr)
            }
            (vt || Se) && Gt(si, Fr),
            Fr = si
        }
        window.addEventListener("mousemove", ft);
        let Br = !1;
        const Ur = l.map.on("touchstart", Or => {
            if (Or.points.length == 2) {
                _(!1),
                ht(),
                Br = !0,
                setTimeout( () => Br = !1, 150);
                return
            }
            _() && setTimeout( () => {
                !Br && Gt(Or.lngLat)
            }
            , 150),
            Fr = Or.lngLat
        }
        )
          , Si = l.map.on("touchmove", Or => {
            _() && Gt(Or.lngLat, Fr),
            Fr = Or.lngLat
        }
        )
          , ui = Or => {
            Or.code === "Space" && (vt || Fr && Gt(Fr),
            vt = !0,
            Or.preventDefault())
        }
        ;
        document.addEventListener("keydown", ui);
        const St = Or => {
            Or.code === "Space" && (vt = !1,
            Q = !1,
            w(G) === 0 && w(qe) && fe(C, "pencil"))
        }
        ;
        document.addEventListener("keyup", St);
        function yr(Or) {
            if (Or.button === 2) {
                fe(Ie, !0);
                const fr = l.map.unproject([Or.clientX, Or.clientY]);
                xe([[fr.lat, fr.lng]])
            }
        }
        document.addEventListener("mousedown", yr);
        function pr(Or) {
            Or.button === 2 && fe(Ie, !1)
        }
        document.addEventListener("mouseup", pr);
        const hi = Or => {
            switch (Or.code) {
            case "KeyE":
                w(G) > 0 && (w(qe) ? fe(C, "pencil") : fe(C, "eraser"));
                return;
            case "KeyI":
                fe(C, "colorpicker");
                return
            }
        }
        ;
        return document.addEventListener("keypress", hi),
        () => {
            Si.unsubscribe(),
            Ur.unsubscribe(),
            yt.unsubscribe(),
            document.removeEventListener("mousemove", ft),
            document.removeEventListener("keydown", ui),
            document.removeEventListener("keyup", St),
            document.removeEventListener("keypress", hi),
            document.removeEventListener("mousedown", yr),
            document.removeEventListener("mouseup", pr),
            We()
        }
    }
    );
    let Q = !1;
    function ie(yt, Mt) {
        let Gt = !1;
        const Fr = Mt === 0;
        for (let ft of yt) {
            const [Br,Ur] = ft
              , Si = bx(Mt)
              , {tile: ui, pixel: St} = w(E).latLonToTileAndPixel(Br, Ur, l.tileZoom)
              , yr = {
                color: Si,
                tile: ui,
                pixel: St,
                season: l.season,
                colorIdx: Mt
            }
              , pr = hf(yr)
              , hi = o.get(pr)
              , Or = w(he) - o.size;
            if (!hi && Or < 1) {
                if (Q && (vt || _()))
                    continue;
                Q = !0,
                Zr.info(_C());
                continue
            }
            hi && hi.colorIdx === Mt || (ua.plop.play(),
            Gt || l.hidePixelHover(),
            o.set(pr, yr),
            ze.place(ft, Mt),
            l.crosshair.place(ft),
            Gt = !0,
            Fr && W.set(pr, yr))
        }
        fe(G, o.size, !0),
        Gt && !T() ? Re([...o.values()]) : Gt && T() && Fr && Re([...W.values()])
    }
    function xe(yt) {
        let Mt = !1
          , Gt = !1;
        for (let Fr of yt) {
            const [ft,Br] = Fr
              , {tile: Ur, pixel: Si} = w(E).latLonToTileAndPixel(ft, Br, l.tileZoom)
              , ui = hf({
                tile: Ur,
                pixel: Si,
                season: l.season
            })
              , St = o.get(ui);
            St && (ua.plop.play(),
            l.hidePixelHover(),
            o.delete(ui),
            W.delete(ui),
            ze.remove([ft, Br]),
            l.crosshair.remove(Fr),
            Mt = !0,
            St.colorIdx === 0 && (Gt = !0)),
            o.size === 0 && !(vt || Se || _()) && fe(C, "pencil")
        }
        fe(G, o.size, !0),
        Mt && !T() ? Re([...o.values()]) : Mt && T() && Gt && Re([...W.values()])
    }
    function ue(yt, Mt) {
        const {tile: Gt, pixel: Fr} = w(E).latLonToTileAndPixel(yt[0], yt[1], l.tileZoom)
          , ft = hf({
            tile: Gt,
            pixel: Fr,
            season: l.season
        })
          , Br = o.get(ft);
        if (Br) {
            Ft(Br.colorIdx),
            requestAnimationFrame( () => {
                var St;
                (St = document.getElementById(`color-${Br.colorIdx}`)) == null || St.focus()
            }
            );
            return
        }
        const Ur = window.devicePixelRatio
          , Si = Math.floor(Mt.x * Ur)
          , ui = Math.floor(Mt.y * Ur);
        l.hidePixelHover(),
        BA(l.map, Si, ui).then( ([St,yr,pr]) => {
            const hi = wx({
                r: St,
                g: yr,
                b: pr
            });
            Ft(hi),
            requestAnimationFrame( () => {
                var Or;
                (Or = document.getElementById(`color-${hi}`)) == null || Or.focus()
            }
            )
        }
        )
    }
    uc( () => w(F), () => {
        l.clickedLatLon && !w(le) && (w(F) === void 0 && fe(F, 1),
        ie([l.clickedLatLon], w(F)))
    }
    ),
    Gr( () => {
        const yt = w(de) ? .8 : 0;
        l.crosshair.setCanvasOpacity(yt)
    }
    );
    let Le = mt(16.5);
    Gr( () => {
        if (w(rt) && w(Ue) && l.clickedLatLon) {
            const yt = l.map.getZoom();
            if (yt < w(Le)) {
                const [Mt,Gt] = l.clickedLatLon
                  , Fr = w(E).latLonToPixelBoundsLatLon(Mt, Gt, l.tileZoom)
                  , ft = cm(Fr)
                  , Br = w(rt) - w(Ue).clientHeight
                  , Ur = w(rt) / 2 - Br / 2;
                l.map.flyTo({
                    center: {
                        lat: ft[0],
                        lng: ft[1]
                    },
                    zoom: 17.5,
                    offset: yt > 11 ? [0, -Ur] : [0, 0]
                })
            }
            fe(Le, l.tileZoom, !0)
        }
    }
    ),
    wi( () => {
        const yt = () => {
            !document.hidden && (console.log("Tab visible again"),
            T() ? Re([...W.values()]) : Re([...o.values()]))
        }
        ;
        return document.addEventListener("visibilitychange", yt),
        () => document.removeEventListener("visibilitychange", yt)
    }
    ),
    Gr( () => {
        switch (w(C)) {
        case "pencil":
            l.map.getCanvas().style.cursor = `url('${DA}') 8 8, default`,
            l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", .4);
            return;
        case "colorpicker":
            l.map.getCanvas().style.cursor = `url('${zA}') 0 16, default`,
            l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", 0);
            return;
        case "eraser":
            l.map.getCanvas().style.cursor = `url('${LA}') 2 14, default`,
            l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", .4);
            return
        }
    }
    ),
    Gr( () => {
        _() ? at() : ht()
    }
    );
    async function Re(yt) {
        await _x(yt),
        l.refreshPixelArt()
    }
    async function We() {
        await bf(),
        ze.clear(),
        l.refreshPixelArt(),
        l.crosshair.clear()
    }
    async function it() {
        await We(),
        ht(),
        l.map.getCanvas().style.cursor = "default",
        l.map.setPaintProperty(l.hoverLayerId, "raster-opacity", .4),
        l.onclose()
    }
    function at() {
        l.map.dragPan.disable(),
        l.map.touchZoomRotate.disable(),
        document.body.style.overscrollBehavior = "none"
    }
    function ht() {
        l.map.dragPan.enable(),
        l.map.touchZoomRotate.enable(),
        document.body.style.overscrollBehavior = ""
    }
    function Ft(yt) {
        return yt >= 32 && fe(Ve, !0),
        Vt.hasColor(yt) ? (ua.smallDropplet.play(),
        fe(F, yt, !0),
        fe(C, "pencil"),
        !0) : (ua.smallDropplet.play(),
        fe(Ze, !0),
        fe(ut, yt, !0),
        !1)
    }
    vx(yt => {
        yt.type === "leave" && w(G) > 0 && yt.cancel()
    }
    );
    const zt = "show-paint-more-than-one-pixel-msg";
    let lr = mt(!1);
    wi( () => {
        var yt;
        fe(lr, !localStorage.getItem(zt) && (((yt = Vt.data) == null ? void 0 : yt.pixelsPainted) ?? 0) < 100, !0)
    }
    ),
    Gr( () => {
        w(G) > 1 && (fe(lr, !1),
        localStorage.setItem(zt, "false"))
    }
    );
    const kt = "lp";
    wi( () => {
        var Mt;
        const yt = localStorage.getItem(kt);
        if (yt)
            try {
                const Gt = JSON.parse(atob(yt))
                  , Fr = (Gt == null ? void 0 : Gt.time) ?? 0
                  , ft = 60 * 1e3;
                (Gt == null ? void 0 : Gt.userId) !== ((Mt = Vt.data) == null ? void 0 : Mt.id) && Date.now() - Fr < 30 * ft && !Tx && (Zr.error(yC()),
                it())
            } catch (Gt) {
                console.error(Gt)
            }
    }
    );
    function xt() {
        var Mt;
        const yt = btoa(JSON.stringify({
            userId: (Mt = Vt.data) == null ? void 0 : Mt.id,
            time: Date.now()
        }));
        localStorage.setItem(kt, yt)
    }
    var Pt = Ck()
      , jt = Rt(Pt)
      , Lt = z(jt);
    {
        var nr = yt => {
            xu(yt, {
                children: (Mt, Gt) => {
                    var Fr = uk()
                      , ft = Rt(Fr);
                    jv(ft, {
                        class: "inline size-5"
                    });
                    var Br = U(ft);
                    st(Ur => Ce(Br, ` ${Ur ?? ""}`), [ () => zw()]),
                    H(Mt, Fr)
                }
                ,
                $$slots: {
                    default: !0
                }
            })
        }
          , xr = yt => {
            var Mt = cr()
              , Gt = Rt(Mt);
            {
                var Fr = Br => {
                    xu(Br, {
                        class: "not-touchscreen:hidden",
                        children: (Ur, Si) => {
                            var ui = hk()
                              , St = Rt(ui);
                            bg(St, {
                                class: "inline size-5"
                            });
                            var yr = U(St);
                            st(pr => Ce(yr, ` ${pr ?? ""}`), [ () => Rw()]),
                            H(Ur, ui)
                        }
                        ,
                        $$slots: {
                            default: !0
                        }
                    })
                }
                  , ft = Br => {
                    var Ur = cr()
                      , Si = Rt(Ur);
                    {
                        var ui = yr => {
                            xu(yr, {
                                class: "not-touchscreen:hidden",
                                children: (pr, hi) => {
                                    var Or = dk()
                                      , si = Rt(Or);
                                    Fg(si, {
                                        class: "inline size-5"
                                    });
                                    var fr = U(si, 1, !0);
                                    st($i => Ce(fr, $i), [ () => Ow()]),
                                    H(pr, Or)
                                }
                                ,
                                $$slots: {
                                    default: !0
                                }
                            })
                        }
                          , St = yr => {
                            var pr = cr()
                              , hi = Rt(pr);
                            {
                                var Or = fr => {
                                    xu(fr, {
                                        class: "touchscreen:hidden",
                                        children: ($i, On) => {
                                            var _i = pk()
                                              , An = Rt(_i);
                                            Vv(An, {
                                                class: "inline size-5"
                                            });
                                            var Kn = U(An)
                                              , Nn = z(Kn, !0);
                                            k(Kn);
                                            var Tt = U(Kn, 2)
                                              , Ot = z(Tt)
                                              , Ht = U(Ot)
                                              , mi = z(Ht, !0);
                                            k(Ht),
                                            k(Tt);
                                            var Ii = U(Tt);
                                            st( (Qi, vi, kr, Yn) => {
                                                Ce(Nn, Qi),
                                                Ce(Ot, `${vi ?? ""} `),
                                                Ce(mi, kr),
                                                Ce(Ii, ` ${Yn ?? ""}`)
                                            }
                                            , [ () => qw(), () => Hw(), () => $w(), () => Kw()]),
                                            H($i, _i)
                                        }
                                        ,
                                        $$slots: {
                                            default: !0
                                        }
                                    })
                                }
                                  , si = fr => {
                                    var $i = cr()
                                      , On = Rt($i);
                                    {
                                        var _i = An => {
                                            xu(An, {
                                                class: "bg-warning text-warning-content animate-bounce",
                                                children: (Kn, Nn) => {
                                                    var Tt = fk()
                                                      , Ot = Rt(Tt);
                                                    mh(Ot, {
                                                        class: "inline size-5"
                                                    });
                                                    var Ht = U(Ot);
                                                    st(mi => Ce(Ht, ` ${mi ?? ""}`), [ () => Qw()]),
                                                    H(Kn, Tt)
                                                }
                                                ,
                                                $$slots: {
                                                    default: !0
                                                }
                                            })
                                        }
                                        ;
                                        tt(On, An => {
                                            w(lr) && An(_i)
                                        }
                                        , !0)
                                    }
                                    H(fr, $i)
                                }
                                ;
                                tt(hi, fr => {
                                    w(De) && w(G) === 0 ? fr(Or) : fr(si, !1)
                                }
                                , !0)
                            }
                            H(yr, pr)
                        }
                        ;
                        tt(Si, yr => {
                            w(Ne) ? yr(ui) : yr(St, !1)
                        }
                        , !0)
                    }
                    H(Br, Ur)
                }
                ;
                tt(Gt, Br => {
                    w(qe) ? Br(Fr) : Br(ft, !1)
                }
                , !0)
            }
            H(yt, Mt)
        }
        ;
        tt(Lt, yt => {
            w(qe) && w(G) === 0 ? yt(nr) : yt(xr, !1)
        }
        )
    }
    var er = U(Lt, 2)
      , Qt = z(er);
    Qt.__click = [mk, de];
    var $t = z(Qt);
    {
        var tr = yt => {
            jA(yt, {
                class: "size-4"
            })
        }
          , $r = yt => {
            VA(yt, {
                class: "size-4"
            })
        }
        ;
        tt($t, yt => {
            w(de) ? yt(tr) : yt($r, !1)
        }
        )
    }
    k(Qt);
    var zr = U(Qt, 2)
      , Mr = z(zr)
      , sr = z(Mr)
      , Xt = U(sr);
    Ov(Xt, {
        class: "inline",
        fontSize: 14,
        get value() {
            return `(${w(G) ?? ""})`
        },
        mono: !0
    }),
    k(Mr);
    var Ir = U(Mr, 2)
      , mr = z(Ir)
      , vr = z(mr);
    di(),
    k(mr);
    var br = U(mr, 2);
    br.__click = [_k, C];
    var _r = z(br);
    Fg(_r, {
        class: "size-4.5"
    }),
    k(br),
    k(Ir);
    var Ar = U(Ir, 2)
      , Tr = z(Ar);
    let be;
    Tr.__click = [gk, T];
    var q = z(Tr);
    {
        let yt = _t( () => !T());
        qv(q, {
            class: "size-4.5",
            get filled() {
                return w(yt)
            }
        })
    }
    k(Tr),
    k(Ar),
    k(zr);
    var V = U(zr, 2);
    V.__click = [vk, it];
    var K = z(V);
    dc(K, {
        class: "size-4"
    }),
    k(V),
    k(er);
    var ae = U(er, 2)
      , we = z(ae);
    mn(we, 23, () => w(gt), yt => yt.idx, (yt, Mt, Gt) => {
        const Fr = _t( () => {
            const [pr,hi,Or] = w(Mt).rgb;
            return {
                r: pr,
                g: hi,
                b: Or
            }
        }
        )
          , ft = _t( () => w(F) === w(Mt).idx && w(De))
          , Br = _t( () => w(Mt).idx === 0)
          , Ur = _t( () => Vt.hasColor(w(Mt).idx));
        var Si = bk()
          , ui = z(Si);
        ui.__click = [yk, Ft, Mt];
        var St = z(ui);
        {
            var yr = pr => {
                var hi = xk()
                  , Or = Rt(hi);
                Wf(Or, {
                    class: "center-absolute absolute size-4 opacity-30 sm:hidden sm:size-6"
                });
                var si = U(Or, 2)
                  , fr = z(si);
                Wf(fr, {
                    class: "text-base-content/80 size-4"
                }),
                k(si),
                H(pr, hi)
            }
            ;
            tt(St, pr => {
                w(Ur) || pr(yr)
            }
            )
        }
        k(ui),
        k(Si),
        st( () => {
            Vr(Si, 1, Kl({
                tooltip: !0,
                "max-sm:h-6": w(Ve),
                "max-sm:before:translate-x-1/4": w(Gt) % 8 === 0 && w(Mt).name.length > 7,
                "max-sm:before:-translate-x-1/4": (w(Gt) - 7) % 8 === 0 && w(Mt).name.length > 7,
                "max-xl:before:translate-x-1/4": w(Gt) % 16 === 0 && w(Mt).name.length > 7,
                "max-xl:before:-translate-x-1/4": (w(Gt) - 15) % 16 === 0 && w(Mt).name.length > 7,
                "xl:before:translate-x-1/4": w(Ve) && w(Gt) % 32 === 0 && w(Mt).name.length > 7,
                "xl:before:-translate-x-1/4": w(Ve) && (w(Gt) - 31) % 32 === 0 && w(Mt).name.length > 7
            })),
            jr(Si, "data-tip", w(Mt).name),
            Vr(ui, 1, Kl({
                "btn relative aspect-square w-full rounded-xl": !0,
                "border-primary ring-primary ring-2": w(ft),
                "border-base-300": !w(ft) && w(Br),
                "border-base-content/20": !w(ft) && !w(Br),
                "max-sm:h-6 max-sm:rounded-md": w(Ve)
            })),
            lc(ui, w(Br) ? `background-image: url(${RA}); background-size: cover; image-rendering: pixelated;` : `background: rgb(${w(Fr).r} ${w(Fr).g} ${w(Fr).b})`),
            jr(ui, "aria-label", w(Mt).name),
            jr(ui, "id", `color-${w(Mt).idx ?? ""}`)
        }
        ),
        _n("focus", ui, () => {
            w(Ur) && (fe(F, w(Mt).idx, !0),
            fe(C, "pencil"))
        }
        ),
        H(yt, Si)
    }
    ),
    k(we),
    k(ae);
    var Me = U(ae, 2)
      , ke = z(Me);
    ke.__click = [wk, Ve];
    var ge = z(ke);
    {
        var je = yt => {
            ok(yt, {
                class: "size-5"
            })
        }
          , Oe = yt => {
            ck(yt, {
                class: "size-5"
            })
        }
        ;
        tt(ge, yt => {
            w(Ve) ? yt(je) : yt(Oe, !1)
        }
        )
    }
    k(ke);
    var Ee = U(ke, 2)
      , Ke = z(Ee);
    {
        let yt = _t( () => w(G) > 100 ? "animate-pulse" : "")
          , Mt = _t( () => w(G) === 0 || w(re) || w(X) < 0 || !aa.captcha)
          , Gt = _t( () => w(re) || !aa.captcha);
        Nv(Ke, {
            get class() {
                return w(yt)
            },
            get charges() {
                return w(X)
            },
            get disabled() {
                return w(Mt)
            },
            get loading() {
                return w(Gt)
            },
            onclick: async () => {
                var Br;
                const Fr = (Br = aa.captcha) == null ? void 0 : Br.token;
                if (!Fr)
                    return;
                ua.droppletAndPlop.play();
                const ft = [...o.values()];
                fe(re, !0);
                try {
                    await ri.paint(ft, Fr),
                    await gx(ft),
                    xt(),
                    Vt.refresh(),
                    Pd.shouldReload = !0,
                    await it()
                } catch (Ur) {
                    Zr.error(`${Ur.message}`)
                } finally {
                    fe(re, !1),
                    aa.captcha = void 0
                }
            }
        })
    }
    k(Ee);
    var ye = U(Ee, 2)
      , It = z(ye)
      , Kt = z(It)
      , Bt = z(Kt);
    di(),
    k(Kt);
    var Ut = U(Kt, 2);
    let wr;
    Ut.__click = [Tk, C];
    var ci = z(Ut);
    bg(ci, {
        class: "size-5",
        get filled() {
            return w(qe)
        }
    }),
    k(Ut),
    k(It),
    k(ye),
    k(Me),
    k(jt),
    Ss(jt, yt => fe(Ue, yt), () => w(Ue));
    var Yr = U(jt, 2);
    QA(Yr, {
        get colorIdx() {
            return w(ut)
        },
        get open() {
            return w(Ze)
        },
        set open(yt) {
            fe(Ze, yt, !0)
        }
    }),
    st( (yt, Mt, Gt, Fr, ft, Br) => {
        Ce(sr, `${yt ?? ""} `),
        Ce(vr, `${Mt ?? ""} `),
        Vr(br, 1, Kl({
            "btn btn-circle btn-sm": !0,
            "btn-ghost": !w(Ne),
            "btn-primary": w(Ne)
        })),
        jr(Ar, "data-tip", Gt),
        be = Vr(Tr, 1, "btn btn-sm btn-circle btn-ghost text-base-content/80", null, be, Fr),
        Vr(we, 1, Kl({
            "md:grid-cols-16 min-[100rem]:grid-cols-32 grid grid-cols-8": !0,
            "xl:grid-cols-32 sm:grid-cols-16 gap-0.5 sm:gap-1": w(Ve),
            "gap-1": !w(Ve)
        })),
        Ce(Bt, `${ft ?? ""} `),
        wr = Vr(Ut, 1, "btn btn-lg btn-square sm:btn-xl shadow-md", null, wr, Br),
        Ut.disabled = w(G) === 0
    }
    , [ () => r5(), () => a5(), () => rv(), () => ({
        "text-primary": !T()
    }), () => Cx(), () => ({
        "btn-primary": w(qe)
    })]),
    Vd("innerHeight", yt => fe(rt, yt, !0)),
    H(x, Pt),
    Dr()
}
Xi(["click"]);
function vm(...x) {
    return Hg(Su(x))
}
var Pk = Be("<div><!></div>");
function Ik(x, l) {
    Lr(l, !0);
    let _ = At(l, "ref", 15, null)
      , T = Jt(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "children"]);
    var E = Pk();
    Yt(E, C => ({
        class: C,
        ...T
    }), [ () => vm("flex items-center", l.class)]);
    var F = z(E);
    Wi(F, () => l.children ?? Sn),
    k(E),
    Ss(E, C => _(C), () => _()),
    H(x, E),
    Dr()
}
var Mk = Be('<div class="pointer-events-none absolute inset-0 flex items-center justify-center"><div class="animate-caret-blink bg-base-content/80 h-4 w-px duration-1000"></div></div>')
  , Ak = Be(" <!>", 1);
function kk(x, l) {
    Lr(l, !0);
    let _ = At(l, "ref", 15, null)
      , T = Jt(l, ["$$slots", "$$events", "$$legacy", "ref", "cell", "class"]);
    var E = cr()
      , F = Rt(E);
    {
        let C = _t( () => vm("border-input relative flex size-12 items-center justify-center border-y border-r text-xl transition-all first:rounded-l-md first:border-l last:rounded-r-md", l.cell.isActive && "ring-base-content/40 z-10 ring-2", l.class));
        an(F, () => I6, (o, W) => {
            W(o, lo({
                get cell() {
                    return l.cell
                },
                get class() {
                    return w(C)
                }
            }, () => T, {
                get ref() {
                    return _()
                },
                set ref(G) {
                    _(G)
                },
                children: (G, re) => {
                    di();
                    var de = Ak()
                      , he = Rt(de)
                      , X = U(he);
                    {
                        var le = Se => {
                            var Ie = Mk();
                            H(Se, Ie)
                        }
                        ;
                        tt(X, Se => {
                            l.cell.hasFakeCaret && Se(le)
                        }
                        )
                    }
                    st( () => Ce(he, `${l.cell.char ?? ""} `)),
                    H(G, de)
                }
                ,
                $$slots: {
                    default: !0
                }
            }))
        }
        )
    }
    H(x, E),
    Dr()
}
function Ek(x, l) {
    Lr(l, !0);
    let _ = At(l, "ref", 15, null)
      , T = At(l, "value", 15, "")
      , E = Jt(l, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
    var F = cr()
      , C = Rt(F);
    {
        let o = _t( () => vm("flex items-center gap-2 has-[:disabled]:opacity-50 [&_input]:disabled:cursor-not-allowed", l.class));
        an(C, () => S6, (W, G) => {
            G(W, lo({
                get class() {
                    return w(o)
                }
            }, () => E, {
                get ref() {
                    return _()
                },
                set ref(re) {
                    _(re)
                },
                get value() {
                    return T()
                },
                set value(re) {
                    T(re)
                }
            }))
        }
        )
    }
    H(x, F),
    Dr()
}
var yf = {
    exports: {}
}, Og;
function zk() {
    return Og || (Og = 1,
    function(x) {
        (function(l) {
            x.exports ? x.exports = l() : window.intlTelInput = l()
        }
        )( () => {
            var l = ( () => {
                var _ = Object.defineProperty
                  , T = Object.getOwnPropertyDescriptor
                  , E = Object.getOwnPropertyNames
                  , F = Object.prototype.hasOwnProperty
                  , C = (Q, ie) => {
                    for (var xe in ie)
                        _(Q, xe, {
                            get: ie[xe],
                            enumerable: !0
                        })
                }
                  , o = (Q, ie, xe, ue) => {
                    if (ie && typeof ie == "object" || typeof ie == "function")
                        for (let Le of E(ie))
                            !F.call(Q, Le) && Le !== xe && _(Q, Le, {
                                get: () => ie[Le],
                                enumerable: !(ue = T(ie, Le)) || ue.enumerable
                            });
                    return Q
                }
                  , W = Q => o(_({}, "__esModule", {
                    value: !0
                }), Q)
                  , G = {};
                C(G, {
                    Iti: () => dt,
                    default: () => vt
                });
                var re = [["af", "93"], ["ax", "358", 1], ["al", "355"], ["dz", "213"], ["as", "1", 5, ["684"]], ["ad", "376"], ["ao", "244"], ["ai", "1", 6, ["264"]], ["ag", "1", 7, ["268"]], ["ar", "54"], ["am", "374"], ["aw", "297"], ["ac", "247"], ["au", "61", 0, null, "0"], ["at", "43"], ["az", "994"], ["bs", "1", 8, ["242"]], ["bh", "973"], ["bd", "880"], ["bb", "1", 9, ["246"]], ["by", "375"], ["be", "32"], ["bz", "501"], ["bj", "229"], ["bm", "1", 10, ["441"]], ["bt", "975"], ["bo", "591"], ["ba", "387"], ["bw", "267"], ["br", "55"], ["io", "246"], ["vg", "1", 11, ["284"]], ["bn", "673"], ["bg", "359"], ["bf", "226"], ["bi", "257"], ["kh", "855"], ["cm", "237"], ["ca", "1", 1, ["204", "226", "236", "249", "250", "263", "289", "306", "343", "354", "365", "367", "368", "382", "387", "403", "416", "418", "428", "431", "437", "438", "450", "584", "468", "474", "506", "514", "519", "548", "579", "581", "584", "587", "604", "613", "639", "647", "672", "683", "705", "709", "742", "753", "778", "780", "782", "807", "819", "825", "867", "873", "879", "902", "905"]], ["cv", "238"], ["bq", "599", 1, ["3", "4", "7"]], ["ky", "1", 12, ["345"]], ["cf", "236"], ["td", "235"], ["cl", "56"], ["cn", "86"], ["cx", "61", 2, ["89164"], "0"], ["cc", "61", 1, ["89162"], "0"], ["co", "57"], ["km", "269"], ["cg", "242"], ["cd", "243"], ["ck", "682"], ["cr", "506"], ["ci", "225"], ["hr", "385"], ["cu", "53"], ["cw", "599", 0], ["cy", "357"], ["cz", "420"], ["dk", "45"], ["dj", "253"], ["dm", "1", 13, ["767"]], ["do", "1", 2, ["809", "829", "849"]], ["ec", "593"], ["eg", "20"], ["sv", "503"], ["gq", "240"], ["er", "291"], ["ee", "372"], ["sz", "268"], ["et", "251"], ["fk", "500"], ["fo", "298"], ["fj", "679"], ["fi", "358", 0], ["fr", "33"], ["gf", "594"], ["pf", "689"], ["ga", "241"], ["gm", "220"], ["ge", "995"], ["de", "49"], ["gh", "233"], ["gi", "350"], ["gr", "30"], ["gl", "299"], ["gd", "1", 14, ["473"]], ["gp", "590", 0], ["gu", "1", 15, ["671"]], ["gt", "502"], ["gg", "44", 1, ["1481", "7781", "7839", "7911"], "0"], ["gn", "224"], ["gw", "245"], ["gy", "592"], ["ht", "509"], ["hn", "504"], ["hk", "852"], ["hu", "36"], ["is", "354"], ["in", "91"], ["id", "62"], ["ir", "98"], ["iq", "964"], ["ie", "353"], ["im", "44", 2, ["1624", "74576", "7524", "7924", "7624"], "0"], ["il", "972"], ["it", "39", 0], ["jm", "1", 4, ["876", "658"]], ["jp", "81"], ["je", "44", 3, ["1534", "7509", "7700", "7797", "7829", "7937"], "0"], ["jo", "962"], ["kz", "7", 1, ["33", "7"], "8"], ["ke", "254"], ["ki", "686"], ["xk", "383"], ["kw", "965"], ["kg", "996"], ["la", "856"], ["lv", "371"], ["lb", "961"], ["ls", "266"], ["lr", "231"], ["ly", "218"], ["li", "423"], ["lt", "370"], ["lu", "352"], ["mo", "853"], ["mg", "261"], ["mw", "265"], ["my", "60"], ["mv", "960"], ["ml", "223"], ["mt", "356"], ["mh", "692"], ["mq", "596"], ["mr", "222"], ["mu", "230"], ["yt", "262", 1, ["269", "639"], "0"], ["mx", "52"], ["fm", "691"], ["md", "373"], ["mc", "377"], ["mn", "976"], ["me", "382"], ["ms", "1", 16, ["664"]], ["ma", "212", 0, null, "0"], ["mz", "258"], ["mm", "95"], ["na", "264"], ["nr", "674"], ["np", "977"], ["nl", "31"], ["nc", "687"], ["nz", "64"], ["ni", "505"], ["ne", "227"], ["ng", "234"], ["nu", "683"], ["nf", "672"], ["kp", "850"], ["mk", "389"], ["mp", "1", 17, ["670"]], ["no", "47", 0], ["om", "968"], ["pk", "92"], ["pw", "680"], ["ps", "970"], ["pa", "507"], ["pg", "675"], ["py", "595"], ["pe", "51"], ["ph", "63"], ["pl", "48"], ["pt", "351"], ["pr", "1", 3, ["787", "939"]], ["qa", "974"], ["re", "262", 0, null, "0"], ["ro", "40"], ["ru", "7", 0, null, "8"], ["rw", "250"], ["ws", "685"], ["sm", "378"], ["st", "239"], ["sa", "966"], ["sn", "221"], ["rs", "381"], ["sc", "248"], ["sl", "232"], ["sg", "65"], ["sx", "1", 21, ["721"]], ["sk", "421"], ["si", "386"], ["sb", "677"], ["so", "252"], ["za", "27"], ["kr", "82"], ["ss", "211"], ["es", "34"], ["lk", "94"], ["bl", "590", 1], ["sh", "290"], ["kn", "1", 18, ["869"]], ["lc", "1", 19, ["758"]], ["mf", "590", 2], ["pm", "508"], ["vc", "1", 20, ["784"]], ["sd", "249"], ["sr", "597"], ["sj", "47", 1, ["79"]], ["se", "46"], ["ch", "41"], ["sy", "963"], ["tw", "886"], ["tj", "992"], ["tz", "255"], ["th", "66"], ["tl", "670"], ["tg", "228"], ["tk", "690"], ["to", "676"], ["tt", "1", 22, ["868"]], ["tn", "216"], ["tr", "90"], ["tm", "993"], ["tc", "1", 23, ["649"]], ["tv", "688"], ["ug", "256"], ["ua", "380"], ["ae", "971"], ["gb", "44", 0, null, "0"], ["us", "1", 0], ["uy", "598"], ["vi", "1", 24, ["340"]], ["uz", "998"], ["vu", "678"], ["va", "39", 1, ["06698"]], ["ve", "58"], ["vn", "84"], ["wf", "681"], ["eh", "212", 1, ["5288", "5289"], "0"], ["ye", "967"], ["zm", "260"], ["zw", "263"]]
                  , de = [];
                for (let Q = 0; Q < re.length; Q++) {
                    const ie = re[Q];
                    de[Q] = {
                        name: "",
                        iso2: ie[0],
                        dialCode: ie[1],
                        priority: ie[2] || 0,
                        areaCodes: ie[3] || null,
                        nodeById: {},
                        nationalPrefix: ie[4] || null
                    }
                }
                var he = de
                  , X = {
                    ad: "Andorra",
                    ae: "United Arab Emirates",
                    af: "Afghanistan",
                    ag: "Antigua & Barbuda",
                    ai: "Anguilla",
                    al: "Albania",
                    am: "Armenia",
                    ao: "Angola",
                    ar: "Argentina",
                    as: "American Samoa",
                    at: "Austria",
                    au: "Australia",
                    aw: "Aruba",
                    ax: "Ã…land Islands",
                    az: "Azerbaijan",
                    ba: "Bosnia & Herzegovina",
                    bb: "Barbados",
                    bd: "Bangladesh",
                    be: "Belgium",
                    bf: "Burkina Faso",
                    bg: "Bulgaria",
                    bh: "Bahrain",
                    bi: "Burundi",
                    bj: "Benin",
                    bl: "St. BarthÃ©lemy",
                    bm: "Bermuda",
                    bn: "Brunei",
                    bo: "Bolivia",
                    bq: "Caribbean Netherlands",
                    br: "Brazil",
                    bs: "Bahamas",
                    bt: "Bhutan",
                    bw: "Botswana",
                    by: "Belarus",
                    bz: "Belize",
                    ca: "Canada",
                    cc: "Cocos (Keeling) Islands",
                    cd: "Congo - Kinshasa",
                    cf: "Central African Republic",
                    cg: "Congo - Brazzaville",
                    ch: "Switzerland",
                    ci: "CÃ´te dâ€™Ivoire",
                    ck: "Cook Islands",
                    cl: "Chile",
                    cm: "Cameroon",
                    cn: "China",
                    co: "Colombia",
                    cr: "Costa Rica",
                    cu: "Cuba",
                    cv: "Cape Verde",
                    cw: "CuraÃ§ao",
                    cx: "Christmas Island",
                    cy: "Cyprus",
                    cz: "Czechia",
                    de: "Germany",
                    dj: "Djibouti",
                    dk: "Denmark",
                    dm: "Dominica",
                    do: "Dominican Republic",
                    dz: "Algeria",
                    ec: "Ecuador",
                    ee: "Estonia",
                    eg: "Egypt",
                    eh: "Western Sahara",
                    er: "Eritrea",
                    es: "Spain",
                    et: "Ethiopia",
                    fi: "Finland",
                    fj: "Fiji",
                    fk: "Falkland Islands",
                    fm: "Micronesia",
                    fo: "Faroe Islands",
                    fr: "France",
                    ga: "Gabon",
                    gb: "United Kingdom",
                    gd: "Grenada",
                    ge: "Georgia",
                    gf: "French Guiana",
                    gg: "Guernsey",
                    gh: "Ghana",
                    gi: "Gibraltar",
                    gl: "Greenland",
                    gm: "Gambia",
                    gn: "Guinea",
                    gp: "Guadeloupe",
                    gq: "Equatorial Guinea",
                    gr: "Greece",
                    gt: "Guatemala",
                    gu: "Guam",
                    gw: "Guinea-Bissau",
                    gy: "Guyana",
                    hk: "Hong Kong SAR China",
                    hn: "Honduras",
                    hr: "Croatia",
                    ht: "Haiti",
                    hu: "Hungary",
                    id: "Indonesia",
                    ie: "Ireland",
                    il: "Israel",
                    im: "Isle of Man",
                    in: "India",
                    io: "British Indian Ocean Territory",
                    iq: "Iraq",
                    ir: "Iran",
                    is: "Iceland",
                    it: "Italy",
                    je: "Jersey",
                    jm: "Jamaica",
                    jo: "Jordan",
                    jp: "Japan",
                    ke: "Kenya",
                    kg: "Kyrgyzstan",
                    kh: "Cambodia",
                    ki: "Kiribati",
                    km: "Comoros",
                    kn: "St. Kitts & Nevis",
                    kp: "North Korea",
                    kr: "South Korea",
                    kw: "Kuwait",
                    ky: "Cayman Islands",
                    kz: "Kazakhstan",
                    la: "Laos",
                    lb: "Lebanon",
                    lc: "St. Lucia",
                    li: "Liechtenstein",
                    lk: "Sri Lanka",
                    lr: "Liberia",
                    ls: "Lesotho",
                    lt: "Lithuania",
                    lu: "Luxembourg",
                    lv: "Latvia",
                    ly: "Libya",
                    ma: "Morocco",
                    mc: "Monaco",
                    md: "Moldova",
                    me: "Montenegro",
                    mf: "St. Martin",
                    mg: "Madagascar",
                    mh: "Marshall Islands",
                    mk: "North Macedonia",
                    ml: "Mali",
                    mm: "Myanmar (Burma)",
                    mn: "Mongolia",
                    mo: "Macao SAR China",
                    mp: "Northern Mariana Islands",
                    mq: "Martinique",
                    mr: "Mauritania",
                    ms: "Montserrat",
                    mt: "Malta",
                    mu: "Mauritius",
                    mv: "Maldives",
                    mw: "Malawi",
                    mx: "Mexico",
                    my: "Malaysia",
                    mz: "Mozambique",
                    na: "Namibia",
                    nc: "New Caledonia",
                    ne: "Niger",
                    nf: "Norfolk Island",
                    ng: "Nigeria",
                    ni: "Nicaragua",
                    nl: "Netherlands",
                    no: "Norway",
                    np: "Nepal",
                    nr: "Nauru",
                    nu: "Niue",
                    nz: "New Zealand",
                    om: "Oman",
                    pa: "Panama",
                    pe: "Peru",
                    pf: "French Polynesia",
                    pg: "Papua New Guinea",
                    ph: "Philippines",
                    pk: "Pakistan",
                    pl: "Poland",
                    pm: "St. Pierre & Miquelon",
                    pr: "Puerto Rico",
                    ps: "Palestinian Territories",
                    pt: "Portugal",
                    pw: "Palau",
                    py: "Paraguay",
                    qa: "Qatar",
                    re: "RÃ©union",
                    ro: "Romania",
                    rs: "Serbia",
                    ru: "Russia",
                    rw: "Rwanda",
                    sa: "Saudi Arabia",
                    sb: "Solomon Islands",
                    sc: "Seychelles",
                    sd: "Sudan",
                    se: "Sweden",
                    sg: "Singapore",
                    sh: "St. Helena",
                    si: "Slovenia",
                    sj: "Svalbard & Jan Mayen",
                    sk: "Slovakia",
                    sl: "Sierra Leone",
                    sm: "San Marino",
                    sn: "Senegal",
                    so: "Somalia",
                    sr: "Suriname",
                    ss: "South Sudan",
                    st: "SÃ£o TomÃ© & PrÃ­ncipe",
                    sv: "El Salvador",
                    sx: "Sint Maarten",
                    sy: "Syria",
                    sz: "Eswatini",
                    tc: "Turks & Caicos Islands",
                    td: "Chad",
                    tg: "Togo",
                    th: "Thailand",
                    tj: "Tajikistan",
                    tk: "Tokelau",
                    tl: "Timor-Leste",
                    tm: "Turkmenistan",
                    tn: "Tunisia",
                    to: "Tonga",
                    tr: "Turkey",
                    tt: "Trinidad & Tobago",
                    tv: "Tuvalu",
                    tw: "Taiwan",
                    tz: "Tanzania",
                    ua: "Ukraine",
                    ug: "Uganda",
                    us: "United States",
                    uy: "Uruguay",
                    uz: "Uzbekistan",
                    va: "Vatican City",
                    vc: "St. Vincent & Grenadines",
                    ve: "Venezuela",
                    vg: "British Virgin Islands",
                    vi: "U.S. Virgin Islands",
                    vn: "Vietnam",
                    vu: "Vanuatu",
                    wf: "Wallis & Futuna",
                    ws: "Samoa",
                    ye: "Yemen",
                    yt: "Mayotte",
                    za: "South Africa",
                    zm: "Zambia",
                    zw: "Zimbabwe"
                }
                  , le = X
                  , Se = {
                    selectedCountryAriaLabel: "Selected country",
                    noCountrySelected: "No country selected",
                    countryListAriaLabel: "List of countries",
                    searchPlaceholder: "Search",
                    zeroSearchResults: "No results found",
                    oneSearchResult: "1 result found",
                    multipleSearchResults: "${count} results found",
                    ac: "Ascension Island",
                    xk: "Kosovo"
                }
                  , Ie = Se
                  , De = {
                    ...le,
                    ...Ie
                }
                  , qe = De;
                for (let Q = 0; Q < he.length; Q++)
                    he[Q].name = qe[he[Q].iso2];
                var Ne = 0
                  , Ze = {
                    allowDropdown: !0,
                    autoPlaceholder: "polite",
                    containerClass: "",
                    countryOrder: null,
                    countrySearch: !0,
                    customPlaceholder: null,
                    dropdownContainer: null,
                    excludeCountries: [],
                    fixDropdownWidth: !0,
                    formatAsYouType: !0,
                    formatOnDisplay: !0,
                    geoIpLookup: null,
                    hiddenInput: null,
                    i18n: {},
                    initialCountry: "",
                    loadUtils: null,
                    nationalMode: !0,
                    onlyCountries: [],
                    placeholderNumberType: "MOBILE",
                    showFlags: !0,
                    separateDialCode: !1,
                    strictMode: !1,
                    useFullscreenPopup: typeof navigator < "u" && typeof window < "u" ? /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 500 : !1,
                    validationNumberTypes: ["MOBILE"]
                }
                  , ut = ["800", "822", "833", "844", "855", "866", "877", "880", "881", "882", "883", "884", "885", "886", "887", "888", "889"]
                  , rt = Q => Q.replace(/\D/g, "")
                  , Ue = (Q="") => Q.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase()
                  , lt = Q => {
                    const ie = rt(Q);
                    if (ie.charAt(0) === "1") {
                        const xe = ie.substr(1, 3);
                        return ut.includes(xe)
                    }
                    return !1
                }
                  , et = (Q, ie, xe, ue) => {
                    if (xe === 0 && !ue)
                        return 0;
                    let Le = 0;
                    for (let Re = 0; Re < ie.length; Re++) {
                        if (/[+0-9]/.test(ie[Re]) && Le++,
                        Le === Q && !ue)
                            return Re + 1;
                        if (ue && Le === Q + 1)
                            return Re
                    }
                    return ie.length
                }
                  , Ve = (Q, ie, xe) => {
                    const ue = document.createElement(Q);
                    return ie && Object.entries(ie).forEach( ([Le,Re]) => ue.setAttribute(Le, Re)),
                    xe && xe.appendChild(ue),
                    ue
                }
                  , gt = (Q, ...ie) => {
                    const {instances: xe} = ze;
                    Object.values(xe).forEach(ue => ue[Q](...ie))
                }
                  , dt = class {
                    constructor(Q, ie={}) {
                        this.id = Ne++,
                        this.telInput = Q,
                        this.highlightedItem = null,
                        this.options = Object.assign({}, Ze, ie),
                        this.hadInitialPlaceholder = !!Q.getAttribute("placeholder")
                    }
                    _init() {
                        this.options.useFullscreenPopup && (this.options.fixDropdownWidth = !1),
                        this.options.onlyCountries.length === 1 && (this.options.initialCountry = this.options.onlyCountries[0]),
                        this.options.separateDialCode && (this.options.nationalMode = !1),
                        this.options.allowDropdown && !this.options.showFlags && !this.options.separateDialCode && (this.options.nationalMode = !1),
                        this.options.useFullscreenPopup && !this.options.dropdownContainer && (this.options.dropdownContainer = document.body),
                        this.isAndroid = typeof navigator < "u" ? /Android/i.test(navigator.userAgent) : !1,
                        this.isRTL = !!this.telInput.closest("[dir=rtl]");
                        const Q = this.options.allowDropdown || this.options.separateDialCode;
                        this.showSelectedCountryOnLeft = this.isRTL ? !Q : Q,
                        this.options.separateDialCode && (this.isRTL ? this.originalPaddingRight = this.telInput.style.paddingRight : this.originalPaddingLeft = this.telInput.style.paddingLeft),
                        this.options.i18n = {
                            ...qe,
                            ...this.options.i18n
                        };
                        const ie = new Promise( (ue, Le) => {
                            this.resolveAutoCountryPromise = ue,
                            this.rejectAutoCountryPromise = Le
                        }
                        )
                          , xe = new Promise( (ue, Le) => {
                            this.resolveUtilsScriptPromise = ue,
                            this.rejectUtilsScriptPromise = Le
                        }
                        );
                        this.promise = Promise.all([ie, xe]),
                        this.selectedCountryData = {},
                        this._processCountryData(),
                        this._generateMarkup(),
                        this._setInitialState(),
                        this._initListeners(),
                        this._initRequests()
                    }
                    _processCountryData() {
                        this._processAllCountries(),
                        this._processDialCodes(),
                        this._translateCountryNames(),
                        this._sortCountries()
                    }
                    _sortCountries() {
                        this.options.countryOrder && (this.options.countryOrder = this.options.countryOrder.map(Q => Q.toLowerCase())),
                        this.countries.sort( (Q, ie) => {
                            const {countryOrder: xe} = this.options;
                            if (xe) {
                                const ue = xe.indexOf(Q.iso2)
                                  , Le = xe.indexOf(ie.iso2)
                                  , Re = ue > -1
                                  , We = Le > -1;
                                if (Re || We)
                                    return Re && We ? ue - Le : Re ? -1 : 1
                            }
                            return Q.name.localeCompare(ie.name)
                        }
                        )
                    }
                    _addToDialCodeMap(Q, ie, xe) {
                        ie.length > this.dialCodeMaxLen && (this.dialCodeMaxLen = ie.length),
                        this.dialCodeToIso2Map.hasOwnProperty(ie) || (this.dialCodeToIso2Map[ie] = []);
                        for (let Le = 0; Le < this.dialCodeToIso2Map[ie].length; Le++)
                            if (this.dialCodeToIso2Map[ie][Le] === Q)
                                return;
                        const ue = xe !== void 0 ? xe : this.dialCodeToIso2Map[ie].length;
                        this.dialCodeToIso2Map[ie][ue] = Q
                    }
                    _processAllCountries() {
                        const {onlyCountries: Q, excludeCountries: ie} = this.options;
                        if (Q.length) {
                            const xe = Q.map(ue => ue.toLowerCase());
                            this.countries = he.filter(ue => xe.includes(ue.iso2))
                        } else if (ie.length) {
                            const xe = ie.map(ue => ue.toLowerCase());
                            this.countries = he.filter(ue => !xe.includes(ue.iso2))
                        } else
                            this.countries = he
                    }
                    _translateCountryNames() {
                        for (let Q = 0; Q < this.countries.length; Q++) {
                            const ie = this.countries[Q].iso2.toLowerCase();
                            this.options.i18n.hasOwnProperty(ie) && (this.countries[Q].name = this.options.i18n[ie])
                        }
                    }
                    _processDialCodes() {
                        this.dialCodes = {},
                        this.dialCodeMaxLen = 0,
                        this.dialCodeToIso2Map = {};
                        for (let Q = 0; Q < this.countries.length; Q++) {
                            const ie = this.countries[Q];
                            this.dialCodes[ie.dialCode] || (this.dialCodes[ie.dialCode] = !0),
                            this._addToDialCodeMap(ie.iso2, ie.dialCode, ie.priority)
                        }
                        for (let Q = 0; Q < this.countries.length; Q++) {
                            const ie = this.countries[Q];
                            if (ie.areaCodes) {
                                const xe = this.dialCodeToIso2Map[ie.dialCode][0];
                                for (let ue = 0; ue < ie.areaCodes.length; ue++) {
                                    const Le = ie.areaCodes[ue];
                                    for (let Re = 1; Re < Le.length; Re++) {
                                        const We = Le.substr(0, Re)
                                          , it = ie.dialCode + We;
                                        this._addToDialCodeMap(xe, it),
                                        this._addToDialCodeMap(ie.iso2, it)
                                    }
                                    this._addToDialCodeMap(ie.iso2, ie.dialCode + Le)
                                }
                            }
                        }
                    }
                    _generateMarkup() {
                        var lr, kt, xt;
                        this.telInput.classList.add("iti__tel-input"),
                        !this.telInput.hasAttribute("autocomplete") && !(this.telInput.form && this.telInput.form.hasAttribute("autocomplete")) && this.telInput.setAttribute("autocomplete", "off");
                        const {allowDropdown: Q, separateDialCode: ie, showFlags: xe, containerClass: ue, hiddenInput: Le, dropdownContainer: Re, fixDropdownWidth: We, useFullscreenPopup: it, countrySearch: at, i18n: ht} = this.options;
                        let Ft = "iti";
                        Q && (Ft += " iti--allow-dropdown"),
                        xe && (Ft += " iti--show-flags"),
                        ue && (Ft += ` ${ue}`),
                        it || (Ft += " iti--inline-dropdown");
                        const zt = Ve("div", {
                            class: Ft
                        });
                        if ((lr = this.telInput.parentNode) == null || lr.insertBefore(zt, this.telInput),
                        Q || xe || ie) {
                            this.countryContainer = Ve("div", {
                                class: "iti__country-container"
                            }, zt),
                            this.showSelectedCountryOnLeft ? this.countryContainer.style.left = "0px" : this.countryContainer.style.right = "0px",
                            Q ? (this.selectedCountry = Ve("button", {
                                type: "button",
                                class: "iti__selected-country",
                                "aria-expanded": "false",
                                "aria-label": this.options.i18n.selectedCountryAriaLabel,
                                "aria-haspopup": "true",
                                "aria-controls": `iti-${this.id}__dropdown-content`,
                                role: "combobox"
                            }, this.countryContainer),
                            this.telInput.disabled && this.selectedCountry.setAttribute("disabled", "true")) : this.selectedCountry = Ve("div", {
                                class: "iti__selected-country"
                            }, this.countryContainer);
                            const Pt = Ve("div", {
                                class: "iti__selected-country-primary"
                            }, this.selectedCountry);
                            if (this.selectedCountryInner = Ve("div", {
                                class: "iti__flag"
                            }, Pt),
                            this.selectedCountryA11yText = Ve("span", {
                                class: "iti__a11y-text"
                            }, this.selectedCountryInner),
                            Q && (this.dropdownArrow = Ve("div", {
                                class: "iti__arrow",
                                "aria-hidden": "true"
                            }, Pt)),
                            ie && (this.selectedDialCode = Ve("div", {
                                class: "iti__selected-dial-code"
                            }, this.selectedCountry)),
                            Q) {
                                const jt = We ? "" : "iti--flexible-dropdown-width";
                                if (this.dropdownContent = Ve("div", {
                                    id: `iti-${this.id}__dropdown-content`,
                                    class: `iti__dropdown-content iti__hide ${jt}`
                                }),
                                at && (this.searchInput = Ve("input", {
                                    type: "text",
                                    class: "iti__search-input",
                                    placeholder: ht.searchPlaceholder,
                                    role: "combobox",
                                    "aria-expanded": "true",
                                    "aria-label": ht.searchPlaceholder,
                                    "aria-controls": `iti-${this.id}__country-listbox`,
                                    "aria-autocomplete": "list",
                                    autocomplete: "off"
                                }, this.dropdownContent),
                                this.searchResultsA11yText = Ve("span", {
                                    class: "iti__a11y-text"
                                }, this.dropdownContent)),
                                this.countryList = Ve("ul", {
                                    class: "iti__country-list",
                                    id: `iti-${this.id}__country-listbox`,
                                    role: "listbox",
                                    "aria-label": ht.countryListAriaLabel
                                }, this.dropdownContent),
                                this._appendListItems(),
                                at && this._updateSearchResultsText(),
                                Re) {
                                    let Lt = "iti iti--container";
                                    it ? Lt += " iti--fullscreen-popup" : Lt += " iti--inline-dropdown",
                                    this.dropdown = Ve("div", {
                                        class: Lt
                                    }),
                                    this.dropdown.appendChild(this.dropdownContent)
                                } else
                                    this.countryContainer.appendChild(this.dropdownContent)
                            }
                        }
                        if (zt.appendChild(this.telInput),
                        this._updateInputPadding(),
                        Le) {
                            const Pt = this.telInput.getAttribute("name") || ""
                              , jt = Le(Pt);
                            if (jt.phone) {
                                const Lt = (kt = this.telInput.form) == null ? void 0 : kt.querySelector(`input[name="${jt.phone}"]`);
                                Lt ? this.hiddenInput = Lt : (this.hiddenInput = Ve("input", {
                                    type: "hidden",
                                    name: jt.phone
                                }),
                                zt.appendChild(this.hiddenInput))
                            }
                            if (jt.country) {
                                const Lt = (xt = this.telInput.form) == null ? void 0 : xt.querySelector(`input[name="${jt.country}"]`);
                                Lt ? this.hiddenInputCountry = Lt : (this.hiddenInputCountry = Ve("input", {
                                    type: "hidden",
                                    name: jt.country
                                }),
                                zt.appendChild(this.hiddenInputCountry))
                            }
                        }
                    }
                    _appendListItems() {
                        for (let Q = 0; Q < this.countries.length; Q++) {
                            const ie = this.countries[Q]
                              , xe = Q === 0 ? "iti__highlight" : ""
                              , ue = Ve("li", {
                                id: `iti-${this.id}__item-${ie.iso2}`,
                                class: `iti__country ${xe}`,
                                tabindex: "-1",
                                role: "option",
                                "data-dial-code": ie.dialCode,
                                "data-country-code": ie.iso2,
                                "aria-selected": "false"
                            }, this.countryList);
                            ie.nodeById[this.id] = ue;
                            let Le = "";
                            this.options.showFlags && (Le += `<div class='iti__flag iti__${ie.iso2}'></div>`),
                            Le += `<span class='iti__country-name'>${ie.name}</span>`,
                            Le += `<span class='iti__dial-code'>+${ie.dialCode}</span>`,
                            ue.insertAdjacentHTML("beforeend", Le)
                        }
                    }
                    _setInitialState(Q=!1) {
                        const ie = this.telInput.getAttribute("value")
                          , xe = this.telInput.value
                          , Le = ie && ie.charAt(0) === "+" && (!xe || xe.charAt(0) !== "+") ? ie : xe
                          , Re = this._getDialCode(Le)
                          , We = lt(Le)
                          , {initialCountry: it, geoIpLookup: at} = this.options
                          , ht = it === "auto" && at;
                        if (Re && !We)
                            this._updateCountryFromNumber(Le);
                        else if (!ht || Q) {
                            const Ft = it ? it.toLowerCase() : "";
                            Ft && this._getCountryData(Ft, !0) ? this._setCountry(Ft) : Re && We ? this._setCountry("us") : this._setCountry()
                        }
                        Le && this._updateValFromNumber(Le)
                    }
                    _initListeners() {
                        this._initTelInputListeners(),
                        this.options.allowDropdown && this._initDropdownListeners(),
                        (this.hiddenInput || this.hiddenInputCountry) && this.telInput.form && this._initHiddenInputListener()
                    }
                    _initHiddenInputListener() {
                        var Q;
                        this._handleHiddenInputSubmit = () => {
                            this.hiddenInput && (this.hiddenInput.value = this.getNumber()),
                            this.hiddenInputCountry && (this.hiddenInputCountry.value = this.getSelectedCountryData().iso2 || "")
                        }
                        ,
                        (Q = this.telInput.form) == null || Q.addEventListener("submit", this._handleHiddenInputSubmit)
                    }
                    _initDropdownListeners() {
                        this._handleLabelClick = ie => {
                            this.dropdownContent.classList.contains("iti__hide") ? this.telInput.focus() : ie.preventDefault()
                        }
                        ;
                        const Q = this.telInput.closest("label");
                        Q && Q.addEventListener("click", this._handleLabelClick),
                        this._handleClickSelectedCountry = () => {
                            this.dropdownContent.classList.contains("iti__hide") && !this.telInput.disabled && !this.telInput.readOnly && this._openDropdown()
                        }
                        ,
                        this.selectedCountry.addEventListener("click", this._handleClickSelectedCountry),
                        this._handleCountryContainerKeydown = ie => {
                            this.dropdownContent.classList.contains("iti__hide") && ["ArrowUp", "ArrowDown", " ", "Enter"].includes(ie.key) && (ie.preventDefault(),
                            ie.stopPropagation(),
                            this._openDropdown()),
                            ie.key === "Tab" && this._closeDropdown()
                        }
                        ,
                        this.countryContainer.addEventListener("keydown", this._handleCountryContainerKeydown)
                    }
                    _initRequests() {
                        let {loadUtils: Q, initialCountry: ie, geoIpLookup: xe} = this.options;
                        Q && !ze.utils ? (this._handlePageLoad = () => {
                            var Le;
                            window.removeEventListener("load", this._handlePageLoad),
                            (Le = ze.attachUtils(Q)) == null || Le.catch( () => {}
                            )
                        }
                        ,
                        ze.documentReady() ? this._handlePageLoad() : window.addEventListener("load", this._handlePageLoad)) : this.resolveUtilsScriptPromise(),
                        ie === "auto" && xe && !this.selectedCountryData.iso2 ? this._loadAutoCountry() : this.resolveAutoCountryPromise()
                    }
                    _loadAutoCountry() {
                        ze.autoCountry ? this.handleAutoCountry() : ze.startedLoadingAutoCountry || (ze.startedLoadingAutoCountry = !0,
                        typeof this.options.geoIpLookup == "function" && this.options.geoIpLookup( (Q="") => {
                            const ie = Q.toLowerCase();
                            ie && this._getCountryData(ie, !0) ? (ze.autoCountry = ie,
                            setTimeout( () => gt("handleAutoCountry"))) : (this._setInitialState(!0),
                            gt("rejectAutoCountryPromise"))
                        }
                        , () => {
                            this._setInitialState(!0),
                            gt("rejectAutoCountryPromise")
                        }
                        ))
                    }
                    _openDropdownWithPlus() {
                        this._openDropdown(),
                        this.searchInput.value = "+",
                        this._filterCountries("", !0)
                    }
                    _initTelInputListeners() {
                        const {strictMode: Q, formatAsYouType: ie, separateDialCode: xe, formatOnDisplay: ue, allowDropdown: Le, countrySearch: Re} = this.options;
                        let We = !1;
                        new RegExp("\\p{L}","u").test(this.telInput.value) && (We = !0),
                        this._handleInputEvent = it => {
                            if (this.isAndroid && (it == null ? void 0 : it.data) === "+" && xe && Le && Re) {
                                const zt = this.telInput.selectionStart || 0
                                  , lr = this.telInput.value.substring(0, zt - 1)
                                  , kt = this.telInput.value.substring(zt);
                                this.telInput.value = lr + kt,
                                this._openDropdownWithPlus();
                                return
                            }
                            this._updateCountryFromNumber(this.telInput.value) && this._triggerCountryChange();
                            const at = (it == null ? void 0 : it.data) && /[^+0-9]/.test(it.data)
                              , ht = (it == null ? void 0 : it.inputType) === "insertFromPaste" && this.telInput.value;
                            at || ht && !Q ? We = !0 : /[^+0-9]/.test(this.telInput.value) || (We = !1);
                            const Ft = (it == null ? void 0 : it.detail) && it.detail.isSetNumber && !ue;
                            if (ie && !We && !Ft) {
                                const zt = this.telInput.selectionStart || 0
                                  , kt = this.telInput.value.substring(0, zt).replace(/[^+0-9]/g, "").length
                                  , xt = (it == null ? void 0 : it.inputType) === "deleteContentForward"
                                  , Pt = this._formatNumberAsYouType()
                                  , jt = et(kt, Pt, zt, xt);
                                this.telInput.value = Pt,
                                this.telInput.setSelectionRange(jt, jt)
                            }
                        }
                        ,
                        this.telInput.addEventListener("input", this._handleInputEvent),
                        (Q || xe) && (this._handleKeydownEvent = it => {
                            if (it.key && it.key.length === 1 && !it.altKey && !it.ctrlKey && !it.metaKey) {
                                if (xe && Le && Re && it.key === "+") {
                                    it.preventDefault(),
                                    this._openDropdownWithPlus();
                                    return
                                }
                                if (Q) {
                                    const at = this.telInput.value
                                      , ht = at.charAt(0) === "+"
                                      , Ft = !ht && this.telInput.selectionStart === 0 && it.key === "+"
                                      , zt = /^[0-9]$/.test(it.key)
                                      , lr = xe ? zt : Ft || zt
                                      , kt = at.slice(0, this.telInput.selectionStart) + it.key + at.slice(this.telInput.selectionEnd)
                                      , xt = this._getFullNumber(kt)
                                      , Pt = ze.utils.getCoreNumber(xt, this.selectedCountryData.iso2)
                                      , jt = this.maxCoreNumberLength && Pt.length > this.maxCoreNumberLength;
                                    let Lt = !1;
                                    if (ht) {
                                        const nr = this.selectedCountryData.iso2;
                                        Lt = this._getCountryFromNumber(xt) !== nr
                                    }
                                    (!lr || jt && !Lt && !Ft) && it.preventDefault()
                                }
                            }
                        }
                        ,
                        this.telInput.addEventListener("keydown", this._handleKeydownEvent))
                    }
                    _cap(Q) {
                        const ie = parseInt(this.telInput.getAttribute("maxlength") || "", 10);
                        return ie && Q.length > ie ? Q.substr(0, ie) : Q
                    }
                    _trigger(Q, ie={}) {
                        const xe = new CustomEvent(Q,{
                            bubbles: !0,
                            cancelable: !0,
                            detail: ie
                        });
                        this.telInput.dispatchEvent(xe)
                    }
                    _openDropdown() {
                        const {fixDropdownWidth: Q, countrySearch: ie} = this.options;
                        if (Q && (this.dropdownContent.style.width = `${this.telInput.offsetWidth}px`),
                        this.dropdownContent.classList.remove("iti__hide"),
                        this.selectedCountry.setAttribute("aria-expanded", "true"),
                        this._setDropdownPosition(),
                        ie) {
                            const xe = this.countryList.firstElementChild;
                            xe && (this._highlightListItem(xe, !1),
                            this.countryList.scrollTop = 0),
                            this.searchInput.focus()
                        }
                        this._bindDropdownListeners(),
                        this.dropdownArrow.classList.add("iti__arrow--up"),
                        this._trigger("open:countrydropdown")
                    }
                    _setDropdownPosition() {
                        if (this.options.dropdownContainer && this.options.dropdownContainer.appendChild(this.dropdown),
                        !this.options.useFullscreenPopup) {
                            const Q = this.telInput.getBoundingClientRect()
                              , ie = this.telInput.offsetHeight;
                            this.options.dropdownContainer && (this.dropdown.style.top = `${Q.top + ie}px`,
                            this.dropdown.style.left = `${Q.left}px`,
                            this._handleWindowScroll = () => this._closeDropdown(),
                            window.addEventListener("scroll", this._handleWindowScroll))
                        }
                    }
                    _bindDropdownListeners() {
                        this._handleMouseoverCountryList = ue => {
                            var Re;
                            const Le = (Re = ue.target) == null ? void 0 : Re.closest(".iti__country");
                            Le && this._highlightListItem(Le, !1)
                        }
                        ,
                        this.countryList.addEventListener("mouseover", this._handleMouseoverCountryList),
                        this._handleClickCountryList = ue => {
                            var Re;
                            const Le = (Re = ue.target) == null ? void 0 : Re.closest(".iti__country");
                            Le && this._selectListItem(Le)
                        }
                        ,
                        this.countryList.addEventListener("click", this._handleClickCountryList);
                        let Q = !0;
                        this._handleClickOffToClose = () => {
                            Q || this._closeDropdown(),
                            Q = !1
                        }
                        ,
                        document.documentElement.addEventListener("click", this._handleClickOffToClose);
                        let ie = ""
                          , xe = null;
                        if (this._handleKeydownOnDropdown = ue => {
                            ["ArrowUp", "ArrowDown", "Enter", "Escape"].includes(ue.key) && (ue.preventDefault(),
                            ue.stopPropagation(),
                            ue.key === "ArrowUp" || ue.key === "ArrowDown" ? this._handleUpDownKey(ue.key) : ue.key === "Enter" ? this._handleEnterKey() : ue.key === "Escape" && this._closeDropdown()),
                            !this.options.countrySearch && /^[a-zA-ZÃ€-Ã¿Ð°-ÑÐ-Ð¯ ]$/.test(ue.key) && (ue.stopPropagation(),
                            xe && clearTimeout(xe),
                            ie += ue.key.toLowerCase(),
                            this._searchForCountry(ie),
                            xe = setTimeout( () => {
                                ie = ""
                            }
                            , 1e3))
                        }
                        ,
                        document.addEventListener("keydown", this._handleKeydownOnDropdown),
                        this.options.countrySearch) {
                            const ue = () => {
                                const Re = this.searchInput.value.trim();
                                Re ? this._filterCountries(Re) : this._filterCountries("", !0)
                            }
                            ;
                            let Le = null;
                            this._handleSearchChange = () => {
                                Le && clearTimeout(Le),
                                Le = setTimeout( () => {
                                    ue(),
                                    Le = null
                                }
                                , 100)
                            }
                            ,
                            this.searchInput.addEventListener("input", this._handleSearchChange),
                            this.searchInput.addEventListener("click", Re => Re.stopPropagation())
                        }
                    }
                    _searchForCountry(Q) {
                        for (let ie = 0; ie < this.countries.length; ie++) {
                            const xe = this.countries[ie];
                            if (xe.name.substr(0, Q.length).toLowerCase() === Q) {
                                const Le = xe.nodeById[this.id];
                                this._highlightListItem(Le, !1),
                                this._scrollTo(Le);
                                break
                            }
                        }
                    }
                    _filterCountries(Q, ie=!1) {
                        let xe = !0;
                        this.countryList.innerHTML = "";
                        const ue = Ue(Q);
                        for (let Le = 0; Le < this.countries.length; Le++) {
                            const Re = this.countries[Le]
                              , We = Ue(Re.name)
                              , it = Re.name.split(/[^a-zA-ZÃ€-Ã¿Ð°-ÑÐ-Ð¯]/).map(ht => ht[0]).join("").toLowerCase()
                              , at = `+${Re.dialCode}`;
                            if (ie || We.includes(ue) || at.includes(ue) || Re.iso2.includes(ue) || it.includes(ue)) {
                                const ht = Re.nodeById[this.id];
                                ht && this.countryList.appendChild(ht),
                                xe && (this._highlightListItem(ht, !1),
                                xe = !1)
                            }
                        }
                        xe && this._highlightListItem(null, !1),
                        this.countryList.scrollTop = 0,
                        this._updateSearchResultsText()
                    }
                    _updateSearchResultsText() {
                        const {i18n: Q} = this.options
                          , ie = this.countryList.childElementCount;
                        let xe;
                        ie === 0 ? xe = Q.zeroSearchResults : ie === 1 ? xe = Q.oneSearchResult : xe = Q.multipleSearchResults.replace("${count}", ie.toString()),
                        this.searchResultsA11yText.textContent = xe
                    }
                    _handleUpDownKey(Q) {
                        var xe, ue;
                        let ie = Q === "ArrowUp" ? (xe = this.highlightedItem) == null ? void 0 : xe.previousElementSibling : (ue = this.highlightedItem) == null ? void 0 : ue.nextElementSibling;
                        !ie && this.countryList.childElementCount > 1 && (ie = Q === "ArrowUp" ? this.countryList.lastElementChild : this.countryList.firstElementChild),
                        ie && (this._scrollTo(ie),
                        this._highlightListItem(ie, !1))
                    }
                    _handleEnterKey() {
                        this.highlightedItem && this._selectListItem(this.highlightedItem)
                    }
                    _updateValFromNumber(Q) {
                        let ie = Q;
                        if (this.options.formatOnDisplay && ze.utils && this.selectedCountryData) {
                            const xe = this.options.nationalMode || ie.charAt(0) !== "+" && !this.options.separateDialCode
                              , {NATIONAL: ue, INTERNATIONAL: Le} = ze.utils.numberFormat
                              , Re = xe ? ue : Le;
                            ie = ze.utils.formatNumber(ie, this.selectedCountryData.iso2, Re)
                        }
                        ie = this._beforeSetNumber(ie),
                        this.telInput.value = ie
                    }
                    _updateCountryFromNumber(Q) {
                        const ie = this._getCountryFromNumber(Q);
                        return ie !== null ? this._setCountry(ie) : !1
                    }
                    _ensureHasDialCode(Q) {
                        const {dialCode: ie, nationalPrefix: xe} = this.selectedCountryData;
                        if (Q.charAt(0) === "+" || !ie)
                            return Q;
                        const Re = xe && Q.charAt(0) === xe && !this.options.separateDialCode ? Q.substring(1) : Q;
                        return `+${ie}${Re}`
                    }
                    _getCountryFromNumber(Q) {
                        const ie = Q.indexOf("+");
                        let xe = ie ? Q.substring(ie) : Q;
                        const ue = this.selectedCountryData.iso2
                          , Le = this.selectedCountryData.dialCode;
                        xe = this._ensureHasDialCode(xe);
                        const Re = this._getDialCode(xe, !0)
                          , We = rt(xe);
                        if (Re) {
                            const it = rt(Re)
                              , at = this.dialCodeToIso2Map[it];
                            if (!ue && this.defaultCountry && at.includes(this.defaultCountry))
                                return this.defaultCountry;
                            const ht = ue && at.includes(ue) && (We.length === it.length || !this.selectedCountryData.areaCodes);
                            if (!(Le === "1" && lt(We)) && !ht) {
                                for (let zt = 0; zt < at.length; zt++)
                                    if (at[zt])
                                        return at[zt]
                            }
                        } else {
                            if (xe.charAt(0) === "+" && We.length)
                                return "";
                            if ((!xe || xe === "+") && !this.selectedCountryData.iso2)
                                return this.defaultCountry
                        }
                        return null
                    }
                    _highlightListItem(Q, ie) {
                        const xe = this.highlightedItem;
                        if (xe && (xe.classList.remove("iti__highlight"),
                        xe.setAttribute("aria-selected", "false")),
                        this.highlightedItem = Q,
                        this.highlightedItem) {
                            this.highlightedItem.classList.add("iti__highlight"),
                            this.highlightedItem.setAttribute("aria-selected", "true");
                            const ue = this.highlightedItem.getAttribute("id") || "";
                            this.selectedCountry.setAttribute("aria-activedescendant", ue),
                            this.options.countrySearch && this.searchInput.setAttribute("aria-activedescendant", ue)
                        }
                        ie && this.highlightedItem.focus()
                    }
                    _getCountryData(Q, ie) {
                        for (let xe = 0; xe < this.countries.length; xe++)
                            if (this.countries[xe].iso2 === Q)
                                return this.countries[xe];
                        if (ie)
                            return null;
                        throw new Error(`No country data for '${Q}'`)
                    }
                    _setCountry(Q) {
                        const {separateDialCode: ie, showFlags: xe, i18n: ue} = this.options
                          , Le = this.selectedCountryData.iso2 ? this.selectedCountryData : {};
                        if (this.selectedCountryData = Q ? this._getCountryData(Q, !1) || {} : {},
                        this.selectedCountryData.iso2 && (this.defaultCountry = this.selectedCountryData.iso2),
                        this.selectedCountryInner) {
                            let Re = ""
                              , We = "";
                            Q && xe ? (Re = `iti__flag iti__${Q}`,
                            We = `${this.selectedCountryData.name} +${this.selectedCountryData.dialCode}`) : (Re = "iti__flag iti__globe",
                            We = ue.noCountrySelected),
                            this.selectedCountryInner.className = Re,
                            this.selectedCountryA11yText.textContent = We
                        }
                        if (this._setSelectedCountryTitleAttribute(Q, ie),
                        ie) {
                            const Re = this.selectedCountryData.dialCode ? `+${this.selectedCountryData.dialCode}` : "";
                            this.selectedDialCode.innerHTML = Re,
                            this._updateInputPadding()
                        }
                        return this._updatePlaceholder(),
                        this._updateMaxLength(),
                        Le.iso2 !== Q
                    }
                    _updateInputPadding() {
                        if (this.selectedCountry) {
                            const ie = (this.selectedCountry.offsetWidth || this._getHiddenSelectedCountryWidth()) + 6;
                            this.showSelectedCountryOnLeft ? this.telInput.style.paddingLeft = `${ie}px` : this.telInput.style.paddingRight = `${ie}px`
                        }
                    }
                    _updateMaxLength() {
                        const {strictMode: Q, placeholderNumberType: ie, validationNumberTypes: xe} = this.options
                          , {iso2: ue} = this.selectedCountryData;
                        if (Q && ze.utils)
                            if (ue) {
                                const Le = ze.utils.numberType[ie];
                                let Re = ze.utils.getExampleNumber(ue, !1, Le, !0)
                                  , We = Re;
                                for (; ze.utils.isPossibleNumber(Re, ue, xe); )
                                    We = Re,
                                    Re += "0";
                                const it = ze.utils.getCoreNumber(We, ue);
                                this.maxCoreNumberLength = it.length,
                                ue === "by" && (this.maxCoreNumberLength = it.length + 1)
                            } else
                                this.maxCoreNumberLength = null
                    }
                    _setSelectedCountryTitleAttribute(Q=null, ie) {
                        if (!this.selectedCountry)
                            return;
                        let xe;
                        Q && !ie ? xe = `${this.selectedCountryData.name}: +${this.selectedCountryData.dialCode}` : Q ? xe = this.selectedCountryData.name : xe = "Unknown",
                        this.selectedCountry.setAttribute("title", xe)
                    }
                    _getHiddenSelectedCountryWidth() {
                        if (this.telInput.parentNode) {
                            const Q = this.telInput.parentNode.cloneNode(!1);
                            Q.style.visibility = "hidden",
                            document.body.appendChild(Q);
                            const ie = this.countryContainer.cloneNode();
                            Q.appendChild(ie);
                            const xe = this.selectedCountry.cloneNode(!0);
                            ie.appendChild(xe);
                            const ue = xe.offsetWidth;
                            return document.body.removeChild(Q),
                            ue
                        }
                        return 0
                    }
                    _updatePlaceholder() {
                        const {autoPlaceholder: Q, placeholderNumberType: ie, nationalMode: xe, customPlaceholder: ue} = this.options
                          , Le = Q === "aggressive" || !this.hadInitialPlaceholder && Q === "polite";
                        if (ze.utils && Le) {
                            const Re = ze.utils.numberType[ie];
                            let We = this.selectedCountryData.iso2 ? ze.utils.getExampleNumber(this.selectedCountryData.iso2, xe, Re) : "";
                            We = this._beforeSetNumber(We),
                            typeof ue == "function" && (We = ue(We, this.selectedCountryData)),
                            this.telInput.setAttribute("placeholder", We)
                        }
                    }
                    _selectListItem(Q) {
                        const ie = this._setCountry(Q.getAttribute("data-country-code"));
                        this._closeDropdown(),
                        this._updateDialCode(Q.getAttribute("data-dial-code")),
                        this.telInput.focus(),
                        ie && this._triggerCountryChange()
                    }
                    _closeDropdown() {
                        this.dropdownContent.classList.add("iti__hide"),
                        this.selectedCountry.setAttribute("aria-expanded", "false"),
                        this.selectedCountry.removeAttribute("aria-activedescendant"),
                        this.highlightedItem && this.highlightedItem.setAttribute("aria-selected", "false"),
                        this.options.countrySearch && this.searchInput.removeAttribute("aria-activedescendant"),
                        this.dropdownArrow.classList.remove("iti__arrow--up"),
                        document.removeEventListener("keydown", this._handleKeydownOnDropdown),
                        this.options.countrySearch && this.searchInput.removeEventListener("input", this._handleSearchChange),
                        document.documentElement.removeEventListener("click", this._handleClickOffToClose),
                        this.countryList.removeEventListener("mouseover", this._handleMouseoverCountryList),
                        this.countryList.removeEventListener("click", this._handleClickCountryList),
                        this.options.dropdownContainer && (this.options.useFullscreenPopup || window.removeEventListener("scroll", this._handleWindowScroll),
                        this.dropdown.parentNode && this.dropdown.parentNode.removeChild(this.dropdown)),
                        this._handlePageLoad && window.removeEventListener("load", this._handlePageLoad),
                        this._trigger("close:countrydropdown")
                    }
                    _scrollTo(Q) {
                        const ie = this.countryList
                          , xe = document.documentElement.scrollTop
                          , ue = ie.offsetHeight
                          , Le = ie.getBoundingClientRect().top + xe
                          , Re = Le + ue
                          , We = Q.offsetHeight
                          , it = Q.getBoundingClientRect().top + xe
                          , at = it + We
                          , ht = it - Le + ie.scrollTop;
                        if (it < Le)
                            ie.scrollTop = ht;
                        else if (at > Re) {
                            const Ft = ue - We;
                            ie.scrollTop = ht - Ft
                        }
                    }
                    _updateDialCode(Q) {
                        const ie = this.telInput.value
                          , xe = `+${Q}`;
                        let ue;
                        if (ie.charAt(0) === "+") {
                            const Le = this._getDialCode(ie);
                            Le ? ue = ie.replace(Le, xe) : ue = xe,
                            this.telInput.value = ue
                        }
                    }
                    _getDialCode(Q, ie) {
                        let xe = "";
                        if (Q.charAt(0) === "+") {
                            let ue = "";
                            for (let Le = 0; Le < Q.length; Le++) {
                                const Re = Q.charAt(Le);
                                if (!isNaN(parseInt(Re, 10))) {
                                    if (ue += Re,
                                    ie)
                                        this.dialCodeToIso2Map[ue] && (xe = Q.substr(0, Le + 1));
                                    else if (this.dialCodes[ue]) {
                                        xe = Q.substr(0, Le + 1);
                                        break
                                    }
                                    if (ue.length === this.dialCodeMaxLen)
                                        break
                                }
                            }
                        }
                        return xe
                    }
                    _getFullNumber(Q) {
                        const ie = Q || this.telInput.value.trim()
                          , {dialCode: xe} = this.selectedCountryData;
                        let ue;
                        const Le = rt(ie);
                        return this.options.separateDialCode && ie.charAt(0) !== "+" && xe && Le ? ue = `+${xe}` : ue = "",
                        ue + ie
                    }
                    _beforeSetNumber(Q) {
                        let ie = Q;
                        if (this.options.separateDialCode) {
                            let xe = this._getDialCode(ie);
                            if (xe) {
                                xe = `+${this.selectedCountryData.dialCode}`;
                                const ue = ie[xe.length] === " " || ie[xe.length] === "-" ? xe.length + 1 : xe.length;
                                ie = ie.substr(ue)
                            }
                        }
                        return this._cap(ie)
                    }
                    _triggerCountryChange() {
                        this._trigger("countrychange")
                    }
                    _formatNumberAsYouType() {
                        const Q = this._getFullNumber()
                          , ie = ze.utils ? ze.utils.formatNumberAsYouType(Q, this.selectedCountryData.iso2) : Q
                          , {dialCode: xe} = this.selectedCountryData;
                        return this.options.separateDialCode && this.telInput.value.charAt(0) !== "+" && ie.includes(`+${xe}`) ? (ie.split(`+${xe}`)[1] || "").trim() : ie
                    }
                    handleAutoCountry() {
                        this.options.initialCountry === "auto" && ze.autoCountry && (this.defaultCountry = ze.autoCountry,
                        this.selectedCountryData.iso2 || this.selectedCountryInner.classList.contains("iti__globe") || this.setCountry(this.defaultCountry),
                        this.resolveAutoCountryPromise())
                    }
                    handleUtils() {
                        ze.utils && (this.telInput.value && this._updateValFromNumber(this.telInput.value),
                        this.selectedCountryData.iso2 && (this._updatePlaceholder(),
                        this._updateMaxLength())),
                        this.resolveUtilsScriptPromise()
                    }
                    destroy() {
                        var Le, Re;
                        const {allowDropdown: Q, separateDialCode: ie} = this.options;
                        if (Q) {
                            this._closeDropdown(),
                            this.selectedCountry.removeEventListener("click", this._handleClickSelectedCountry),
                            this.countryContainer.removeEventListener("keydown", this._handleCountryContainerKeydown);
                            const We = this.telInput.closest("label");
                            We && We.removeEventListener("click", this._handleLabelClick)
                        }
                        const {form: xe} = this.telInput;
                        this._handleHiddenInputSubmit && xe && xe.removeEventListener("submit", this._handleHiddenInputSubmit),
                        this.telInput.removeEventListener("input", this._handleInputEvent),
                        this._handleKeydownEvent && this.telInput.removeEventListener("keydown", this._handleKeydownEvent),
                        this.telInput.removeAttribute("data-intl-tel-input-id"),
                        ie && (this.isRTL ? this.telInput.style.paddingRight = this.originalPaddingRight : this.telInput.style.paddingLeft = this.originalPaddingLeft);
                        const ue = this.telInput.parentNode;
                        (Le = ue == null ? void 0 : ue.parentNode) == null || Le.insertBefore(this.telInput, ue),
                        (Re = ue == null ? void 0 : ue.parentNode) == null || Re.removeChild(ue),
                        delete ze.instances[this.id]
                    }
                    getExtension() {
                        return ze.utils ? ze.utils.getExtension(this._getFullNumber(), this.selectedCountryData.iso2) : ""
                    }
                    getNumber(Q) {
                        if (ze.utils) {
                            const {iso2: ie} = this.selectedCountryData;
                            return ze.utils.formatNumber(this._getFullNumber(), ie, Q)
                        }
                        return ""
                    }
                    getNumberType() {
                        return ze.utils ? ze.utils.getNumberType(this._getFullNumber(), this.selectedCountryData.iso2) : -99
                    }
                    getSelectedCountryData() {
                        return this.selectedCountryData
                    }
                    getValidationError() {
                        if (ze.utils) {
                            const {iso2: Q} = this.selectedCountryData;
                            return ze.utils.getValidationError(this._getFullNumber(), Q)
                        }
                        return -99
                    }
                    isValidNumber() {
                        if (!this.selectedCountryData.iso2)
                            return !1;
                        const Q = this._getFullNumber()
                          , ie = Q.search(new RegExp("\\p{L}","u"));
                        if (ie > -1) {
                            const xe = Q.substring(0, ie)
                              , ue = this._utilsIsPossibleNumber(xe)
                              , Le = this._utilsIsPossibleNumber(Q);
                            return ue && Le
                        }
                        return this._utilsIsPossibleNumber(Q)
                    }
                    _utilsIsPossibleNumber(Q) {
                        return ze.utils ? ze.utils.isPossibleNumber(Q, this.selectedCountryData.iso2, this.options.validationNumberTypes) : null
                    }
                    isValidNumberPrecise() {
                        if (!this.selectedCountryData.iso2)
                            return !1;
                        const Q = this._getFullNumber()
                          , ie = Q.search(new RegExp("\\p{L}","u"));
                        if (ie > -1) {
                            const xe = Q.substring(0, ie)
                              , ue = this._utilsIsValidNumber(xe)
                              , Le = this._utilsIsValidNumber(Q);
                            return ue && Le
                        }
                        return this._utilsIsValidNumber(Q)
                    }
                    _utilsIsValidNumber(Q) {
                        return ze.utils ? ze.utils.isValidNumber(Q, this.selectedCountryData.iso2, this.options.validationNumberTypes) : null
                    }
                    setCountry(Q) {
                        const ie = Q == null ? void 0 : Q.toLowerCase()
                          , xe = this.selectedCountryData.iso2;
                        (Q && ie !== xe || !Q && xe) && (this._setCountry(ie),
                        this._updateDialCode(this.selectedCountryData.dialCode),
                        this._triggerCountryChange())
                    }
                    setNumber(Q) {
                        const ie = this._updateCountryFromNumber(Q);
                        this._updateValFromNumber(Q),
                        ie && this._triggerCountryChange(),
                        this._trigger("input", {
                            isSetNumber: !0
                        })
                    }
                    setPlaceholderNumberType(Q) {
                        this.options.placeholderNumberType = Q,
                        this._updatePlaceholder()
                    }
                    setDisabled(Q) {
                        this.telInput.disabled = Q,
                        Q ? this.selectedCountry.setAttribute("disabled", "true") : this.selectedCountry.removeAttribute("disabled")
                    }
                }
                  , ct = Q => {
                    if (!ze.utils && !ze.startedLoadingUtilsScript) {
                        let ie;
                        if (typeof Q == "function")
                            try {
                                ie = Promise.resolve(Q())
                            } catch (xe) {
                                return Promise.reject(xe)
                            }
                        else
                            return Promise.reject(new TypeError(`The argument passed to attachUtils must be a function that returns a promise for the utilities module, not ${typeof Q}`));
                        return ze.startedLoadingUtilsScript = !0,
                        ie.then(xe => {
                            const ue = xe == null ? void 0 : xe.default;
                            if (!ue || typeof ue != "object")
                                throw new TypeError("The loader function passed to attachUtils did not resolve to a module object with utils as its default export.");
                            return ze.utils = ue,
                            gt("handleUtils"),
                            !0
                        }
                        ).catch(xe => {
                            throw gt("rejectUtilsScriptPromise", xe),
                            xe
                        }
                        )
                    }
                    return null
                }
                  , ze = Object.assign( (Q, ie) => {
                    const xe = new dt(Q,ie);
                    return xe._init(),
                    Q.setAttribute("data-intl-tel-input-id", xe.id.toString()),
                    ze.instances[xe.id] = xe,
                    xe
                }
                , {
                    defaults: Ze,
                    documentReady: () => document.readyState === "complete",
                    getCountryData: () => he,
                    getInstance: Q => {
                        const ie = Q.getAttribute("data-intl-tel-input-id");
                        return ie ? ze.instances[ie] : null
                    }
                    ,
                    instances: {},
                    attachUtils: ct,
                    startedLoadingUtilsScript: !1,
                    startedLoadingAutoCountry: !1,
                    version: "25.3.2"
                })
                  , vt = ze;
                return W(G)
            }
            )();
            return l.default
        }
        )
    }(yf)),
    yf.exports
}
var Lk = zk();
const Dk = um(Lk);
var Rk = Be('<div><span class="loading loading-spinner loading-xl"></span></div>')
  , Bk = Be('<span class="w-8"> </span>')
  , Fk = Be('<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="text-base-content/80 mt-0.5 text-sm"> </p></div> <form class="mt-8 flex w-full flex-col gap-3"><input class="input pl-12! w-full" type="tel" id="phone"/> <button class="btn btn-primary w-full"> <!></button></form>', 1)
  , Ok = async (x, l, _) => {
    await l(w(_))
}
  , Nk = Be('<span class="w-8"> </span>')
  , jk = (x, l) => {
    fe(l, "")
}
  , qk = Be('<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="mt-0.5 text-sm"> </p></div> <div class="mt-4"><!></div> <div class="mt-3 flex flex-col items-center gap-1"><button class="btn btn-ghost w-max"> <!></button> <button class="text-primary cursor-pointer text-xs"> </button></div>', 1)
  , Vk = Be('<div class="flex h-full w-full flex-col items-center justify-center"><!></div>');
function Zk(x, l) {
    Lr(l, !0);
    let _ = mt(!0)
      , T = mt("")
      , E = mt(0)
      , F = mt(!1);
    const C = _t( () => w(E) > 0 || w(F));
    let o = mt(!1)
      , W = mt("")
      , G = mt(void 0);
    const re = _t( () => {
        var Ie;
        return `phone:${(Ie = Vt.data) == null ? void 0 : Ie.id}`
    }
    );
    Gr( () => {
        const Ie = localStorage.getItem(w(re));
        Ie && fe(T, Ie, !0)
    }
    ),
    wi( () => {
        ri.getOtpCooldown().then(qe => {
            fe(E, qe.cooldownMs, !0)
        }
        ).catch(qe => {
            Zr.error(qe.message)
        }
        ).finally( () => {
            fe(_, !1)
        }
        );
        const Ie = 1e3
          , De = setInterval( () => {
            fe(E, Math.max(0, w(E) - Ie), !0)
        }
        , Ie);
        return () => {
            clearInterval(De)
        }
    }
    );
    async function de(Ie) {
        try {
            fe(F, !0);
            const De = await ri.sendOtp(Ie);
            Zr.info(`${wC()} ${De.phone}`),
            fe(T, De.phone, !0),
            fe(E, De.cooldownMs, !0),
            localStorage.setItem(w(re), w(T))
        } catch (De) {
            Zr.error(De.message)
        } finally {
            fe(F, !1)
        }
    }
    Gr( () => {
        w(W).length === 6 && (fe(o, !0),
        (async () => {
            try {
                await ri.verifyOtp(w(W)),
                await Vt.refresh(),
                Zr.success(SC()),
                localStorage.removeItem(w(re)),
                l.onsuccess(w(T))
            } catch (Ie) {
                Zr.error(Ie.message)
            } finally {
                fe(W, ""),
                fe(o, !1)
            }
        }
        )())
    }
    );
    var he = Vk()
      , X = z(he);
    {
        var le = Ie => {
            var De = Rk();
            H(Ie, De)
        }
          , Se = Ie => {
            var De = cr()
              , qe = Rt(De);
            {
                var Ne = ut => {
                    var rt = Fk()
                      , Ue = Rt(rt)
                      , lt = z(Ue)
                      , et = z(lt, !0);
                    k(lt);
                    var Ve = U(lt, 2)
                      , gt = z(Ve, !0);
                    k(Ve),
                    k(Ue);
                    var dt = U(Ue, 2)
                      , ct = z(dt);
                    Fn(ct, () => xe => (fe(G, Dk(xe, {
                        strictMode: !0,
                        initialCountry: "br",
                        loadUtils: () => zx( () => import("../chunks/1FgtjJRR.js"), [], import.meta.url),
                        containerClass: "w-full",
                        dropdownContainer: document.body
                    })),
                    () => {
                        var ue;
                        (ue = w(G)) == null || ue.destroy()
                    }
                    ));
                    var ze = U(ct, 2)
                      , vt = z(ze)
                      , Q = U(vt);
                    {
                        var ie = xe => {
                            var ue = Bk()
                              , Le = z(ue);
                            k(ue),
                            st(Re => Ce(Le, `(${Re ?? ""})`), [ () => zd(w(E))]),
                            H(xe, ue)
                        }
                        ;
                        tt(Q, xe => {
                            w(E) > 0 && xe(ie)
                        }
                        )
                    }
                    k(ze),
                    k(dt),
                    st( (xe, ue, Le) => {
                        Ce(et, xe),
                        Ce(gt, ue),
                        ze.disabled = w(C),
                        Ce(vt, `${Le ?? ""} `)
                    }
                    , [ () => tS(), () => nS(), () => oS()]),
                    _n("submit", dt, async () => {
                        var ue;
                        if (w(C))
                            return;
                        if (!((ue = w(G)) != null && ue.isValidNumber())) {
                            Zr.error(MC());
                            return
                        }
                        const xe = w(G).getNumber();
                        await de(xe)
                    }
                    ),
                    H(ut, rt)
                }
                  , Ze = ut => {
                    var rt = qk()
                      , Ue = Rt(rt)
                      , lt = z(Ue)
                      , et = z(lt, !0);
                    k(lt);
                    var Ve = U(lt, 2)
                      , gt = z(Ve);
                    k(Ve),
                    k(Ue);
                    var dt = U(Ue, 2)
                      , ct = z(dt);
                    {
                        const Re = (We, it) => {
                            let at = () => it == null ? void 0 : it().cells;
                            var ht = cr()
                              , Ft = Rt(ht);
                            an(Ft, () => Ik, (zt, lr) => {
                                lr(zt, {
                                    class: "border-primary",
                                    children: (kt, xt) => {
                                        var Pt = cr()
                                          , jt = Rt(Pt);
                                        mn(jt, 16, at, Lt => Lt, (Lt, nr) => {
                                            var xr = cr()
                                              , er = Rt(xr);
                                            an(er, () => kk, (Qt, $t) => {
                                                $t(Qt, {
                                                    get cell() {
                                                        return nr
                                                    },
                                                    class: "border-base-content/20 size-11 sm:size-12"
                                                })
                                            }
                                            ),
                                            H(Lt, xr)
                                        }
                                        ),
                                        H(kt, Pt)
                                    }
                                    ,
                                    $$slots: {
                                        default: !0
                                    }
                                })
                            }
                            ),
                            H(We, ht)
                        }
                        ;
                        an(ct, () => Ek, (We, it) => {
                            it(We, {
                                maxlength: 6,
                                class: "mx-auto w-max",
                                get disabled() {
                                    return w(o)
                                },
                                get value() {
                                    return w(W)
                                },
                                set value(at) {
                                    fe(W, at, !0)
                                },
                                children: Re,
                                $$slots: {
                                    default: !0
                                }
                            })
                        }
                        )
                    }
                    k(dt);
                    var ze = U(dt, 2)
                      , vt = z(ze);
                    vt.__click = [Ok, de, T];
                    var Q = z(vt)
                      , ie = U(Q);
                    {
                        var xe = Re => {
                            var We = Nk()
                              , it = z(We);
                            k(We),
                            st(at => Ce(it, `(${at ?? ""})`), [ () => zd(w(E))]),
                            H(Re, We)
                        }
                        ;
                        tt(ie, Re => {
                            w(E) > 0 && Re(xe)
                        }
                        )
                    }
                    k(vt);
                    var ue = U(vt, 2);
                    ue.__click = [jk, T];
                    var Le = z(ue, !0);
                    k(ue),
                    k(ze),
                    st( (Re, We, it, at) => {
                        Ce(et, Re),
                        Ce(gt, `${We ?? ""} ${w(T) ?? ""}`),
                        vt.disabled = w(C),
                        Ce(Q, `${it ?? ""} `),
                        Ce(Le, at)
                    }
                    , [ () => uS(), () => pS(), () => _S(), () => yS()]),
                    H(ut, rt)
                }
                ;
                tt(qe, ut => {
                    w(T) ? ut(Ze, !1) : ut(Ne)
                }
                , !0)
            }
            H(Ie, De)
        }
        ;
        tt(X, Ie => {
            w(_) ? Ie(le) : Ie(Se, !1)
        }
        )
    }
    k(he),
    H(x, he),
    Dr()
}
Xi(["click"]);
var $k = Be('<dialog class="modal"><div class="modal-box h-72 max-w-sm"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <!></div></dialog>');
function Uk(x, l) {
    Lr(l, !0);
    let _ = At(l, "open", 15);
    var T = $k()
      , E = z(T)
      , F = U(z(E), 2);
    {
        var C = o => {
            Zk(o, {
                onsuccess: () => _(!1)
            })
        }
        ;
        tt(F, o => {
            _() && o(C)
        }
        )
    }
    k(E),
    k(T),
    Fn(T, () => o => {
        Gr( () => {
            _() ? o.show() : o.close()
        }
        )
    }
    ),
    _n("close", T, () => _(!1)),
    H(x, T),
    Dr()
}
var Gk = (x, l) => {
    l()
}
  , Hk = Be('<span class="center-absolute loading loading-spinner absolute"></span>')
  , Wk = Be('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>')
  , Xk = (x, l, _) => {
    l(w(_).id)
}
  , Kk = Be('<span class="center-absolute loading loading-spinner absolute"></span>')
  , Yk = Be('<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>')
  , Jk = Be('<div><div class="text-base-content/80 text-sm"> </div> <div class="mt-2 grid grid-cols-3 gap-2"><!> <!></div></div>')
  , Qk = (x, l) => {
    var _;
    (_ = w(l)) == null || _.show()
}
  , eE = (x, l) => {
    l(!1)
}
  , tE = (x, l) => {
    var _;
    (_ = w(l)) == null || _.close()
}
  , rE = async (x, l) => {
    try {
        fe(l, !0),
        await ri.deleteMe(),
        Zr.warning(ZC()),
        await Vt.logout()
    } catch (_) {
        Zr.error(_.message)
    } finally {
        fe(l, !1)
    }
}
  , iE = Be('<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><div class="flex flex-col gap-6 sm:flex-row"><div class="sm:min-w-34 flex items-center justify-center gap-6 sm:flex-col sm:gap-3"><div class="relative w-max"><!> <a class="tooltip btn btn-circle tooltip-right absolute -bottom-1 -right-1 max-sm:overflow-x-hidden" href="/profile-picture"><!></a></div> <!></div> <div class="flex w-full flex-col gap-3"><!> <!> <label class="input w-full"><span class="label"> </span> <input type="email" placeholder="Email" disabled/></label> <label class="label text-sm"><input class="checkbox checkbox-xs" type="checkbox"/> </label></div></div> <div class="mt-4 flex w-full items-center justify-between"><button type="button" class="btn btn-error btn-soft btn-sm w-max"> </button> <div class="flex gap-2"><button class="btn btn-soft" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog> <dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <p class="mt-4"> </p> <div class="mt-4 flex justify-end gap-2"><button class="btn btn-soft"> </button> <button class="btn btn-error"> </button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);
function nE(x, l) {
    Lr(l, !0);
    let _ = At(l, "open", 15)
      , T = mt(Mn(l.userData.name))
      , E = mt(Mn(l.userData.discord))
      , F = mt(Mn(l.userData.showLastPixel))
      , C = mt(!1)
      , o = mt(void 0)
      , W = mt(void 0);
    wi( () => {
        const sr = Xt => {
            Xt.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", sr),
        () => document.removeEventListener("keydown", sr)
    }
    );
    let G = mt(void 0)
      , re = mt(void 0);
    Gr( () => {
        fe(T, l.userData.name, !0),
        fe(F, l.userData.showLastPixel, !0)
    }
    ),
    Gr( () => {
        _() && !w(W) && ri.getMyProfilePictures().then(sr => {
            fe(W, sr, !0)
        }
        ).catch(sr => {
            Zr.error(sr.message)
        }
        )
    }
    );
    let de = mt(!1);
    async function he(sr) {
        try {
            fe(de, !0),
            await ri.changeProfilePicture(sr),
            await Vt.refresh()
        } finally {
            fe(de, !1)
        }
    }
    var X = iE()
      , le = Rt(X)
      , Se = z(le)
      , Ie = U(z(Se), 2)
      , De = z(Ie, !0);
    k(Ie);
    var qe = U(Ie, 2)
      , Ne = z(qe)
      , Ze = z(Ne)
      , ut = z(Ze)
      , rt = z(ut);
    ss(rt, {
        class: "size-30",
        get userId() {
            return l.userData.id
        },
        get pictureUrl() {
            return l.userData.picture
        }
    });
    var Ue = U(rt, 2)
      , lt = z(Ue);
    Gg(lt, {
        class: "size-5"
    }),
    k(Ue),
    k(ut);
    var et = U(ut, 2);
    {
        var Ve = sr => {
            var Xt = Jk()
              , Ir = z(Xt)
              , mr = z(Ir, !0);
            k(Ir);
            var vr = U(Ir, 2)
              , br = z(vr);
            {
                var _r = Tr => {
                    var be = Wk();
                    be.__click = [Gk, he];
                    var q = z(be);
                    ss(q, {
                        class: "size-10 border",
                        get userId() {
                            return l.userData.id
                        }
                    });
                    var V = U(q, 2);
                    {
                        var K = ae => {
                            var we = Hk();
                            H(ae, we)
                        }
                        ;
                        tt(V, ae => {
                            w(de) && ae(K)
                        }
                        )
                    }
                    k(be),
                    st( () => be.disabled = w(de)),
                    H(Tr, be)
                }
                ;
                tt(br, Tr => {
                    l.userData.picture && Tr(_r)
                }
                )
            }
            var Ar = U(br, 2);
            mn(Ar, 17, () => w(W), Tr => Tr.id, (Tr, be) => {
                var q = cr()
                  , V = Rt(q);
                {
                    var K = ae => {
                        var we = Yk();
                        we.__click = [Xk, he, be];
                        var Me = z(we);
                        ss(Me, {
                            class: "size-10 border",
                            get userId() {
                                return l.userData.id
                            },
                            get pictureUrl() {
                                return w(be).url
                            }
                        });
                        var ke = U(Me, 2);
                        {
                            var ge = je => {
                                var Oe = Kk();
                                H(je, Oe)
                            }
                            ;
                            tt(ke, je => {
                                w(de) && je(ge)
                            }
                            )
                        }
                        k(we),
                        st( () => we.disabled = w(de)),
                        H(ae, we)
                    }
                    ;
                    tt(V, ae => {
                        l.userData.picture !== w(be).url && ae(K)
                    }
                    )
                }
                H(Tr, q)
            }
            ),
            k(vr),
            k(Xt),
            st(Tr => Ce(mr, Tr), [ () => i2()]),
            H(sr, Xt)
        }
        ;
        tt(et, sr => {
            var Xt;
            (Xt = w(W)) != null && Xt.length && sr(Ve)
        }
        )
    }
    k(Ze);
    var gt = U(Ze, 2)
      , dt = z(gt);
    {
        let sr = _t( () => wf())
          , Xt = _t( () => wf());
        Sf(dt, {
            get label() {
                return w(sr)
            },
            get placeholder() {
                return w(Xt)
            },
            min: 1,
            max: 16,
            get value() {
                return w(T)
            },
            set value(Ir) {
                fe(T, Ir, !0)
            },
            get validate() {
                return w(G)
            },
            set validate(Ir) {
                fe(G, Ir, !0)
            }
        })
    }
    var ct = U(dt, 2);
    {
        let sr = _t( () => p5());
        Sf(ct, {
            label: "Discord",
            get placeholder() {
                return w(sr)
            },
            max: 32,
            get value() {
                return w(E)
            },
            set value(Xt) {
                fe(E, Xt, !0)
            },
            get validate() {
                return w(re)
            },
            set validate(Xt) {
                fe(re, Xt, !0)
            }
        })
    }
    var ze = U(ct, 2)
      , vt = z(ze)
      , Q = z(vt, !0);
    k(vt);
    var ie = U(vt, 2);
    Ea(ie),
    k(ze);
    var xe = U(ze, 2)
      , ue = z(xe);
    Ea(ue);
    var Le = U(ue);
    k(xe),
    k(gt),
    k(Ne);
    var Re = U(Ne, 2)
      , We = z(Re);
    We.__click = [Qk, o];
    var it = z(We, !0);
    k(We);
    var at = U(We, 2)
      , ht = z(at);
    ht.__click = [eE, _];
    var Ft = z(ht, !0);
    k(ht);
    var zt = U(ht, 2)
      , lr = z(zt, !0);
    k(zt),
    k(at),
    k(Re),
    k(qe),
    k(Se),
    k(le),
    Fn(le, () => sr => {
        Gr( () => {
            _() ? sr.show() : sr.close()
        }
        )
    }
    );
    var kt = U(le, 2)
      , xt = z(kt)
      , Pt = U(z(xt), 2)
      , jt = z(Pt, !0);
    k(Pt);
    var Lt = U(Pt, 2)
      , nr = z(Lt, !0);
    k(Lt);
    var xr = U(Lt, 2)
      , er = z(xr);
    er.__click = [tE, o];
    var Qt = z(er, !0);
    k(er);
    var $t = U(er, 2);
    $t.__click = [rE, C];
    var tr = z($t, !0);
    k($t),
    k(xr),
    k(xt);
    var $r = U(xt, 2)
      , zr = z($r)
      , Mr = z(zr, !0);
    k(zr),
    k($r),
    k(kt),
    Ss(kt, sr => fe(o, sr), () => w(o)),
    st( (sr, Xt, Ir, mr, vr, br, _r, Ar, Tr, be, q, V) => {
        Ce(De, sr),
        jr(Ue, "data-tip", Xt),
        Ce(Q, Ir),
        Yf(ie, l.userData.email),
        Ce(Le, ` ${mr ?? ""}`),
        Ce(it, vr),
        ht.disabled = w(C),
        Ce(Ft, br),
        zt.disabled = w(C),
        Ce(lr, _r),
        Ce(jt, Ar),
        Ce(nr, Tr),
        Ce(Qt, be),
        $t.disabled = w(C),
        Ce(tr, q),
        Ce(Mr, V)
    }
    , [ () => wS(), () => Px(), () => s2(), () => c2(), () => Cg(), () => Ql(), () => f2(), () => g2(), () => x2(), () => Qf(), () => Cg(), () => Ql()]),
    _n("close", le, () => _(!1)),
    _n("submit", qe, async () => {
        var sr, Xt;
        try {
            if (!((sr = w(G)) != null && sr()) || !((Xt = w(re)) != null && Xt()))
                return;
            fe(C, !0),
            await ri.updateMe({
                name: w(T),
                showLastPixel: w(F),
                discord: w(E)
            }),
            Vt.refresh(),
            Zr.success(jC()),
            _(!1)
        } catch (Ir) {
            Zr.error(Ir.message)
        } finally {
            fe(C, !1)
        }
    }
    ),
    Ix(ue, () => w(F), sr => fe(F, sr)),
    H(x, X),
    Dr()
}
Xi(["click"]);
var aE = Pr('<svg><path d="M440-160v-487L216-423l-56-57 320-320 320 320-56 57-224-224v487h-80Z"></path></svg>');
function sE(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = aE();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var oE = Pr('<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h280v80H200Zm440-160-55-58 102-102H360v-80h327L585-622l55-58 200 200-200 200Z"></path></svg>');
function Zv(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = oE();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var lE = Pr('<svg><path d="M240-80q-50 0-85-35t-35-85v-120h120v-560l60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60v680q0 50-35 85t-85 35H240Zm480-80q17 0 28.5-11.5T760-200v-560H320v440h360v120q0 17 11.5 28.5T720-160ZM360-600v-80h240v80H360Zm0 120v-80h240v80H360Zm320-120q-17 0-28.5-11.5T640-640q0-17 11.5-28.5T680-680q17 0 28.5 11.5T720-640q0 17-11.5 28.5T680-600Zm0 120q-17 0-28.5-11.5T640-520q0-17 11.5-28.5T680-560q17 0 28.5 11.5T720-520q0 17-11.5 28.5T680-480ZM240-160h360v-80H200v40q0 17 11.5 28.5T240-160Zm-40 0v-80 80Z"></path></svg>');
function cE(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = lE();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var uE = Pr('<svg><defs><radialGradient id="snoo-radial-gragient" cx="169.75" cy="92.19" r="50.98" fx="169.75" fy="92.19" gradientTransform="matrix(1 0 0 .87 0 11.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#feffff"></stop><stop offset=".4" stop-color="#feffff"></stop><stop offset=".51" stop-color="#f9fcfc"></stop><stop offset=".62" stop-color="#edf3f5"></stop><stop offset=".7" stop-color="#dee9ec"></stop><stop offset=".72" stop-color="#d8e4e8"></stop><stop offset=".76" stop-color="#ccd8df"></stop><stop offset=".8" stop-color="#c8d5dd"></stop><stop offset=".83" stop-color="#ccd6de"></stop><stop offset=".85" stop-color="#d8dbe2"></stop><stop offset=".88" stop-color="#ede3e9"></stop><stop offset=".9" stop-color="#ffebef"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-2" cx="47.31" r="50.98" fx="47.31"></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-3" cx="109.61" cy="85.59" r="153.78" fx="109.61" fy="85.59" gradientTransform="matrix(1 0 0 .7 0 25.56)"></radialGradient><radialGradient id="snoo-radial-gragient-4" cx="-6.01" cy="64.68" r="12.85" fx="-6.01" fy="64.68" gradientTransform="matrix(1.07 0 0 1.55 81.08 27.26)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#f60"></stop><stop offset=".5" stop-color="#ff4500"></stop><stop offset=".7" stop-color="#fc4301"></stop><stop offset=".82" stop-color="#f43f07"></stop><stop offset=".92" stop-color="#e53812"></stop><stop offset="1" stop-color="#d4301f"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient-4" id="snoo-radial-gragient-5" cx="-73.55" cy="64.68" r="12.85" fx="-73.55" fy="64.68" gradientTransform="matrix(-1.07 0 0 1.55 62.87 27.26)"></radialGradient><radialGradient id="snoo-radial-gragient-6" cx="107.93" cy="166.96" r="45.3" fx="107.93" fy="166.96" gradientTransform="matrix(1 0 0 .66 0 57.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#172e35"></stop><stop offset=".29" stop-color="#0e1c21"></stop><stop offset=".73" stop-color="#030708"></stop><stop offset="1"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-7" cx="147.88" cy="32.94" r="39.77" fx="147.88" fy="32.94" gradientTransform="matrix(1 0 0 .98 0 .54)"></radialGradient><radialGradient id="snoo-radial-gragient-8" cx="131.31" cy="73.08" r="32.6" fx="131.31" fy="73.08" gradientUnits="userSpaceOnUse"><stop offset=".48" stop-color="#7a9299"></stop><stop offset=".67" stop-color="#172e35"></stop><stop offset=".75"></stop><stop offset=".82" stop-color="#172e35"></stop></radialGradient></defs><path fill="#ff4500" stroke-width="0" d="M108 0C48.35 0 0 48.35 0 108c0 29.82 12.09 56.82 31.63 76.37l-20.57 20.57C6.98 209.02 9.87 216 15.64 216H108c59.65 0 108-48.35 108-108S167.65 0 108 0Z"></path><circle cx="169.22" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient)" stroke-width="0"></circle><circle cx="46.78" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient-2)" stroke-width="0"></circle><ellipse cx="108.06" cy="128.64" fill="url(#snoo-radial-gragient-3)" stroke-width="0" rx="72" ry="54"></ellipse><path fill="url(#snoo-radial-gragient-4)" stroke-width="0" d="M86.78 123.48c-.42 9.08-6.49 12.38-13.56 12.38s-12.46-4.93-12.04-14.01c.42-9.08 6.49-15.02 13.56-15.02s12.46 7.58 12.04 16.66Z"></path><path fill="url(#snoo-radial-gragient-5)" stroke-width="0" d="M129.35 123.48c.42 9.08 6.49 12.38 13.56 12.38s12.46-4.93 12.04-14.01c-.42-9.08-6.49-15.02-13.56-15.02s-12.46 7.58-12.04 16.66Z"></path><ellipse cx="79.63" cy="116.37" class="snoo-cls-11 svelte-1977t4s" rx="2.8" ry="3.05"></ellipse><ellipse cx="146.21" cy="116.37" class="snoo-cls-11 svelte-1977t4s" rx="2.8" ry="3.05"></ellipse><path fill="url(#snoo-radial-gragient-6)" stroke-width="0" d="M108.06 142.92c-8.76 0-17.16.43-24.92 1.22-1.33.13-2.17 1.51-1.65 2.74 4.35 10.39 14.61 17.69 26.57 17.69s22.23-7.3 26.57-17.69c.52-1.23-.33-2.61-1.65-2.74-7.77-.79-16.16-1.22-24.92-1.22Z"></path><circle cx="147.49" cy="49.43" r="17.87" fill="url(#snoo-radial-gragient-7)" stroke-width="0"></circle><path fill="url(#snoo-radial-gragient-8)" stroke-width="0" d="M107.8 76.92c-2.14 0-3.87-.89-3.87-2.27 0-16.01 13.03-29.04 29.04-29.04 2.14 0 3.87 1.73 3.87 3.87s-1.73 3.87-3.87 3.87c-11.74 0-21.29 9.55-21.29 21.29 0 1.38-1.73 2.27-3.87 2.27Z"></path><path fill="#842123" stroke-width="0" d="M62.82 122.65c.39-8.56 6.08-14.16 12.69-14.16 6.26 0 11.1 6.39 11.28 14.33.17-8.88-5.13-15.99-12.05-15.99s-13.14 6.05-13.56 15.2c-.42 9.15 4.97 13.83 12.04 13.83h.52c-6.44-.16-11.3-4.79-10.91-13.2Zm90.48 0c-.39-8.56-6.08-14.16-12.69-14.16-6.26 0-11.1 6.39-11.28 14.33-.17-8.88 5.13-15.99 12.05-15.99 7.07 0 13.14 6.05 13.56 15.2.42 9.15-4.97 13.83-12.04 13.83h-.52c6.44-.16 11.3-4.79 10.91-13.2Z"></path></svg>');
function hE(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = uE();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        "xmlns:xlink": "http://www.w3.org/1999/xlink",
        viewBox: "0 0 216 216",
        ..._
    }), void 0, void 0, "svelte-1977t4s"),
    H(x, T)
}
var dE = Pr('<svg><path d="m476-80 182-480h84L924-80h-84l-43-122H603L560-80h-84ZM160-200l-56-56 202-202q-35-35-63.5-80T190-640h84q20 39 40 68t48 58q33-33 68.5-92.5T484-720H40v-80h280v-80h80v80h280v80H564q-21 72-63 148t-83 116l96 98-30 82-122-125-202 201Zm468-72h144l-72-204-72 204Z"></path></svg>');
function pE(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = dE();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        height: "24px",
        viewBox: "0 -960 960 960",
        width: "24px",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var fE = Pr('<svg><path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"></path></svg>');
function mE(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = fE();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var _E = Pr('<svg><path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"></path></svg>');
function gE(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = _E();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var vE = (x, l) => {
    fe(l, !0)
}
  , yE = Be('<span class="tooltip font-flag ml-0.5"> </span>')
  , xE = Be('<div class="mt-1"><!></div>')
  , bE = (x, l, _) => {
    localStorage.setItem(Ax, w(l).key),
    fe(_, w(l).key, !0),
    location.reload()
}
  , wE = Be('<span class="center-absolute loading loading-spinner loading-xs absolute"></span>')
  , TE = Be("<li><button><!> </button></li>")
  , CE = async (x, l) => {
    var _;
    try {
        const T = await ((_ = w(l)) == null ? void 0 : _.prompt());
        (T == null ? void 0 : T.outcome) === "accepted" && fe(l, void 0)
    } catch (T) {
        Zr.error(Vb({
            error: T.message
        }))
    }
}
  , SE = Be('<button class="btn pwa:hidden w-full sm:hidden"><!> </button>')
  , PE = Be('<form class="w-full" method="POST"><button class="btn w-full"><!> Purchases</button></form>')
  , IE = async (x, l, _, T) => {
    var E;
    try {
        fe(l, !0),
        await _.user.logout(),
        T(),
        Zr.warning(GC(), {
            icon: Zv
        }),
        (E = _.onlogout) == null || E.call(_)
    } catch {
        Zr.error(XC())
    } finally {
        fe(l, !1)
    }
}
  , ME = Be('<div class="dropdown"><div tabindex="0" role="button" class="btn size-12 p-0 shadow-md"><!></div> <div class="dropdown-content menu bg-base-100 rounded-box border-base-300 z-1 relative right-1 w-[min(100vw-24px,400px)] translate-y-2 border p-4 shadow-md" tabindex="0"><button class="btn btn-ghost btn-circle absolute right-2 top-2"><!></button> <section class="flex gap-2"><div class="relative"><!> <button class="btn btn-circle btn-sm absolute -bottom-1 -right-1"><!></button></div> <div><div class="flex items-center gap-1.5 pr-8 text-lg font-medium"><h3 class="line-clamp-1 text-ellipsis text-lg"> </h3> <span> </span> <!> <!></div> <div class="flex items-center gap-1"><!> <span> <span class="text-primary font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span class="text-secondary"><span class="font-semibold"> </span> <button class="tooltip"><!></button></span></div></div></section> <section class="mt-3 flex flex-col gap-2"><div class="mb-1 flex items-center justify-between"><h3 class="text-lg font-semibold"> </h3> <div class="flex items-center gap-2"><div class="dropdown dropdown-end"><div tabindex="0" role="button" class="btn btn-sm btn-circle"><!></div> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 w-max rounded-xl p-2 shadow-sm"></ul></div> <div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div></div></div>  <!> <a class="btn w-full" href="https://www.twitch.tv/directory/category/wplace" target="_blank"><!> </a> <a class="btn w-full" href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> Reddit</a> <!> <button class="btn"><!> </button></section></div></div> <!>', 1);
function AE(x, l) {
    Lr(l, !0);
    let _ = mt(!1)
      , T = mt(!1);
    function E() {
        var de;
        (de = document.activeElement) == null || de.blur()
    }
    const F = [{
        label: "ðŸ‡ºðŸ‡¸ English",
        key: "en"
    }, {
        label: "ðŸ‡§ðŸ‡· PortuguÃªs",
        key: "pt"
    }];
    let C = mt("")
      , o = mt(void 0);
    var W = cr()
      , G = Rt(W);
    {
        var re = de => {
            var he = ME()
              , X = Rt(he)
              , le = z(X)
              , Se = z(le);
            Xg(Se, {
                get userId() {
                    return l.user.data.id
                },
                get level() {
                    return l.user.data.level
                },
                get pictureUrl() {
                    return l.user.data.picture
                }
            }),
            k(le);
            var Ie = U(le, 2)
              , De = z(Ie);
            De.__click = E;
            var qe = z(De);
            dc(qe, {
                class: "size-5"
            }),
            k(De);
            var Ne = U(De, 2)
              , Ze = z(Ne)
              , ut = z(Ze);
            ss(ut, {
                get userId() {
                    return l.user.data.id
                },
                get pictureUrl() {
                    return l.user.data.picture
                }
            });
            var rt = U(ut, 2);
            rt.__click = [vE, _];
            var Ue = z(rt);
            Pf(Ue, {
                class: "size-4"
            }),
            k(rt),
            k(Ze);
            var lt = U(Ze, 2)
              , et = z(lt)
              , Ve = z(et)
              , gt = z(Ve, !0);
            k(Ve);
            var dt = U(Ve, 2)
              , ct = z(dt);
            k(dt);
            var ze = U(dt, 2);
            {
                var vt = ke => {
                    const ge = _t( () => as(l.user.data.equippedFlag));
                    var je = yE()
                      , Oe = z(je, !0);
                    k(je),
                    st( () => {
                        jr(je, "data-tip", w(ge).name),
                        Ce(Oe, w(ge).flag)
                    }
                    ),
                    H(ke, je)
                }
                ;
                tt(ze, ke => {
                    l.user.data.equippedFlag && ke(vt)
                }
                )
            }
            var Q = U(ze, 2);
            {
                var ie = ke => {
                    var ge = xE()
                      , je = z(ge);
                    fh(je, {
                        get username() {
                            return l.user.data.discord
                        }
                    }),
                    k(ge),
                    H(ke, ge)
                }
                ;
                tt(Q, ke => {
                    l.user.data.discord && ke(ie)
                }
                )
            }
            k(et);
            var xe = U(et, 2)
              , ue = z(xe);
            mh(ue, {
                class: "inline size-4"
            });
            var Le = U(ue, 2)
              , Re = z(Le)
              , We = U(Re)
              , it = z(We, !0);
            k(We),
            k(Le),
            k(xe);
            var at = U(xe, 2)
              , ht = z(at);
            sE(ht, {
                class: "inline size-4"
            });
            var Ft = U(ht, 2)
              , zt = z(Ft)
              , lr = z(zt);
            k(zt);
            var kt = U(zt)
              , xt = U(kt)
              , Pt = z(xt);
            Hf(Pt, {
                class: "mb-0.5 inline size-4 opacity-50"
            }),
            k(xt),
            k(Ft),
            k(at),
            k(lt),
            k(Ne);
            var jt = U(Ne, 2)
              , Lt = z(jt)
              , nr = z(Lt)
              , xr = z(nr, !0);
            k(nr);
            var er = U(nr, 2)
              , Qt = z(er)
              , $t = z(Qt)
              , tr = z($t);
            pE(tr, {
                class: "size-4"
            }),
            k($t);
            var $r = U($t, 2);
            mn($r, 21, () => F, Jf, (ke, ge) => {
                const je = _t( () => w(C) === w(ge).key);
                var Oe = TE()
                  , Ee = z(Oe);
                let Ke;
                Ee.__click = [bE, ge, C];
                var ye = z(Ee);
                {
                    var It = Bt => {
                        var Ut = wE();
                        H(Bt, Ut)
                    }
                    ;
                    tt(ye, Bt => {
                        w(je) && Bt(It)
                    }
                    )
                }
                var Kt = U(ye);
                k(Ee),
                k(Oe),
                st(Bt => {
                    Ke = Vr(Ee, 1, "font-flag relative font-medium", null, Ke, Bt),
                    Ce(Kt, ` ${w(ge).label ?? ""}`)
                }
                , [ () => ({
                    "bg-base-200": w(je)
                })]),
                H(ke, Oe)
            }
            ),
            k($r),
            k(Qt);
            var zr = U(Qt, 2)
              , Mr = z(zr);
            Mr.__click = () => {
                aa.muted = !aa.muted
            }
            ;
            var sr = z(Mr);
            {
                var Xt = ke => {
                    mE(ke, {
                        class: "size-4"
                    })
                }
                  , Ir = ke => {
                    gE(ke, {
                        class: "size-4"
                    })
                }
                ;
                tt(sr, ke => {
                    aa.muted ? ke(Xt) : ke(Ir, !1)
                }
                )
            }
            k(Mr),
            k(zr),
            k(er),
            k(Lt);
            var mr = U(Lt, 2);
            {
                var vr = ke => {
                    var ge = SE();
                    ge.__click = [CE, o];
                    var je = z(ge);
                    mv(je, {
                        class: "size-5"
                    });
                    var Oe = U(je);
                    k(ge),
                    st(Ee => Ce(Oe, ` ${Ee ?? ""}`), [ () => Ub()]),
                    H(ke, ge)
                }
                ;
                tt(mr, ke => {
                    w(o) && ke(vr)
                }
                )
            }
            var br = U(mr, 2)
              , _r = z(br);
            Jg(_r, {
                class: "size-5"
            });
            var Ar = U(_r);
            k(br);
            var Tr = U(br, 2)
              , be = z(Tr);
            hE(be, {
                class: "size-5"
            }),
            di(),
            k(Tr);
            var q = U(Tr, 2);
            {
                var V = ke => {
                    var ge = PE()
                      , je = z(ge)
                      , Oe = z(je);
                    cE(Oe, {
                        class: "size-5"
                    }),
                    di(),
                    k(je),
                    k(ge),
                    st( () => jr(ge, "action", `${dx}/payment/create-portal-session`)),
                    H(ke, ge)
                }
                ;
                tt(q, ke => {
                    var ge;
                    (ge = l.user.data) != null && ge.isCustomer && ke(V)
                }
                )
            }
            var K = U(q, 2);
            K.__click = [IE, T, l, E];
            var ae = z(K);
            Zv(ae, {
                class: "size-5"
            });
            var we = U(ae);
            k(K),
            k(jt),
            k(Ie),
            k(X);
            var Me = U(X, 2);
            nE(Me, {
                get userData() {
                    return l.user.data
                },
                get open() {
                    return w(_)
                },
                set open(ke) {
                    fe(_, ke, !0)
                }
            }),
            st( (ke, ge, je, Oe, Ee, Ke, ye, It, Kt, Bt, Ut) => {
                jr(le, "title", ke),
                jr(Ve, "title", l.user.data.name),
                Ce(gt, l.user.data.name),
                Vr(dt, 1, ge),
                Ce(ct, `#${l.user.data.id ?? ""}`),
                Ce(Re, `${je ?? ""}: `),
                Ce(it, Oe),
                Ce(lr, `Level ${Ee ?? ""}`),
                Ce(kt, ` (${Ke ?? ""}%) `),
                jr(xt, "data-tip", ye),
                Ce(xr, It),
                jr(zr, "data-tip", Kt),
                Ce(Ar, ` ${Bt ?? ""}`),
                K.disabled = w(T),
                Ce(we, ` ${Ut ?? ""}`)
            }
            , [ () => Db(), () => Kl(Xn(l.user.data.id)), () => im(), () => l.user.data.pixelsPainted.toLocaleString("en-US"), () => Math.floor(l.user.data.level), () => Math.floor(l.user.data.level % 1 * 100), () => l5(), () => Nb(), () => aa.muted ? nC() : tC(), () => Wb(), () => Yb()]),
            _n("focus", le, () => {
                fe(o, window.pwaInstallPrompt, !0)
            }
            ),
            H(de, he)
        }
        ;
        tt(G, de => {
            l.user.data && l.user.charges !== void 0 && de(re)
        }
        )
    }
    H(x, W),
    Dr()
}
Xi(["click"]);
var kE = Pr('<svg><path d="M100-240v-480l360 240-360 240Zm400 0v-480l360 240-360 240ZM180-480Zm400 0Zm-400 90 136-90-136-90v180Zm400 0 136-90-136-90v180Z"></path></svg>');
function EE(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = kE();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        height: "24px",
        viewBox: "0 -960 960 960",
        width: "24px",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var zE = Pr('<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q146 0 255.5 91.5T872-559h-82q-19-73-68.5-130.5T600-776v16q0 33-23.5 56.5T520-680h-80v80q0 17-11.5 28.5T400-560h-80v80h80v120h-40L168-552q-3 18-5.5 36t-2.5 36q0 131 92 225t228 95v80Zm364-20L716-228q-21 12-45 20t-51 8q-75 0-127.5-52.5T440-380q0-75 52.5-127.5T620-560q75 0 127.5 52.5T800-380q0 27-8 51t-20 45l128 128-56 56ZM620-280q42 0 71-29t29-71q0-42-29-71t-71-29q-42 0-71 29t-29 71q0 42 29 71t71 29Z"></path></svg>');
function LE(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = zE();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var DE = async (x, l, _, T, E, F) => {
    if (w(l)) {
        _.map.easeTo(w(l)),
        fe(l, void 0);
        return
    }
    fe(T, !0);
    try {
        Va(_.map.getCenter(), _.map.getZoom());
        const C = new cc(w(E))
          , {tile: o, pixel: W} = await ri.getRandomTile(_.season)
          , G = o.x * w(E) + W.x
          , re = o.y * w(E) + W.y
          , [de,he] = C.pixelsToLatLon(G, re, w(F))
          , X = {
            lat: de,
            lng: he
        }
          , le = w(F) + 2;
        fe(l, {
            zoom: le,
            center: X
        }, !0),
        _.map.flyTo(w(l)),
        Jo.isEmpty() && Jo.push({
            pos: _.map.getCenter(),
            zoom: _.map.getZoom()
        }),
        setTimeout( () => {
            fe(l, void 0)
        }
        , 2500),
        Jo.push({
            pos: X,
            zoom: le
        })
    } catch (C) {
        Zr.error(C.message)
    } finally {
        fe(T, !1)
    }
}
  , RE = Be('<button class="btn btn-square shadow-md"><!></button>');
function BE(x, l) {
    Lr(l, !0);
    const _ = _t( () => Bn.seasons[l.season].tileSize)
      , T = _t( () => Bn.seasons[l.season].zoom);
    let E = mt(!1)
      , F = mt(void 0);
    var C = RE();
    C.__click = [DE, F, l, E, _, T];
    var o = z(C);
    {
        var W = re => {
            LE(re, {
                class: "size-5"
            })
        }
          , G = re => {
            EE(re, {
                class: "size-5"
            })
        }
        ;
        tt(o, re => {
            w(F) ? re(G, !1) : re(W)
        }
        )
    }
    k(C),
    st(re => {
        jr(C, "title", re),
        C.disabled = w(E)
    }
    , [ () => lb()]),
    H(x, C),
    Dr()
}
Xi(["click"]);
var FE = Be('<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>')
  , OE = Be('<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>')
  , NE = Be('<span class="font-flag tooltip ml-0.5"> </span>')
  , jE = Be("<span> </span>")
  , qE = Be('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>')
  , VE = Be('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>')
  , ZE = Be('<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>')
  , $E = Be('<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>')
  , UE = Be('<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>')
  , GE = Be('<div class="tabs tabs-box"></div> <div class="my-4 flex items-center justify-between"><!></div> <!>', 1);
function HE(x, l) {
    Lr(l, !0);
    const _ = [];
    let T = mt("today")
      , E = {
        players: {
            label: lv(),
            icon: Gd
        },
        alliances: {
            label: cv(),
            icon: Hd
        }
    }
      , F = mt("players")
      , C = Mn({
        players: {},
        alliances: {}
    });
    const o = _t( () => C[w(F)][w(T)]);
    Gr( () => {
        if (w(o))
            return;
        const Se = w(T)
          , Ie = w(F);
        Ie === "players" ? ri.leaderboardRegionPlayers(l.regionId, Se).then(De => {
            C[Ie][Se] = De
        }
        ).catch(De => {
            Zr.error(De.message)
        }
        ) : Ie === "alliances" && ri.leaderboardRegionAlliances(l.regionId, Se).then(De => {
            C[Ie][Se] = De
        }
        ).catch(De => {
            Zr.error(De.message)
        }
        )
    }
    );
    var W = GE()
      , G = Rt(W);
    mn(G, 21, () => Object.entries(E), ([Se,{label: Ie, icon: De}]) => Se, (Se, Ie) => {
        var De = _t( () => Vg(w(Ie), 2));
        let qe = () => w(De)[0]
          , Ne = () => w(De)[1].label
          , Ze = () => w(De)[1].icon;
        const ut = _t(Ze);
        var rt = FE()
          , Ue = z(rt);
        Ea(Ue);
        var lt, et = U(Ue, 2);
        an(et, () => w(ut), (gt, dt) => {
            dt(gt, {
                get this() {
                    return Ze()
                },
                class: "mr-1 size-5 max-sm:hidden"
            })
        }
        );
        var Ve = U(et);
        k(rt),
        st( () => {
            jr(Ue, "aria-label", Ne()),
            lt !== (lt = qe()) && (Ue.value = (Ue.__value = qe()) ?? ""),
            Ce(Ve, ` ${Ne() ?? ""}`)
        }
        ),
        em(_, [], Ue, () => (qe(),
        w(F)), gt => fe(F, gt)),
        H(Se, rt)
    }
    ),
    k(G);
    var re = U(G, 2)
      , de = z(re);
    hm(de, {
        get value() {
            return w(T)
        },
        set value(Se) {
            fe(T, Se, !0)
        }
    }),
    k(re);
    var he = U(re, 2);
    {
        var X = Se => {
            var Ie = OE()
              , De = z(Ie)
              , qe = U(De);
            {
                var Ne = ut => {
                    var rt = wa();
                    st(Ue => Ce(rt, Ue), [ () => Ud().toLowerCase()]),
                    H(ut, rt)
                }
                  , Ze = ut => {
                    var rt = cr()
                      , Ue = Rt(rt);
                    {
                        var lt = Ve => {
                            var gt = wa();
                            st(dt => Ce(gt, dt), [ () => am()]),
                            H(Ve, gt)
                        }
                          , et = Ve => {
                            var gt = cr()
                              , dt = Rt(gt);
                            {
                                var ct = ze => {
                                    var vt = wa();
                                    st(Q => Ce(vt, Q), [ () => sm()]),
                                    H(ze, vt)
                                }
                                ;
                                tt(dt, ze => {
                                    w(T) === "month" && ze(ct)
                                }
                                , !0)
                            }
                            H(Ve, gt)
                        }
                        ;
                        tt(Ue, Ve => {
                            w(T) === "week" ? Ve(lt) : Ve(et, !1)
                        }
                        , !0)
                    }
                    H(ut, rt)
                }
                ;
                tt(qe, ut => {
                    w(T) === "today" ? ut(Ne) : ut(Ze, !1)
                }
                )
            }
            k(Ie),
            st(ut => Ce(De, `${ut ?? ""} `), [ () => nm()]),
            H(Se, Ie)
        }
          , le = Se => {
            var Ie = cr()
              , De = Rt(Ie);
            {
                var qe = Ze => {
                    var ut = cr()
                      , rt = Rt(ut);
                    {
                        var Ue = et => {
                            const Ve = _t( () => w(o));
                            var gt = VE()
                              , dt = z(gt)
                              , ct = z(dt)
                              , ze = U(z(ct))
                              , vt = z(ze, !0);
                            k(ze);
                            var Q = U(ze)
                              , ie = z(Q)
                              , xe = U(ie, 2, !0);
                            k(Q),
                            k(ct),
                            k(dt);
                            var ue = U(dt);
                            mn(ue, 31, () => w(Ve), Le => Le.id, (Le, Re, We) => {
                                const it = _t( () => {
                                    var Xt;
                                    return ((Xt = Vt.data) == null ? void 0 : Xt.id) === w(Re).id
                                }
                                );
                                var at = qE();
                                let ht;
                                var Ft = z(at)
                                  , zt = z(Ft, !0);
                                k(Ft);
                                var lr = U(Ft)
                                  , kt = z(lr)
                                  , xt = z(kt);
                                ss(xt, {
                                    class: "size-10 border",
                                    get userId() {
                                        return w(Re).id
                                    },
                                    get pictureUrl() {
                                        return w(Re).picture
                                    }
                                });
                                var Pt = U(xt, 2)
                                  , jt = z(Pt)
                                  , Lt = z(jt)
                                  , nr = U(Lt)
                                  , xr = z(nr);
                                k(nr),
                                k(jt);
                                var er = U(jt, 2);
                                {
                                    var Qt = Xt => {
                                        const Ir = _t( () => as(w(Re).equippedFlag));
                                        var mr = NE()
                                          , vr = z(mr, !0);
                                        k(mr),
                                        st( () => {
                                            jr(mr, "data-tip", w(Ir).name),
                                            Ce(vr, w(Ir).flag)
                                        }
                                        ),
                                        H(Xt, mr)
                                    }
                                    ;
                                    tt(er, Xt => {
                                        "equippedFlag"in w(Re) && w(Re).equippedFlag && Xt(Qt)
                                    }
                                    )
                                }
                                var $t = U(er, 2);
                                {
                                    var tr = Xt => {
                                        fh(Xt, {
                                            get username() {
                                                return w(Re).discord
                                            }
                                        })
                                    }
                                    ;
                                    tt($t, Xt => {
                                        w(Re).discord && Xt(tr)
                                    }
                                    )
                                }
                                var $r = U($t, 2);
                                {
                                    var zr = Xt => {
                                        var Ir = jE()
                                          , mr = z(Ir, !0);
                                        k(Ir),
                                        st( (vr, br) => {
                                            Vr(Ir, 1, `badge badge-sm ml-0.5 border-0 ${vr ?? ""} ${br ?? ""}`),
                                            Ce(mr, w(Re).allianceName)
                                        }
                                        , [ () => tm(w(Re).allianceId), () => Xn(w(Re).allianceId)]),
                                        H(Xt, Ir)
                                    }
                                    ;
                                    tt($r, Xt => {
                                        "allianceName"in w(Re) && w(Re).allianceName && Xt(zr)
                                    }
                                    )
                                }
                                k(Pt),
                                k(kt),
                                k(lr);
                                var Mr = U(lr)
                                  , sr = z(Mr, !0);
                                k(Mr),
                                k(at),
                                st( (Xt, Ir, mr) => {
                                    ht = Vr(at, 1, "", null, ht, Xt),
                                    Ce(zt, w(We) + 1),
                                    Vr(jt, 1, `font-semibold max-sm:ml-2 ${Ir ?? ""}`),
                                    Ce(Lt, `${w(Re).name ?? ""} `),
                                    Ce(xr, `#${w(Re).id ?? ""}`),
                                    Ce(sr, mr)
                                }
                                , [ () => ({
                                    "bg-base-200": w(it)
                                }), () => Xn(w(Re).id), () => w(Re).pixelsPainted.toLocaleString("en-US")]),
                                Ko(at, () => Yo, () => ({
                                    duration: 200
                                })),
                                H(Le, at)
                            }
                            ),
                            k(ue),
                            k(gt),
                            st( (Le, Re, We) => {
                                Ce(vt, Le),
                                Ce(ie, `${Re ?? ""} `),
                                Ce(xe, We)
                            }
                            , [ () => om(), () => Yl(), () => Jl().toLowerCase()]),
                            H(et, gt)
                        }
                          , lt = et => {
                            var Ve = cr()
                              , gt = Rt(Ve);
                            {
                                var dt = ct => {
                                    var ze = $E()
                                      , vt = z(ze)
                                      , Q = z(vt)
                                      , ie = U(z(Q))
                                      , xe = z(ie, !0);
                                    k(ie);
                                    var ue = U(ie)
                                      , Le = z(ue)
                                      , Re = U(Le, 2, !0);
                                    k(ue),
                                    k(Q),
                                    k(vt);
                                    var We = U(vt);
                                    mn(We, 31, () => w(o), it => it.id, (it, at, ht) => {
                                        const Ft = _t( () => {
                                            var er;
                                            return ((er = Vt.data) == null ? void 0 : er.allianceId) === w(at).id
                                        }
                                        );
                                        var zt = ZE();
                                        let lr;
                                        var kt = z(zt)
                                          , xt = z(kt, !0);
                                        k(kt);
                                        var Pt = U(kt)
                                          , jt = z(Pt)
                                          , Lt = z(jt, !0);
                                        k(jt),
                                        k(Pt);
                                        var nr = U(Pt)
                                          , xr = z(nr, !0);
                                        k(nr),
                                        k(zt),
                                        st( (er, Qt, $t) => {
                                            lr = Vr(zt, 1, "", null, lr, er),
                                            Ce(xt, w(ht) + 1),
                                            Vr(jt, 1, `font-semibold ${Qt ?? ""}`),
                                            Ce(Lt, w(at).name),
                                            Ce(xr, $t)
                                        }
                                        , [ () => ({
                                            "bg-base-200": w(Ft)
                                        }), () => Xn(w(at).id), () => w(at).pixelsPainted.toLocaleString("en-US")]),
                                        Ko(zt, () => Yo, () => ({
                                            duration: 200
                                        })),
                                        H(it, zt)
                                    }
                                    ),
                                    k(We),
                                    k(ze),
                                    st( (it, at, ht) => {
                                        Ce(xe, it),
                                        Ce(Le, `${at ?? ""} `),
                                        Ce(Re, ht)
                                    }
                                    , [ () => Zd(), () => Yl(), () => Jl().toLowerCase()]),
                                    H(ct, ze)
                                }
                                ;
                                tt(gt, ct => {
                                    w(F) === "alliances" && ct(dt)
                                }
                                , !0)
                            }
                            H(et, Ve)
                        }
                        ;
                        tt(rt, et => {
                            w(F) === "players" ? et(Ue) : et(lt, !1)
                        }
                        )
                    }
                    H(Ze, ut)
                }
                  , Ne = Ze => {
                    var ut = UE();
                    H(Ze, ut)
                }
                ;
                tt(De, Ze => {
                    w(o) ? Ze(qe) : Ze(Ne, !1)
                }
                , !0)
            }
            H(Se, Ie)
        }
        ;
        tt(he, Se => {
            w(o) && w(o).length === 0 ? Se(X) : Se(le, !1)
        }
        )
    }
    H(x, W),
    Dr()
}
var WE = Be('<div class="mt-5"><!></div>')
  , XE = Be('<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">âœ•</button></form> <h2><span class="font-flag tooltip"> </span> <span> </span> <span> </span></h2> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>');
function KE(x, l) {
    Lr(l, !0);
    let _ = At(l, "open", 15);
    const T = _t( () => as(l.region.countryId));
    wi( () => {
        const Se = Ie => {
            Ie.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", Se),
        () => document.removeEventListener("keydown", Se)
    }
    );
    var E = XE()
      , F = z(E)
      , C = U(z(F), 2)
      , o = z(C)
      , W = z(o, !0);
    k(o);
    var G = U(o, 2)
      , re = z(G, !0);
    k(G);
    var de = U(G, 2)
      , he = z(de);
    k(de),
    k(C);
    var X = U(C, 2);
    {
        var le = Se => {
            var Ie = WE()
              , De = z(Ie);
            HE(De, {
                get regionId() {
                    return l.region.id
                }
            }),
            k(Ie),
            Cn(2, Ie, () => Wn, () => ({
                duration: 300
            })),
            H(Se, Ie)
        }
        ;
        tt(X, Se => {
            _() && Se(le)
        }
        )
    }
    k(F),
    di(2),
    k(E),
    Fn(E, () => Se => {
        Gr( () => {
            _() ? Se.show() : Se.close()
        }
        )
    }
    ),
    st(Se => {
        Vr(C, 1, `flex gap-2 text-xl font-bold sm:text-2xl ${Se ?? ""}`),
        jr(o, "data-tip", w(T).name),
        Ce(W, w(T).flag),
        Ce(re, l.region.name),
        Ce(he, `#${l.region.number ?? ""}`)
    }
    , [ () => Xn(l.region.cityId)]),
    _n("close", E, () => _(!1)),
    H(x, E),
    Dr()
}
var YE = Pr('<svg><path d="M791-55 686-160H160v-112q0-34 17.5-62.5T224-378q45-23 91.5-37t94.5-21L55-791l57-57 736 736-57 57ZM240-240h366L486-360h-6q-56 0-111 13.5T260-306q-9 5-14.5 14t-5.5 20v32Zm496-138q29 14 46 42.5t18 61.5L666-408q18 7 35.5 14t34.5 16ZM568-506l-59-59q23-9 37-29.5t14-45.5q0-33-23.5-56.5T480-720q-25 0-45.5 14T405-669l-59-59q23-34 58-53t76-19q66 0 113 47t47 113q0 41-19 76t-53 58Zm38 266H240h366ZM457-617Z"></path></svg>');
function JE(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = YE();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        height: "24px",
        viewBox: "0 -960 960 960",
        width: "24px",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var QE = Pr('<svg><path d="m233-120 65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Z"></path></svg>')
  , e8 = Pr('<svg><path d="m354-287 126-76 126 77-33-144 111-96-146-13-58-136-58 135-146 13 111 97-33 143ZM233-120l65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Zm247-350Z"></path></svg>');
function t8(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
    var T = cr()
      , E = Rt(T);
    {
        var F = o => {
            var W = QE();
            Yt(W, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, W)
        }
          , C = o => {
            var W = e8();
            Yt(W, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, W)
        }
        ;
        tt(E, o => {
            l.filled ? o(F) : o(C, !1)
        }
        )
    }
    H(x, T)
}
var r8 = (x, l, _, T, E) => {
    if (w(l) && w(_)) {
        const F = w(l) - w(_).clientHeight
          , C = w(l) / 2 - F / 2;
        T.map.flyTo({
            center: {
                lat: w(E).center[0],
                lng: w(E).center[1]
            },
            zoom: 17.5,
            offset: [0, -C]
        })
    }
}
  , i8 = (x, l, _) => l.onclickregion(w(_))
  , n8 = Be('<button><span class="font-flag tooltip"> </span> <span class="line-clamp-1 text-ellipsis"> </span> <span> </span></button>')
  , a8 = Be('<div class="skeleton h-5 w-16"></div>')
  , s8 = Be('<div class="skeleton mt-1 h-5 w-32"></div>')
  , o8 = Be('<span class="font-flag tooltip ml-0.5"> </span>')
  , l8 = async (x, l, _, T, E, F) => {
    fe(l, !0);
    try {
        await ri.banAllianceUser(w(_).id),
        await T({
            ...w(E),
            season: F.season
        })
    } catch (C) {
        Zr.error(C.message)
    } finally {
        fe(l, !1)
    }
}
  , c8 = Be('<div class="dropdown dropdown-top max-sm:dropdown-top max-sm:dropdown-left"><button tabindex="0" class="btn btn-xs btn-circle"><!></button> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 mb-1 w-max rounded-xl p-2 shadow-sm"><li><button class="text-error"><!> </button></li></ul></div>')
  , u8 = Be("<span> </span> <!>", 1)
  , h8 = Be('<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><!></div> <span> <span class="ml-0.5"> </span></span> <!> <!> <!></div>')
  , d8 = (x, l) => l.onclickpaint(l.latLon)
  , p8 = async (x, l, _, T) => {
    try {
        fe(l, !0),
        w(_) ? (await ri.deleteFavoriteLocation(w(_).id),
        Zr.warning(EC())) : (await ri.favoriteLocation(w(T).center),
        Zr.success(DC())),
        ua.smallPlop.play(),
        Vt.refresh()
    } catch (E) {
        Zr.error(E.message)
    } finally {
        fe(l, !1)
    }
}
  , f8 = Be("<button><!> </button>")
  , m8 = (x, l, _) => l.onclickshare(sP(Za.url, {
    pos: {
        lat: w(_).center[0],
        lng: w(_).center[1]
    },
    zoom: l.zoom
}))
  , _8 = Be('<div><div class="flex gap-2 px-3"><div class="flex grow gap-1"><button class="btn btn-sm btn-circle btn-soft"><!></button> <h2 class="mt-0.5 flex items-center gap-2 text-lg"><span class="whitespace-nowrap"> </span> <!></h2></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="text-base-content/80 mt-1 px-3 text-sm"><!></div> <div class="hide-scrollbar flex max-w-full gap-1.5 overflow-x-auto px-3 pb-2 pt-3 sm:pb-3"><button class="btn btn-primary"><!> </button> <!> <button class="btn btn-primary btn-soft"><!> </button></div></div>');
function g8(x, l) {
    Lr(l, !0);
    let _ = mt(void 0);
    const T = _t( () => new cc(l.tileSize));
    let E = mt(void 0)
      , F = mt(void 0)
      , C = mt(!1)
      , o = mt(!1);
    const W = _t( () => {
        const [at,ht] = l.latLon ?? [0, 0]
          , Ft = w(T).latLonToPixelBoundsLatLon(at, ht, l.pixelArtZoom)
          , zt = cm(Ft)
          , {tile: lr, pixel: kt} = w(T).latLonToTileAndPixel(at, ht, l.pixelArtZoom)
          , xt = w(T).latLonToRegionAndPixel(at, ht, l.pixelArtZoom);
        return {
            bounds: Ft,
            center: zt,
            tile: lr,
            pixel: kt,
            regionPixel: xt.pixel
        }
    }
    );
    Gr( () => {
        ua.plop.play(),
        l.crosshair.clearAndPlace(l.latLon)
    }
    );
    let G = 0;
    const re = ({pixel: at, tile: ht, season: Ft}) => `s${Ft}:p(${at[0]},${at[1]}):t(${ht[0]},${ht[1]})`;
    let de;
    uc( () => [w(W), l.season], () => {
        const at = {
            ...w(W),
            season: l.season
        }
          , ht = re(at);
        if (fe(_, l.pixelInfoCache.get(ht), !0),
        w(_) !== void 0)
            return;
        l.pixelInfoCache.size === 0 && (G = 0),
        G++,
        G > 6 ? (clearTimeout(de),
        de = setTimeout(async () => he(at), 500)) : he(at)
    }
    );
    async function he(at) {
        const ht = await ri.getPixelInfo(at);
        if (ht.paintedBy !== void 0) {
            const zt = re(at);
            l.pixelInfoCache.set(zt, ht)
        }
        const Ft = re({
            ...w(W),
            season: l.season
        });
        return fe(_, l.pixelInfoCache.get(Ft), !0),
        ht
    }
    function X() {
        l.crosshair.clear(),
        ua.smallPlop.play(),
        l.onclose()
    }
    wi( () => {
        const at = ht => {
            ht.key === "Escape" && X()
        }
        ;
        return document.addEventListener("keydown", at),
        () => document.removeEventListener("keydown", at)
    }
    );
    var le = _8()
      , Se = z(le)
      , Ie = z(Se)
      , De = z(Ie);
    De.__click = [r8, E, F, l, W];
    var qe = z(De);
    dm(qe, {
        class: "fill-primary size-5"
    }),
    k(De);
    var Ne = U(De, 2)
      , Ze = z(Ne)
      , ut = z(Ze);
    k(Ze);
    var rt = U(Ze, 2);
    {
        var Ue = at => {
            const ht = _t( () => w(_).region)
              , Ft = _t( () => as(w(ht).countryId));
            var zt = n8();
            zt.__click = [i8, l, ht];
            var lr = z(zt)
              , kt = z(lr, !0);
            k(lr);
            var xt = U(lr, 2)
              , Pt = z(xt, !0);
            k(xt);
            var jt = U(xt, 2)
              , Lt = z(jt);
            k(jt),
            k(zt),
            st(nr => {
                Vr(zt, 1, `btn btn-xs flex gap-1 py-3 text-sm max-sm:max-w-32 ${nr ?? ""}`),
                jr(lr, "data-tip", w(Ft).name),
                Ce(kt, w(Ft).flag),
                Ce(Pt, w(ht).name),
                Ce(Lt, `#${w(ht).number ?? ""}`)
            }
            , [ () => Xn(w(ht).cityId)]),
            H(at, zt)
        }
          , lt = at => {
            var ht = a8();
            H(at, ht)
        }
        ;
        tt(rt, at => {
            var ht;
            (ht = w(_)) != null && ht.region ? at(Ue) : at(lt, !1)
        }
        )
    }
    k(Ne),
    k(Ie);
    var et = U(Ie, 2);
    et.__click = X;
    var Ve = z(et);
    dc(Ve, {
        class: "size-4"
    }),
    k(et),
    k(Se);
    var gt = U(Se, 2)
      , dt = z(gt);
    {
        var ct = at => {
            var ht = s8();
            H(at, ht)
        }
          , ze = at => {
            var ht = cr()
              , Ft = Rt(ht);
            {
                var zt = kt => {
                    var xt = wa();
                    st(Pt => Ce(xt, Pt), [ () => F3()]),
                    H(kt, xt)
                }
                  , lr = kt => {
                    const xt = _t( () => w(_).paintedBy);
                    var Pt = h8()
                      , jt = z(Pt)
                      , Lt = z(jt);
                    k(jt);
                    var nr = U(jt, 2)
                      , xr = z(nr);
                    ss(xr, {
                        class: "size-5 border-0",
                        get userId() {
                            return w(xt).id
                        },
                        get pictureUrl() {
                            return w(xt).picture
                        }
                    }),
                    k(nr);
                    var er = U(nr, 2)
                      , Qt = z(er)
                      , $t = U(Qt)
                      , tr = z($t);
                    k($t),
                    k(er);
                    var $r = U(er, 2);
                    {
                        var zr = mr => {
                            const vr = _t( () => as(w(xt).equippedFlag));
                            var br = o8()
                              , _r = z(br, !0);
                            k(br),
                            st( () => {
                                jr(br, "data-tip", w(vr).name),
                                Ce(_r, w(vr).flag)
                            }
                            ),
                            H(mr, br)
                        }
                        ;
                        tt($r, mr => {
                            w(xt).equippedFlag && mr(zr)
                        }
                        )
                    }
                    var Mr = U($r, 2);
                    {
                        var sr = mr => {
                            fh(mr, {
                                get username() {
                                    return w(xt).discord
                                }
                            })
                        }
                        ;
                        tt(Mr, mr => {
                            w(xt).discord && mr(sr)
                        }
                        )
                    }
                    var Xt = U(Mr, 2);
                    {
                        var Ir = mr => {
                            var vr = u8()
                              , br = Rt(vr)
                              , _r = z(br, !0);
                            k(br);
                            var Ar = U(br, 2);
                            {
                                var Tr = be => {
                                    var q = c8()
                                      , V = z(q)
                                      , K = z(V);
                                    pm(K, {
                                        class: "size-4"
                                    }),
                                    k(V);
                                    var ae = U(V, 2)
                                      , we = z(ae)
                                      , Me = z(we);
                                    Me.__click = [l8, o, xt, he, W, l];
                                    var ke = z(Me);
                                    JE(ke, {
                                        class: "size-5"
                                    });
                                    var ge = U(ke);
                                    k(Me),
                                    k(we),
                                    k(ae),
                                    k(q),
                                    st(je => Ce(ge, ` ${je ?? ""}`), [ () => ov()]),
                                    H(be, q)
                                }
                                ;
                                tt(Ar, be => {
                                    var q;
                                    w(xt).allianceId === ((q = Vt.data) == null ? void 0 : q.allianceId) && Vt.data.allianceRole === "admin" && Vt.data.id !== w(xt).id && be(Tr)
                                }
                                )
                            }
                            st( (be, q) => {
                                Vr(br, 1, `badge badge-sm ml-0.5 border-0 ${be ?? ""} ${q ?? ""}`),
                                Ce(_r, w(xt).allianceName)
                            }
                            , [ () => tm(w(xt).allianceId), () => Xn(w(xt).allianceId)]),
                            H(mr, vr)
                        }
                        ;
                        tt(Xt, mr => {
                            w(xt).allianceName && mr(Ir)
                        }
                        )
                    }
                    k(Pt),
                    st( (mr, vr) => {
                        var br;
                        Ce(Lt, `${mr ?? ""}:`),
                        Vr(er, 1, `font-medium ${vr ?? ""}`),
                        Ce(Qt, `${(((br = Vt.data) == null ? void 0 : br.id) === w(xt).id ? Vt.data.name : w(xt).name) ?? ""} `),
                        Ce(tr, `#${w(xt).id ?? ""}`)
                    }
                    , [ () => j3(), () => Xn(w(xt).id)]),
                    H(kt, Pt)
                }
                ;
                tt(Ft, kt => {
                    w(_).paintedBy.id === 0 ? kt(zt) : kt(lr, !1)
                }
                , !0)
            }
            H(at, ht)
        }
        ;
        tt(dt, at => {
            w(_) === void 0 ? at(ct) : at(ze, !1)
        }
        )
    }
    k(gt);
    var vt = U(gt, 2)
      , Q = z(vt);
    Q.__click = [d8, l];
    var ie = z(Q);
    mh(ie, {
        class: "size-4.5"
    });
    var xe = U(ie);
    k(Q);
    var ue = U(Q, 2);
    {
        var Le = at => {
            const ht = _t( () => Vt.data.favoriteLocations.find(Pt => Math.abs(Pt.latitude - w(W).center[0]) < 5e-5 && Math.abs(Pt.longitude - w(W).center[1]) < 5e-5))
              , Ft = _t( () => !w(ht) && Vt.data.favoriteLocations.length >= Vt.data.maxFavoriteLocations);
            var zt = f8();
            let lr;
            zt.__click = [p8, C, ht, W];
            var kt = z(zt);
            {
                let Pt = _t( () => !!w(ht));
                t8(kt, {
                    class: "size-4.5",
                    get filled() {
                        return w(Pt)
                    }
                })
            }
            var xt = U(kt);
            k(zt),
            st( (Pt, jt) => {
                lr = Vr(zt, 1, "btn btn-primary btn-soft", null, lr, Pt),
                zt.disabled = w(C) || w(Ft),
                Ce(xt, ` ${jt ?? ""}`)
            }
            , [ () => ({
                "text-yellow-400": !!w(ht)
            }), () => w(Ft) ? Z3() : G3()]),
            H(at, zt)
        }
        ;
        tt(ue, at => {
            Vt.data && at(Le)
        }
        )
    }
    var Re = U(ue, 2);
    Re.__click = [m8, l, W];
    var We = z(Re);
    _v(We, {
        class: "size-4.5"
    });
    var it = U(We);
    k(Re),
    k(vt),
    k(le),
    Ss(le, at => fe(F, at), () => w(F)),
    st( (at, ht) => {
        Ce(ut, `Pixel: ${w(W).regionPixel[0] ?? ""}, ${w(W).regionPixel[1] ?? ""}`),
        Q.disabled = Vt.loading,
        Ce(xe, ` ${at ?? ""}`),
        Ce(it, ` ${ht ?? ""}`)
    }
    , [ () => iv(), () => X3()]),
    Vd("innerHeight", at => fe(E, at, !0)),
    H(x, le),
    Dr()
}
Xi(["click"]);
function v8(x) {
    var T;
    const l = document.createElement("div");
    (T = x.parentElement) == null || T.insertBefore(l, x.nextSibling);
    const _ = new IntersectionObserver(E => {
        E[0].isIntersecting ? x.classList.remove("stuck") : x.classList.add("stuck")
    }
    ,{
        threshold: 0,
        rootMargin: "0px"
    });
    return _.observe(l),
    () => {
        l.remove(),
        _.disconnect()
    }
}
var y8 = Pr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Z"></path></svg>')
  , x8 = Pr('<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Zm300-440Zm86 160h134v-240H510l-16-80H280v240h290l16 80Z"></path></svg>');
function b8(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy", "filled"]);
    var T = cr()
      , E = Rt(T);
    {
        var F = o => {
            var W = y8();
            Yt(W, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, W)
        }
          , C = o => {
            var W = x8();
            Yt(W, () => ({
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 -960 960 960",
                fill: "currentColor",
                ..._
            })),
            H(o, W)
        }
        ;
        tt(E, o => {
            l.filled ? o(F) : o(C, !1)
        }
        )
    }
    H(x, T)
}
var w8 = Be('<span class="loading loading-spinner center-absolute absolute"></span>')
  , T8 = Be('<button class="btn btn-lg sm:btn-md btn-primary relative h-10"><!> <!> <span class="text-sm">Droplets</span></button>')
  , C8 = Be('<span class="loading loading-spinner center-absolute absolute"></span>')
  , S8 = Be('<!> <span class="text-sm"> </span>', 1)
  , P8 = Be('<span class="text-sm"> </span>')
  , I8 = Be('<button><div class="tooltip-content max-w-54 p-2"> </div> <!> <!></button>')
  , M8 = Be('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="font-flag flex grow items-center justify-center p-1 text-7xl"> </div> <p class="mt-2 text-center text-xl font-bold"> </p> <!> <div><!></div></div>')
  , A8 = (x, l) => {
    fe(l, !w(l))
}
  , k8 = Be('<div><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium">Flags</h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="grid-cols mt-3 grid gap-3 sm:grid-cols-2 lg:grid-cols-4"></div> <div class="mt-4 flex justify-center"><button class="btn btn-lg"> </button></div></div>');
function E8(x, l) {
    Lr(l, !0);
    const _ = (Ne, Ze=Sn) => {
        const ut = _t( () => {
            var ue;
            return (((ue = Vt.data) == null ? void 0 : ue.droplets) ?? 0) >= C.price
        }
        )
          , rt = _t( () => w(W) === Ze().id);
        var Ue = M8()
          , lt = z(Ue)
          , et = z(lt, !0);
        k(lt);
        var Ve = U(lt, 2)
          , gt = z(Ve, !0);
        k(Ve);
        var dt = U(Ve, 2);
        {
            var ct = ue => {
                gm(ue, {})
            }
            ;
            tt(dt, ue => {
                Ze().id === w(G) && ue(ct)
            }
            )
        }
        var ze = U(dt, 2);
        let vt;
        var Q = z(ze);
        {
            var ie = ue => {
                var Le = T8();
                Le.__click = async () => {
                    try {
                        const ht = Ze().id;
                        fe(W, ht, !0),
                        await ri.purchase({
                            id: F,
                            amount: 1,
                            variant: ht
                        }),
                        Vt.refresh(),
                        ua.notification1.play();
                        const Ft = E.find(zt => zt.id === ht);
                        Ft && (Ft.owned = !0),
                        fe(G, ht, !0)
                    } catch (ht) {
                        Zr.error(ht.message)
                    } finally {
                        fe(W, void 0)
                    }
                }
                ;
                var Re = z(Le);
                {
                    var We = ht => {
                        var Ft = w8();
                        H(ht, Ft)
                    }
                    ;
                    tt(Re, ht => {
                        w(rt) && ht(We)
                    }
                    )
                }
                var it = U(Re, 2);
                qd(it, {
                    class: "size-4"
                });
                var at = U(it);
                di(),
                k(Le),
                st(ht => {
                    Le.disabled = !w(ut) || w(rt),
                    Ce(at, ` ${ht ?? ""} `)
                }
                , [ () => C.price.toLocaleString("en-US")]),
                H(ue, Le)
            }
              , xe = ue => {
                const Le = _t( () => {
                    var xt;
                    return ((xt = Vt.data) == null ? void 0 : xt.equippedFlag) === Ze().id
                }
                );
                var Re = I8();
                let We;
                Re.__click = async () => {
                    try {
                        fe(W, Ze().id, !0);
                        const xt = w(Le) ? 0 : Ze().id;
                        await ri.equipFlag(xt),
                        Vt.data && (Vt.data.equippedFlag = xt),
                        Vt.refresh()
                    } catch (xt) {
                        Zr.error(xt.message)
                    } finally {
                        fe(W, void 0)
                    }
                }
                ;
                var it = z(Re)
                  , at = z(it, !0);
                k(it);
                var ht = U(it, 2);
                {
                    var Ft = xt => {
                        var Pt = C8();
                        H(xt, Pt)
                    }
                    ;
                    tt(ht, xt => {
                        w(rt) && xt(Ft)
                    }
                    )
                }
                var zt = U(ht, 2);
                {
                    var lr = xt => {
                        var Pt = S8()
                          , jt = Rt(Pt);
                        dc(jt, {
                            class: "size-4"
                        });
                        var Lt = U(jt, 2)
                          , nr = z(Lt, !0);
                        k(Lt),
                        st(xr => Ce(nr, xr), [ () => z2()]),
                        H(xt, Pt)
                    }
                      , kt = xt => {
                        var Pt = P8()
                          , jt = z(Pt, !0);
                        k(Pt),
                        st(Lt => Ce(jt, Lt), [ () => R2()]),
                        H(xt, Pt)
                    }
                    ;
                    tt(zt, xt => {
                        w(Le) ? xt(lr) : xt(kt, !1)
                    }
                    )
                }
                k(Re),
                st( (xt, Pt) => {
                    We = Vr(Re, 1, "btn btn-lg sm:btn-md tooltip tooltip-bottom relative h-10", null, We, xt),
                    Re.disabled = w(rt),
                    Ce(at, Pt)
                }
                , [ () => ({
                    "btn-warning": w(Le)
                }), () => A2()]),
                H(ue, Re)
            }
            ;
            tt(Q, ue => {
                Ze().owned ? ue(xe, !1) : ue(ie)
            }
            )
        }
        k(ze),
        k(Ue),
        st( (ue, Le) => {
            Ce(et, Ze().flag),
            Ce(gt, Ze().name),
            vt = Vr(ze, 1, "mt-3", null, vt, ue),
            jr(ze, "data-tip", Le)
        }
        , [ () => ({
            tooltip: !w(ut)
        }), () => $d()]),
        H(Ne, Ue)
    }
      , T = Bn.countries.map(Ne => ({
        ...Ne,
        owned: Vt.flagsBitmap.get(Ne.id)
    }));
    T.sort( (Ne, Ze) => Number(Ze.owned) - Number(Ne.owned));
    const E = Mn(T)
      , F = 110
      , C = Bn.products[F];
    let o = mt(!1)
      , W = mt(void 0)
      , G = mt(void 0);
    var re = k8()
      , de = z(re)
      , he = z(de);
    b8(he, {
        class: "size-5.5",
        filled: !0
    }),
    di(2),
    k(de);
    var X = U(de, 2)
      , le = z(X, !0);
    k(X);
    var Se = U(X, 2);
    mn(Se, 23, () => E, Ne => Ne.id, (Ne, Ze, ut) => {
        var rt = cr()
          , Ue = Rt(rt);
        {
            var lt = et => {
                _(et, () => w(Ze))
            }
            ;
            tt(Ue, et => {
                (w(ut) < 8 || w(o)) && et(lt)
            }
            )
        }
        H(Ne, rt)
    }
    ),
    k(Se);
    var Ie = U(Se, 2)
      , De = z(Ie);
    De.__click = [A8, o];
    var qe = z(De, !0);
    k(De),
    k(Ie),
    k(re),
    st(Ne => {
        Ce(le, Ne),
        Ce(qe, w(o) ? "Show less" : "Show more")
    }
    , [ () => P2()]),
    H(x, re),
    Dr()
}
Xi(["click"]);
var z8 = Be('<p class="mt-1 text-center text-sm"> </p>')
  , L8 = (x, l) => {
    Zg(l, -1)
}
  , D8 = (x, l) => {
    Zg(l)
}
  , R8 = async (x, l, _, T) => {
    try {
        fe(l, !0),
        await ri.purchase({
            id: _.productId,
            amount: T()
        }),
        ua.notification1.play(),
        _.onpurchasecompleted(T())
    } catch (E) {
        Zr.error(E.message)
    } finally {
        fe(l, !1)
    }
}
  , B8 = Be('<span class="loading loading-spinner center-absolute absolute"></span>')
  , F8 = Be('<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><!></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <!> <div class="mt-4 flex justify-center gap-3"><button class="btn btn-circle">-</button> <input class="input number-input max-w-16 text-center font-bold opacity-80" type="number" min="1"/> <button class="btn btn-circle">+</button></div> <div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!> <span class="text-sm">Droplets</span></button></div></div>');
function Ng(x, l) {
    Lr(l, !0);
    let _ = At(l, "amount", 15, 1);
    const T = _t( () => _() * l.unitPrice);
    let E = mt(!1);
    Gr( () => {
        _() < 0 && _(0)
    }
    );
    var F = F8()
      , C = z(F)
      , o = z(C);
    Wi(o, () => l.icon ?? Sn),
    k(C);
    var W = U(C, 2)
      , G = z(W, !0);
    k(W);
    var re = U(W, 2);
    {
        var de = Ue => {
            var lt = z8()
              , et = z(lt, !0);
            k(lt),
            st( () => Ce(et, l.subtitle)),
            H(Ue, lt)
        }
        ;
        tt(re, Ue => {
            l.subtitle && Ue(de)
        }
        )
    }
    var he = U(re, 2)
      , X = z(he);
    X.__click = [L8, _];
    var le = U(X, 2);
    Ea(le);
    var Se = U(le, 2);
    Se.__click = [D8, _],
    k(he);
    var Ie = U(he, 2);
    let De;
    var qe = z(Ie);
    qe.__click = [R8, E, l, _];
    var Ne = z(qe);
    {
        var Ze = Ue => {
            var lt = B8();
            H(Ue, lt)
        }
        ;
        tt(Ne, Ue => {
            w(E) && Ue(Ze)
        }
        )
    }
    var ut = U(Ne, 2);
    qd(ut, {
        class: "size-4"
    });
    var rt = U(ut);
    di(),
    k(qe),
    k(Ie),
    k(F),
    st( (Ue, lt, et, Ve) => {
        Ce(G, Ue),
        jr(Ie, "data-tip", lt),
        De = Vr(Ie, 1, "", null, De, et),
        qe.disabled = l.userDroplets < w(T) || w(E) || !_(),
        Ce(rt, ` ${Ve ?? ""} `)
    }
    , [ () => l.title(_()), () => $d(), () => ({
        tooltip: l.userDroplets < w(T)
    }), () => w(T).toLocaleString("en-US")]),
    jd(le, _),
    H(x, F),
    Dr()
}
Xi(["click"]);
var O8 = Pr('<svg><path d="M346-140 100-386q-10-10-15-22t-5-25q0-13 5-25t15-22l230-229-106-106 62-65 400 400q10 10 14.5 22t4.5 25q0 13-4.5 25T686-386L440-140q-10 10-22 15t-25 5q-13 0-25-5t-22-15Zm47-506L179-432h428L393-646Zm399 526q-36 0-61-25.5T706-208q0-27 13.5-51t30.5-47l42-54 44 54q16 23 30 47t14 51q0 37-26 62.5T792-120Z"></path></svg>');
function N8(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = O8();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var j8 = Pr('<svg><path d="M280-80q-33 0-56.5-23.5T200-160q0-33 23.5-56.5T280-240q33 0 56.5 23.5T360-160q0 33-23.5 56.5T280-80Zm400 0q-33 0-56.5-23.5T600-160q0-33 23.5-56.5T680-240q33 0 56.5 23.5T760-160q0 33-23.5 56.5T680-80ZM246-720l96 200h280l110-200H246Zm-38-80h590q23 0 35 20.5t1 41.5L692-482q-11 20-29.5 31T622-440H324l-44 80h480v80H280q-45 0-68-39.5t-2-78.5l54-98-144-304H40v-80h130l38 80Zm134 280h280-280Z"></path></svg>');
function $v(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = j8();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var q8 = Pr('<svg><path d="m700-300-57-56 84-84H120v-80h607l-83-84 57-56 179 180-180 180Z"></path></svg>');
function V8(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = q8();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var Z8 = Pr('<svg><path d="M280-160v-80h400v80H280Zm160-160v-327L336-544l-56-56 200-200 200 200-56 56-104-103v327h-80Z"></path></svg>');
function $8(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = Z8();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var U8 = Be('<div><section class="not-stuck:border-transparent stuck:border-base-content/10 bg-base-100/70 sticky top-0 z-10 border-b px-6 pb-4 pt-6 backdrop-blur-sm"><div class="relative flex items-center gap-1"><!> <h3 class="text-3xl font-bold"> </h3> <div class="ml-auto mr-4"><!></div> <form method="dialog" class="absolute -right-4 -top-4"><button class="btn btn-sm btn-circle btn-ghost">âœ•</button></form></div></section> <div class="flex flex-col gap-6 px-6 pb-6"><section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="mt-3 grid gap-3 sm:grid-cols-2"><!> <!></div></section> <section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <div class="mt-3"><div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="relative flex size-52 items-center justify-center"><div class="scale-[3]"><!></div></div></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <p class="mt-1 text-center text-sm"> </p> <div><a href="/profile-picture"><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <span class="text-sm">Droplets</span></button></a></div></div></div></section> <section><!></section></div></div>')
  , G8 = Be('<span class="center-absolute absolute"><!></span>')
  , H8 = Be('<dialog class="modal"><div class="modal-box max-h-11/12 w-11/12 max-w-4xl p-0"><!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><div class="flex flex-col items-center gap-6 px-4"><h2 class="text-lg font-semibold"> </h2> <div class="flex items-center gap-2 text-3xl sm:text-5xl"><span class="text-base-content/80 flex items-center gap-2"> <span class="text-primary text-3xl font-semibold max-sm:hidden"> </span></span> <span><!></span> <span class="text-primary flex font-bold"> </span></div> <form method="dialog"><button class="btn btn-primary btn-lg relative"> <!></button></form></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>', 1);
function W8(x, l) {
    Lr(l, !0);
    let _ = At(l, "open", 15)
      , T = mt(void 0)
      , E = mt(Mn({
        name: Sg(),
        prev: 1e3,
        new: 1e5
    }));
    wi( () => {
        const Re = We => {
            We.key === "Escape" && _(!1)
        }
        ;
        return document.addEventListener("keydown", Re),
        () => document.removeEventListener("keydown", Re)
    }
    );
    const F = {
        id: 70,
        product: Bn.products[70]
    }
      , C = {
        id: 80,
        product: Bn.products[80]
    }
      , o = {
        product: Bn.products[120]
    };
    var W = H8()
      , G = Rt(W)
      , re = z(G)
      , de = z(re);
    {
        var he = Re => {
            var We = U8()
              , it = z(We)
              , at = z(it)
              , ht = z(at);
            $v(ht, {
                class: "size-8"
            });
            var Ft = U(ht, 2)
              , zt = z(Ft, !0);
            k(Ft);
            var lr = U(Ft, 2)
              , kt = z(lr);
            {
                let Ke = _t( () => {
                    var ye;
                    return ((ye = Vt.data) == null ? void 0 : ye.droplets) ?? 0
                }
                );
                Wg(kt, {
                    get value() {
                        return w(Ke)
                    }
                })
            }
            k(lr),
            di(2),
            k(at),
            k(it),
            Fn(it, () => v8);
            var xt = U(it, 2)
              , Pt = z(xt)
              , jt = z(Pt)
              , Lt = z(jt);
            N8(Lt, {
                class: "size-5.5",
                filled: !0
            });
            var nr = U(Lt, 2)
              , xr = z(nr, !0);
            k(nr),
            k(jt);
            var er = U(jt, 2)
              , Qt = z(er, !0);
            k(er);
            var $t = U(er, 2)
              , tr = z($t);
            {
                const Ke = It => {
                    $8(It, {
                        class: "text-primary size-26"
                    })
                }
                ;
                let ye = _t( () => Tb());
                Ng(tr, {
                    get productId() {
                        return F.id
                    },
                    title: It => xb({
                        amount: F.product.items[0].amount * It
                    }),
                    get subtitle() {
                        return w(ye)
                    },
                    get unitPrice() {
                        return F.product.price
                    },
                    get userDroplets() {
                        return Vt.data.droplets
                    },
                    onpurchasecompleted: async It => {
                        var Ut, wr, ci, Yr, yt;
                        const Kt = (wr = (Ut = Vt.data) == null ? void 0 : Ut.charges) == null ? void 0 : wr.max;
                        await Vt.refresh();
                        const Bt = (Yr = (ci = Vt.data) == null ? void 0 : ci.charges) == null ? void 0 : Yr.max;
                        Kt !== void 0 && Bt !== void 0 && (fe(E, {
                            name: Sg(),
                            prev: Kt,
                            new: Bt
                        }, !0),
                        (yt = w(T)) == null || yt.show())
                    }
                    ,
                    icon: Ke,
                    $$slots: {
                        icon: !0
                    }
                })
            }
            var $r = U(tr, 2);
            {
                const Ke = It => {
                    jv(It, {
                        class: "text-primary my-3 size-20"
                    })
                }
                ;
                let ye = _t( () => hb());
                Ng($r, {
                    get productId() {
                        return C.id
                    },
                    title: It => b5({
                        amount: C.product.items[0].amount * It
                    }),
                    get subtitle() {
                        return w(ye)
                    },
                    get unitPrice() {
                        return C.product.price
                    },
                    get userDroplets() {
                        return Vt.data.droplets
                    },
                    onpurchasecompleted: async It => {
                        var Bt, Ut, wr;
                        const Kt = (Ut = (Bt = Vt.data) == null ? void 0 : Bt.charges) == null ? void 0 : Ut.count;
                        await Vt.refresh(),
                        Kt !== void 0 && (fe(E, {
                            name: v5(),
                            prev: Math.floor(Kt),
                            new: Math.floor(Kt + C.product.items[0].amount * It)
                        }, !0),
                        (wr = w(T)) == null || wr.show())
                    }
                    ,
                    icon: Ke,
                    $$slots: {
                        icon: !0
                    }
                })
            }
            k($t),
            k(Pt);
            var zr = U(Pt, 2)
              , Mr = z(zr)
              , sr = z(Mr);
            Gd(sr, {
                class: "size-5.5",
                filled: !0
            });
            var Xt = U(sr, 2)
              , Ir = z(Xt, !0);
            k(Xt),
            k(Mr);
            var mr = U(Mr, 2)
              , vr = z(mr)
              , br = z(vr)
              , _r = z(br)
              , Ar = z(_r)
              , Tr = z(Ar);
            Xg(Tr, {
                get userId() {
                    return Vt.data.id
                },
                get level() {
                    return Vt.data.level
                },
                get pictureUrl() {
                    return Vt.data.picture
                }
            }),
            k(Ar),
            k(_r),
            k(br);
            var be = U(br, 2)
              , q = z(be, !0);
            k(be);
            var V = U(be, 2)
              , K = z(V, !0);
            k(V);
            var ae = U(V, 2);
            let we;
            var Me = z(ae)
              , ke = z(Me)
              , ge = z(ke);
            qd(ge, {
                class: "size-4"
            });
            var je = U(ge);
            di(),
            k(ke),
            k(Me),
            k(ae),
            k(vr),
            k(mr),
            k(zr);
            var Oe = U(zr, 2)
              , Ee = z(Oe);
            E8(Ee, {}),
            k(Oe),
            k(xt),
            k(We),
            st( (Ke, ye, It, Kt, Bt, Ut, wr, ci, Yr) => {
                Ce(zt, Ke),
                Ce(xr, ye),
                Ce(Qt, It),
                Ce(Ir, Kt),
                Ce(q, Bt),
                Ce(K, Ut),
                jr(ae, "data-tip", wr),
                we = Vr(ae, 1, "", null, we, ci),
                ke.disabled = Vt.data.droplets < o.product.price,
                Ce(je, ` ${Yr ?? ""} `)
            }
            , [ () => ev(), () => fb(), () => gb(), () => T2(), () => Pb(), () => Ab(), () => $d(), () => ({
                tooltip: Vt.data.droplets < o.product.price
            }), () => o.product.price.toLocaleString("en-US")]),
            Cn(2, We, () => Wn),
            H(Re, We)
        }
        ;
        tt(de, Re => {
            Vt.data && _() && Re(he)
        }
        )
    }
    k(re);
    var X = U(re, 2)
      , le = z(X)
      , Se = z(le, !0);
    k(le),
    k(X),
    k(G),
    Fn(G, () => Re => {
        Gr( () => {
            _() ? Re.show() : Re.close()
        }
        )
    }
    );
    var Ie = U(G, 2)
      , De = z(Ie)
      , qe = z(De)
      , Ne = z(qe)
      , Ze = z(Ne, !0);
    k(Ne);
    var ut = U(Ne, 2)
      , rt = z(ut)
      , Ue = z(rt)
      , lt = U(Ue)
      , et = z(lt);
    k(lt),
    k(rt);
    var Ve = U(rt, 2)
      , gt = z(Ve);
    V8(gt, {
        class: "size-5"
    }),
    k(Ve);
    var dt = U(Ve, 2)
      , ct = z(dt, !0);
    k(dt),
    k(ut);
    var ze = U(ut, 2)
      , vt = z(ze)
      , Q = z(vt)
      , ie = U(Q);
    Iu(ie, () => w(E).new, Re => {
        var We = G8()
          , it = z(We);
        gm(it, {}),
        k(We),
        H(Re, We)
    }
    ),
    k(vt),
    k(ze),
    k(qe),
    k(De);
    var xe = U(De, 2)
      , ue = z(xe)
      , Le = z(ue, !0);
    k(ue),
    k(xe),
    k(Ie),
    Ss(Ie, Re => fe(T, Re), () => w(T)),
    st( (Re, We, it) => {
        Ce(Se, Re),
        Ce(Ze, w(E).name),
        Ce(Ue, `${w(E).prev ?? ""} `),
        Ce(et, `(+${w(E).new - w(E).prev})`),
        Ce(ct, w(E).new),
        Ce(Q, `${We ?? ""} `),
        Ce(Le, it)
    }
    , [ () => Ql(), () => Ql(), () => Ql()]),
    _n("close", G, () => _(!1)),
    H(x, W),
    Dr()
}
var X8 = Pr('<svg><path d="M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z"></path></svg>');
function K8(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = X8();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var Y8 = Pr('<svg><path d="M480-680q-33 0-56.5-23.5T400-760q0-33 23.5-56.5T480-840q33 0 56.5 23.5T560-760q0 33-23.5 56.5T480-680Zm-60 560v-480h120v480H420Z"></path></svg>');
function J8(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = Y8();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var Q8 = Pr('<svg><path d="M440-40v-80q-125-14-214.5-103.5T122-438H42v-80h80q14-125 103.5-214.5T440-836v-80h80v80q125 14 214.5 103.5T838-518h80v80h-80q-14 125-103.5 214.5T520-120v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Z"></path></svg>');
function ez(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = Q8();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var tz = Pr('<svg><path d="M440-42v-80q-125-14-214.5-103.5T122-440H42v-80h80q14-125 103.5-214.5T440-838v-80h80v80q125 14 214.5 103.5T838-520h80v80h-80q-14 125-103.5 214.5T520-122v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Zm0-120q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Z"></path></svg>');
function rz(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = tz();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var iz = Pr('<svg><path d="M380-720v-98L142-580h98v60H40v-200h60v98l238-238h-98v-60h200v200h-60ZM593-40q-24 0-46-9t-39-26L304-280l30-31q16-16 37.5-21.5t42.5.5l66 19v-327q0-17 11.5-28.5T520-680q17 0 28.5 11.5T560-640v433l-97-27 102 102q5 5 12.5 8.5T593-120h167q33 0 56.5-23.5T840-200v-160q0-17 11.5-28.5T880-400q17 0 28.5 11.5T920-360v160q0 66-47 113T760-40H593Zm7-280v-160q0-17 11.5-28.5T640-520q17 0 28.5 11.5T680-480v160h-80Zm120 0v-120q0-17 11.5-28.5T760-480q17 0 28.5 11.5T800-440v120h-80Zm-20 80Z"></path></svg>');
function nz(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = iz();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var az = Pr('<svg><path d="M360-840v-80h240v80H360Zm80 440h80v-240h-80v240Zm40 320q-74 0-139.5-28.5T226-186q-49-49-77.5-114.5T120-440q0-74 28.5-139.5T226-694q49-49 114.5-77.5T480-800q62 0 119 20t107 58l56-56 56 56-56 56q38 50 58 107t20 119q0 74-28.5 139.5T734-186q-49 49-114.5 77.5T480-80Zm0-80q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Zm0-280Z"></path></svg>');
function sz(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = az();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var oz = Pr('<svg><path d="M280-200v-80h284q63 0 109.5-40T720-420q0-60-46.5-100T564-560H312l104 104-56 56-200-200 200-200 56 56-104 104h252q97 0 166.5 63T800-420q0 94-69.5 157T564-200H280Z"></path></svg>');
function lz(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = oz();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
var cz = Pr('<svg><path d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"></path></svg>');
function uz(x, l) {
    let _ = Jt(l, ["$$slots", "$$events", "$$legacy"]);
    var T = cz();
    Yt(T, () => ({
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 -960 960 960",
        fill: "currentColor",
        ..._
    })),
    H(x, T)
}
function xf(x) {
    const l = document.createElement("img");
    return l.src = x,
    new Promise( (_, T) => {
        l.addEventListener("load", () => {
            _(l)
        }
        ),
        l.addEventListener("error", E => {
            T(E)
        }
        )
    }
    )
}
function hz(x) {
    const l = document.createElement("canvas");
    l.width = x.naturalWidth,
    l.height = x.naturalHeight;
    const _ = l.getContext("2d");
    return _ == null || _.drawImage(x, 0, 0),
    l
}
function dz(x, l, _) {
    return x < l ? l : x > _ ? _ : x
}
function pz(x, l) {
    const _ = 10 ** l;
    return Math.round(x * _) / _
}
var fz = Be('<meta property="og:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="twitter:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="robots" content="index, follow, max-image-preview:large"/> <meta name="color-scheme" content="light only"/>', 1)
  , mz = (x, l) => {
    fe(l, !w(l))
}
  , _z = Be("<button><!></button>")
  , gz = async (x, l, _, T) => {
    var E;
    w(l) || fe(l, await new Promise( (F, C) => {
        navigator.geolocation.getCurrentPosition(o => {
            F(o)
        }
        , o => {
            C(o)
        }
        )
    }
    )),
    w(l) && (Va({
        lat: w(l).coords.latitude,
        lng: w(l).coords.longitude
    }, w(_)),
    (E = w(T)) == null || E.flyTo({
        center: {
            lat: w(l).coords.latitude,
            lng: w(l).coords.longitude
        },
        zoom: 16.5
    }))
}
  , vz = Be('<div class="relative"><!> <span class="center-absolute absolute text-[10px] text-red-400">?</span></div>')
  , yz = Be('<button class="btn btn-lg btn-square sm:btn-xl z-30 shadow-md"><!></button>')
  , xz = (x, l, _, T) => {
    var E;
    fe(l, !0),
    w(_) && Va((E = w(_)) == null ? void 0 : E.getCenter(), w(T))
}
  , bz = Be('<button class="btn btn-primary shadow-xl"> </button>')
  , wz = Be("<div><!></div>")
  , Tz = (x, l, _, T) => {
    var F;
    fe(l, !0);
    const E = (F = w(_)) == null ? void 0 : F.getCenter();
    E && Va(E, w(T))
}
  , Cz = Be('<button class="btn btn-square shadow-md"><!></button>')
  , Sz = (x, l) => {
    fe(l, !0)
}
  , Pz = Be('<button class="btn btn-square relative shadow-md"><!></button>')
  , Iz = (x, l) => {
    fe(l, !0)
}
  , Mz = Be('<button class="btn btn-square relative shadow-md"><!></button>')
  , Az = Be('<div class="flex flex-col items-center gap-3"><!> <!> <!> <!></div>')
  , kz = (x, l) => {
    fe(l, !w(l))
}
  , Ez = Be('<div class="flex flex-col gap-3"><button><!></button></div>')
  , zz = Be('<div class="z-100 absolute bottom-1 left-1/2 -translate-x-1/2"><!></div>')
  , Lz = (x, l) => {
    fe(l, !0)
}
  , Dz = Be('<button class="btn btn-sm btn-circle"><!></button>')
  , Rz = (x, l) => {
    var _;
    (_ = w(l)) == null || _.zoomIn()
}
  , Bz = (x, l) => {
    var _;
    (_ = w(l)) == null || _.zoomOut()
}
  , Fz = Be('<button class="btn btn-sm btn-circle"><!></button>')
  , Oz = () => {
    window.location.replace(Za.url.origin)
}
  , Nz = Be('<button class="btn btn-sm btn-circle not-pwa:hidden"><!></button>')
  , jz = (x, l) => {
    w(l) && Jo.goToPrev(w(l))
}
  , qz = Be('<button class="btn btn-sm btn-circle"><!></button>')
  , Vz = Be('<div class="btn btn-sm btn-error w-max cursor-auto text-nowrap text-xs sm:text-base"><!> </div>')
  , Zz = (x, l, _) => {
    var T;
    (T = w(l)) == null || T.flyTo({
        center: w(l).getCenter(),
        zoom: _
    })
}
  , $z = Be('<button class="btn sm:btn-lg duration text-nowrap text-xs transition-opacity sm:text-base"><!> </button>')
  , Uz = Be("<span></span>")
  , Gz = Be('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-lg"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><!></div></div>')
  , Hz = Be('<div class="absolute bottom-0 left-0 z-50 w-full"><div class="rounded-t-box bg-base-100 border-base-300 w-full border-t py-3"><!></div></div>')
  , Wz = (x, l) => {
    fe(l, {
        name: "mainMenu"
    }, !0)
}
  , Xz = Be('<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><div class="px-3 pb-2 pt-1"><div class="flex items-center justify-between"><span><!> </span> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mt-1 flex items-center justify-center gap-4"><button class="btn btn-primary w-46"><!></button></div></div></div></div>')
  , Kz = Be('<div class="disable-pinch-zoom relative h-full overflow-hidden svelte-6wmtgk"><div id="map" class="h-screen w-screen cursor-default"></div> <div><div><!> <!></div></div> <!> <div><!> <div class="flex flex-col gap-1 max-sm:hidden"><button class="btn btn-sm btn-circle">+</button> <button class="btn btn-sm btn-circle">-</button></div> <div class="max-sm:hidden"><a href="https://www.twitch.tv/directory/category/wplace" class="btn btn-sm btn-circle" target="_blank" title="Livestreams"><!></a></div> <!> <!> <!></div> <div><!> <!></div> <div><!></div> <div><!></div> <div><!></div>  <!></div> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>', 1);
function bL(x, l) {
    Lr(l, !0);
    const _ = xg
      , T = px
      , E = new cc(T)
      , F = _ - .4
      , C = aP(Za.url)
      , o = C.season ?? yg
      , W = new Map;
    let G = mt(void 0)
      , re = mt(14.5)
      , de = mt(!1);
    const he = _t( () => {
        var Tt;
        return ((Tt = Vt.data) == null ? void 0 : Tt.id) === 401
    }
    );
    let X = mt(!1)
      , le = mt(Mn(C.select && C.pos ? {
        name: "pixelSelected",
        latLon: [C.pos.lat, C.pos.lng]
    } : {
        name: "mainMenu"
    }));
    wi( () => {
        Ie().then(Ht => fe(G, Ht));
        let Tt = [0, 0];
        function Ot(Ht) {
            var mi;
            if (w(G) && w(re) > _ + 1) {
                const {lat: Ii, lng: Qi} = w(G).unproject([Ht.clientX, Ht.clientY])
                  , vi = E.latLonToPixels(Ii, Qi, _)
                  , kr = Math.floor(vi[0])
                  , Yn = Math.floor(vi[1]);
                if (Tt[0] !== kr || Tt[1] !== Yn) {
                    const gr = E.latLonToPixelBoundsLatLon(Ii, Qi, _)
                      , Zt = lm(gr, !0);
                    (mi = w(G).getSource(Ne)) == null || mi.setCoordinates(Zt),
                    Tt = [kr, Yn]
                }
            }
        }
        return window.addEventListener("mousemove", Ot),
        () => {
            var Ht;
            (Ht = w(G)) == null || Ht.remove(),
            window.removeEventListener("mousemove", Ot),
            Se && clearInterval(Se),
            bf()
        }
    }
    );
    let Se;
    async function Ie() {
        const Tt = C.pos ? {
            ...C.pos,
            zoom: w(re)
        } : await XS();
        C.zoom !== void 0 && (Tt.zoom = C.zoom);
        const Ot = await new Promise(vi => {
            const kr = new bd.Map({
                style: " https://maps.wplace.live/styles/liberty",
                center: Tt,
                zoom: Tt.zoom,
                container: "map",
                dragRotate: !1,
                doubleClickZoom: !1,
                pitch: 0,
                maxPitch: 0,
                attributionControl: !1
            });
            kr.touchZoomRotate.disableRotation(),
            kr.on("style.load", () => {
                kr == null || kr.setLayoutProperty("poi_transit", "visibility", "none"),
                kr == null || kr.setLayoutProperty("poi_r20", "visibility", "none"),
                kr == null || kr.setLayoutProperty("poi_r7", "visibility", "none"),
                kr == null || kr.setLayoutProperty("poi_r1", "visibility", "none"),
                kr == null || kr.setLayoutProperty("building", "visibility", "none"),
                kr == null || kr.setLayoutProperty("building-3d", "visibility", "none"),
                kr == null || kr.setLayoutProperty("landuse_pitch", "visibility", "none"),
                kr == null || kr.setLayoutProperty("landuse_hospital", "visibility", "none"),
                kr == null || kr.setLayoutProperty("landuse_school", "visibility", "none"),
                kr == null || kr.setLayoutProperty("landuse_residential", "visibility", "none"),
                kr == null || kr.setLayoutProperty("waterway_tunnel", "visibility", "none"),
                kr == null || kr.setFilter("water", ["all", ["!=", "brunnel", "tunnel"], ["!=", "class", "swimming_pool"]]),
                vi(kr)
            }
            )
        }
        );
        qe(Ot),
        Ue();
        const Ht = Bn.refreshIntervalMs;
        function mi() {
            let vi = w(re) > _ + 1.5 ? Ht : 2.5 * Ht;
            try {
                document.visibilityState === "visible" && qe(Ot)
            } finally {
                setTimeout(mi, vi)
            }
        }
        Se = setTimeout(mi, Ht);
        let Ii = w(re);
        Ot.on("zoom", () => {
            fe(re, Ot.getZoom(), !0);
            const vi = pz(w(re), 1);
            vi != Ii && (w(ze) && w(ze).setOpacity(vt(Ii)),
            Ii = vi)
        }
        );
        let Qi = "default";
        return Ot.on("dragstart", () => {
            const vi = Ot.getCanvas();
            Qi = vi.style.cursor,
            vi.style.cursor = "move"
        }
        ),
        Ot.on("dragend", () => {
            Ot.getCanvas().style.cursor = Qi
        }
        ),
        Ot.on("mouseout", () => {
            lt()
        }
        ),
        Ot.on("click", async vi => {
            var Qr;
            const kr = vi.lngLat.lat
              , Yn = vi.lngLat.lng
              , gr = [kr, Yn];
            if (w(le).name === "paintingPixel")
                return;
            if (w(le).name === "selectHq") {
                w(le).hq = gr,
                (Qr = w(Q)) == null || Qr.clearAndPlace(gr);
                return
            }
            const Zt = Ot.getZoom();
            if (Zt < F) {
                Zr.info(JC());
                return
            }
            Va({
                lat: kr,
                lng: Yn
            }, Zt),
            fe(le, {
                name: "pixelSelected",
                latLon: gr
            }, !0)
        }
        ),
        Ot
    }
    const De = "pixel-art-layer";
    function qe(Tt) {
        const Ot = window.innerWidth
          , Ht = `${fx}/s${yg}/tiles/{x}/{y}.png`;
        if (W.clear(),
        !Tt.style)
            return;
        Tt.getSource(De) ? Tt.refreshTiles(De) : Tt.addSource(De, {
            type: "raster",
            tiles: [Ht],
            minzoom: _,
            maxzoom: _,
            tileSize: Ot > 640 ? 550 : 400
        }),
        Tt.getLayer(De) || Tt.addLayer({
            id: De,
            type: "raster",
            source: De,
            paint: {
                "raster-resampling": "nearest",
                "raster-opacity": w(Ve)
            }
        })
    }
    const Ne = "pixel-hover"
      , Ze = 1e-5
      , ut = [[0, 0], [Ze, 0], [Ze, -Ze], [0, -Ze]]
      , rt = .4;
    async function Ue() {
        var Tt, Ot, Ht, mi;
        if (!((Tt = w(G)) != null && Tt.getSource(Ne))) {
            const Ii = hz(await xf(HS));
            (Ot = w(G)) == null || Ot.addSource(Ne, {
                type: "canvas",
                canvas: Ii,
                coordinates: ut
            })
        }
        (Ht = w(G)) != null && Ht.getLayer(Ne) || (mi = w(G)) == null || mi.addLayer({
            id: Ne,
            type: "raster",
            source: Ne,
            paint: {
                "raster-resampling": "nearest",
                "raster-opacity": rt
            }
        })
    }
    function lt() {
        var Tt, Ot;
        (Ot = (Tt = w(G)) == null ? void 0 : Tt.getSource(Ne)) == null || Ot.setCoordinates(ut)
    }
    let et = mt(Mn(C.opaque ?? !0))
      , Ve = _t( () => w(et) ? 1 : .3);
    Gr( () => {
        var Tt;
        (Tt = w(G)) != null && Tt.getLayer(De) && w(G).setPaintProperty(De, "raster-opacity", w(Ve))
    }
    );
    let gt = mt(void 0)
      , dt = mt(void 0)
      , ct = mt(void 0);
    wi( () => (navigator.permissions.query({
        name: "geolocation"
    }).then(Tt => {
        Tt.state === "granted" && fe(ct, navigator.geolocation.watchPosition(Ot => {
            fe(gt, Ot)
        }
        , Ot => {
            fe(dt, Ot)
        }
        , {
            enableHighAccuracy: !1,
            maximumAge: 1e3,
            timeout: 6e3
        }), !0)
    }
    ),
    () => {
        w(ct) && navigator.geolocation.clearWatch(w(ct))
    }
    ));
    let ze = mt(void 0);
    uc( () => [w(gt), w(G)], () => {
        var Tt, Ot;
        if (w(gt) && w(G)) {
            const Ht = {
                lat: w(gt).coords.latitude,
                lng: w(gt).coords.longitude
            }
              , mi = vt(w(re));
            if (!w(ze)) {
                const Ii = document.createElement("div");
                Ii.classList.add("maplibregl-user-location-dot"),
                Ii.classList.add("cursor-auto"),
                fe(ze, new bd.Marker({
                    element: Ii,
                    opacity: mi
                }).setLngLat(Ht).addTo(w(G)))
            }
            (Ot = (Tt = w(ze)) == null ? void 0 : Tt.setLngLat(Ht)) == null || Ot.setOpacity(mi)
        }
    }
    );
    function vt(Tt) {
        return Tt < _ ? "1.0" : dz((Tt - _) * .2, .5, 1).toFixed(2)
    }
    let Q = mt(void 0);
    Gr( () => {
        var Tt;
        w(G) && ((Tt = so( () => w(Q))) == null || Tt.clear(),
        xf(Pg).then(Ot => {
            fe(Q, new Mg({
                id: "select-crosshair",
                map: w(G),
                tileSize: T,
                zoom: _,
                img: Ot,
                markerFn: () => {
                    const Ht = new bd.Marker({
                        color: "#0069ff"
                    });
                    return Ht.addClassName("z-20"),
                    Ht
                }
            }))
        }
        ))
    }
    );
    let ie = mt(void 0);
    Gr( () => {
        var Tt;
        w(G) && ((Tt = so( () => w(Q))) == null || Tt.clear(),
        xf(Pg).then(Ot => {
            fe(ie, new Mg({
                id: "paint-crosshair",
                map: w(G),
                tileSize: T,
                zoom: _,
                img: Ot
            }))
        }
        ))
    }
    );
    let xe = mt(!1)
      , ue = mt(!1)
      , Le = mt(!1)
      , Re = mt(!!C.newUser)
      , We = mt(!1)
      , it = mt(!!C.alliance)
      , at = mt(!1);
    const ht = "void-message";
    let Ft = mt(!1);
    Gr( () => {
        const Tt = localStorage.getItem(ht);
        Vt.data && !Tt && (fe(Ft, !0),
        localStorage.setItem(ht, "true"))
    }
    );
    let zt = mt(!1)
      , lr = mt(Mn(Za.url))
      , kt = mt(Mn({
        cityId: 0,
        countryId: 1,
        id: 0,
        name: "None",
        number: 1
    }))
      , xt = mt(!1);
    const Pt = "view-rules";
    let jt = !1;
    Gr( () => {
        Vt.data && (!jt && Vt.data.pixelsPainted > 1 && (localStorage.getItem(Pt) || (fe(xt, !0),
        localStorage.setItem(Pt, "true"))),
        jt = !0)
    }
    );
    let Lt = mt(!1);
    Gr( () => {
        var Tt;
        fe(Lt, !!((Tt = Vt.data) != null && Tt.needsPhoneVerification))
    }
    );
    let nr = mt([])
      , xr = _t( () => w(re) < F ? "1.0" : w(re) < F + 2 ? "0.5" : "0.3");
    Gr( () => {
        var Ot;
        const Tt = (Ot = Vt.data) == null ? void 0 : Ot.favoriteLocations;
        if (Tt && w(G)) {
            for (const Ht of so( () => w(nr)))
                Ht.remove();
            fe(nr, Tt.map(Ht => {
                const mi = document.createElement("div");
                mi.classList.add("text-yellow-400"),
                mi.classList.add("cursor-pointer"),
                mi.classList.add("z-10"),
                mi.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
					<path fill="#000a" d="m183-51 79-338L-1-617l346-29 135-319 135 319 346 29-263 228 79 338-297-180L183-51Z"/>
					<path d="m293-203.08 49.62-212.54-164.93-142.84 217.23-18.85L480-777.69l85.08 200.38 217.23 18.85-164.93 142.84L667-203.08 480-315.92 293-203.08Z"/>
				</svg>`;
                const Ii = {
                    lat: Ht.latitude,
                    lng: Ht.longitude
                };
                return mi.addEventListener("click", vi => {
                    vi.stopPropagation(),
                    er([Ht.latitude, Ht.longitude])
                }
                ),
                new bd.Marker({
                    element: mi,
                    opacity: w(xr)
                }).setLngLat(Ii).addTo(w(G))
            }
            ))
        }
    }
    );
    function er(Tt) {
        var Ht;
        const Ot = {
            lat: Tt[0],
            lng: Tt[1]
        };
        (Ht = w(G)) == null || Ht.flyTo({
            center: Ot,
            zoom: Math.max(w(re), 15)
        }),
        Va(Ot, w(re)),
        fe(le, {
            name: "pixelSelected",
            latLon: [Ot.lat, Ot.lng]
        }, !0)
    }
    Gr( () => {
        if (w(le).name === "paintingPixel")
            for (const Tt of w(nr))
                Tt.addClassName("hidden");
        else
            for (const Tt of w(nr))
                Tt.removeClassName("hidden"),
                Tt.setOpacity(w(xr))
    }
    );
    let Qt = Number.MAX_VALUE;
    Gr( () => {
        if (Vt.charges !== void 0 && Vt.data) {
            const Tt = Vt.data.charges.max
              , Ot = Vt.charges;
            Qt < Tt && Ot >= Tt && ua.notification1.play(),
            Qt = Vt.charges
        }
    }
    );
    let $t = mt(!1)
      , tr = Date.now();
    wi( () => {
        const Tt = nP()
          , Ot = () => {
            var mi;
            if (!document.hidden && Date.now() - tr > 30 * Xl.min) {
                if (Tt) {
                    const Qi = (mi = w(G)) == null ? void 0 : mi.getCenter();
                    Qi && Va(Qi, w(re)),
                    window.location.replace(Za.url.origin)
                } else
                    Vt.refresh();
                tr = Date.now()
            }
        }
        ;
        return document.addEventListener("visibilitychange", Ot),
        () => document.removeEventListener("visibilitychange", Ot)
    }
    ),
    wi( () => {
        function Tt() {
            ri.online = !0
        }
        window.addEventListener("online", Tt);
        function Ot() {
            ri.online = !1
        }
        return window.addEventListener("offline", Ot),
        () => {
            window.removeEventListener("online", Tt),
            window.removeEventListener("offline", Ot)
        }
    }
    ),
    Gr( () => {
        if (!ri.online) {
            const Tt = setInterval( () => {
                ri.health().then( () => {
                    ri.online = !0,
                    !Vt.data && !Vt.loading && Vt.refresh()
                }
                )
            }
            , 5e3);
            return () => {
                clearInterval(Tt)
            }
        }
    }
    ),
    wi( () => {
        function Tt(Ot) {
            Ot.data.type && w(G) && qe(w(G))
        }
        return navigator.serviceWorker.addEventListener("message", Tt),
        () => {
            navigator.serviceWorker.removeEventListener("message", Tt)
        }
    }
    );
    var $r = Kz();
    lx(Tt => {
        var Ot = fz();
        cx.title = "Wplace - Paint the world",
        di(6),
        H(Tt, Ot)
    }
    );
    var zr = Rt($r);
    {
        const Tt = gr => {
            var Zt = _z();
            Zt.__click = [mz, et];
            var Qr = z(Zt);
            {
                let ni = _t( () => !w(et));
                qv(Qr, {
                    class: "size-5",
                    get filled() {
                        return w(ni)
                    }
                })
            }
            k(Zt),
            st(ni => {
                jr(Zt, "title", ni),
                Vr(Zt, 1, Kl({
                    "btn btn-lg btn-square sm:btn-xl z-30 shadow-md": !0,
                    "text-base-content/80": w(et),
                    "btn-primary btn-soft": !w(et)
                }))
            }
            , [ () => rv()]),
            H(gr, Zt)
        }
          , Ot = gr => {
            var Zt = yz();
            Zt.__click = [gz, gt, re, G];
            var Qr = z(Zt);
            {
                var ni = oi => {
                    rz(oi, {
                        class: "size-5.5 fill-blue-800"
                    })
                }
                  , yi = oi => {
                    var ki = vz()
                      , Ki = z(ki);
                    ez(Ki, {
                        class: "size-5.5 fill-red-400"
                    }),
                    di(2),
                    k(ki),
                    H(oi, ki)
                }
                ;
                tt(Qr, oi => {
                    w(gt) ? oi(ni) : oi(yi, !1)
                }
                )
            }
            k(Zt),
            st(oi => jr(Zt, "title", oi), [ () => P1()]),
            H(gr, Zt)
        }
        ;
        var Mr = U(z(zr), 2);
        let Ht;
        var sr = z(Mr);
        let mi;
        var Xt = z(sr);
        {
            var Ir = gr => {
                var Zt = bz();
                Zt.__click = [xz, xe, G, re];
                var Qr = z(Zt, !0);
                k(Zt),
                st(ni => Ce(Qr, ni), [ () => Ux()]),
                H(gr, Zt)
            }
              , mr = gr => {
                var Zt = cr()
                  , Qr = Rt(Zt);
                {
                    var ni = yi => {
                        var oi = wz()
                          , ki = z(oi);
                        AE(ki, {
                            get user() {
                                return Vt
                            },
                            onlogout: () => {
                                fe(le, {
                                    name: "mainMenu"
                                }, !0)
                            }
                            ,
                            onclickleaderboard: () => {
                                fe(Le, !0)
                            }
                            ,
                            onclickshop: () => {
                                var Pi;
                                fe(ue, !0);
                                const Ki = (Pi = w(G)) == null ? void 0 : Pi.getCenter();
                                Ki && Va(Ki, w(re))
                            }
                        }),
                        k(oi),
                        Cn(3, oi, () => Wn, () => ({
                            duration: 150
                        })),
                        H(yi, oi)
                    }
                    ;
                    tt(Qr, yi => {
                        Vt.data && w(G) && w(le).name !== "paintingPixel" && yi(ni)
                    }
                    , !0)
                }
                H(gr, Zt)
            }
            ;
            tt(Xt, gr => {
                !Vt.loading && !Vt.data ? gr(Ir) : gr(mr, !1)
            }
            )
        }
        var vr = U(Xt, 2);
        {
            var br = gr => {
                var Zt = Az()
                  , Qr = z(Zt);
                {
                    var ni = Pi => {
                        vf(Pi, {
                            key: "shop-profile-picture",
                            children: (Ni, zi) => {
                                var gi = Cz();
                                gi.__click = [Tz, ue, G, re];
                                var en = z(gi);
                                $v(en, {
                                    class: "size-5"
                                }),
                                k(gi),
                                st(Jn => jr(gi, "title", Jn), [ () => ev()]),
                                H(Ni, gi)
                            }
                            ,
                            $$slots: {
                                default: !0
                            }
                        })
                    }
                    ;
                    tt(Qr, Pi => {
                        Vt.data && Pi(ni)
                    }
                    )
                }
                var yi = U(Qr, 2);
                {
                    var oi = Pi => {
                        var Ni = Pz();
                        Ni.__click = [Sz, it];
                        var zi = z(Ni);
                        Hd(zi, {
                            class: "size-5"
                        }),
                        k(Ni),
                        st(gi => jr(Ni, "title", gi), [ () => Zd()]),
                        H(Pi, Ni)
                    }
                    ;
                    tt(yi, Pi => {
                        Vt.data && Pi(oi)
                    }
                    )
                }
                var ki = U(yi, 2);
                BE(ki, {
                    get map() {
                        return w(G)
                    },
                    get season() {
                        return o
                    }
                });
                var Ki = U(ki, 2);
                vf(Ki, {
                    key: "region-leaderboard",
                    children: (Pi, Ni) => {
                        var zi = Mz();
                        zi.__click = [Iz, Le];
                        var gi = z(zi);
                        Fv(gi, {
                            class: "size-5"
                        }),
                        k(zi),
                        st(en => jr(zi, "title", en), [ () => rm()]),
                        H(Pi, zi)
                    }
                    ,
                    $$slots: {
                        default: !0
                    }
                }),
                k(Zt),
                Cn(3, Zt, () => Wn, () => ({
                    duration: 150
                })),
                H(gr, Zt)
            }
              , _r = gr => {
                var Zt = cr()
                  , Qr = Rt(Zt);
                {
                    var ni = yi => {
                        var oi = Ez()
                          , ki = z(oi);
                        let Ki;
                        ki.__click = [kz, de];
                        var Pi = z(ki);
                        {
                            var Ni = gi => {
                                Wf(gi, {
                                    class: "size-5"
                                })
                            }
                              , zi = gi => {
                                Ld(gi, {
                                    class: "size-5"
                                })
                            }
                            ;
                            tt(Pi, gi => {
                                w(de) ? gi(Ni) : gi(zi, !1)
                            }
                            )
                        }
                        k(ki),
                        k(oi),
                        st( (gi, en) => {
                            jr(ki, "title", gi),
                            Ki = Vr(ki, 1, "btn btn-square not-touchscreen:hidden shadow-md", null, Ki, en)
                        }
                        , [ () => w(de) ? e1() : i1(), () => ({
                            "btn-primary": w(de)
                        })]),
                        Cn(1, oi, () => Wn, () => ({
                            delay: 150,
                            duration: 150
                        })),
                        H(yi, oi)
                    }
                    ;
                    tt(Qr, yi => {
                        w(G) && w(le).name === "paintingPixel" && yi(ni)
                    }
                    , !0)
                }
                H(gr, Zt)
            }
            ;
            tt(vr, gr => {
                w(G) && w(le).name !== "paintingPixel" ? gr(br) : gr(_r, !1)
            }
            )
        }
        k(sr),
        k(Mr);
        var Ar = U(Mr, 2);
        {
            var Tr = gr => {
                var Zt = zz()
                  , Qr = z(Zt);
                {
                    let ni = _t( () => mx.trim());
                    Ex(Qr, {
                        get siteKey() {
                            return w(ni)
                        },
                        refreshExpired: "auto",
                        appearance: "interaction-only",
                        callback: yi => {
                            aa.captcha = {
                                token: yi,
                                time: Date.now()
                            }
                            window.setCaptchaContext(aa.captcha, async () => {
                                console.log("Reset the captcha");
                                aa.captcha = void 0;
                            });
                        }
                    })
                }
                k(Zt),
                Cn(2, Zt, () => Wn, () => ({
                    duration: 300
                })),
                H(gr, Zt)
            }
            ;
            tt(Ar, gr => {
                (!aa.captcha || aa.now - aa.captcha.time > 180 * 1e3) && gr(Tr)
            }
            )
        }
        var be = U(Ar, 2);
        let Ii;
        var q = z(be);
        {
            var V = gr => {
                vf(gr, {
                    key: "info",
                    children: (Zt, Qr) => {
                        var ni = Dz();
                        ni.__click = [Lz, We];
                        var yi = z(ni);
                        J8(yi, {
                            class: "size-3.5"
                        }),
                        k(ni),
                        st(oi => jr(ni, "title", oi), [ () => s1()]),
                        H(Zt, ni)
                    }
                    ,
                    $$slots: {
                        default: !0
                    }
                })
            }
            ;
            tt(q, gr => {
                w(le).name !== "paintingPixel" && gr(V)
            }
            )
        }
        var K = U(q, 2)
          , ae = z(K);
        ae.__click = [Rz, G];
        var we = U(ae, 2);
        we.__click = [Bz, G],
        k(K);
        var Me = U(K, 2)
          , ke = z(Me)
          , ge = z(ke);
        Jg(ge, {
            class: "size-4"
        }),
        k(ke),
        k(Me);
        var je = U(Me, 2);
        {
            var Oe = gr => {
                var Zt = Fz()
                  , Qr = z(Zt);
                uz(Qr, {
                    class: "size-4",
                    onclick: () => {
                        fe(X, !w(X))
                    }
                }),
                k(Zt),
                st(ni => jr(Zt, "title", ni), [ () => e2()]),
                H(gr, Zt)
            }
            ;
            tt(je, gr => {
                w(he) && gr(Oe)
            }
            )
        }
        var Ee = U(je, 2);
        {
            var Ke = gr => {
                var Zt = Nz();
                Zt.__click = [Oz];
                var Qr = z(Zt);
                Lx(Qr, {
                    class: "size-3"
                }),
                k(Zt),
                st(ni => jr(Zt, "title", ni), [ () => Dx()]),
                H(gr, Zt)
            }
            ;
            tt(Ee, gr => {
                w(le).name !== "paintingPixel" && gr(Ke)
            }
            )
        }
        var ye = U(Ee, 2);
        {
            var It = gr => {
                var Zt = qz();
                Zt.__click = [jz, G];
                var Qr = z(Zt);
                lz(Qr, {
                    class: "size-3"
                }),
                k(Zt),
                st( (ni, yi) => {
                    jr(Zt, "title", ni),
                    Zt.disabled = yi
                }
                , [ () => m1(), () => !Jo.hasPrev()]),
                Cn(1, Zt, () => Wn, () => ({
                    delay: 1e3,
                    duration: 300
                })),
                Cn(2, Zt, () => Wn, () => ({
                    duration: 300
                })),
                H(gr, Zt)
            }
            ;
            tt(ye, gr => {
                Jo.hasPrev() && w(le).name !== "paintingPixel" && gr(It)
            }
            )
        }
        k(be);
        var Kt = U(be, 2);
        let Qi;
        var Bt = z(Kt);
        {
            var Ut = gr => {
                var Zt = Vz()
                  , Qr = z(Zt);
                Rx(Qr, {
                    class: "size-5"
                });
                var ni = U(Qr);
                k(Zt),
                st(yi => Ce(ni, ` ${yi ?? ""}`), [ () => v1()]),
                Cn(1, Zt, () => Wn, () => ({
                    duration: 1e3
                })),
                Cn(2, Zt, () => Wn),
                H(gr, Zt)
            }
            ;
            tt(Bt, gr => {
                ri.online || gr(Ut)
            }
            )
        }
        var wr = U(Bt, 2);
        {
            var ci = gr => {
                var Zt = $z();
                Zt.__click = [Zz, G, _];
                var Qr = z(Zt);
                nz(Qr, {
                    class: "size-5"
                });
                var ni = U(Qr);
                k(Zt),
                st(yi => Ce(ni, ` ${yi ?? ""}`), [ () => b1()]),
                Cn(3, Zt, () => Wn, () => ({
                    duration: 300
                })),
                H(gr, Zt)
            }
            ;
            tt(wr, gr => {
                w(re) < F && gr(ci)
            }
            )
        }
        k(Kt);
        var Yr = U(Kt, 2);
        let vi;
        var yt = z(Yr);
        Tt(yt),
        k(Yr);
        var Mt = U(Yr, 2);
        let kr;
        var Gt = z(Mt);
        {
            var Fr = gr => {
                Nv(gr, {
                    class: "z-30",
                    onclick: () => {
                        var Zt;
                        (Zt = Vt.data) != null && Zt.needsPhoneVerification ? (fe(Lt, !0),
                        Zr.warning(Tg())) : Vt.charges !== void 0 && Vt.charges < 1 ? Zr.warning(PA, {
                            icon: sz
                        }) : w(G) && Vt.data ? (ua.smallDropplet.play(),
                        fe(le, {
                            name: "paintingPixel"
                        }, !0)) : (fe(xe, !0),
                        w(G) && Va(w(G).getCenter(), w(re)))
                    }
                    ,
                    get disabled() {
                        return Vt.loading
                    },
                    get loading() {
                        return Vt.loading
                    },
                    get charges() {
                        return Vt.charges
                    }
                })
            }
              , ft = gr => {
                var Zt = Uz();
                H(gr, Zt)
            }
            ;
            tt(Gt, gr => {
                w(le).name === "mainMenu" ? gr(Fr) : gr(ft, !1)
            }
            )
        }
        k(Mt);
        var Br = U(Mt, 2);
        let Yn;
        var Ur = z(Br);
        Ot(Ur),
        k(Br);
        var Si = U(Br, 2);
        {
            var ui = gr => {
                var Zt = cr()
                  , Qr = Rt(Zt);
                {
                    var ni = oi => {
                        var ki = Gz()
                          , Ki = z(ki)
                          , Pi = z(Ki);
                        g8(Pi, {
                            get latLon() {
                                return w(le).latLon
                            },
                            get map() {
                                return w(G)
                            },
                            get crosshair() {
                                return w(Q)
                            },
                            get pixelInfoCache() {
                                return W
                            },
                            get season() {
                                return o
                            },
                            get tileSize() {
                                return T
                            },
                            get pixelArtZoom() {
                                return _
                            },
                            get zoom() {
                                return w(re)
                            },
                            get opaquePixelArt() {
                                return w(et)
                            },
                            onclose: () => fe(le, {
                                name: "mainMenu"
                            }, !0),
                            onclickshare: Ni => {
                                fe(lr, Ni, !0),
                                fe(zt, !0)
                            }
                            ,
                            onclickpaint: ([Ni,zi]) => {
                                var en, Jn, Ui;
                                if (!Vt.data) {
                                    fe(xe, !0);
                                    return
                                }
                                if ((en = Vt.data) != null && en.needsPhoneVerification) {
                                    fe(Lt, !0),
                                    Zr.warning(Tg());
                                    return
                                }
                                if (Vt.charges !== void 0 && Vt.charges < 1) {
                                    Zr.warning(A1());
                                    return
                                }
                                const gi = cm(E.latLonToPixelBoundsLatLon(Ni, zi, _));
                                (Jn = w(G)) == null || Jn.flyTo({
                                    center: {
                                        lat: gi[0],
                                        lon: gi[1]
                                    }
                                }),
                                fe(le, {
                                    name: "paintingPixel",
                                    clickedLatLon: [Ni, zi]
                                }, !0),
                                (Ui = w(Q)) == null || Ui.clear()
                            }
                            ,
                            onclickregion: Ni => {
                                fe(kt, Ni, !0),
                                fe(at, !0)
                            }
                        }),
                        k(Ki),
                        k(ki),
                        Cn(3, Ki, () => df, () => ({
                            duration: 100
                        })),
                        H(oi, ki)
                    }
                      , yi = oi => {
                        var ki = cr()
                          , Ki = Rt(ki);
                        {
                            var Pi = zi => {
                                var gi = Hz()
                                  , en = z(gi)
                                  , Jn = z(en);
                                Sk(Jn, {
                                    get map() {
                                        return w(G)
                                    },
                                    get clickedLatLon() {
                                        return w(le).clickedLatLon
                                    },
                                    get tileSize() {
                                        return T
                                    },
                                    get tileZoom() {
                                        return _
                                    },
                                    get season() {
                                        return o
                                    },
                                    get zoom() {
                                        return w(re)
                                    },
                                    get crosshair() {
                                        return w(ie)
                                    },
                                    refreshPixelArt: () => w(G) && qe(w(G)),
                                    hidePixelHover: lt,
                                    hoverLayerId: Ne,
                                    onclose: () => {
                                        fe(le, {
                                            name: "mainMenu"
                                        }, !0),
                                        lt()
                                    }
                                    ,
                                    get screenLocked() {
                                        return w(de)
                                    },
                                    set screenLocked(Ui) {
                                        fe(de, Ui, !0)
                                    },
                                    get opaquePixelArt() {
                                        return w(et)
                                    },
                                    set opaquePixelArt(Ui) {
                                        fe(et, Ui, !0)
                                    }
                                }),
                                k(en),
                                k(gi),
                                Cn(3, en, () => df, () => ({
                                    duration: 100
                                })),
                                H(zi, gi)
                            }
                              , Ni = zi => {
                                var gi = cr()
                                  , en = Rt(gi);
                                {
                                    var Jn = Ui => {
                                        var Wr = Xz()
                                          , Qn = z(Wr)
                                          , sa = z(Qn)
                                          , da = z(sa)
                                          , os = z(da)
                                          , Ps = z(os);
                                        Vv(Ps, {
                                            class: "inline size-4"
                                        });
                                        var jn = U(Ps);
                                        k(os);
                                        var ea = U(os, 2);
                                        ea.__click = [Wz, le];
                                        var Jr = z(ea);
                                        dc(Jr, {
                                            class: "size-4"
                                        }),
                                        k(ea),
                                        k(da);
                                        var Ua = U(da, 2)
                                          , Da = z(Ua);
                                        Da.__click = async () => {
                                            var Gi;
                                            if (w(le).name === "selectHq") {
                                                const Li = w(le).hq;
                                                if (Li)
                                                    try {
                                                        fe($t, !0),
                                                        await ri.updateAllianceHeadquarters(Li[0], Li[1]),
                                                        (Gi = w(Q)) == null || Gi.clear(),
                                                        fe(it, !0),
                                                        fe(le, {
                                                            name: "mainMenu"
                                                        }, !0)
                                                    } catch (sn) {
                                                        Zr.error(sn.message)
                                                    } finally {
                                                        fe($t, !1)
                                                    }
                                            }
                                        }
                                        ;
                                        var co = z(Da);
                                        K8(co, {
                                            class: "size-6"
                                        }),
                                        k(Da),
                                        k(Ua),
                                        k(sa),
                                        k(Qn),
                                        k(Wr),
                                        st(Gi => {
                                            Ce(jn, ` ${Gi ?? ""}`),
                                            Da.disabled = w(le).hq === void 0 || w($t)
                                        }
                                        , [ () => oC()]),
                                        Cn(3, Qn, () => df, () => ({
                                            duration: 100
                                        })),
                                        H(Ui, Wr)
                                    }
                                    ;
                                    tt(en, Ui => {
                                        w(le).name === "selectHq" && Ui(Jn)
                                    }
                                    , !0)
                                }
                                H(zi, gi)
                            }
                            ;
                            tt(Ki, zi => {
                                w(le).name === "paintingPixel" && w(ie) ? zi(Pi) : zi(Ni, !1)
                            }
                            , !0)
                        }
                        H(oi, ki)
                    }
                    ;
                    tt(Qr, oi => {
                        w(le).name === "pixelSelected" && w(Q) ? oi(ni) : oi(yi, !1)
                    }
                    )
                }
                H(gr, Zt)
            }
            ;
            tt(Si, gr => {
                w(G) && gr(ui)
            }
            )
        }
        k(zr),
        st( (gr, Zt, Qr, ni, yi, oi, ki, Ki, Pi) => {
            Ht = Vr(Mr, 1, "absolute right-2 top-2 z-30", null, Ht, gr),
            mi = Vr(sr, 1, "flex flex-col gap-4", null, mi, Zt),
            Ii = Vr(be, 1, "absolute left-2 top-2 z-30 flex flex-col gap-3", null, Ii, Qr),
            jr(ae, "title", ni),
            jr(we, "title", yi),
            Qi = Vr(Kt, 1, "absolute left-1/2 top-2 z-30 flex -translate-x-1/2 flex-col items-center justify-center gap-2", null, Qi, oi),
            vi = Vr(Yr, 1, "absolute bottom-3 left-3 z-30", null, vi, ki),
            kr = Vr(Mt, 1, "absolute bottom-3 left-1/2 z-30 -translate-x-1/2", null, kr, Ki),
            Yn = Vr(Br, 1, "absolute bottom-3 right-3 z-30", null, Yn, Pi)
        }
        , [ () => ({
            hidden: w(X)
        }), () => ({
            "items-end": !Vt.data,
            "items-center": Vt.data
        }), () => ({
            hidden: w(X)
        }), () => c1(), () => d1(), () => ({
            hidden: w(X)
        }), () => ({
            hidden: w(X)
        }), () => ({
            hidden: w(X)
        }), () => ({
            hidden: w(X)
        })])
    }
    var St = U(zr, 2);
    bA(St, {
        get open() {
            return w(xe)
        },
        set open(Tt) {
            fe(xe, Tt, !0)
        }
    });
    var yr = U(St, 2);
    W8(yr, {
        get open() {
            return w(ue)
        },
        set open(Tt) {
            fe(ue, Tt, !0)
        }
    });
    var pr = U(yr, 2);
    fM(pr, {
        get open() {
            return w(Re)
        },
        set open(Tt) {
            fe(Re, Tt, !0)
        }
    });
    var hi = U(pr, 2);
    IM(hi, {
        get open() {
            return w(We)
        },
        set open(Tt) {
            fe(We, Tt, !0)
        }
    });
    var Or = U(hi, 2);
    hM(Or, {
        get open() {
            return w(xt)
        },
        set open(Tt) {
            fe(xt, Tt, !0)
        }
    });
    var si = U(Or, 2);
    vA(si, {
        onvisitclick: Tt => {
            var Ot;
            (Ot = w(G)) == null || Ot.flyTo({
                center: Tt,
                zoom: xg + 1
            }),
            Va(Tt, w(re)),
            Jo.push({
                pos: Tt,
                zoom: w(re)
            }),
            fe(Le, !1)
        }
        ,
        get open() {
            return w(Le)
        },
        set open(Tt) {
            fe(Le, Tt, !0)
        }
    });
    var fr = U(si, 2);
    KE(fr, {
        get region() {
            return w(kt)
        },
        get open() {
            return w(at)
        },
        set open(Tt) {
            fe(at, Tt, !0)
        }
    });
    var $i = U(fr, 2);
    Mx($i, {
        get open() {
            return aa.dropletsDialogOpen
        },
        set open(Tt) {
            aa.dropletsDialogOpen = Tt
        }
    });
    var On = U($i, 2);
    {
        var _i = Tt => {
            ZI(Tt, {
                onhqchange: () => {
                    fe(le, {
                        name: "selectHq"
                    }, !0),
                    fe(it, !1)
                }
                ,
                onhqclick: Ot => {
                    var Ht;
                    (Ht = w(G)) == null || Ht.flyTo({
                        center: Ot,
                        zoom: Math.max(w(re), 15)
                    }),
                    fe(le, {
                        name: "pixelSelected",
                        latLon: [Ot.lat, Ot.lng]
                    }, !0),
                    fe(it, !1)
                }
                ,
                onlastpixelclick: Ot => {
                    var Ht;
                    (Ht = w(G)) == null || Ht.flyTo({
                        center: Ot,
                        zoom: Math.max(w(re), 15)
                    }),
                    fe(le, {
                        name: "pixelSelected",
                        latLon: [Ot.lat, Ot.lng]
                    }, !0),
                    fe(it, !1)
                }
                ,
                get open() {
                    return w(it)
                },
                set open(Ot) {
                    fe(it, Ot, !0)
                }
            })
        }
        ;
        tt(On, Tt => {
            w(G) && Tt(_i)
        }
        )
    }
    var An = U(On, 2);
    Uk(An, {
        get open() {
            return w(Lt)
        },
        set open(Tt) {
            fe(Lt, Tt, !0)
        }
    });
    var Kn = U(An, 2);
    {
        var Nn = Tt => {
            nM(Tt, {
                get url() {
                    return w(lr)
                },
                get map() {
                    return w(G)
                },
                hideHover: () => {
                    var Ot, Ht;
                    (Ot = w(G)) == null || Ot.setPaintProperty(Ne, "raster-opacity", 0),
                    (Ht = w(Q)) == null || Ht.setCanvasOpacity(0)
                }
                ,
                showHover: () => {
                    var Ot, Ht;
                    (Ot = w(G)) == null || Ot.setPaintProperty(Ne, "raster-opacity", rt),
                    (Ht = w(Q)) == null || Ht.setCanvasOpacity(1)
                }
                ,
                get open() {
                    return w(zt)
                },
                set open(Ot) {
                    fe(zt, Ot, !0)
                }
            })
        }
        ;
        tt(Kn, Tt => {
            w(G) && Tt(Nn)
        }
        )
    }
    H(x, $r),
    Dr()
}
Xi(["click"]);
export {bL as component};
